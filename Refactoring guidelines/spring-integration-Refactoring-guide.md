# A guide to Refactoring mock clones in spring-integration

## Mock Clone Instance #spring-integration_MCI_1
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.file.remote.session.SessionFactory`
- **Test Case Count**: 12
- **MO Count**: 12

### Reusable Method
```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_1_1
#### Test Case Name: `testLs_1_dirs`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void testLs_1_dirs() throws Exception {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
     Session session = mock(Session.class);
-    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
-    gw.setOptions("-1 -dirs");
-    gw.afterPropertiesSet();
-    when(sessionFactory.getSession()).thenReturn(session);
+    SessionFactory sessionFactory = createMockSessionFactory(session);
+    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
+    gw.setOptions("-1 -dirs");
+    gw.afterPropertiesSet();
     TestLsEntry[] files = fileList();
     when(session.list("testremote/")).thenReturn(files);
     @SuppressWarnings("unchecked")
     MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
     assertThat(out.getPayload()).hasSize(3);
     assertThat(out.getPayload().get(0)).isEqualTo("f1");
     assertThat(out.getPayload().get(1)).isEqualTo("f2");
     assertThat(out.getPayload().get(2)).isEqualTo("f3");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_1_dirs() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1 -dirs");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out.getPayload()).hasSize(3);
    assertThat(out.getPayload().get(0)).isEqualTo("f1");
    assertThat(out.getPayload().get(1)).isEqualTo("f2");
    assertThat(out.getPayload().get(2)).isEqualTo("f3");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_1_2
#### Test Case Name: `testLs_1_dirs_links`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void testLs_1_dirs_links() throws Exception {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
+    SessionFactory sessionFactory = createMockSessionFactory(session);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1 -dirs -links");
    gw.afterPropertiesSet();
-    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out.getPayload()).hasSize(4);
    assertThat(out.getPayload().get(0)).isEqualTo("f1");
    assertThat(out.getPayload().get(1)).isEqualTo("f2");
    assertThat(out.getPayload().get(2)).isEqualTo("f3");
    assertThat(out.getPayload().get(3)).isEqualTo("f4");
}
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_1_dirs_links() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1 -dirs -links");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out.getPayload()).hasSize(4);
    assertThat(out.getPayload().get(0)).isEqualTo("f1");
    assertThat(out.getPayload().get(1)).isEqualTo("f2");
    assertThat(out.getPayload().get(2)).isEqualTo("f3");
    assertThat(out.getPayload().get(3)).isEqualTo("f4");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_1_3
#### Test Case Name: `testLs_1_a_f_dirs_links`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testLs_1_a_f_dirs_links() throws Exception {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
     Session session = mock(Session.class);
+    SessionFactory sessionFactory = createMockSessionFactory(session);
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
     gw.setOptions("-1 -a -f -dirs -links");
     gw.afterPropertiesSet();
-    when(sessionFactory.getSession()).thenReturn(session);
     TestLsEntry[] files = fileList();
     when(session.list("testremote/")).thenReturn(files);
     @SuppressWarnings("unchecked")
     MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
     assertThat(out.getPayload()).hasSize(6);
     assertThat(out.getPayload().get(0)).isEqualTo("f2");
     assertThat(out.getPayload().get(1)).isEqualTo("f1");
     assertThat(out.getPayload().get(2)).isEqualTo("f3");
     assertThat(out.getPayload().get(3)).isEqualTo("f4");
     assertThat(out.getPayload().get(4)).isEqualTo(".f5");
     assertThat(out.getPayload().get(5)).isEqualTo(".f6");
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_1_a_f_dirs_links() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1 -a -f -dirs -links");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out.getPayload()).hasSize(6);
    assertThat(out.getPayload().get(0)).isEqualTo("f2");
    assertThat(out.getPayload().get(1)).isEqualTo("f1");
    assertThat(out.getPayload().get(2)).isEqualTo("f3");
    assertThat(out.getPayload().get(3)).isEqualTo("f4");
    assertThat(out.getPayload().get(4)).isEqualTo(".f5");
    assertThat(out.getPayload().get(5)).isEqualTo(".f6");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_1_4
#### Test Case Name: `testLs`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testLs() throws Exception {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
     Session session = mock(Session.class);
-    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
-    gw.afterPropertiesSet();
-    when(sessionFactory.getSession()).thenReturn(session);
+    SessionFactory sessionFactory = createMockSessionFactory(session);
+    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
+    gw.afterPropertiesSet();
     TestLsEntry[] files = fileList();
     when(session.list("testremote/x/")).thenReturn(files);
     @SuppressWarnings("unchecked")
     MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote/x"));
     assertThat(out).isNotNull();
     assertThat(out.getPayload()).hasSize(2);
     // sort by default
     assertThat(out.getPayload().get(0)).isSameAs(files[1]);
     assertThat(out.getPayload().get(1)).isSameAs(files[0]);
     assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/x/");
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/x/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote/x"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(2);
    // sort by default
    assertThat(out.getPayload().get(0)).isSameAs(files[1]);
    assertThat(out.getPayload().get(1)).isSameAs(files[0]);
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/x/");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_1_5
#### Test Case Name: `testLs_1_a_f_dirs_links_filtered`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void testLs_1_a_f_dirs_links_filtered() throws Exception {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
     Session session = mock(Session.class);
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
     gw.setOptions("-1 -a -f -dirs -links");
     gw.setFilter(new TestPatternFilter("*4"));
     gw.afterPropertiesSet();
-    when(sessionFactory.getSession()).thenReturn(session);
+    SessionFactory sessionFactory = createMockSessionFactory(session);
     TestLsEntry[] files = fileList();
     when(session.list("testremote/")).thenReturn(files);
     @SuppressWarnings("unchecked")
     MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
     assertThat(out.getPayload()).hasSize(1);
     assertThat(out.getPayload().get(0)).isEqualTo("f4");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_1_a_f_dirs_links_filtered() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1 -a -f -dirs -links");
    gw.setFilter(new TestPatternFilter("*4"));
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out.getPayload()).hasSize(1);
    assertThat(out.getPayload().get(0)).isEqualTo("f4");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_1_6
#### Test Case Name: `testRm`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testRm() throws Exception {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
     Session session = mock(Session.class);
+    SessionFactory sessionFactory = createMockSessionFactory(session);
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "rm", "payload");
     gw.afterPropertiesSet();
-    when(sessionFactory.getSession()).thenReturn(session);
     when(session.remove("testremote/x/f1")).thenReturn(Boolean.TRUE);
     @SuppressWarnings("unchecked")
     MessageBuilder<Boolean> out = (MessageBuilder<Boolean>) gw.handleRequestMessage(new GenericMessage<>("testremote/x/f1"));
     assertThat(out.getPayload()).isTrue();
     verify(session).remove("testremote/x/f1");
     assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/x/");
     assertThat(out.getHeaders().get(FileHeaders.REMOTE_FILE)).isEqualTo("f1");
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testRm() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "rm", "payload");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    when(session.remove("testremote/x/f1")).thenReturn(Boolean.TRUE);
    @SuppressWarnings("unchecked")
    MessageBuilder<Boolean> out = (MessageBuilder<Boolean>) gw.handleRequestMessage(new GenericMessage<>("testremote/x/f1"));
    assertThat(out.getPayload()).isTrue();
    verify(session).remove("testremote/x/f1");
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/x/");
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_FILE)).isEqualTo("f1");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_1_7
#### Test Case Name: `testLs_f`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void testLs_f() throws Exception {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
+    SessionFactory sessionFactory = createMockSessionFactory(session);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-f");
    gw.afterPropertiesSet();
-    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/x/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote/x"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(2);
    assertThat(out.getPayload().get(0)).isSameAs(files[0]);
    assertThat(out.getPayload().get(1)).isSameAs(files[1]);
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/x/");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_f() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-f");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/x/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote/x"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(2);
    assertThat(out.getPayload().get(0)).isSameAs(files[0]);
    assertThat(out.getPayload().get(1)).isSameAs(files[1]);
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/x/");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_1_8
#### Test Case Name: `testLs_f_R`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void testLs_f_R() throws Exception {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
     Session session = mock(Session.class);
+    SessionFactory sessionFactory = createMockSessionFactory(session);
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
     gw.setOptions("-f -R");
     gw.afterPropertiesSet();
-    when(sessionFactory.getSession()).thenReturn(session);
     TestLsEntry[] level1 = level1List();
     TestLsEntry[] level2 = level2List();
     TestLsEntry[] level3 = level3List();
     when(session.list("testremote/x/")).thenReturn(level1);
     when(session.list("testremote/x/d1/")).thenReturn(level2);
     when(session.list("testremote/x/d1/d2/")).thenReturn(level3);
     @SuppressWarnings("unchecked")
     MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote/x"));
     assertThat(out).isNotNull();
     assertThat(out.getPayload()).hasSize(4);
     assertThat(out.getPayload().get(0).getFilename()).isEqualTo("f1");
     assertThat(out.getPayload().get(1).getFilename()).isEqualTo("d1/d2/f4");
     assertThat(out.getPayload().get(2).getFilename()).isEqualTo("d1/f3");
     assertThat(out.getPayload().get(3).getFilename()).isEqualTo("f2");
     assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/x/");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_f_R() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-f -R");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] level1 = level1List();
    TestLsEntry[] level2 = level2List();
    TestLsEntry[] level3 = level3List();
    when(session.list("testremote/x/")).thenReturn(level1);
    when(session.list("testremote/x/d1/")).thenReturn(level2);
    when(session.list("testremote/x/d1/d2/")).thenReturn(level3);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote/x"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(4);
    assertThat(out.getPayload().get(0).getFilename()).isEqualTo("f1");
    assertThat(out.getPayload().get(1).getFilename()).isEqualTo("d1/d2/f4");
    assertThat(out.getPayload().get(2).getFilename()).isEqualTo("d1/f3");
    assertThat(out.getPayload().get(3).getFilename()).isEqualTo("f2");
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/x/");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_1_9
#### Test Case Name: `testLs_f_R_dirs`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void testLs_f_R_dirs() throws Exception {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
+    SessionFactory sessionFactory = createMockSessionFactory(session);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-f -R -dirs");
    gw.afterPropertiesSet();
-    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] level1 = level1List();
    TestLsEntry[] level2 = level2List();
    TestLsEntry[] level3 = level3List();
    when(session.list("testremote/x/")).thenReturn(level1);
    when(session.list("testremote/x/d1/")).thenReturn(level2);
    when(session.list("testremote/x/d1/d2/")).thenReturn(level3);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote/x"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(6);
    assertThat(out.getPayload().get(0).getFilename()).isEqualTo("f1");
    assertThat(out.getPayload().get(1).getFilename()).isEqualTo("d1");
    assertThat(out.getPayload().get(2).getFilename()).isEqualTo("d1/d2");
    assertThat(out.getPayload().get(3).getFilename()).isEqualTo("d1/d2/f4");
    assertThat(out.getPayload().get(4).getFilename()).isEqualTo("d1/f3");
    assertThat(out.getPayload().get(5).getFilename()).isEqualTo("f2");
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/x/");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_f_R_dirs() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-f -R -dirs");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] level1 = level1List();
    TestLsEntry[] level2 = level2List();
    TestLsEntry[] level3 = level3List();
    when(session.list("testremote/x/")).thenReturn(level1);
    when(session.list("testremote/x/d1/")).thenReturn(level2);
    when(session.list("testremote/x/d1/d2/")).thenReturn(level3);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote/x"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(6);
    assertThat(out.getPayload().get(0).getFilename()).isEqualTo("f1");
    assertThat(out.getPayload().get(1).getFilename()).isEqualTo("d1");
    assertThat(out.getPayload().get(2).getFilename()).isEqualTo("d1/d2");
    assertThat(out.getPayload().get(3).getFilename()).isEqualTo("d1/d2/f4");
    assertThat(out.getPayload().get(4).getFilename()).isEqualTo("d1/f3");
    assertThat(out.getPayload().get(5).getFilename()).isEqualTo("f2");
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/x/");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_1_10
#### Test Case Name: `testLs_None`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void testLs_None() throws Exception {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
+    SessionFactory sessionFactory = createMockSessionFactory(session);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.afterPropertiesSet();
-    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = new TestLsEntry[0];
    when(session.list("testremote/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(0);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_None() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = new TestLsEntry[0];
    when(session.list("testremote/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(0);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_1_11
#### Test Case Name: `testLs_1`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void testLs_1() throws Exception {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1");
    gw.afterPropertiesSet();
-    when(sessionFactory.getSession()).thenReturn(session);
+    SessionFactory sessionFactory = createMockSessionFactory(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(2);
    assertThat(out.getPayload().get(0)).isEqualTo("f1");
    assertThat(out.getPayload().get(1)).isEqualTo("f2");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_1() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(2);
    assertThat(out.getPayload().get(0)).isEqualTo("f1");
    assertThat(out.getPayload().get(1)).isEqualTo("f2");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_1_12
#### Test Case Name: `testLs_1_f`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testLs_1_f() throws Exception {
-    //no sort
-    SessionFactory sessionFactory = mock(SessionFactory.class);
+    //no sort
     Session session = mock(Session.class);
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
     gw.setOptions("-1 -f");
     gw.afterPropertiesSet();
-    when(sessionFactory.getSession()).thenReturn(session);
+    SessionFactory sessionFactory = createMockSessionFactory(session);
     TestLsEntry[] files = fileList();
     when(session.list("testremote/")).thenReturn(files);
     @SuppressWarnings("unchecked")
     MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
     assertThat(out.getPayload()).hasSize(2);
     assertThat(out.getPayload().get(0)).isEqualTo("f2");
     assertThat(out.getPayload().get(1)).isEqualTo("f1");
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_1_f() throws Exception {
    //no sort
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1 -f");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out.getPayload()).hasSize(2);
    assertThat(out.getPayload().get(0)).isEqualTo("f2");
    assertThat(out.getPayload().get(1)).isEqualTo("f1");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_2
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.file.remote.session.SessionFactory`
- **Test Case Count**: 8
- **MO Count**: 8

### Reusable Method
```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_2_1
#### Test Case Name: `testMGetWildGuts`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
@@
private void testMGetWildGuts(final String path1, final String path2) {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
+    Session session = new TestSession() {
+
+        int n;
+
+        @Override
+        public void read(String source, OutputStream outputStream) throws IOException {
+            if (n++ == 0) {
+                assertThat(source).isEqualTo("testremote/f1");
+            } else {
+                assertThat(source).isEqualTo("testremote/f2");
+            }
+            outputStream.write("testData".getBytes());
+        }
+
+        @Override
+        public TestLsEntry[] list(String path) {
+            return new TestLsEntry[] { new TestLsEntry(path1.replaceFirst("testremote/", ""), 123, false, false, 1234, "-r--r--r--"), new TestLsEntry(path2.replaceFirst("testremote/", ""), 123, false, false, 1234, "-r--r--r--") };
+        }
+    };
+    SessionFactory sessionFactory = createMockSessionFactory(session);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mget", "payload");
    gw.setLocalDirectory(new File(this.tmpDir));
    gw.afterPropertiesSet();
    new File(this.tmpDir + "/f1").delete();
    new File(this.tmpDir + "/f2").delete();
-    when(sessionFactory.getSession()).thenReturn(new TestSession() {
-
-        int n;
-
-        @Override
-        public void read(String source, OutputStream outputStream) throws IOException {
-            if (n++ == 0) {
-                assertThat(source).isEqualTo("testremote/f1");
-            } else {
-                assertThat(source).isEqualTo("testremote/f2");
-            }
-            outputStream.write("testData".getBytes());
-        }
-
-        @Override
-        public TestLsEntry[] list(String path) {
-            return new TestLsEntry[] { new TestLsEntry(path1.replaceFirst("testremote/", ""), 123, false, false, 1234, "-r--r--r--"), new TestLsEntry(path2.replaceFirst("testremote/", ""), 123, false, false, 1234, "-r--r--r--") };
-        }
-    });
    @SuppressWarnings("unchecked")
    MessageBuilder<List<File>> out = (MessageBuilder<List<File>>) gw.handleRequestMessage(new GenericMessage<>("testremote/*"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(2);
    assertThat(out.getPayload().get(0).getName()).isEqualTo("f1");
    assertThat(out.getPayload().get(1).getName()).isEqualTo("f2");
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
private void testMGetWildGuts(final String path1, final String path2) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mget", "payload");
    gw.setLocalDirectory(new File(this.tmpDir));
    gw.afterPropertiesSet();
    new File(this.tmpDir + "/f1").delete();
    new File(this.tmpDir + "/f2").delete();
    when(sessionFactory.getSession()).thenReturn(new TestSession() {

        int n;

        @Override
        public void read(String source, OutputStream outputStream) throws IOException {
            if (n++ == 0) {
                assertThat(source).isEqualTo("testremote/f1");
            } else {
                assertThat(source).isEqualTo("testremote/f2");
            }
            outputStream.write("testData".getBytes());
        }

        @Override
        public TestLsEntry[] list(String path) {
            return new TestLsEntry[] { new TestLsEntry(path1.replaceFirst("testremote/", ""), 123, false, false, 1234, "-r--r--r--"), new TestLsEntry(path2.replaceFirst("testremote/", ""), 123, false, false, 1234, "-r--r--r--") };
        }
    });
    @SuppressWarnings("unchecked")
    MessageBuilder<List<File>> out = (MessageBuilder<List<File>>) gw.handleRequestMessage(new GenericMessage<>("testremote/*"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(2);
    assertThat(out.getPayload().get(0).getName()).isEqualTo("f1");
    assertThat(out.getPayload().get(1).getName()).isEqualTo("f2");
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_2_2
#### Test Case Name: `testGet`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testGet() {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
+    Session session = new TestSession() {
+        @Override
+        public TestLsEntry[] list(String path) {
+            return new TestLsEntry[] { new TestLsEntry("f1", 1234, false, false, 12345, "-rw-r--r--") };
+        }
+
+        @Override
+        public void read(String source, OutputStream outputStream) throws IOException {
+            outputStream.write("testfile".getBytes());
+        }
+    };
+    SessionFactory sessionFactory = createMockSessionFactory(session);
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "get", "payload");
     gw.setLocalDirectory(new File(this.tmpDir));
     gw.afterPropertiesSet();
     new File(this.tmpDir + "/f1").delete();
-    when(sessionFactory.getSession()).thenReturn(new TestSession() {
-
-        @Override
-        public TestLsEntry[] list(String path) {
-            return new TestLsEntry[] { new TestLsEntry("f1", 1234, false, false, 12345, "-rw-r--r--") };
-        }
-
-        @Override
-        public void read(String source, OutputStream outputStream) throws IOException {
-            outputStream.write("testfile".getBytes());
-        }
-    });
     @SuppressWarnings("unchecked")
     MessageBuilder<File> out = (MessageBuilder<File>) gw.handleRequestMessage(new GenericMessage<>("f1"));
     File outFile = new File(this.tmpDir + "/f1");
     assertThat(out.getPayload()).isEqualTo(outFile);
     assertThat(outFile.exists()).isTrue();
     outFile.delete();
     assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isNull();
     assertThat(out.getHeaders().get(FileHeaders.REMOTE_FILE)).isEqualTo("f1");
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testGet() {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "get", "payload");
    gw.setLocalDirectory(new File(this.tmpDir));
    gw.afterPropertiesSet();
    new File(this.tmpDir + "/f1").delete();
    when(sessionFactory.getSession()).thenReturn(new TestSession() {

        @Override
        public TestLsEntry[] list(String path) {
            return new TestLsEntry[] { new TestLsEntry("f1", 1234, false, false, 12345, "-rw-r--r--") };
        }

        @Override
        public void read(String source, OutputStream outputStream) throws IOException {
            outputStream.write("testfile".getBytes());
        }
    });
    @SuppressWarnings("unchecked")
    MessageBuilder<File> out = (MessageBuilder<File>) gw.handleRequestMessage(new GenericMessage<>("f1"));
    File outFile = new File(this.tmpDir + "/f1");
    assertThat(out.getPayload()).isEqualTo(outFile);
    assertThat(outFile.exists()).isTrue();
    outFile.delete();
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isNull();
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_FILE)).isEqualTo("f1");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_2_3
#### Test Case Name: `testMGetSingle`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
-    SessionFactory sessionFactory = mock(SessionFactory.class);
+    SessionFactory sessionFactory = createMockSessionFactory(new TestSession() {
+        @Override
+        public void read(String source, OutputStream outputStream) throws IOException {
+            outputStream.write("testData".getBytes());
+        }
+
+        @Override
+        public TestLsEntry[] list(String path) {
+            return new TestLsEntry[] { new TestLsEntry("f1", 123, false, false, 1234, "-r--r--r--") };
+        }
+    });
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mget", "payload");
     gw.setLocalDirectory(new File(this.tmpDir));
     gw.afterPropertiesSet();
     new File(this.tmpDir + "/f1").delete();
-    when(sessionFactory.getSession()).thenReturn(new TestSession() {
-
-        @Override
-        public void read(String source, OutputStream outputStream) throws IOException {
-            outputStream.write("testData".getBytes());
-        }
-
-        @Override
-        public TestLsEntry[] list(String path) {
-            return new TestLsEntry[] { new TestLsEntry("f1", 123, false, false, 1234, "-r--r--r--") };
-        }
-    });
     @SuppressWarnings("unchecked")
     MessageBuilder<List<File>> out = (MessageBuilder<List<File>>) gw.handleRequestMessage(new GenericMessage<>("testremote/f1"));
     assertThat(out).isNotNull();
     assertThat(out.getPayload()).hasSize(1);
     assertThat(out.getPayload().get(0).getName()).isEqualTo("f1");
     assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testMGetSingle() {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mget", "payload");
    gw.setLocalDirectory(new File(this.tmpDir));
    gw.afterPropertiesSet();
    new File(this.tmpDir + "/f1").delete();
    when(sessionFactory.getSession()).thenReturn(new TestSession() {

        @Override
        public void read(String source, OutputStream outputStream) throws IOException {
            outputStream.write("testData".getBytes());
        }

        @Override
        public TestLsEntry[] list(String path) {
            return new TestLsEntry[] { new TestLsEntry("f1", 123, false, false, 1234, "-r--r--r--") };
        }
    });
    @SuppressWarnings("unchecked")
    MessageBuilder<List<File>> out = (MessageBuilder<List<File>>) gw.handleRequestMessage(new GenericMessage<>("testremote/f1"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(1);
    assertThat(out.getPayload().get(0).getName()).isEqualTo("f1");
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_2_4
#### Test Case Name: `testGetExists`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @SuppressWarnings("unchecked")
 @Test
 public void testGetExists() throws Exception {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
+    SessionFactory sessionFactory = createMockSessionFactory(new TestSession() {
+        @Override
+        public TestLsEntry[] list(String path) {
+            return new TestLsEntry[] { new TestLsEntry("f1", 1234, false, false, 12345, "-rw-r--r--") };
+        }
+
+        @Override
+        public void read(String source, OutputStream outputStream) throws IOException {
+            outputStream.write("testfile".getBytes());
+        }
+    });
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "get", "payload");
     gw.setLocalDirectory(new File(this.tmpDir));
     gw.afterPropertiesSet();
     File outFile = new File(this.tmpDir + "/f1");
     FileOutputStream fos = new FileOutputStream(outFile);
     fos.write("foo".getBytes());
     fos.close();
-    when(sessionFactory.getSession()).thenReturn(new TestSession() {
-
-        @Override
-        public TestLsEntry[] list(String path) {
-            return new TestLsEntry[] { new TestLsEntry("f1", 1234, false, false, 12345, "-rw-r--r--") };
-        }
-
-        @Override
-        public void read(String source, OutputStream outputStream) throws IOException {
-            outputStream.write("testfile".getBytes());
-        }
-    });
     // default (null)
     MessageBuilder<File> out;
     assertThatExceptionOfType(MessageHandlingException.class).isThrownBy(() -> gw.handleRequestMessage(new GenericMessage<>("f1"))).withMessageContaining("already exists");
     gw.setFileExistsMode(FileExistsMode.FAIL);
     assertThatExceptionOfType(MessageHandlingException.class).isThrownBy(() -> gw.handleRequestMessage(new GenericMessage<>("f1"))).withMessageContaining("already exists");
     gw.setFileExistsMode(FileExistsMode.IGNORE);
     out = (MessageBuilder<File>) gw.handleRequestMessage(new GenericMessage<>("f1"));
     assertThat(out.getPayload()).isEqualTo(outFile);
     assertContents("foo", outFile);
     gw.setFileExistsMode(FileExistsMode.APPEND);
     out = (MessageBuilder<File>) gw.handleRequestMessage(new GenericMessage<>("f1"));
     assertThat(out.getPayload()).isEqualTo(outFile);
     assertContents("footestfile", outFile);
     gw.setFileExistsMode(FileExistsMode.REPLACE);
     out = (MessageBuilder<File>) gw.handleRequestMessage(new GenericMessage<>("f1"));
     assertThat(out.getPayload()).isEqualTo(outFile);
     assertContents("testfile", outFile);
     outFile.delete();
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("unchecked")
@Test
public void testGetExists() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "get", "payload");
    gw.setLocalDirectory(new File(this.tmpDir));
    gw.afterPropertiesSet();
    File outFile = new File(this.tmpDir + "/f1");
    FileOutputStream fos = new FileOutputStream(outFile);
    fos.write("foo".getBytes());
    fos.close();
    when(sessionFactory.getSession()).thenReturn(new TestSession() {

        @Override
        public TestLsEntry[] list(String path) {
            return new TestLsEntry[] { new TestLsEntry("f1", 1234, false, false, 12345, "-rw-r--r--") };
        }

        @Override
        public void read(String source, OutputStream outputStream) throws IOException {
            outputStream.write("testfile".getBytes());
        }
    });
    // default (null)
    MessageBuilder<File> out;
    assertThatExceptionOfType(MessageHandlingException.class).isThrownBy(() -> gw.handleRequestMessage(new GenericMessage<>("f1"))).withMessageContaining("already exists");
    gw.setFileExistsMode(FileExistsMode.FAIL);
    assertThatExceptionOfType(MessageHandlingException.class).isThrownBy(() -> gw.handleRequestMessage(new GenericMessage<>("f1"))).withMessageContaining("already exists");
    gw.setFileExistsMode(FileExistsMode.IGNORE);
    out = (MessageBuilder<File>) gw.handleRequestMessage(new GenericMessage<>("f1"));
    assertThat(out.getPayload()).isEqualTo(outFile);
    assertContents("foo", outFile);
    gw.setFileExistsMode(FileExistsMode.APPEND);
    out = (MessageBuilder<File>) gw.handleRequestMessage(new GenericMessage<>("f1"));
    assertThat(out.getPayload()).isEqualTo(outFile);
    assertContents("footestfile", outFile);
    gw.setFileExistsMode(FileExistsMode.REPLACE);
    out = (MessageBuilder<File>) gw.handleRequestMessage(new GenericMessage<>("f1"));
    assertThat(out.getPayload()).isEqualTo(outFile);
    assertContents("testfile", outFile);
    outFile.delete();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_2_5
#### Test Case Name: `testMGetEmpty`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testMGetEmpty() {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mget", "payload");
     gw.setLocalDirectory(new File(this.tmpDir));
     gw.setOptions("   -x   ");
     gw.afterPropertiesSet();
     new File(this.tmpDir + "/f1").delete();
     new File(this.tmpDir + "/f2").delete();
-    when(sessionFactory.getSession()).thenReturn(new TestSession() {
-
-        @Override
-        public void read(String source, OutputStream outputStream) throws IOException {
-            outputStream.write("testData".getBytes());
-        }
-    });
+    SessionFactory sessionFactory = createMockSessionFactory(new TestSession() {
+        @Override
+        public void read(String source, OutputStream outputStream) throws IOException {
+            outputStream.write("testData".getBytes());
+        }
+    });
     assertThatExceptionOfType(MessagingException.class).isThrownBy(() -> gw.handleRequestMessage(new GenericMessage<>("testremote/*")));
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testMGetEmpty() {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mget", "payload");
    gw.setLocalDirectory(new File(this.tmpDir));
    gw.setOptions("   -x   ");
    gw.afterPropertiesSet();
    new File(this.tmpDir + "/f1").delete();
    new File(this.tmpDir + "/f2").delete();
    when(sessionFactory.getSession()).thenReturn(new TestSession() {

        @Override
        public void read(String source, OutputStream outputStream) throws IOException {
            outputStream.write("testData".getBytes());
        }
    });
    assertThatExceptionOfType(MessagingException.class).isThrownBy(() -> gw.handleRequestMessage(new GenericMessage<>("testremote/*")));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_2_6
#### Test Case Name: `testGetExistsExpression`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 @SuppressWarnings("unchecked")
 public void testGetExistsExpression() throws Exception {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
+    SessionFactory sessionFactory = createMockSessionFactory(new TestSession() {
+        @Override
+        public TestLsEntry[] list(String path) {
+            return new TestLsEntry[] { new TestLsEntry("f1", 1234, false, false, 12345, "-rw-r--r--") };
+        }
+
+        @Override
+        public void read(String source, OutputStream outputStream) throws IOException {
+            outputStream.write("testfile".getBytes());
+        }
+    });
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "get", "payload");
     gw.setFileExistsModeExpressionString("headers[\"file.exists.mode\"]");
     gw.setLocalDirectory(new File(this.tmpDir));
     gw.afterPropertiesSet();
     File outFile = new File(this.tmpDir + "/f1");
     FileOutputStream fos = new FileOutputStream(outFile);
     fos.write("foo".getBytes());
     fos.close();
-    when(sessionFactory.getSession()).thenReturn(new TestSession() {
-
-        @Override
-        public TestLsEntry[] list(String path) {
-            return new TestLsEntry[] { new TestLsEntry("f1", 1234, false, false, 12345, "-rw-r--r--") };
-        }
-
-        @Override
-        public void read(String source, OutputStream outputStream) throws IOException {
-            outputStream.write("testfile".getBytes());
-        }
-    });
     // default (null)
     MessageBuilder<File> out;
     assertThatExceptionOfType(MessageHandlingException.class).isThrownBy(() -> gw.handleRequestMessage(new GenericMessage<>("f1"))).withMessageContaining("already exists");
     assertThatExceptionOfType(MessageHandlingException.class).isThrownBy(() -> gw.handleRequestMessage(new GenericMessage<>("f1", Map.of("file.exists.mode", FileExistsMode.FAIL)))).withMessageContaining("already exists");
     out = (MessageBuilder<File>) gw.handleRequestMessage(new GenericMessage<>("f1", Map.of("file.exists.mode", "IGNORE")));
     assertThat(out.getPayload()).isEqualTo(outFile);
     assertContents("foo", outFile);
     out = (MessageBuilder<File>) gw.handleRequestMessage(new GenericMessage<>("f1", Map.of("file.exists.mode", "append")));
     assertThat(out.getPayload()).isEqualTo(outFile);
     assertContents("footestfile", outFile);
     out = (MessageBuilder<File>) gw.handleRequestMessage(new GenericMessage<>("f1", Map.of("file.exists.mode", FileExistsMode.REPLACE)));
     assertThat(out.getPayload()).isEqualTo(outFile);
     assertContents("testfile", outFile);
     outFile.delete();
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@SuppressWarnings("unchecked")
public void testGetExistsExpression() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "get", "payload");
    gw.setFileExistsModeExpressionString("headers[\"file.exists.mode\"]");
    gw.setLocalDirectory(new File(this.tmpDir));
    gw.afterPropertiesSet();
    File outFile = new File(this.tmpDir + "/f1");
    FileOutputStream fos = new FileOutputStream(outFile);
    fos.write("foo".getBytes());
    fos.close();
    when(sessionFactory.getSession()).thenReturn(new TestSession() {

        @Override
        public TestLsEntry[] list(String path) {
            return new TestLsEntry[] { new TestLsEntry("f1", 1234, false, false, 12345, "-rw-r--r--") };
        }

        @Override
        public void read(String source, OutputStream outputStream) throws IOException {
            outputStream.write("testfile".getBytes());
        }
    });
    // default (null)
    MessageBuilder<File> out;
    assertThatExceptionOfType(MessageHandlingException.class).isThrownBy(() -> gw.handleRequestMessage(new GenericMessage<>("f1"))).withMessageContaining("already exists");
    assertThatExceptionOfType(MessageHandlingException.class).isThrownBy(() -> gw.handleRequestMessage(new GenericMessage<>("f1", Map.of("file.exists.mode", FileExistsMode.FAIL)))).withMessageContaining("already exists");
    out = (MessageBuilder<File>) gw.handleRequestMessage(new GenericMessage<>("f1", Map.of("file.exists.mode", "IGNORE")));
    assertThat(out.getPayload()).isEqualTo(outFile);
    assertContents("foo", outFile);
    out = (MessageBuilder<File>) gw.handleRequestMessage(new GenericMessage<>("f1", Map.of("file.exists.mode", "append")));
    assertThat(out.getPayload()).isEqualTo(outFile);
    assertContents("footestfile", outFile);
    out = (MessageBuilder<File>) gw.handleRequestMessage(new GenericMessage<>("f1", Map.of("file.exists.mode", FileExistsMode.REPLACE)));
    assertThat(out.getPayload()).isEqualTo(outFile);
    assertContents("testfile", outFile);
    outFile.delete();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_2_7
#### Test Case Name: `testGet_P`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void testGet_P() {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "get", "payload");
     gw.setLocalDirectory(new File(this.tmpDir));
     gw.setOptions("-P");
     gw.afterPropertiesSet();
     new File(this.tmpDir + "/f1").delete();
     Calendar cal = Calendar.getInstance();
     cal.add(Calendar.MONTH, -1);
     final Date modified = new Date(cal.getTime().getTime() / 1000 * 1000);
-    when(sessionFactory.getSession()).thenReturn(new TestSession() {
-
-        @Override
-        public TestLsEntry[] list(String path) {
-            return new TestLsEntry[] { new TestLsEntry("f1", 1234, false, false, modified.getTime(), "-rw-r--r--") };
-        }
-
-        @Override
-        public void read(String source, OutputStream outputStream) throws IOException {
-            outputStream.write("testfile".getBytes());
-        }
-    });
+    SessionFactory sessionFactory = createMockSessionFactory(new TestSession() {
+        @Override
+        public TestLsEntry[] list(String path) {
+            return new TestLsEntry[] { new TestLsEntry("f1", 1234, false, false, modified.getTime(), "-rw-r--r--") };
+        }
+
+        @Override
+        public void read(String source, OutputStream outputStream) throws IOException {
+            outputStream.write("testfile".getBytes());
+        }
+    });
     @SuppressWarnings("unchecked")
     MessageBuilder<File> out = (MessageBuilder<File>) gw.handleRequestMessage(new GenericMessage<>("x/f1"));
     File outFile = new File(this.tmpDir + "/f1");
     assertThat(out.getPayload()).isEqualTo(outFile);
     assertThat(outFile.exists()).isTrue();
     assertThat(outFile.lastModified()).isEqualTo(modified.getTime());
     outFile.delete();
     assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("x/");
     assertThat(out.getHeaders().get(FileHeaders.REMOTE_FILE)).isEqualTo("f1");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testGet_P() {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "get", "payload");
    gw.setLocalDirectory(new File(this.tmpDir));
    gw.setOptions("-P");
    gw.afterPropertiesSet();
    new File(this.tmpDir + "/f1").delete();
    Calendar cal = Calendar.getInstance();
    cal.add(Calendar.MONTH, -1);
    final Date modified = new Date(cal.getTime().getTime() / 1000 * 1000);
    when(sessionFactory.getSession()).thenReturn(new TestSession() {

        @Override
        public TestLsEntry[] list(String path) {
            return new TestLsEntry[] { new TestLsEntry("f1", 1234, false, false, modified.getTime(), "-rw-r--r--") };
        }

        @Override
        public void read(String source, OutputStream outputStream) throws IOException {
            outputStream.write("testfile".getBytes());
        }
    });
    @SuppressWarnings("unchecked")
    MessageBuilder<File> out = (MessageBuilder<File>) gw.handleRequestMessage(new GenericMessage<>("x/f1"));
    File outFile = new File(this.tmpDir + "/f1");
    assertThat(out.getPayload()).isEqualTo(outFile);
    assertThat(outFile.exists()).isTrue();
    assertThat(outFile.lastModified()).isEqualTo(modified.getTime());
    outFile.delete();
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("x/");
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_FILE)).isEqualTo("f1");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_2_8
#### Test Case Name: `testGet_create_dir`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    new File(this.tmpDir + "/x/f1").delete();
    new File(this.tmpDir + "/x").delete();
-    SessionFactory sessionFactory = mock(SessionFactory.class);
+    SessionFactory sessionFactory = createMockSessionFactory(new TestSession() {
+        @Override
+        public TestLsEntry[] list(String path) {
+            return new TestLsEntry[] { new TestLsEntry("f1", 1234, false, false, 12345, "-rw-r--r--") };
+        }
+
+        @Override
+        public void read(String source, OutputStream outputStream) throws IOException {
+            outputStream.write("testfile".getBytes());
+        }
+    });
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "get", "payload");
    gw.setLocalDirectory(new File(this.tmpDir + "/x"));
    gw.afterPropertiesSet();
-    when(sessionFactory.getSession()).thenReturn(new TestSession() {
-
-        @Override
-        public TestLsEntry[] list(String path) {
-            return new TestLsEntry[] { new TestLsEntry("f1", 1234, false, false, 12345, "-rw-r--r--") };
-        }
-
-        @Override
-        public void read(String source, OutputStream outputStream) throws IOException {
-            outputStream.write("testfile".getBytes());
-        }
-    });
    gw.handleRequestMessage(new GenericMessage<>("f1"));
    File out = new File(this.tmpDir + "/x/f1");
    assertThat(out.exists()).isTrue();
    out.delete();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testGet_create_dir() {
    new File(this.tmpDir + "/x/f1").delete();
    new File(this.tmpDir + "/x").delete();
    SessionFactory sessionFactory = mock(SessionFactory.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "get", "payload");
    gw.setLocalDirectory(new File(this.tmpDir + "/x"));
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(new TestSession() {

        @Override
        public TestLsEntry[] list(String path) {
            return new TestLsEntry[] { new TestLsEntry("f1", 1234, false, false, 12345, "-rw-r--r--") };
        }

        @Override
        public void read(String source, OutputStream outputStream) throws IOException {
            outputStream.write("testfile".getBytes());
        }
    });
    gw.handleRequestMessage(new GenericMessage<>("f1"));
    File out = new File(this.tmpDir + "/x/f1");
    assertThat(out.exists()).isTrue();
    out.delete();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_3
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.file.remote.session.SessionFactory`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static SessionFactory createMockSessionFactory(Session<?> session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_3_1
#### Test Case Name: `testMove`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
-    SessionFactory sessionFactory = mock(SessionFactory.class);
+    SessionFactory sessionFactory = createMockSessionFactory(session);
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mv", "payload");
     gw.afterPropertiesSet();
     Session<?> session = mock(Session.class);
     final AtomicReference<String> args = new AtomicReference<>();
     doAnswer(invocation -> {
         Object[] arguments = invocation.getArguments();
         args.set((String) arguments[0] + arguments[1]);
         return null;
     }).when(session).rename(anyString(), anyString());
-    when(sessionFactory.getSession()).thenReturn(session);
     Message<String> requestMessage = MessageBuilder.withPayload("foo").setHeader(FileHeaders.RENAME_TO, "bar").build();
     MessageBuilder<?> out = (MessageBuilder<?>) gw.handleRequestMessage(requestMessage);
     assertThat(out.getHeaders().get(FileHeaders.REMOTE_FILE)).isEqualTo("foo");
     assertThat(args.get()).isEqualTo("foobar");
     assertThat(out.getPayload()).isEqualTo(Boolean.TRUE);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testMove() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mv", "payload");
    gw.afterPropertiesSet();
    Session<?> session = mock(Session.class);
    final AtomicReference<String> args = new AtomicReference<>();
    doAnswer(invocation -> {
        Object[] arguments = invocation.getArguments();
        args.set((String) arguments[0] + arguments[1]);
        return null;
    }).when(session).rename(anyString(), anyString());
    when(sessionFactory.getSession()).thenReturn(session);
    Message<String> requestMessage = MessageBuilder.withPayload("foo").setHeader(FileHeaders.RENAME_TO, "bar").build();
    MessageBuilder<?> out = (MessageBuilder<?>) gw.handleRequestMessage(requestMessage);
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_FILE)).isEqualTo("foo");
    assertThat(args.get()).isEqualTo("foobar");
    assertThat(out.getPayload()).isEqualTo(Boolean.TRUE);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session<?> session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_3_2
#### Test Case Name: `testMoveWithExpression`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void testMoveWithExpression() throws Exception {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mv", "payload");
     gw.setRenameExpression(PARSER.parseExpression("payload.substring(1)"));
     gw.afterPropertiesSet();
     Session<?> session = mock(Session.class);
     final AtomicReference<String> args = new AtomicReference<>();
     doAnswer(invocation -> {
         Object[] arguments = invocation.getArguments();
         args.set((String) arguments[0] + arguments[1]);
         return null;
     }).when(session).rename(anyString(), anyString());
-    when(sessionFactory.getSession()).thenReturn(session);
+    SessionFactory sessionFactory = createMockSessionFactory(session);
     MessageBuilder<?> out = (MessageBuilder<?>) gw.handleRequestMessage(new GenericMessage<>("foo"));
     assertThat(out.getHeaders().get(FileHeaders.RENAME_TO)).isEqualTo("oo");
     assertThat(out.getHeaders().get(FileHeaders.REMOTE_FILE)).isEqualTo("foo");
     assertThat(args.get()).isEqualTo("foooo");
     assertThat(out.getPayload()).isEqualTo(Boolean.TRUE);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testMoveWithExpression() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mv", "payload");
    gw.setRenameExpression(PARSER.parseExpression("payload.substring(1)"));
    gw.afterPropertiesSet();
    Session<?> session = mock(Session.class);
    final AtomicReference<String> args = new AtomicReference<>();
    doAnswer(invocation -> {
        Object[] arguments = invocation.getArguments();
        args.set((String) arguments[0] + arguments[1]);
        return null;
    }).when(session).rename(anyString(), anyString());
    when(sessionFactory.getSession()).thenReturn(session);
    MessageBuilder<?> out = (MessageBuilder<?>) gw.handleRequestMessage(new GenericMessage<>("foo"));
    assertThat(out.getHeaders().get(FileHeaders.RENAME_TO)).isEqualTo("oo");
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_FILE)).isEqualTo("foo");
    assertThat(args.get()).isEqualTo("foooo");
    assertThat(out.getPayload()).isEqualTo(Boolean.TRUE);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session<?> session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_3_3
#### Test Case Name: `testMoveWithMkDirs`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testMoveWithMkDirs() throws Exception {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mv", "payload");
     gw.setRenameExpression(PARSER.parseExpression("'foo/bar/baz'"));
     gw.afterPropertiesSet();
     Session<?> session = mock(Session.class);
     final AtomicReference<String> args = new AtomicReference<>();
     doAnswer(invocation -> {
         Object[] arguments = invocation.getArguments();
         args.set((String) arguments[0] + arguments[1]);
         return null;
     }).when(session).rename(anyString(), anyString());
     final List<String> madeDirs = new ArrayList<>();
     doAnswer(invocation -> {
         madeDirs.add(invocation.getArgument(0));
         return true;
     }).when(session).mkdir(anyString());
-    when(sessionFactory.getSession()).thenReturn(session);
+    SessionFactory sessionFactory = createMockSessionFactory(session);
     Message<String> requestMessage = MessageBuilder.withPayload("foo").setHeader(FileHeaders.RENAME_TO, "bar").build();
     MessageBuilder<?> out = (MessageBuilder<?>) gw.handleRequestMessage(requestMessage);
     assertThat(out.getHeaders().get(FileHeaders.REMOTE_FILE)).isEqualTo("foo");
     assertThat(args.get()).isEqualTo("foofoo/bar/baz");
     assertThat(out.getPayload()).isEqualTo(Boolean.TRUE);
     assertThat(madeDirs.size()).isEqualTo(2);
     assertThat(madeDirs.get(0)).isEqualTo("foo");
     assertThat(madeDirs.get(1)).isEqualTo("foo/bar");
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testMoveWithMkDirs() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mv", "payload");
    gw.setRenameExpression(PARSER.parseExpression("'foo/bar/baz'"));
    gw.afterPropertiesSet();
    Session<?> session = mock(Session.class);
    final AtomicReference<String> args = new AtomicReference<>();
    doAnswer(invocation -> {
        Object[] arguments = invocation.getArguments();
        args.set((String) arguments[0] + arguments[1]);
        return null;
    }).when(session).rename(anyString(), anyString());
    final List<String> madeDirs = new ArrayList<>();
    doAnswer(invocation -> {
        madeDirs.add(invocation.getArgument(0));
        return true;
    }).when(session).mkdir(anyString());
    when(sessionFactory.getSession()).thenReturn(session);
    Message<String> requestMessage = MessageBuilder.withPayload("foo").setHeader(FileHeaders.RENAME_TO, "bar").build();
    MessageBuilder<?> out = (MessageBuilder<?>) gw.handleRequestMessage(requestMessage);
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_FILE)).isEqualTo("foo");
    assertThat(args.get()).isEqualTo("foofoo/bar/baz");
    assertThat(out.getPayload()).isEqualTo(Boolean.TRUE);
    assertThat(madeDirs.size()).isEqualTo(2);
    assertThat(madeDirs.get(0)).isEqualTo("foo");
    assertThat(madeDirs.get(1)).isEqualTo("foo/bar");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory createMockSessionFactory(Session<?> session) {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_4
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.file.remote.session.SessionFactory`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
// === Declare in class scope ===
private SessionFactory sessionFactory;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    sessionFactory = mock(SessionFactory.class);
}

// === Replace local variable in test with ===
sessionFactory;

```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_4_1
#### Test Case Name: `testBad`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
@@
@Test
public void testBad() {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
+    // removed local mock; replaced with global field `sessionFactory`
    assertThatIllegalArgumentException().isThrownBy(() -> new TestRemoteFileOutboundGateway(sessionFactory, "bad", "payload"));
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testBad() {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    assertThatIllegalArgumentException().isThrownBy(() -> new TestRemoteFileOutboundGateway(sessionFactory, "bad", "payload"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private SessionFactory sessionFactory;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    sessionFactory = mock(SessionFactory.class);
}

// === Replace local variable in test with ===
sessionFactory;

```
</details>

---
#### Test Case ID #spring-integration_Test_4_2
#### Test Case Name: `testBadFilterGet`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
@@
@Test
public void testBadFilterGet() {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
+    // removed local mock; replaced with global field `sessionFactory`
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "get", "payload");
    gw.setFilter(new TestPatternFilter(""));
    assertThatIllegalArgumentException().isThrownBy(gw::afterPropertiesSet).withMessageStartingWith("Filters are not supported");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testBadFilterGet() {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "get", "payload");
    gw.setFilter(new TestPatternFilter(""));
    assertThatIllegalArgumentException().isThrownBy(gw::afterPropertiesSet).withMessageStartingWith("Filters are not supported");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private SessionFactory sessionFactory;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    sessionFactory = mock(SessionFactory.class);
}

// === Replace local variable in test with ===
sessionFactory;

```
</details>

---
#### Test Case ID #spring-integration_Test_4_3
#### Test Case Name: `testBadFilterRm`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
@@
@Test
public void testBadFilterRm() {
-    SessionFactory sessionFactory = mock(SessionFactory.class);
+    // removed local mock; replaced with global field `sessionFactory`
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "rm", "payload");
    gw.setFilter(new TestPatternFilter(""));
    assertThatIllegalArgumentException().isThrownBy(gw::afterPropertiesSet).withMessageStartingWith("Filters are not supported");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testBadFilterRm() {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "rm", "payload");
    gw.setFilter(new TestPatternFilter(""));
    assertThatIllegalArgumentException().isThrownBy(gw::afterPropertiesSet).withMessageStartingWith("Filters are not supported");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private SessionFactory sessionFactory;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    sessionFactory = mock(SessionFactory.class);
}

// === Replace local variable in test with ===
sessionFactory;

```
</details>

---
## Mock Clone Instance #spring-integration_MCI_5
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.mqtt.core.Mqttv3ClientManager`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static Mqttv3ClientManager createMockMqttv3ClientManager(MqttAsyncClient client) {
    var clientManager = mock(Mqttv3ClientManager.class);
    when(clientManager.getConnectionInfo()).thenReturn(new MqttConnectOptions());
    given(clientManager.getClient()).willReturn(client);
    return clientManager;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_5_1
#### Test Case Name: `testClientManagerIsNotConnectedAndClosedInHandler`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mqtt\src\test\java\org\springframework\integration\mqtt\MqttAdapterTests.java`)
#### Mock Object Variable Name: `clientManager`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    // given
-    var clientManager = mock(Mqttv3ClientManager.class);
-    when(clientManager.getConnectionInfo()).thenReturn(new MqttConnectOptions());
    var client = mock(MqttAsyncClient.class);
-    given(clientManager.getClient()).willReturn(client);
+    var clientManager = createMockMqttv3ClientManager(client);
    var deliveryToken = mock(MqttDeliveryToken.class);
    given(client.publish(anyString(), any(), any(), any())).willReturn(deliveryToken);
    var handler = new MqttPahoMessageHandler(clientManager);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testClientManagerIsNotConnectedAndClosedInHandler() throws Exception {
    // given
    var clientManager = mock(Mqttv3ClientManager.class);
    when(clientManager.getConnectionInfo()).thenReturn(new MqttConnectOptions());
    var client = mock(MqttAsyncClient.class);
    given(clientManager.getClient()).willReturn(client);
    var deliveryToken = mock(MqttDeliveryToken.class);
    given(client.publish(anyString(), any(), any(), any())).willReturn(deliveryToken);
    var handler = new MqttPahoMessageHandler(clientManager);
    handler.setDefaultTopic("mqtt-foo");
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.start();
    // when
    handler.handleMessage(new GenericMessage<>("Hello, world!"));
    handler.stop();
    // then
    verify(client, never()).connect(any(MqttConnectOptions.class));
    verify(client).publish(anyString(), any(), any(), any());
    verify(client, never()).disconnect();
    verify(client, never()).disconnect(anyLong());
    verify(client, never()).close();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Mqttv3ClientManager createMockMqttv3ClientManager(MqttAsyncClient client) {
    var clientManager = mock(Mqttv3ClientManager.class);
    when(clientManager.getConnectionInfo()).thenReturn(new MqttConnectOptions());
    given(clientManager.getClient()).willReturn(client);
    return clientManager;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_5_2
#### Test Case Name: `testClientManagerIsNotConnectedAndClosedInAdapter`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mqtt\src\test\java\org\springframework\integration\mqtt\MqttAdapterTests.java`)
#### Mock Object Variable Name: `clientManager`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    // given
-    var clientManager = mock(Mqttv3ClientManager.class);
-    when(clientManager.getConnectionInfo()).thenReturn(new MqttConnectOptions());
    var client = mock(MqttAsyncClient.class);
-    given(clientManager.getClient()).willReturn(client);
+    var clientManager = createMockMqttv3ClientManager(client);
    var subscribeToken = mock(MqttToken.class);
    given(subscribeToken.getGrantedQos()).thenReturn(new int[] { 2 });
    given(client.subscribe(any(String[].class), any(int[].class), any())).willReturn(subscribeToken);
    var adapter = new MqttPahoMessageDrivenChannelAdapter(clientManager, "mqtt-foo");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testClientManagerIsNotConnectedAndClosedInAdapter() throws Exception {
    // given
    var clientManager = mock(Mqttv3ClientManager.class);
    when(clientManager.getConnectionInfo()).thenReturn(new MqttConnectOptions());
    var client = mock(MqttAsyncClient.class);
    given(clientManager.getClient()).willReturn(client);
    var subscribeToken = mock(MqttToken.class);
    given(subscribeToken.getGrantedQos()).willReturn(new int[] { 2 });
    given(client.subscribe(any(String[].class), any(int[].class), any())).willReturn(subscribeToken);
    var adapter = new MqttPahoMessageDrivenChannelAdapter(clientManager, "mqtt-foo");
    adapter.setBeanFactory(mock(BeanFactory.class));
    adapter.afterPropertiesSet();
    // when
    adapter.start();
    adapter.connectComplete(false, null);
    adapter.stop();
    // then
    verify(client, never()).connect(any(MqttConnectOptions.class));
    verify(client).subscribe(eq(new String[] { "mqtt-foo" }), any(int[].class), any());
    verify(client).unsubscribe(new String[] { "mqtt-foo" });
    verify(client, never()).disconnect();
    verify(client, never()).disconnect(anyLong());
    verify(client, never()).close();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Mqttv3ClientManager createMockMqttv3ClientManager(MqttAsyncClient client) {
    var clientManager = mock(Mqttv3ClientManager.class);
    when(clientManager.getConnectionInfo()).thenReturn(new MqttConnectOptions());
    given(clientManager.getClient()).willReturn(client);
    return clientManager;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_6
- **Scope**: method level
- **Mocked Class**: `com.rabbitmq.client.Connection`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static Connection createMockConnection(Channel channel) {
    Connection connection = mock(Connection.class);
    willReturn(true).given(connection).isOpen();
    willReturn(channel).given(connection).createChannel();
    return connection;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_6_1
#### Test Case Name: `testAck`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\inbound\AmqpMessageSourceTests.java`)
#### Mock Object Variable Name: `connection`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    willReturn(getResponse).given(channel).basicGet("foo", false);
-    Connection connection = mock(Connection.class);
-    willReturn(true).given(connection).isOpen();
-    willReturn(channel).given(connection).createChannel();
+    Connection connection = createMockConnection(channel);
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
    CachingConnectionFactory ccf = new CachingConnectionFactory(connectionFactory);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testAck() throws Exception {
    Channel channel = mock(Channel.class);
    willReturn(true).given(channel).isOpen();
    Envelope envelope = new Envelope(123L, false, "ex", "rk");
    BasicProperties props = new BasicProperties.Builder().contentType(MessageProperties.DEFAULT_CONTENT_TYPE).build();
    GetResponse getResponse = new GetResponse(envelope, props, "bar".getBytes(), 0);
    willReturn(getResponse).given(channel).basicGet("foo", false);
    Connection connection = mock(Connection.class);
    willReturn(true).given(connection).isOpen();
    willReturn(channel).given(connection).createChannel();
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
    CachingConnectionFactory ccf = new CachingConnectionFactory(connectionFactory);
    AmqpMessageSource source = new AmqpMessageSource(ccf, "foo");
    source.setRawMessageHeader(true);
    Message<?> received = source.receive();
    assertThat(received.getHeaders().get(AmqpMessageHeaderErrorMessageStrategy.AMQP_RAW_MESSAGE)).isInstanceOf(org.springframework.amqp.core.Message.class);
    assertThat(received.getHeaders().get(IntegrationMessageHeaderAccessor.SOURCE_DATA)).isSameAs(received.getHeaders().get(AmqpMessageHeaderErrorMessageStrategy.AMQP_RAW_MESSAGE));
    assertThat(received.getHeaders().get(AmqpHeaders.CONSUMER_QUEUE)).isEqualTo("foo");
    // make sure channel is not cached
    org.springframework.amqp.rabbit.connection.Connection conn = ccf.createConnection();
    // should not have been "closed"
    Channel notCached = conn.createChannel(false);
    verify(connection, times(2)).createChannel();
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(Status.ACCEPT);
    verify(channel).basicAck(123L, false);
    // should have been "closed"
    Channel cached = conn.createChannel(false);
    verify(connection, times(2)).createChannel();
    notCached.close();
    cached.close();
    ccf.destroy();
    verify(channel, times(2)).close();
    verify(connection).close(30000);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Connection createMockConnection(Channel channel) {
    Connection connection = mock(Connection.class);
    willReturn(true).given(connection).isOpen();
    willReturn(channel).given(connection).createChannel();
    return connection;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_6_2
#### Test Case Name: `testNackOrRequeue`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\inbound\AmqpMessageSourceTests.java`)
#### Mock Object Variable Name: `connection`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    willReturn(getResponse).given(channel).basicGet("foo", false);
-    Connection connection = mock(Connection.class);
-    willReturn(true).given(connection).isOpen();
-    willReturn(channel).given(connection).createChannel();
+    Connection connection = createMockConnection(channel);
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
    CachingConnectionFactory ccf = new CachingConnectionFactory(connectionFactory);
    AmqpMessageSource source = new AmqpMessageSource(ccf, "foo");
    Message<?> received = source.receive();
    verify(connection).createChannel();
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(requeue ? Status.REQUEUE : Status.REJECT);
    verify(channel).basicReject(123L, requeue);
    verify(connection).createChannel();
    ccf.destroy();
    verify(channel).close();
    verify(connection).close(30000);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
private void testNackOrRequeue(boolean requeue) throws Exception {
    Channel channel = mock(Channel.class);
    willReturn(true).given(channel).isOpen();
    Envelope envelope = new Envelope(123L, false, "ex", "rk");
    BasicProperties props = new BasicProperties.Builder().contentType(MessageProperties.DEFAULT_CONTENT_TYPE).build();
    GetResponse getResponse = new GetResponse(envelope, props, "bar".getBytes(), 0);
    willReturn(getResponse).given(channel).basicGet("foo", false);
    Connection connection = mock(Connection.class);
    willReturn(true).given(connection).isOpen();
    willReturn(channel).given(connection).createChannel();
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
    CachingConnectionFactory ccf = new CachingConnectionFactory(connectionFactory);
    AmqpMessageSource source = new AmqpMessageSource(ccf, "foo");
    Message<?> received = source.receive();
    verify(connection).createChannel();
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(requeue ? Status.REQUEUE : Status.REJECT);
    verify(channel).basicReject(123L, requeue);
    verify(connection).createChannel();
    ccf.destroy();
    verify(channel).close();
    verify(connection).close(30000);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Connection createMockConnection(Channel channel) {
    Connection connection = mock(Connection.class);
    willReturn(true).given(connection).isOpen();
    willReturn(channel).given(connection).createChannel();
    return connection;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_6_3
#### Test Case Name: `testBatch`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\inbound\AmqpMessageSourceTests.java`)
#### Mock Object Variable Name: `connection`
<summary>Suggested Diff</summary>

```diff
@@
    willReturn(getResponse).given(channel).basicGet("foo", false);
-    Connection connection = mock(Connection.class);
-    willReturn(true).given(connection).isOpen();
-    willReturn(channel).given(connection).createChannel();
+    Connection connection = createMockConnection(channel);
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
    CachingConnectionFactory ccf = new CachingConnectionFactory(connectionFactory);
    AmqpMessageSource source = new AmqpMessageSource(ccf, "foo");
    Message<?> received = source.receive();
    assertThat(received).isNotNull();
    assertThat(((List<String>) received.getPayload())).contains("test1", "test2");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "unchecked" })
@Test
public void testBatch() throws Exception {
    SimpleBatchingStrategy bs = new SimpleBatchingStrategy(2, 10_000, 10_000L);
    MessageProperties messageProperties = new MessageProperties();
    messageProperties.setContentType("text/plain");
    org.springframework.amqp.core.Message message = new org.springframework.amqp.core.Message("test1".getBytes(), messageProperties);
    bs.addToBatch("foo", "bar", message);
    message = new org.springframework.amqp.core.Message("test2".getBytes(), messageProperties);
    MessageBatch batched = bs.addToBatch("foo", "bar", message);
    Channel channel = mock(Channel.class);
    willReturn(true).given(channel).isOpen();
    Envelope envelope = new Envelope(123L, false, "ex", "rk");
    BasicProperties props = new BasicProperties.Builder().headers(batched.message().getMessageProperties().getHeaders()).contentType("text/plain").build();
    GetResponse getResponse = new GetResponse(envelope, props, batched.message().getBody(), 0);
    willReturn(getResponse).given(channel).basicGet("foo", false);
    Connection connection = mock(Connection.class);
    willReturn(true).given(connection).isOpen();
    willReturn(channel).given(connection).createChannel();
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
    CachingConnectionFactory ccf = new CachingConnectionFactory(connectionFactory);
    AmqpMessageSource source = new AmqpMessageSource(ccf, "foo");
    Message<?> received = source.receive();
    assertThat(received).isNotNull();
    assertThat(((List<String>) received.getPayload())).contains("test1", "test2");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Connection createMockConnection(Channel channel) {
    Connection connection = mock(Connection.class);
    willReturn(true).given(connection).isOpen();
    willReturn(channel).given(connection).createChannel();
    return connection;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_7
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.file.remote.RemoteFileTemplate<java.lang.String>`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static RemoteFileTemplate<String> createMockRemoteFileTemplate(Session<String> session) {
    RemoteFileTemplate<String> remoteFileTemplate = mock();
    when(remoteFileTemplate.getSession()).thenReturn(session);
    when(remoteFileTemplate.list("remoteDirectory")).thenReturn(new String[] { "file1", "file2" });
    return remoteFileTemplate;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_7_1
#### Test Case Name: `fetchFilesFromRemoteAfterClearingFetchedCache`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\RemoteFileStreamingMessageSourceTests.java`)
#### Mock Object Variable Name: `remoteFileTemplate`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void fetchFilesFromRemoteAfterClearingFetchedCache() throws IOException {
-    RemoteFileTemplate<String> remoteFileTemplate = mock();
-    when(remoteFileTemplate.list("remoteDirectory")).thenReturn(new String[] { "file1", "file2" });
     Session<String> session = mock();
     when(session.readRaw(anyString())).thenReturn(mock());
-    when(remoteFileTemplate.getSession()).thenReturn(session);
+    RemoteFileTemplate<String> remoteFileTemplate = createMockRemoteFileTemplate(session);
     Comparator<String> comparator = mock();
     TestRemoteFileStreamingMessageSource testRemoteFileStreamingMessageSource = new TestRemoteFileStreamingMessageSource(remoteFileTemplate, comparator);
     testRemoteFileStreamingMessageSource.setRemoteDirectory("remoteDirectory");
     testRemoteFileStreamingMessageSource.setBeanFactory(mock());
     testRemoteFileStreamingMessageSource.start();
     assertThat(testRemoteFileStreamingMessageSource.doReceive(2)).isNotNull();
     testRemoteFileStreamingMessageSource.clearFetchedCache();
     assertThat(testRemoteFileStreamingMessageSource.doReceive(2)).isNotNull();
     verify(remoteFileTemplate, times(2)).list("remoteDirectory");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void fetchFilesFromRemoteAfterClearingFetchedCache() throws IOException {
    RemoteFileTemplate<String> remoteFileTemplate = mock();
    when(remoteFileTemplate.list("remoteDirectory")).thenReturn(new String[] { "file1", "file2" });
    Session<String> session = mock();
    when(session.readRaw(anyString())).thenReturn(mock());
    when(remoteFileTemplate.getSession()).thenReturn(session);
    Comparator<String> comparator = mock();
    TestRemoteFileStreamingMessageSource testRemoteFileStreamingMessageSource = new TestRemoteFileStreamingMessageSource(remoteFileTemplate, comparator);
    testRemoteFileStreamingMessageSource.setRemoteDirectory("remoteDirectory");
    testRemoteFileStreamingMessageSource.setBeanFactory(mock());
    testRemoteFileStreamingMessageSource.start();
    assertThat(testRemoteFileStreamingMessageSource.doReceive(2)).isNotNull();
    testRemoteFileStreamingMessageSource.clearFetchedCache();
    assertThat(testRemoteFileStreamingMessageSource.doReceive(2)).isNotNull();
    verify(remoteFileTemplate, times(2)).list("remoteDirectory");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static RemoteFileTemplate<String> createMockRemoteFileTemplate(Session<String> session) {
    RemoteFileTemplate<String> remoteFileTemplate = mock();
    when(remoteFileTemplate.getSession()).thenReturn(session);
    when(remoteFileTemplate.list("remoteDirectory")).thenReturn(new String[] { "file1", "file2" });
    return remoteFileTemplate;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_7_2
#### Test Case Name: `filterOutFilesNotAcceptedByFilter`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\RemoteFileStreamingMessageSourceTests.java`)
#### Mock Object Variable Name: `remoteFileTemplate`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void filterOutFilesNotAcceptedByFilter() throws IOException {
-    RemoteFileTemplate<String> remoteFileTemplate = mock();
-    when(remoteFileTemplate.list("remoteDirectory")).thenReturn(new String[] { "file1", "file2" });
     Session<String> session = mock();
     when(session.readRaw(anyString())).thenReturn(mock());
-    when(remoteFileTemplate.getSession()).thenReturn(session);
+    RemoteFileTemplate<String> remoteFileTemplate = createMockRemoteFileTemplate(session);
     FileListFilter<String> fileListFilter = mock();
     when(fileListFilter.supportsSingleFileFiltering()).thenReturn(true);
     when(fileListFilter.accept("file1")).thenReturn(false);
     when(fileListFilter.accept("file2")).thenReturn(false);
     Comparator<String> comparator = mock();
     TestRemoteFileStreamingMessageSource testRemoteFileStreamingMessageSource = new TestRemoteFileStreamingMessageSource(remoteFileTemplate, comparator);
     testRemoteFileStreamingMessageSource.setFilter(fileListFilter);
     testRemoteFileStreamingMessageSource.setRemoteDirectory("remoteDirectory");
     testRemoteFileStreamingMessageSource.setBeanFactory(mock());
     testRemoteFileStreamingMessageSource.start();
     assertThat(testRemoteFileStreamingMessageSource.doReceive(-1)).isNull();
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void filterOutFilesNotAcceptedByFilter() throws IOException {
    RemoteFileTemplate<String> remoteFileTemplate = mock();
    when(remoteFileTemplate.list("remoteDirectory")).thenReturn(new String[] { "file1", "file2" });
    Session<String> session = mock();
    when(session.readRaw(anyString())).thenReturn(mock());
    when(remoteFileTemplate.getSession()).thenReturn(session);
    FileListFilter<String> fileListFilter = mock();
    when(fileListFilter.supportsSingleFileFiltering()).thenReturn(true);
    when(fileListFilter.accept("file1")).thenReturn(false);
    when(fileListFilter.accept("file2")).thenReturn(false);
    Comparator<String> comparator = mock();
    TestRemoteFileStreamingMessageSource testRemoteFileStreamingMessageSource = new TestRemoteFileStreamingMessageSource(remoteFileTemplate, comparator);
    testRemoteFileStreamingMessageSource.setFilter(fileListFilter);
    testRemoteFileStreamingMessageSource.setRemoteDirectory("remoteDirectory");
    testRemoteFileStreamingMessageSource.setBeanFactory(mock());
    testRemoteFileStreamingMessageSource.start();
    assertThat(testRemoteFileStreamingMessageSource.doReceive(-1)).isNull();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static RemoteFileTemplate<String> createMockRemoteFileTemplate(Session<String> session) {
    RemoteFileTemplate<String> remoteFileTemplate = mock();
    when(remoteFileTemplate.getSession()).thenReturn(session);
    when(remoteFileTemplate.list("remoteDirectory")).thenReturn(new String[] { "file1", "file2" });
    return remoteFileTemplate;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_8
- **Scope**: method level
- **Mocked Class**: `java.net.InetAddress`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
// === Declare in class scope ===
private InetAddress local;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    local = mock(InetAddress.class);
}

// === Replace local variable in test with ===
local;

```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_8_1
#### Test Case Name: `testToMessage`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpMessageMapperTests.java`)
#### Mock Object Variable Name: `local`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testToMessage() {
     TcpMessageMapper mapper = new TcpMessageMapper();
     TcpConnection connection = creatMockTcpConcnection(TEST_PAYLOAD.getBytes(), "MyHost", "1.1.1.1", 1234);
-    InetAddress local = mock(InetAddress.class);
+    // removed local mock; replaced with global field `local`
     Socket socket = creatMockSocket(local);
     SocketInfo info = new SocketInfo(socket);
     when(connection.getSocketInfo()).thenReturn(info);
     Message<?> message = mapper.toMessage(connection);
     assertThat(new String((byte[]) message.getPayload())).isEqualTo(TEST_PAYLOAD);
     assertThat(message.getHeaders().get(IpHeaders.HOSTNAME)).isEqualTo("MyHost");
     assertThat(message.getHeaders().get(IpHeaders.IP_ADDRESS)).isEqualTo("1.1.1.1");
     assertThat(message.getHeaders().get(IpHeaders.REMOTE_PORT)).isEqualTo(1234);
     assertThat(message.getHeaders().get(IpHeaders.LOCAL_ADDRESS)).isSameAs(local);
     assertThat(message.getHeaders().get(MessageHeaders.CONTENT_TYPE)).isNull();
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testToMessage() {
    TcpMessageMapper mapper = new TcpMessageMapper();
    TcpConnection connection = creatMockTcpConcnection(TEST_PAYLOAD.getBytes(), "MyHost", "1.1.1.1", 1234);
    InetAddress local = mock(InetAddress.class);
    Socket socket = creatMockSocket(local);
    SocketInfo info = new SocketInfo(socket);
    when(connection.getSocketInfo()).thenReturn(info);
    Message<?> message = mapper.toMessage(connection);
    assertThat(new String((byte[]) message.getPayload())).isEqualTo(TEST_PAYLOAD);
    assertThat(message.getHeaders().get(IpHeaders.HOSTNAME)).isEqualTo("MyHost");
    assertThat(message.getHeaders().get(IpHeaders.IP_ADDRESS)).isEqualTo("1.1.1.1");
    assertThat(message.getHeaders().get(IpHeaders.REMOTE_PORT)).isEqualTo(1234);
    assertThat(message.getHeaders().get(IpHeaders.LOCAL_ADDRESS)).isSameAs(local);
    assertThat(message.getHeaders().get(MessageHeaders.CONTENT_TYPE)).isNull();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private InetAddress local;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    local = mock(InetAddress.class);
}

// === Replace local variable in test with ===
local;

```
</details>

---
#### Test Case ID #spring-integration_Test_8_2
#### Test Case Name: `testToMessageWithContentType`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpMessageMapperTests.java`)
#### Mock Object Variable Name: `local`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testToMessageWithContentType() {
     TcpMessageMapper mapper = new TcpMessageMapper();
     mapper.setAddContentTypeHeader(true);
     TcpConnection connection = creatMockTcpConcnection(TEST_PAYLOAD.getBytes(), "MyHost", "1.1.1.1", 1234);
-    InetAddress local = mock(InetAddress.class);
+    // removed local mock; replaced with global field `local`
     Socket socket = creatMockSocket(local);
     SocketInfo info = new SocketInfo(socket);
     when(connection.getSocketInfo()).thenReturn(info);
     Message<?> message = mapper.toMessage(connection);
     assertThat(new String((byte[]) message.getPayload())).isEqualTo(TEST_PAYLOAD);
     assertThat(message.getHeaders().get(IpHeaders.HOSTNAME)).isEqualTo("MyHost");
     assertThat(message.getHeaders().get(IpHeaders.IP_ADDRESS)).isEqualTo("1.1.1.1");
     assertThat(message.getHeaders().get(IpHeaders.REMOTE_PORT)).isEqualTo(1234);
     assertThat(message.getHeaders().get(IpHeaders.LOCAL_ADDRESS)).isSameAs(local);
     assertThat(message.getHeaders().get(MessageHeaders.CONTENT_TYPE)).isEqualTo("application/octet-stream;charset=UTF-8");
     MimeType parseOk = MimeType.valueOf((String) message.getHeaders().get(MessageHeaders.CONTENT_TYPE));
     assertThat(parseOk.toString()).isEqualTo(message.getHeaders().get(MessageHeaders.CONTENT_TYPE));
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testToMessageWithContentType() {
    TcpMessageMapper mapper = new TcpMessageMapper();
    mapper.setAddContentTypeHeader(true);
    TcpConnection connection = creatMockTcpConcnection(TEST_PAYLOAD.getBytes(), "MyHost", "1.1.1.1", 1234);
    InetAddress local = mock(InetAddress.class);
    Socket socket = creatMockSocket(local);
    SocketInfo info = new SocketInfo(socket);
    when(connection.getSocketInfo()).thenReturn(info);
    Message<?> message = mapper.toMessage(connection);
    assertThat(new String((byte[]) message.getPayload())).isEqualTo(TEST_PAYLOAD);
    assertThat(message.getHeaders().get(IpHeaders.HOSTNAME)).isEqualTo("MyHost");
    assertThat(message.getHeaders().get(IpHeaders.IP_ADDRESS)).isEqualTo("1.1.1.1");
    assertThat(message.getHeaders().get(IpHeaders.REMOTE_PORT)).isEqualTo(1234);
    assertThat(message.getHeaders().get(IpHeaders.LOCAL_ADDRESS)).isSameAs(local);
    assertThat(message.getHeaders().get(MessageHeaders.CONTENT_TYPE)).isEqualTo("application/octet-stream;charset=UTF-8");
    MimeType parseOk = MimeType.valueOf((String) message.getHeaders().get(MessageHeaders.CONTENT_TYPE));
    assertThat(parseOk.toString()).isEqualTo(message.getHeaders().get(MessageHeaders.CONTENT_TYPE));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private InetAddress local;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    local = mock(InetAddress.class);
}

// === Replace local variable in test with ===
local;

```
</details>

---
#### Test Case ID #spring-integration_Test_8_3
#### Test Case Name: `testToMessageWithCustomContentType`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpMessageMapperTests.java`)
#### Mock Object Variable Name: `local`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testToMessageWithCustomContentType() {
     TcpMessageMapper mapper = new TcpMessageMapper();
     mapper.setAddContentTypeHeader(true);
     mapper.setContentType("application/octet-stream;charset=ISO-8859-1");
     TcpConnection connection = creatMockTcpConcnection(TEST_PAYLOAD.getBytes(), "MyHost", "1.1.1.1", 1234);
-    InetAddress local = mock(InetAddress.class);
+    // removed local mock; replaced with global field `local`
     Socket socket = creatMockSocket(local);
     SocketInfo info = new SocketInfo(socket);
     when(connection.getSocketInfo()).thenReturn(info);
     Message<?> message = mapper.toMessage(connection);
     assertThat(new String((byte[]) message.getPayload())).isEqualTo(TEST_PAYLOAD);
     assertThat(message.getHeaders().get(IpHeaders.HOSTNAME)).isEqualTo("MyHost");
     assertThat(message.getHeaders().get(IpHeaders.IP_ADDRESS)).isEqualTo("1.1.1.1");
     assertThat(message.getHeaders().get(IpHeaders.REMOTE_PORT)).isEqualTo(1234);
     assertThat(message.getHeaders().get(IpHeaders.LOCAL_ADDRESS)).isSameAs(local);
     assertThat(message.getHeaders().get(MessageHeaders.CONTENT_TYPE)).isEqualTo("application/octet-stream;charset=ISO-8859-1");
     MimeType parseOk = MimeType.valueOf((String) message.getHeaders().get(MessageHeaders.CONTENT_TYPE));
     assertThat(parseOk.toString()).isEqualTo(message.getHeaders().get(MessageHeaders.CONTENT_TYPE));
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testToMessageWithCustomContentType() {
    TcpMessageMapper mapper = new TcpMessageMapper();
    mapper.setAddContentTypeHeader(true);
    mapper.setContentType("application/octet-stream;charset=ISO-8859-1");
    TcpConnection connection = creatMockTcpConcnection(TEST_PAYLOAD.getBytes(), "MyHost", "1.1.1.1", 1234);
    InetAddress local = mock(InetAddress.class);
    Socket socket = creatMockSocket(local);
    SocketInfo info = new SocketInfo(socket);
    when(connection.getSocketInfo()).thenReturn(info);
    Message<?> message = mapper.toMessage(connection);
    assertThat(new String((byte[]) message.getPayload())).isEqualTo(TEST_PAYLOAD);
    assertThat(message.getHeaders().get(IpHeaders.HOSTNAME)).isEqualTo("MyHost");
    assertThat(message.getHeaders().get(IpHeaders.IP_ADDRESS)).isEqualTo("1.1.1.1");
    assertThat(message.getHeaders().get(IpHeaders.REMOTE_PORT)).isEqualTo(1234);
    assertThat(message.getHeaders().get(IpHeaders.LOCAL_ADDRESS)).isSameAs(local);
    assertThat(message.getHeaders().get(MessageHeaders.CONTENT_TYPE)).isEqualTo("application/octet-stream;charset=ISO-8859-1");
    MimeType parseOk = MimeType.valueOf((String) message.getHeaders().get(MessageHeaders.CONTENT_TYPE));
    assertThat(parseOk.toString()).isEqualTo(message.getHeaders().get(MessageHeaders.CONTENT_TYPE));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private InetAddress local;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    local = mock(InetAddress.class);
}

// === Replace local variable in test with ===
local;

```
</details>

---
## Mock Clone Instance #spring-integration_MCI_9
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.ip.tcp.connection.TcpSocketFactorySupport`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static TcpSocketFactorySupport createMockTcpSocketFactorySupport(SocketFactory socketFactory) {
    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
    when(factorySupport.getSocketFactory()).thenReturn(socketFactory);
    return factorySupport;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_9_1
#### Test Case Name: `testNetClient`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\SocketSupportTests.java`)
#### Mock Object Variable Name: `factorySupport`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testNetClient() throws Exception {
-    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
     SocketFactory factory = Mockito.mock(SocketFactory.class);
-    when(factorySupport.getSocketFactory()).thenReturn(factory);
+    TcpSocketFactorySupport factorySupport = createMockTcpSocketFactorySupport(factory);
     Socket socket = mock(Socket.class);
     InputStream is = mock(InputStream.class);
     when(is.read()).thenReturn(-1);
     when(socket.getInputStream()).thenReturn(is);
     InetAddress inetAddress = InetAddress.getLocalHost();
     when(socket.getInetAddress()).thenReturn(inetAddress);
     when(factory.createSocket()).thenReturn(socket);
     TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);
     TcpNetClientConnectionFactory connectionFactory = new TcpNetClientConnectionFactory("x", 0);
     connectionFactory.setTcpSocketFactorySupport(factorySupport);
     connectionFactory.setTcpSocketSupport(socketSupport);
     connectionFactory.start();
     connectionFactory.getConnection();
     verify(socketSupport).postProcessSocket(socket);
     connectionFactory.stop();
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testNetClient() throws Exception {
    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
    SocketFactory factory = Mockito.mock(SocketFactory.class);
    when(factorySupport.getSocketFactory()).thenReturn(factory);
    Socket socket = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
    when(socket.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
    when(socket.getInetAddress()).thenReturn(inetAddress);
    when(factory.createSocket()).thenReturn(socket);
    TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);
    TcpNetClientConnectionFactory connectionFactory = new TcpNetClientConnectionFactory("x", 0);
    connectionFactory.setTcpSocketFactorySupport(factorySupport);
    connectionFactory.setTcpSocketSupport(socketSupport);
    connectionFactory.start();
    connectionFactory.getConnection();
    verify(socketSupport).postProcessSocket(socket);
    connectionFactory.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static TcpSocketFactorySupport createMockTcpSocketFactorySupport(SocketFactory socketFactory) {
    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
    when(factorySupport.getSocketFactory()).thenReturn(socketFactory);
    return factorySupport;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_9_2
#### Test Case Name: `testNetClientSocketTimeout`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\SocketSupportTests.java`)
#### Mock Object Variable Name: `factorySupport`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testNetClientSocketTimeout() throws Exception {
-    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
     SocketFactory factory = Mockito.mock(SocketFactory.class);
+    TcpSocketFactorySupport factorySupport = createMockTcpSocketFactorySupport(factory);
     Socket socket = mock(Socket.class);
     InputStream is = mock(InputStream.class);
     when(is.read()).thenReturn(-1);
     when(socket.getInputStream()).thenReturn(is);
     InetAddress inetAddress = InetAddress.getLocalHost();
     when(socket.getInetAddress()).thenReturn(inetAddress);
     when(factory.createSocket()).thenReturn(socket);
     doThrow(new SocketTimeoutException()).when(socket).connect(any(), eq(1000));
     TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);
     TcpNetClientConnectionFactory connectionFactory = new TcpNetClientConnectionFactory("x", 0);
     connectionFactory.setConnectTimeout(1);
     connectionFactory.setTcpSocketFactorySupport(factorySupport);
     connectionFactory.setTcpSocketSupport(socketSupport);
     connectionFactory.start();
     assertThatThrownBy(connectionFactory::getConnection).isInstanceOf(UncheckedIOException.class).hasCauseInstanceOf(SocketTimeoutException.class);
     connectionFactory.stop();
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testNetClientSocketTimeout() throws Exception {
    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
    SocketFactory factory = Mockito.mock(SocketFactory.class);
    when(factorySupport.getSocketFactory()).thenReturn(factory);
    Socket socket = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
    when(socket.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
    when(socket.getInetAddress()).thenReturn(inetAddress);
    when(factory.createSocket()).thenReturn(socket);
    doThrow(new SocketTimeoutException()).when(socket).connect(any(), eq(1000));
    TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);
    TcpNetClientConnectionFactory connectionFactory = new TcpNetClientConnectionFactory("x", 0);
    connectionFactory.setConnectTimeout(1);
    connectionFactory.setTcpSocketFactorySupport(factorySupport);
    connectionFactory.setTcpSocketSupport(socketSupport);
    connectionFactory.start();
    assertThatThrownBy(connectionFactory::getConnection).isInstanceOf(UncheckedIOException.class).hasCauseInstanceOf(SocketTimeoutException.class);
    connectionFactory.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static TcpSocketFactorySupport createMockTcpSocketFactorySupport(SocketFactory socketFactory) {
    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
    when(factorySupport.getSocketFactory()).thenReturn(socketFactory);
    return factorySupport;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_10
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.file.remote.session.Session<?>`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static Session<?> createMockSession(AtomicReference<String> args) {
    Session<?> session = mock(Session.class);
    doAnswer(invocation -> {
        Object[] arguments = invocation.getArguments();
        args.set((String) arguments[0] + arguments[1]);
        return null;
    }).when(session).rename(anyString(), anyString());
    return session;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_10_1
#### Test Case Name: `testMove`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    gw.afterPropertiesSet();
-    Session<?> session = mock(Session.class);
    final AtomicReference<String> args = new AtomicReference<>();
-    doAnswer(invocation -> {
-        Object[] arguments = invocation.getArguments();
-        args.set((String) arguments[0] + arguments[1]);
-        return null;
-    }).when(session).rename(anyString(), anyString());
+    Session<?> session = createMockSession(args);
    when(sessionFactory.getSession()).thenReturn(session);
    Message<String> requestMessage = MessageBuilder.withPayload("foo").setHeader(FileHeaders.RENAME_TO, "bar").build();
    MessageBuilder<?> out = (MessageBuilder<?>) gw.handleRequestMessage(requestMessage);
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_FILE)).isEqualTo("foo");
    assertThat(args.get()).isEqualTo("foobar");
    assertThat(out.getPayload()).isEqualTo(Boolean.TRUE);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testMove() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mv", "payload");
    gw.afterPropertiesSet();
    Session<?> session = mock(Session.class);
    final AtomicReference<String> args = new AtomicReference<>();
    doAnswer(invocation -> {
        Object[] arguments = invocation.getArguments();
        args.set((String) arguments[0] + arguments[1]);
        return null;
    }).when(session).rename(anyString(), anyString());
    when(sessionFactory.getSession()).thenReturn(session);
    Message<String> requestMessage = MessageBuilder.withPayload("foo").setHeader(FileHeaders.RENAME_TO, "bar").build();
    MessageBuilder<?> out = (MessageBuilder<?>) gw.handleRequestMessage(requestMessage);
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_FILE)).isEqualTo("foo");
    assertThat(args.get()).isEqualTo("foobar");
    assertThat(out.getPayload()).isEqualTo(Boolean.TRUE);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session<?> createMockSession(AtomicReference<String> args) {
    Session<?> session = mock(Session.class);
    doAnswer(invocation -> {
        Object[] arguments = invocation.getArguments();
        args.set((String) arguments[0] + arguments[1]);
        return null;
    }).when(session).rename(anyString(), anyString());
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_10_2
#### Test Case Name: `testMoveWithExpression`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    gw.setRenameExpression(PARSER.parseExpression("payload.substring(1)"));
    gw.afterPropertiesSet();
-    Session<?> session = mock(Session.class);
    final AtomicReference<String> args = new AtomicReference<>();
-    doAnswer(invocation -> {
-        Object[] arguments = invocation.getArguments();
-        args.set((String) arguments[0] + arguments[1]);
-        return null;
-    }).when(session).rename(anyString(), anyString());
+    Session<?> session = createMockSession(args);
    when(sessionFactory.getSession()).thenReturn(session);
    MessageBuilder<?> out = (MessageBuilder<?>) gw.handleRequestMessage(new GenericMessage<>("foo"));
    assertThat(out.getHeaders().get(FileHeaders.RENAME_TO)).isEqualTo("oo");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testMoveWithExpression() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mv", "payload");
    gw.setRenameExpression(PARSER.parseExpression("payload.substring(1)"));
    gw.afterPropertiesSet();
    Session<?> session = mock(Session.class);
    final AtomicReference<String> args = new AtomicReference<>();
    doAnswer(invocation -> {
        Object[] arguments = invocation.getArguments();
        args.set((String) arguments[0] + arguments[1]);
        return null;
    }).when(session).rename(anyString(), anyString());
    when(sessionFactory.getSession()).thenReturn(session);
    MessageBuilder<?> out = (MessageBuilder<?>) gw.handleRequestMessage(new GenericMessage<>("foo"));
    assertThat(out.getHeaders().get(FileHeaders.RENAME_TO)).isEqualTo("oo");
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_FILE)).isEqualTo("foo");
    assertThat(args.get()).isEqualTo("foooo");
    assertThat(out.getPayload()).isEqualTo(Boolean.TRUE);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session<?> createMockSession(AtomicReference<String> args) {
    Session<?> session = mock(Session.class);
    doAnswer(invocation -> {
        Object[] arguments = invocation.getArguments();
        args.set((String) arguments[0] + arguments[1]);
        return null;
    }).when(session).rename(anyString(), anyString());
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_10_3
#### Test Case Name: `testMoveWithMkDirs`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    gw.afterPropertiesSet();
-    Session<?> session = mock(Session.class);
    final AtomicReference<String> args = new AtomicReference<>();
-    doAnswer(invocation -> {
-        Object[] arguments = invocation.getArguments();
-        args.set((String) arguments[0] + arguments[1]);
-        return null;
-    }).when(session).rename(anyString(), anyString());
+    Session<?> session = createMockSession(args);
    final List<String> madeDirs = new ArrayList<>();
    doAnswer(invocation -> {
        madeDirs.add(invocation.getArgument(0));
        return true;
    }).when(session).mkdir(anyString());
    when(sessionFactory.getSession()).thenReturn(session);
    Message<String> requestMessage = MessageBuilder.withPayload("foo").setHeader(FileHeaders.RENAME_TO, "bar").build();
    MessageBuilder<?> out = (MessageBuilder<?>) gw.handleRequestMessage(requestMessage);
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_FILE)).isEqualTo("foo");
    assertThat(args.get()).isEqualTo("foofoo/bar/baz");
    assertThat(out.getPayload()).isEqualTo(Boolean.TRUE);
    assertThat(madeDirs.size()).isEqualTo(2);
    assertThat(madeDirs.get(0)).isEqualTo("foo");
    assertThat(madeDirs.get(1)).isEqualTo("foo/bar");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testMoveWithMkDirs() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mv", "payload");
    gw.setRenameExpression(PARSER.parseExpression("'foo/bar/baz'"));
    gw.afterPropertiesSet();
    Session<?> session = mock(Session.class);
    final AtomicReference<String> args = new AtomicReference<>();
    doAnswer(invocation -> {
        Object[] arguments = invocation.getArguments();
        args.set((String) arguments[0] + arguments[1]);
        return null;
    }).when(session).rename(anyString(), anyString());
    final List<String> madeDirs = new ArrayList<>();
    doAnswer(invocation -> {
        madeDirs.add(invocation.getArgument(0));
        return true;
    }).when(session).mkdir(anyString());
    when(sessionFactory.getSession()).thenReturn(session);
    Message<String> requestMessage = MessageBuilder.withPayload("foo").setHeader(FileHeaders.RENAME_TO, "bar").build();
    MessageBuilder<?> out = (MessageBuilder<?>) gw.handleRequestMessage(requestMessage);
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_FILE)).isEqualTo("foo");
    assertThat(args.get()).isEqualTo("foofoo/bar/baz");
    assertThat(out.getPayload()).isEqualTo(Boolean.TRUE);
    assertThat(madeDirs.size()).isEqualTo(2);
    assertThat(madeDirs.get(0)).isEqualTo("foo");
    assertThat(madeDirs.get(1)).isEqualTo("foo/bar");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session<?> createMockSession(AtomicReference<String> args) {
    Session<?> session = mock(Session.class);
    doAnswer(invocation -> {
        Object[] arguments = invocation.getArguments();
        args.set((String) arguments[0] + arguments[1]);
        return null;
    }).when(session).rename(anyString(), anyString());
    return session;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_11
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.support.locks.LockRegistry`
- **Test Case Count**: 2
- **MO Count**: 3

### Reusable Method
```java
private static LockRegistry createMockLockRegistry(Lock lock) {
    LockRegistry registry = mock(LockRegistry.class);
    given(registry.obtain(anyString())).willReturn(lock);
    return registry;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_11_1
#### Test Case Name: `competingWithLock`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\support\leader\LockRegistryLeaderInitiatorTests.java`)
#### Mock Object Variable Name: `firstRegistry`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    // switch used to toggle which registry obtains lock
    AtomicBoolean firstLocked = new AtomicBoolean(true);
    // set up first registry instance - this one will be able to obtain lock initially
-    LockRegistry firstRegistry = mock(LockRegistry.class);
    Lock firstLock = mock(Lock.class);
-    given(firstRegistry.obtain(anyString())).willReturn(firstLock);
+    LockRegistry firstRegistry = createMockLockRegistry(firstLock);
    given(firstLock.tryLock(anyLong(), any(TimeUnit.class))).willAnswer(i -> firstLocked.get());
    // set up first initiator instance using first LockRegistry
    LockRegistryLeaderInitiator first = new LockRegistryLeaderInitiator(firstRegistry, new DefaultCandidate());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void competingWithLock() throws Exception {
    // switch used to toggle which registry obtains lock
    AtomicBoolean firstLocked = new AtomicBoolean(true);
    // set up first registry instance - this one will be able to obtain lock initially
    LockRegistry firstRegistry = mock(LockRegistry.class);
    Lock firstLock = mock(Lock.class);
    given(firstRegistry.obtain(anyString())).willReturn(firstLock);
    given(firstLock.tryLock(anyLong(), any(TimeUnit.class))).willAnswer(i -> firstLocked.get());
    // set up first initiator instance using first LockRegistry
    LockRegistryLeaderInitiator first = new LockRegistryLeaderInitiator(firstRegistry, new DefaultCandidate());
    CountDownLatch firstGranted = new CountDownLatch(1);
    CountDownLatch firstRevoked = new CountDownLatch(1);
    CountDownLatch firstAquireLockFailed = new CountDownLatch(1);
    first.setHeartBeatMillis(10);
    first.setBusyWaitMillis(1);
    first.setLeaderEventPublisher(new CountingPublisher(firstGranted, firstRevoked, firstAquireLockFailed));
    // set up second registry instance - this one will NOT be able to obtain lock initially
    LockRegistry secondRegistry = mock(LockRegistry.class);
    Lock secondLock = mock(Lock.class);
    given(secondRegistry.obtain(anyString())).willReturn(secondLock);
    given(secondLock.tryLock(anyLong(), any(TimeUnit.class))).willAnswer(i -> !firstLocked.get());
    // set up second initiator instance using second LockRegistry
    LockRegistryLeaderInitiator second = new LockRegistryLeaderInitiator(secondRegistry, new DefaultCandidate());
    CountDownLatch secondGranted = new CountDownLatch(1);
    CountDownLatch secondRevoked = new CountDownLatch(1);
    CountDownLatch secondAquireLockFailed = new CountDownLatch(1);
    second.setHeartBeatMillis(10);
    second.setBusyWaitMillis(1);
    second.setLeaderEventPublisher(new CountingPublisher(secondGranted, secondRevoked, secondAquireLockFailed));
    // start initiators
    first.start();
    second.start();
    // first initiator should lead and publish granted event
    assertThat(firstGranted.await(10, TimeUnit.SECONDS)).isTrue();
    assertThat(first.getContext().isLeader()).isTrue();
    assertThat(second.getContext().isLeader()).isFalse();
    // simulate first registry instance unable to obtain lock, for example due to lock timeout
    firstLocked.set(false);
    // second initiator should take lead and publish granted event, first initiator should publish revoked event
    assertThat(secondGranted.await(10, TimeUnit.SECONDS)).isTrue();
    assertThat(firstRevoked.await(10, TimeUnit.SECONDS)).isTrue();
    assertThat(second.getContext().isLeader()).isTrue();
    assertThat(first.getContext().isLeader()).isFalse();
    first.stop();
    second.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static LockRegistry createMockLockRegistry(Lock lock) {
    LockRegistry registry = mock(LockRegistry.class);
    given(registry.obtain(anyString())).willReturn(lock);
    return registry;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_11_2
#### Test Case Name: `competingWithLock`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\support\leader\LockRegistryLeaderInitiatorTests.java`)
#### Mock Object Variable Name: `secondRegistry`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    second.setHeartBeatMillis(10);
    second.setBusyWaitMillis(1);
    second.setLeaderEventPublisher(new CountingPublisher(secondGranted, secondRevoked, secondAquireLockFailed));
    // start initiators
    first.start();
    second.start();
@@
    // set up second registry instance - this one will NOT be able to obtain lock initially
-    LockRegistry secondRegistry = mock(LockRegistry.class);
    Lock secondLock = mock(Lock.class);
+    LockRegistry secondRegistry = createMockLockRegistry(secondLock);
    given(secondLock.tryLock(anyLong(), any(TimeUnit.class))).willAnswer(i -> !firstLocked.get());
    // set up second initiator instance using second LockRegistry
    LockRegistryLeaderInitiator second = new LockRegistryLeaderInitiator(secondRegistry, new DefaultCandidate());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void competingWithLock() throws Exception {
    // switch used to toggle which registry obtains lock
    AtomicBoolean firstLocked = new AtomicBoolean(true);
    // set up first registry instance - this one will be able to obtain lock initially
    LockRegistry firstRegistry = mock(LockRegistry.class);
    Lock firstLock = mock(Lock.class);
    given(firstRegistry.obtain(anyString())).willReturn(firstLock);
    given(firstLock.tryLock(anyLong(), any(TimeUnit.class))).willAnswer(i -> firstLocked.get());
    // set up first initiator instance using first LockRegistry
    LockRegistryLeaderInitiator first = new LockRegistryLeaderInitiator(firstRegistry, new DefaultCandidate());
    CountDownLatch firstGranted = new CountDownLatch(1);
    CountDownLatch firstRevoked = new CountDownLatch(1);
    CountDownLatch firstAquireLockFailed = new CountDownLatch(1);
    first.setHeartBeatMillis(10);
    first.setBusyWaitMillis(1);
    first.setLeaderEventPublisher(new CountingPublisher(firstGranted, firstRevoked, firstAquireLockFailed));
    // set up second registry instance - this one will NOT be able to obtain lock initially
    LockRegistry secondRegistry = mock(LockRegistry.class);
    Lock secondLock = mock(Lock.class);
    given(secondRegistry.obtain(anyString())).willReturn(secondLock);
    given(secondLock.tryLock(anyLong(), any(TimeUnit.class))).willAnswer(i -> !firstLocked.get());
    // set up second initiator instance using second LockRegistry
    LockRegistryLeaderInitiator second = new LockRegistryLeaderInitiator(secondRegistry, new DefaultCandidate());
    CountDownLatch secondGranted = new CountDownLatch(1);
    CountDownLatch secondRevoked = new CountDownLatch(1);
    CountDownLatch secondAquireLockFailed = new CountDownLatch(1);
    second.setHeartBeatMillis(10);
    second.setBusyWaitMillis(1);
    second.setLeaderEventPublisher(new CountingPublisher(secondGranted, secondRevoked, secondAquireLockFailed));
    // start initiators
    first.start();
    second.start();
    // first initiator should lead and publish granted event
    assertThat(firstGranted.await(10, TimeUnit.SECONDS)).isTrue();
    assertThat(first.getContext().isLeader()).isTrue();
    assertThat(second.getContext().isLeader()).isFalse();
    // simulate first registry instance unable to obtain lock, for example due to lock timeout
    firstLocked.set(false);
    // second initiator should take lead and publish granted event, first initiator should publish revoked event
    assertThat(secondGranted.await(10, TimeUnit.SECONDS)).isTrue();
    assertThat(firstRevoked.await(10, TimeUnit.SECONDS)).isTrue();
    assertThat(second.getContext().isLeader()).isTrue();
    assertThat(first.getContext().isLeader()).isFalse();
    first.stop();
    second.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static LockRegistry createMockLockRegistry(Lock lock) {
    LockRegistry registry = mock(LockRegistry.class);
    given(registry.obtain(anyString())).willReturn(lock);
    return registry;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_11_3
#### Test Case Name: `testGracefulLeaderSelectorExit`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\support\leader\LockRegistryLeaderInitiatorTests.java`)
#### Mock Object Variable Name: `registry`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    AtomicReference<Throwable> throwableAtomicReference = new AtomicReference<>();
-    LockRegistry registry = mock(LockRegistry.class);
    Lock lock = spy(new ReentrantLock());
    willAnswer(invocation -> {
        try {
            return invocation.callRealMethod();
        } catch (Throwable e) {
            throwableAtomicReference.set(e);
            throw e;
        }
    }).given(lock).unlock();
-    given(registry.obtain(anyString())).willReturn(lock);
+    LockRegistry registry = createMockLockRegistry(lock);
    LockRegistryLeaderInitiator another = new LockRegistryLeaderInitiator(registry);
    willAnswer(invocation -> {
        another.stop();
        return false;
    }).given(lock).tryLock(anyLong(), eq(TimeUnit.MILLISECONDS));
    new DirectFieldAccessor(another).setPropertyValue("taskExecutor", new TaskExecutorAdapter(new SyncTaskExecutor()));
    another.start();
    Throwable throwable = throwableAtomicReference.get();
    assertThat(throwable).isNull();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testGracefulLeaderSelectorExit() throws Exception {
    AtomicReference<Throwable> throwableAtomicReference = new AtomicReference<>();
    LockRegistry registry = mock(LockRegistry.class);
    Lock lock = spy(new ReentrantLock());
    willAnswer(invocation -> {
        try {
            return invocation.callRealMethod();
        } catch (Throwable e) {
            throwableAtomicReference.set(e);
            throw e;
        }
    }).given(lock).unlock();
    given(registry.obtain(anyString())).willReturn(lock);
    LockRegistryLeaderInitiator another = new LockRegistryLeaderInitiator(registry);
    willAnswer(invocation -> {
        another.stop();
        return false;
    }).given(lock).tryLock(anyLong(), eq(TimeUnit.MILLISECONDS));
    new DirectFieldAccessor(another).setPropertyValue("taskExecutor", new TaskExecutorAdapter(new SyncTaskExecutor()));
    another.start();
    Throwable throwable = throwableAtomicReference.get();
    assertThat(throwable).isNull();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static LockRegistry createMockLockRegistry(Lock lock) {
    LockRegistry registry = mock(LockRegistry.class);
    given(registry.obtain(anyString())).willReturn(lock);
    return registry;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_12
- **Scope**: class level
- **Mocked Class**: `java.nio.channels.SocketChannel`
- **Test Case Count**: 7
- **MO Count**: 8

### Reusable Method
```java
public class MockSocketChannel {
    public static SocketChannel createMockSocketChannel(Socket socket) {
        SocketChannel socketChannel = mock(SocketChannel.class);
        when(socketChannel.socket()).thenReturn(socket);
        return socketChannel;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_12_1
#### Test Case Name: `testBinary`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpNetConnectionTests.java`)
#### Mock Object Variable Name: `socketChannel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testBinary() throws Exception {
-    SocketChannel socketChannel = mock(SocketChannel.class);
     Socket socket = mock(Socket.class);
-    when(socketChannel.socket()).thenReturn(socket);
+    SocketChannel socketChannel = MockSocketChannel.createMockSocketChannel(socket);
     TcpNioConnection connection = new TcpNioConnection(socketChannel, true, false, e -> {
     }, null);
     ChannelInputStream inputStream = TestUtils.getPropertyValue(connection, "channelInputStream", ChannelInputStream.class);
     inputStream.write(ByteBuffer.wrap(new byte[] { (byte) 0x80 }));
     assertThat(inputStream.read()).isEqualTo(0x80);
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testBinary() throws Exception {
    SocketChannel socketChannel = mock(SocketChannel.class);
    Socket socket = mock(Socket.class);
    when(socketChannel.socket()).thenReturn(socket);
    TcpNioConnection connection = new TcpNioConnection(socketChannel, true, false, e -> {
    }, null);
    ChannelInputStream inputStream = TestUtils.getPropertyValue(connection, "channelInputStream", ChannelInputStream.class);
    inputStream.write(ByteBuffer.wrap(new byte[] { (byte) 0x80 }));
    assertThat(inputStream.read()).isEqualTo(0x80);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockSocketChannel {
    public static SocketChannel createMockSocketChannel(Socket socket) {
        SocketChannel socketChannel = mock(SocketChannel.class);
        when(socketChannel.socket()).thenReturn(socket);
        return socketChannel;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_12_2
#### Test Case Name: `testByteArrayRead`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpNioConnectionTests.java`)
#### Mock Object Variable Name: `socketChannel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testByteArrayRead() throws Exception {
-    SocketChannel socketChannel = mock(SocketChannel.class);
     Socket socket = mock(Socket.class);
-    when(socketChannel.socket()).thenReturn(socket);
+    SocketChannel socketChannel = MockSocketChannel.createMockSocketChannel(socket);
     TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
     TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
     stream.write(ByteBuffer.wrap("foo".getBytes()));
     byte[] out = new byte[2];
     int n = stream.read(out);
     assertThat(n).isEqualTo(2);
     assertThat(new String(out)).isEqualTo("fo");
     out = new byte[2];
     n = stream.read(out);
     assertThat(n).isEqualTo(1);
     assertThat(new String(out)).isEqualTo("o\u0000");
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testByteArrayRead() throws Exception {
    SocketChannel socketChannel = mock(SocketChannel.class);
    Socket socket = mock(Socket.class);
    when(socketChannel.socket()).thenReturn(socket);
    TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
    TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
    stream.write(ByteBuffer.wrap("foo".getBytes()));
    byte[] out = new byte[2];
    int n = stream.read(out);
    assertThat(n).isEqualTo(2);
    assertThat(new String(out)).isEqualTo("fo");
    out = new byte[2];
    n = stream.read(out);
    assertThat(n).isEqualTo(1);
    assertThat(new String(out)).isEqualTo("o\u0000");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockSocketChannel {
    public static SocketChannel createMockSocketChannel(Socket socket) {
        SocketChannel socketChannel = mock(SocketChannel.class);
        when(socketChannel.socket()).thenReturn(socket);
        return socketChannel;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_12_3
#### Test Case Name: `testByteArrayReadMulti`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpNioConnectionTests.java`)
#### Mock Object Variable Name: `socketChannel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testByteArrayReadMulti() throws Exception {
-    SocketChannel socketChannel = mock(SocketChannel.class);
     Socket socket = mock(Socket.class);
-    when(socketChannel.socket()).thenReturn(socket);
+    SocketChannel socketChannel = MockSocketChannel.createMockSocketChannel(socket);
     TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
     TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
     stream.write(ByteBuffer.wrap("foo".getBytes()));
     stream.write(ByteBuffer.wrap("bar".getBytes()));
     byte[] out = new byte[6];
     int n = stream.read(out);
     assertThat(n).isEqualTo(6);
     assertThat(new String(out)).isEqualTo("foobar");
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testByteArrayReadMulti() throws Exception {
    SocketChannel socketChannel = mock(SocketChannel.class);
    Socket socket = mock(Socket.class);
    when(socketChannel.socket()).thenReturn(socket);
    TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
    TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
    stream.write(ByteBuffer.wrap("foo".getBytes()));
    stream.write(ByteBuffer.wrap("bar".getBytes()));
    byte[] out = new byte[6];
    int n = stream.read(out);
    assertThat(n).isEqualTo(6);
    assertThat(new String(out)).isEqualTo("foobar");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockSocketChannel {
    public static SocketChannel createMockSocketChannel(Socket socket) {
        SocketChannel socketChannel = mock(SocketChannel.class);
        when(socketChannel.socket()).thenReturn(socket);
        return socketChannel;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_12_4
#### Test Case Name: `testByteArrayReadWithOffset`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpNioConnectionTests.java`)
#### Mock Object Variable Name: `socketChannel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testByteArrayReadWithOffset() throws Exception {
-    SocketChannel socketChannel = mock(SocketChannel.class);
     Socket socket = mock(Socket.class);
-    when(socketChannel.socket()).thenReturn(socket);
+    SocketChannel socketChannel = MockSocketChannel.createMockSocketChannel(socket);
     TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
     TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
     stream.write(ByteBuffer.wrap("foo".getBytes()));
     byte[] out = new byte[5];
     int n = stream.read(out, 1, 4);
     assertThat(n).isEqualTo(3);
     assertThat(new String(out)).isEqualTo("\u0000foo\u0000");
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testByteArrayReadWithOffset() throws Exception {
    SocketChannel socketChannel = mock(SocketChannel.class);
    Socket socket = mock(Socket.class);
    when(socketChannel.socket()).thenReturn(socket);
    TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
    TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
    stream.write(ByteBuffer.wrap("foo".getBytes()));
    byte[] out = new byte[5];
    int n = stream.read(out, 1, 4);
    assertThat(n).isEqualTo(3);
    assertThat(new String(out)).isEqualTo("\u0000foo\u0000");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockSocketChannel {
    public static SocketChannel createMockSocketChannel(Socket socket) {
        SocketChannel socketChannel = mock(SocketChannel.class);
        when(socketChannel.socket()).thenReturn(socket);
        return socketChannel;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_12_5
#### Test Case Name: `testByteArrayReadWithBadArgs`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpNioConnectionTests.java`)
#### Mock Object Variable Name: `socketChannel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void testByteArrayReadWithBadArgs() throws Exception {
-    SocketChannel socketChannel = mock(SocketChannel.class);
     Socket socket = mock(Socket.class);
-    when(socketChannel.socket()).thenReturn(socket);
+    SocketChannel socketChannel = MockSocketChannel.createMockSocketChannel(socket);
     TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
     TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
     stream.write(ByteBuffer.wrap("foo".getBytes()));
     byte[] out = new byte[5];
     assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> stream.read(out, 1, 5));
     assertThatIllegalArgumentException().isThrownBy(() -> stream.read(null, 1, 5));
     assertThat(stream.read(out, 0, 0)).isEqualTo(0);
     assertThat(stream.read(out)).isEqualTo(3);
}
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testByteArrayReadWithBadArgs() throws Exception {
    SocketChannel socketChannel = mock(SocketChannel.class);
    Socket socket = mock(Socket.class);
    when(socketChannel.socket()).thenReturn(socket);
    TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
    TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
    stream.write(ByteBuffer.wrap("foo".getBytes()));
    byte[] out = new byte[5];
    assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> stream.read(out, 1, 5));
    assertThatIllegalArgumentException().isThrownBy(() -> stream.read(null, 1, 5));
    assertThat(stream.read(out, 0, 0)).isEqualTo(0);
    assertThat(stream.read(out)).isEqualTo(3);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockSocketChannel {
    public static SocketChannel createMockSocketChannel(Socket socket) {
        SocketChannel socketChannel = mock(SocketChannel.class);
        when(socketChannel.socket()).thenReturn(socket);
        return socketChannel;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_12_6
#### Test Case Name: `testByteArrayBlocksForZeroRead`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpNioConnectionTests.java`)
#### Mock Object Variable Name: `socketChannel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void testByteArrayBlocksForZeroRead() throws Exception {
-    SocketChannel socketChannel = mock(SocketChannel.class);
     Socket socket = mock(Socket.class);
-    when(socketChannel.socket()).thenReturn(socket);
+    SocketChannel socketChannel = MockSocketChannel.createMockSocketChannel(socket);
     TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
     final TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
     final CountDownLatch latch = new CountDownLatch(1);
     final byte[] out = new byte[4];
     this.executor.execute(() -> {
         try {
             stream.read(out);
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
         latch.countDown();
     });
     Thread.sleep(1000);
     assertThat(out[0]).isEqualTo((byte) 0x00);
     stream.write(ByteBuffer.wrap("foo".getBytes()));
     assertThat(latch.await(10, TimeUnit.SECONDS)).isTrue();
     assertThat(new String(out)).isEqualTo("foo\u0000");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testByteArrayBlocksForZeroRead() throws Exception {
    SocketChannel socketChannel = mock(SocketChannel.class);
    Socket socket = mock(Socket.class);
    when(socketChannel.socket()).thenReturn(socket);
    TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
    final TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
    final CountDownLatch latch = new CountDownLatch(1);
    final byte[] out = new byte[4];
    this.executor.execute(() -> {
        try {
            stream.read(out);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        latch.countDown();
    });
    Thread.sleep(1000);
    assertThat(out[0]).isEqualTo((byte) 0x00);
    stream.write(ByteBuffer.wrap("foo".getBytes()));
    assertThat(latch.await(10, TimeUnit.SECONDS)).isTrue();
    assertThat(new String(out)).isEqualTo("foo\u0000");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockSocketChannel {
    public static SocketChannel createMockSocketChannel(Socket socket) {
        SocketChannel socketChannel = mock(SocketChannel.class);
        when(socketChannel.socket()).thenReturn(socket);
        return socketChannel;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_12_7
#### Test Case Name: `transferHeaders`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpNioConnectionTests.java`)
#### Mock Object Variable Name: `inChannel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Socket inSocket = mock(Socket.class);
-    SocketChannel inChannel = mock(SocketChannel.class);
-    when(inChannel.socket()).thenReturn(inSocket);
+    SocketChannel inChannel = MockSocketChannel.createMockSocketChannel(inSocket);
    TcpNioConnection inboundConnection = new TcpNioConnection(inChannel, true, false, nullPublisher, null);
    inboundConnection.setDeserializer(new MapJsonSerializer());
    MapMessageConverter inConverter = new MapMessageConverter();
    MessageConvertingTcpMessageMapper inMapper = new MessageConvertingTcpMessageMapper(inConverter);
    inboundConnection.setMapper(inMapper);
    final ByteArrayOutputStream written = new ByteArrayOutputStream();
    doAnswer(new Answer<Integer>() {

        @Override
        public Integer answer(InvocationOnMock invocation) {
            ByteBuffer buff = invocation.getArgument(0);
            byte[] bytes = written.toByteArray();
            buff.put(bytes);
            return bytes.length;
        }
    }).when(inChannel).read(any(ByteBuffer.class));
    Socket outSocket = mock(Socket.class);
    SocketChannel outChannel = mock(SocketChannel.class);
    when(outChannel.socket()).thenReturn(outSocket);
    TcpNioConnection outboundConnection = new TcpNioConnection(outChannel, true, false, nullPublisher, null);
    doAnswer(invocation -> {
        ByteBuffer buff = invocation.getArgument(0);
        byte[] bytes = new byte[buff.limit()];
        buff.get(bytes);
        written.write(bytes);
        return null;
    }).when(outChannel).write(any(ByteBuffer.class));
    MapMessageConverter outConverter = new MapMessageConverter();
    outConverter.setHeaderNames("bar");
    MessageConvertingTcpMessageMapper outMapper = new MessageConvertingTcpMessageMapper(outConverter);
    outboundConnection.setMapper(outMapper);
    outboundConnection.setSerializer(new MapJsonSerializer());
    Message<String> message = MessageBuilder.withPayload("foo").setHeader("bar", "baz").build();
    outboundConnection.send(message);
    final AtomicReference<Message<?>> inboundMessage = new AtomicReference<Message<?>>();
    final CountDownLatch latch = new CountDownLatch(1);
    TcpListener listener = message1 -> {
        inboundMessage.set(message1);
        latch.countDown();
        return false;
    };
    inboundConnection.registerListener(listener);
    inboundConnection.readPacket();
    assertThat(latch.await(10, TimeUnit.SECONDS)).isTrue();
    assertThat(inboundMessage.get()).isNotNull();
    assertThat(inboundMessage.get().getPayload()).isEqualTo("foo");
    assertThat(inboundMessage.get().getHeaders().get("bar")).isEqualTo("baz");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void transferHeaders() throws Exception {
    Socket inSocket = mock(Socket.class);
    SocketChannel inChannel = mock(SocketChannel.class);
    when(inChannel.socket()).thenReturn(inSocket);
    TcpNioConnection inboundConnection = new TcpNioConnection(inChannel, true, false, nullPublisher, null);
    inboundConnection.setDeserializer(new MapJsonSerializer());
    MapMessageConverter inConverter = new MapMessageConverter();
    MessageConvertingTcpMessageMapper inMapper = new MessageConvertingTcpMessageMapper(inConverter);
    inboundConnection.setMapper(inMapper);
    final ByteArrayOutputStream written = new ByteArrayOutputStream();
    doAnswer(new Answer<Integer>() {

        @Override
        public Integer answer(InvocationOnMock invocation) {
            ByteBuffer buff = invocation.getArgument(0);
            byte[] bytes = written.toByteArray();
            buff.put(bytes);
            return bytes.length;
        }
    }).when(inChannel).read(any(ByteBuffer.class));
    Socket outSocket = mock(Socket.class);
    SocketChannel outChannel = mock(SocketChannel.class);
    when(outChannel.socket()).thenReturn(outSocket);
    TcpNioConnection outboundConnection = new TcpNioConnection(outChannel, true, false, nullPublisher, null);
    doAnswer(invocation -> {
        ByteBuffer buff = invocation.getArgument(0);
        byte[] bytes = new byte[buff.limit()];
        buff.get(bytes);
        written.write(bytes);
        return null;
    }).when(outChannel).write(any(ByteBuffer.class));
    MapMessageConverter outConverter = new MapMessageConverter();
    outConverter.setHeaderNames("bar");
    MessageConvertingTcpMessageMapper outMapper = new MessageConvertingTcpMessageMapper(outConverter);
    outboundConnection.setMapper(outMapper);
    outboundConnection.setSerializer(new MapJsonSerializer());
    Message<String> message = MessageBuilder.withPayload("foo").setHeader("bar", "baz").build();
    outboundConnection.send(message);
    final AtomicReference<Message<?>> inboundMessage = new AtomicReference<Message<?>>();
    final CountDownLatch latch = new CountDownLatch(1);
    TcpListener listener = message1 -> {
        inboundMessage.set(message1);
        latch.countDown();
        return false;
    };
    inboundConnection.registerListener(listener);
    inboundConnection.readPacket();
    assertThat(latch.await(10, TimeUnit.SECONDS)).isTrue();
    assertThat(inboundMessage.get()).isNotNull();
    assertThat(inboundMessage.get().getPayload()).isEqualTo("foo");
    assertThat(inboundMessage.get().getHeaders().get("bar")).isEqualTo("baz");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockSocketChannel {
    public static SocketChannel createMockSocketChannel(Socket socket) {
        SocketChannel socketChannel = mock(SocketChannel.class);
        when(socketChannel.socket()).thenReturn(socket);
        return socketChannel;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_12_8
#### Test Case Name: `transferHeaders`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpNioConnectionTests.java`)
#### Mock Object Variable Name: `outChannel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Socket outSocket = mock(Socket.class);
-    SocketChannel outChannel = mock(SocketChannel.class);
-    when(outChannel.socket()).thenReturn(outSocket);
+    SocketChannel outChannel = MockSocketChannel.createMockSocketChannel(outSocket);
    TcpNioConnection outboundConnection = new TcpNioConnection(outChannel, true, false, nullPublisher, null);
    doAnswer(invocation -> {
        ByteBuffer buff = invocation.getArgument(0);
        byte[] bytes = new byte[buff.limit()];
        buff.get(bytes);
        written.write(bytes);
        return null;
    }).when(outChannel).write(any(ByteBuffer.class));
    MapMessageConverter outConverter = new MapMessageConverter();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void transferHeaders() throws Exception {
    Socket inSocket = mock(Socket.class);
    SocketChannel inChannel = mock(SocketChannel.class);
    when(inChannel.socket()).thenReturn(inSocket);
    TcpNioConnection inboundConnection = new TcpNioConnection(inChannel, true, false, nullPublisher, null);
    inboundConnection.setDeserializer(new MapJsonSerializer());
    MapMessageConverter inConverter = new MapMessageConverter();
    MessageConvertingTcpMessageMapper inMapper = new MessageConvertingTcpMessageMapper(inConverter);
    inboundConnection.setMapper(inMapper);
    final ByteArrayOutputStream written = new ByteArrayOutputStream();
    doAnswer(new Answer<Integer>() {

        @Override
        public Integer answer(InvocationOnMock invocation) {
            ByteBuffer buff = invocation.getArgument(0);
            byte[] bytes = written.toByteArray();
            buff.put(bytes);
            return bytes.length;
        }
    }).when(inChannel).read(any(ByteBuffer.class));
    Socket outSocket = mock(Socket.class);
    SocketChannel outChannel = mock(SocketChannel.class);
    when(outChannel.socket()).thenReturn(outSocket);
    TcpNioConnection outboundConnection = new TcpNioConnection(outChannel, true, false, nullPublisher, null);
    doAnswer(invocation -> {
        ByteBuffer buff = invocation.getArgument(0);
        byte[] bytes = new byte[buff.limit()];
        buff.get(bytes);
        written.write(bytes);
        return null;
    }).when(outChannel).write(any(ByteBuffer.class));
    MapMessageConverter outConverter = new MapMessageConverter();
    outConverter.setHeaderNames("bar");
    MessageConvertingTcpMessageMapper outMapper = new MessageConvertingTcpMessageMapper(outConverter);
    outboundConnection.setMapper(outMapper);
    outboundConnection.setSerializer(new MapJsonSerializer());
    Message<String> message = MessageBuilder.withPayload("foo").setHeader("bar", "baz").build();
    outboundConnection.send(message);
    final AtomicReference<Message<?>> inboundMessage = new AtomicReference<Message<?>>();
    final CountDownLatch latch = new CountDownLatch(1);
    TcpListener listener = message1 -> {
        inboundMessage.set(message1);
        latch.countDown();
        return false;
    };
    inboundConnection.registerListener(listener);
    inboundConnection.readPacket();
    assertThat(latch.await(10, TimeUnit.SECONDS)).isTrue();
    assertThat(inboundMessage.get()).isNotNull();
    assertThat(inboundMessage.get().getPayload()).isEqualTo("foo");
    assertThat(inboundMessage.get().getHeaders().get("bar")).isEqualTo("baz");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockSocketChannel {
    public static SocketChannel createMockSocketChannel(Socket socket) {
        SocketChannel socketChannel = mock(SocketChannel.class);
        when(socketChannel.socket()).thenReturn(socket);
        return socketChannel;
    }
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_13
- **Scope**: method level
- **Mocked Class**: `java.nio.channels.SocketChannel`
- **Test Case Count**: 1
- **MO Count**: 3

### Reusable Method
```java
private static SocketChannel createMockSocketChannel(boolean isOpenReturn) {
    SocketChannel channel = mock(SocketChannel.class);
    willReturn(isOpenReturn).given(channel).isOpen();
    return channel;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_13_1
#### Test Case Name: `testCleanup`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpNioConnectionTests.java`)
#### Mock Object Variable Name: `chan1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Map<SocketChannel, TcpNioConnection> connections = new HashMap<>();
-    SocketChannel chan1 = mock(SocketChannel.class);
+    SocketChannel chan1 = createMockSocketChannel(true);
    SocketChannel chan2 = mock(SocketChannel.class);
    SocketChannel chan3 = mock(SocketChannel.class);
    TcpNioConnection conn1 = mock(TcpNioConnection.class);
    TcpNioConnection conn2 = mock(TcpNioConnection.class);
    TcpNioConnection conn3 = mock(TcpNioConnection.class);
    connections.put(chan1, conn1);
    connections.put(chan2, conn2);
    connections.put(chan3, conn3);
-    willReturn(true).given(chan1).isOpen();
    willReturn(true).given(chan2).isOpen();
    willReturn(true).given(chan3).isOpen();
    Selector selector = mock(Selector.class);
    HashSet<SelectionKey> keys = new HashSet<>();
    when(selector.selectedKeys()).thenReturn(keys);
    factory.processNioSelections(1, selector, null, connections);
    // all open
    assertThat(connections.size()).isEqualTo(3);
    DirectFieldAccessor factoryFieldAccessor = new DirectFieldAccessor(factory);
-    willReturn(false).given(chan1).isOpen();
+    willReturn(false).given(chan1).isOpen();
    factory.processNioSelections(1, selector, null, connections);
    // interval didn't pass
    assertThat(connections.size()).isEqualTo(3);
    factoryFieldAccessor.setPropertyValue("nextCheckForClosedNioConnections", System.currentTimeMillis() - 10);
    factory.processNioSelections(1, selector, null, connections);
    // first is closed
    assertThat(connections.size()).isEqualTo(2);
    willReturn(false).given(chan2).isOpen();
    factory.processNioSelections(1, selector, null, connections);
    // interval didn't pass
    assertThat(connections.size()).isEqualTo(2);
    factoryFieldAccessor.setPropertyValue("nextCheckForClosedNioConnections", System.currentTimeMillis() - 10);
    factory.processNioSelections(1, selector, null, connections);
    // second is closed
    assertThat(connections.size()).isEqualTo(1);
    willReturn(false).given(chan3).isOpen();
    factory.processNioSelections(1, selector, null, connections);
    // interval didn't pass
    assertThat(connections.size()).isEqualTo(1);
    factoryFieldAccessor.setPropertyValue("nextCheckForClosedNioConnections", System.currentTimeMillis() - 10);
    factory.processNioSelections(1, selector, null, connections);
    // third is closed
    assertThat(connections.size()).isEqualTo(0);
    assertThat(TestUtils.getPropertyValue(factory, "connections", Map.class).size()).isEqualTo(0);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testCleanup() {
    TcpNioClientConnectionFactory factory = new TcpNioClientConnectionFactory("localhost", 0);
    factory.setApplicationEventPublisher(nullPublisher);
    Map<SocketChannel, TcpNioConnection> connections = new HashMap<>();
    SocketChannel chan1 = mock(SocketChannel.class);
    SocketChannel chan2 = mock(SocketChannel.class);
    SocketChannel chan3 = mock(SocketChannel.class);
    TcpNioConnection conn1 = mock(TcpNioConnection.class);
    TcpNioConnection conn2 = mock(TcpNioConnection.class);
    TcpNioConnection conn3 = mock(TcpNioConnection.class);
    connections.put(chan1, conn1);
    connections.put(chan2, conn2);
    connections.put(chan3, conn3);
    willReturn(true).given(chan1).isOpen();
    willReturn(true).given(chan2).isOpen();
    willReturn(true).given(chan3).isOpen();
    Selector selector = mock(Selector.class);
    HashSet<SelectionKey> keys = new HashSet<>();
    when(selector.selectedKeys()).thenReturn(keys);
    factory.processNioSelections(1, selector, null, connections);
    // all open
    assertThat(connections.size()).isEqualTo(3);
    DirectFieldAccessor factoryFieldAccessor = new DirectFieldAccessor(factory);
    willReturn(false).given(chan1).isOpen();
    factory.processNioSelections(1, selector, null, connections);
    // interval didn't pass
    assertThat(connections.size()).isEqualTo(3);
    factoryFieldAccessor.setPropertyValue("nextCheckForClosedNioConnections", System.currentTimeMillis() - 10);
    factory.processNioSelections(1, selector, null, connections);
    // first is closed
    assertThat(connections.size()).isEqualTo(2);
    willReturn(false).given(chan2).isOpen();
    factory.processNioSelections(1, selector, null, connections);
    // interval didn't pass
    assertThat(connections.size()).isEqualTo(2);
    factoryFieldAccessor.setPropertyValue("nextCheckForClosedNioConnections", System.currentTimeMillis() - 10);
    factory.processNioSelections(1, selector, null, connections);
    // second is closed
    assertThat(connections.size()).isEqualTo(1);
    willReturn(false).given(chan3).isOpen();
    factory.processNioSelections(1, selector, null, connections);
    // interval didn't pass
    assertThat(connections.size()).isEqualTo(1);
    factoryFieldAccessor.setPropertyValue("nextCheckForClosedNioConnections", System.currentTimeMillis() - 10);
    factory.processNioSelections(1, selector, null, connections);
    // third is closed
    assertThat(connections.size()).isEqualTo(0);
    assertThat(TestUtils.getPropertyValue(factory, "connections", Map.class).size()).isEqualTo(0);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SocketChannel createMockSocketChannel(boolean isOpenReturn) {
    SocketChannel channel = mock(SocketChannel.class);
    willReturn(isOpenReturn).given(channel).isOpen();
    return channel;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_13_2
#### Test Case Name: `testCleanup`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpNioConnectionTests.java`)
#### Mock Object Variable Name: `chan2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SocketChannel chan1 = mock(SocketChannel.class);
-    SocketChannel chan2 = mock(SocketChannel.class);
+    SocketChannel chan2 = createMockSocketChannel(true);
    SocketChannel chan3 = mock(SocketChannel.class);
    TcpNioConnection conn1 = mock(TcpNioConnection.class);
    TcpNioConnection conn2 = mock(TcpNioConnection.class);
    TcpNioConnection conn3 = mock(TcpNioConnection.class);
    connections.put(chan1, conn1);
    connections.put(chan2, conn2);
    connections.put(chan3, conn3);
    willReturn(true).given(chan1).isOpen();
-    willReturn(true).given(chan2).isOpen();
    willReturn(true).given(chan3).isOpen();
    Selector selector = mock(Selector.class);
    HashSet<SelectionKey> keys = new HashSet<>();
    when(selector.selectedKeys()).thenReturn(keys);
    factory.processNioSelections(1, selector, null, connections);
    // all open
    assertThat(connections.size()).isEqualTo(3);
    DirectFieldAccessor factoryFieldAccessor = new DirectFieldAccessor(factory);
    willReturn(false).given(chan1).isOpen();
    factory.processNioSelections(1, selector, null, connections);
    // interval didn't pass
    assertThat(connections.size()).isEqualTo(3);
    factoryFieldAccessor.setPropertyValue("nextCheckForClosedNioConnections", System.currentTimeMillis() - 10);
    factory.processNioSelections(1, selector, null, connections);
    // first is closed
    assertThat(connections.size()).isEqualTo(2);
-    willReturn(false).given(chan2).isOpen();
+    willReturn(false).given(chan2).isOpen();
    factory.processNioSelections(1, selector, null, connections);
    // interval didn't pass
    assertThat(connections.size()).isEqualTo(2);
    factoryFieldAccessor.setPropertyValue("nextCheckForClosedNioConnections", System.currentTimeMillis() - 10);
    factory.processNioSelections(1, selector, null, connections);
    // second is closed
    assertThat(connections.size()).isEqualTo(1);
    willReturn(false).given(chan3).isOpen();
    factory.processNioSelections(1, selector, null, connections);
    // interval didn't pass
    assertThat(connections.size()).isEqualTo(1);
    factoryFieldAccessor.setPropertyValue("nextCheckForClosedNioConnections", System.currentTimeMillis() - 10);
    factory.processNioSelections(1, selector, null, connections);
    // third is closed
    assertThat(connections.size()).isEqualTo(0);
    assertThat(TestUtils.getPropertyValue(factory, "connections", Map.class).size()).isEqualTo(0);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testCleanup() {
    TcpNioClientConnectionFactory factory = new TcpNioClientConnectionFactory("localhost", 0);
    factory.setApplicationEventPublisher(nullPublisher);
    Map<SocketChannel, TcpNioConnection> connections = new HashMap<>();
    SocketChannel chan1 = mock(SocketChannel.class);
    SocketChannel chan2 = mock(SocketChannel.class);
    SocketChannel chan3 = mock(SocketChannel.class);
    TcpNioConnection conn1 = mock(TcpNioConnection.class);
    TcpNioConnection conn2 = mock(TcpNioConnection.class);
    TcpNioConnection conn3 = mock(TcpNioConnection.class);
    connections.put(chan1, conn1);
    connections.put(chan2, conn2);
    connections.put(chan3, conn3);
    willReturn(true).given(chan1).isOpen();
    willReturn(true).given(chan2).isOpen();
    willReturn(true).given(chan3).isOpen();
    Selector selector = mock(Selector.class);
    HashSet<SelectionKey> keys = new HashSet<>();
    when(selector.selectedKeys()).thenReturn(keys);
    factory.processNioSelections(1, selector, null, connections);
    // all open
    assertThat(connections.size()).isEqualTo(3);
    DirectFieldAccessor factoryFieldAccessor = new DirectFieldAccessor(factory);
    willReturn(false).given(chan1).isOpen();
    factory.processNioSelections(1, selector, null, connections);
    // interval didn't pass
    assertThat(connections.size()).isEqualTo(3);
    factoryFieldAccessor.setPropertyValue("nextCheckForClosedNioConnections", System.currentTimeMillis() - 10);
    factory.processNioSelections(1, selector, null, connections);
    // first is closed
    assertThat(connections.size()).isEqualTo(2);
    willReturn(false).given(chan2).isOpen();
    factory.processNioSelections(1, selector, null, connections);
    // interval didn't pass
    assertThat(connections.size()).isEqualTo(2);
    factoryFieldAccessor.setPropertyValue("nextCheckForClosedNioConnections", System.currentTimeMillis() - 10);
    factory.processNioSelections(1, selector, null, connections);
    // second is closed
    assertThat(connections.size()).isEqualTo(1);
    willReturn(false).given(chan3).isOpen();
    factory.processNioSelections(1, selector, null, connections);
    // interval didn't pass
    assertThat(connections.size()).isEqualTo(1);
    factoryFieldAccessor.setPropertyValue("nextCheckForClosedNioConnections", System.currentTimeMillis() - 10);
    factory.processNioSelections(1, selector, null, connections);
    // third is closed
    assertThat(connections.size()).isEqualTo(0);
    assertThat(TestUtils.getPropertyValue(factory, "connections", Map.class).size()).isEqualTo(0);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SocketChannel createMockSocketChannel(boolean isOpenReturn) {
    SocketChannel channel = mock(SocketChannel.class);
    willReturn(isOpenReturn).given(channel).isOpen();
    return channel;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_13_3
#### Test Case Name: `testCleanup`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpNioConnectionTests.java`)
#### Mock Object Variable Name: `chan3`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SocketChannel chan1 = mock(SocketChannel.class);
    SocketChannel chan2 = mock(SocketChannel.class);
-    SocketChannel chan3 = mock(SocketChannel.class);
+    SocketChannel chan3 = createMockSocketChannel(true);
    TcpNioConnection conn1 = mock(TcpNioConnection.class);
    TcpNioConnection conn2 = mock(TcpNioConnection.class);
    TcpNioConnection conn3 = mock(TcpNioConnection.class);
    connections.put(chan1, conn1);
    connections.put(chan2, conn2);
    connections.put(chan3, conn3);
    willReturn(true).given(chan1).isOpen();
    willReturn(true).given(chan2).isOpen();
-    willReturn(true).given(chan3).isOpen();
    Selector selector = mock(Selector.class);
    HashSet<SelectionKey> keys = new HashSet<>();
    when(selector.selectedKeys()).thenReturn(keys);
    factory.processNioSelections(1, selector, null, connections);
    // all open
    assertThat(connections.size()).isEqualTo(3);
    DirectFieldAccessor factoryFieldAccessor = new DirectFieldAccessor(factory);
    willReturn(false).given(chan1).isOpen();
    factory.processNioSelections(1, selector, null, connections);
    // interval didn't pass
    assertThat(connections.size()).isEqualTo(3);
    factoryFieldAccessor.setPropertyValue("nextCheckForClosedNioConnections", System.currentTimeMillis() - 10);
    factory.processNioSelections(1, selector, null, connections);
    // first is closed
    assertThat(connections.size()).isEqualTo(2);
    willReturn(false).given(chan2).isOpen();
    factory.processNioSelections(1, selector, null, connections);
    // interval didn't pass
    assertThat(connections.size()).isEqualTo(2);
    factoryFieldAccessor.setPropertyValue("nextCheckForClosedNioConnections", System.currentTimeMillis() - 10);
    factory.processNioSelections(1, selector, null, connections);
    // second is closed
    assertThat(connections.size()).isEqualTo(1);
-    willReturn(false).given(chan3).isOpen();
+    willReturn(false).given(chan3).isOpen();
    factory.processNioSelections(1, selector, null, connections);
    // interval didn't pass
    assertThat(connections.size()).isEqualTo(1);
    factoryFieldAccessor.setPropertyValue("nextCheckForClosedNioConnections", System.currentTimeMillis() - 10);
    factory.processNioSelections(1, selector, null, connections);
    // third is closed
    assertThat(connections.size()).isEqualTo(0);
    assertThat(TestUtils.getPropertyValue(factory, "connections", Map.class).size()).isEqualTo(0);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testCleanup() {
    TcpNioClientConnectionFactory factory = new TcpNioClientConnectionFactory("localhost", 0);
    factory.setApplicationEventPublisher(nullPublisher);
    Map<SocketChannel, TcpNioConnection> connections = new HashMap<>();
    SocketChannel chan1 = mock(SocketChannel.class);
    SocketChannel chan2 = mock(SocketChannel.class);
    SocketChannel chan3 = mock(SocketChannel.class);
    TcpNioConnection conn1 = mock(TcpNioConnection.class);
    TcpNioConnection conn2 = mock(TcpNioConnection.class);
    TcpNioConnection conn3 = mock(TcpNioConnection.class);
    connections.put(chan1, conn1);
    connections.put(chan2, conn2);
    connections.put(chan3, conn3);
    willReturn(true).given(chan1).isOpen();
    willReturn(true).given(chan2).isOpen();
    willReturn(true).given(chan3).isOpen();
    Selector selector = mock(Selector.class);
    HashSet<SelectionKey> keys = new HashSet<>();
    when(selector.selectedKeys()).thenReturn(keys);
    factory.processNioSelections(1, selector, null, connections);
    // all open
    assertThat(connections.size()).isEqualTo(3);
    DirectFieldAccessor factoryFieldAccessor = new DirectFieldAccessor(factory);
    willReturn(false).given(chan1).isOpen();
    factory.processNioSelections(1, selector, null, connections);
    // interval didn't pass
    assertThat(connections.size()).isEqualTo(3);
    factoryFieldAccessor.setPropertyValue("nextCheckForClosedNioConnections", System.currentTimeMillis() - 10);
    factory.processNioSelections(1, selector, null, connections);
    // first is closed
    assertThat(connections.size()).isEqualTo(2);
    willReturn(false).given(chan2).isOpen();
    factory.processNioSelections(1, selector, null, connections);
    // interval didn't pass
    assertThat(connections.size()).isEqualTo(2);
    factoryFieldAccessor.setPropertyValue("nextCheckForClosedNioConnections", System.currentTimeMillis() - 10);
    factory.processNioSelections(1, selector, null, connections);
    // second is closed
    assertThat(connections.size()).isEqualTo(1);
    willReturn(false).given(chan3).isOpen();
    factory.processNioSelections(1, selector, null, connections);
    // interval didn't pass
    assertThat(connections.size()).isEqualTo(1);
    factoryFieldAccessor.setPropertyValue("nextCheckForClosedNioConnections", System.currentTimeMillis() - 10);
    factory.processNioSelections(1, selector, null, connections);
    // third is closed
    assertThat(connections.size()).isEqualTo(0);
    assertThat(TestUtils.getPropertyValue(factory, "connections", Map.class).size()).isEqualTo(0);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SocketChannel createMockSocketChannel(boolean isOpenReturn) {
    SocketChannel channel = mock(SocketChannel.class);
    willReturn(isOpenReturn).given(channel).isOpen();
    return channel;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_14
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.file.remote.session.Session`
- **Test Case Count**: 11
- **MO Count**: 11

### Reusable Method
```java
private static Session createMockSession(String path, TestLsEntry[] entries) {
    Session session = mock(Session.class);
    when(session.list(path)).thenReturn(entries);
    return session;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_14_1
#### Test Case Name: `testLs`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory sessionFactory = mock(SessionFactory.class);
-    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
-    when(session.list("testremote/x/")).thenReturn(files);
+    Session session = createMockSession("testremote/x/", files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote/x"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(2);
    // sort by default
    assertThat(out.getPayload().get(0)).isSameAs(files[1]);
    assertThat(out.getPayload().get(1)).isSameAs(files[0]);
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/x/");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/x/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote/x"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(2);
    // sort by default
    assertThat(out.getPayload().get(0)).isSameAs(files[1]);
    assertThat(out.getPayload().get(1)).isSameAs(files[0]);
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/x/");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session createMockSession(String path, TestLsEntry[] entries) {
    Session session = mock(Session.class);
    when(session.list(path)).thenReturn(entries);
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_14_2
#### Test Case Name: `testLs_f`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory sessionFactory = mock(SessionFactory.class);
-    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-f");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
-    when(session.list("testremote/x/")).thenReturn(files);
+    Session session = createMockSession("testremote/x/", files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote/x"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(2);
    assertThat(out.getPayload().get(0)).isSameAs(files[0]);
    assertThat(out.getPayload().get(1)).isSameAs(files[1]);
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/x/");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_f() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-f");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/x/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote/x"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(2);
    assertThat(out.getPayload().get(0)).isSameAs(files[0]);
    assertThat(out.getPayload().get(1)).isSameAs(files[1]);
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/x/");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session createMockSession(String path, TestLsEntry[] entries) {
    Session session = mock(Session.class);
    when(session.list(path)).thenReturn(entries);
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_14_3
#### Test Case Name: `testLs_f_R`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory sessionFactory = mock(SessionFactory.class);
-    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-f -R");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] level1 = level1List();
    TestLsEntry[] level2 = level2List();
    TestLsEntry[] level3 = level3List();
+    Session session = createMockSession("testremote/x/", level1);
+    when(session.list("testremote/x/d1/")).thenReturn(level2);
+    when(session.list("testremote/x/d1/d2/")).thenReturn(level3);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote/x"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(4);
    assertThat(out.getPayload().get(0).getFilename()).isEqualTo("f1");
    assertThat(out.getPayload().get(1).getFilename()).isEqualTo("d1/d2/f4");
    assertThat(out.getPayload().get(2).getFilename()).isEqualTo("d1/f3");
    assertThat(out.getPayload().get(3).getFilename()).isEqualTo("f2");
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/x/");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_f_R() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-f -R");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] level1 = level1List();
    TestLsEntry[] level2 = level2List();
    TestLsEntry[] level3 = level3List();
    when(session.list("testremote/x/")).thenReturn(level1);
    when(session.list("testremote/x/d1/")).thenReturn(level2);
    when(session.list("testremote/x/d1/d2/")).thenReturn(level3);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote/x"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(4);
    assertThat(out.getPayload().get(0).getFilename()).isEqualTo("f1");
    assertThat(out.getPayload().get(1).getFilename()).isEqualTo("d1/d2/f4");
    assertThat(out.getPayload().get(2).getFilename()).isEqualTo("d1/f3");
    assertThat(out.getPayload().get(3).getFilename()).isEqualTo("f2");
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/x/");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session createMockSession(String path, TestLsEntry[] entries) {
    Session session = mock(Session.class);
    when(session.list(path)).thenReturn(entries);
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_14_4
#### Test Case Name: `testLs_f_R_dirs`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory sessionFactory = mock(SessionFactory.class);
-    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-f -R -dirs");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] level1 = level1List();
    TestLsEntry[] level2 = level2List();
    TestLsEntry[] level3 = level3List();
+    Session session = createMockSession("testremote/x/", level1);
+    when(session.list("testremote/x/d1/")).thenReturn(level2);
+    when(session.list("testremote/x/d1/d2/")).thenReturn(level3);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote/x"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(6);
    assertThat(out.getPayload().get(0).getFilename()).isEqualTo("f1");
    assertThat(out.getPayload().get(1).getFilename()).isEqualTo("d1");
    assertThat(out.getPayload().get(2).getFilename()).isEqualTo("d1/d2");
    assertThat(out.getPayload().get(3).getFilename()).isEqualTo("d1/d2/f4");
    assertThat(out.getPayload().get(4).getFilename()).isEqualTo("d1/f3");
    assertThat(out.getPayload().get(5).getFilename()).isEqualTo("f2");
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/x/");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_f_R_dirs() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-f -R -dirs");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] level1 = level1List();
    TestLsEntry[] level2 = level2List();
    TestLsEntry[] level3 = level3List();
    when(session.list("testremote/x/")).thenReturn(level1);
    when(session.list("testremote/x/d1/")).thenReturn(level2);
    when(session.list("testremote/x/d1/d2/")).thenReturn(level3);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote/x"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(6);
    assertThat(out.getPayload().get(0).getFilename()).isEqualTo("f1");
    assertThat(out.getPayload().get(1).getFilename()).isEqualTo("d1");
    assertThat(out.getPayload().get(2).getFilename()).isEqualTo("d1/d2");
    assertThat(out.getPayload().get(3).getFilename()).isEqualTo("d1/d2/f4");
    assertThat(out.getPayload().get(4).getFilename()).isEqualTo("d1/f3");
    assertThat(out.getPayload().get(5).getFilename()).isEqualTo("f2");
    assertThat(out.getHeaders().get(FileHeaders.REMOTE_DIRECTORY)).isEqualTo("testremote/x/");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session createMockSession(String path, TestLsEntry[] entries) {
    Session session = mock(Session.class);
    when(session.list(path)).thenReturn(entries);
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_14_5
#### Test Case Name: `testLs_None`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory sessionFactory = mock(SessionFactory.class);
-    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = new TestLsEntry[0];
-    when(session.list("testremote/")).thenReturn(files);
+    Session session = createMockSession("testremote/", files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(0);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_None() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = new TestLsEntry[0];
    when(session.list("testremote/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<TestLsEntry>> out = (MessageBuilder<List<TestLsEntry>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(0);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session createMockSession(String path, TestLsEntry[] entries) {
    Session session = mock(Session.class);
    when(session.list(path)).thenReturn(entries);
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_14_6
#### Test Case Name: `testLs_1`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory sessionFactory = mock(SessionFactory.class);
-    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
-    when(session.list("testremote/")).thenReturn(files);
+    Session session = createMockSession("testremote/", files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(2);
    assertThat(out.getPayload().get(0)).isEqualTo("f1");
    assertThat(out.getPayload().get(1)).isEqualTo("f2");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_1() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out).isNotNull();
    assertThat(out.getPayload()).hasSize(2);
    assertThat(out.getPayload().get(0)).isEqualTo("f1");
    assertThat(out.getPayload().get(1)).isEqualTo("f2");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session createMockSession(String path, TestLsEntry[] entries) {
    Session session = mock(Session.class);
    when(session.list(path)).thenReturn(entries);
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_14_7
#### Test Case Name: `testLs_1_f`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory sessionFactory = mock(SessionFactory.class);
-    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1 -f");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
+    Session session = createMockSession("testremote/", files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out.getPayload()).hasSize(2);
    assertThat(out.getPayload().get(0)).isEqualTo("f2");
    assertThat(out.getPayload().get(1)).isEqualTo("f1");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_1_f() throws Exception {
    //no sort
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1 -f");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out.getPayload()).hasSize(2);
    assertThat(out.getPayload().get(0)).isEqualTo("f2");
    assertThat(out.getPayload().get(1)).isEqualTo("f1");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session createMockSession(String path, TestLsEntry[] entries) {
    Session session = mock(Session.class);
    when(session.list(path)).thenReturn(entries);
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_14_8
#### Test Case Name: `testLs_1_dirs`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory sessionFactory = mock(SessionFactory.class);
-    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1 -dirs");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
-    when(session.list("testremote/")).thenReturn(files);
+    Session session = createMockSession("testremote/", files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out.getPayload()).hasSize(3);
    assertThat(out.getPayload().get(0)).isEqualTo("f1");
    assertThat(out.getPayload().get(1)).isEqualTo("f2");
    assertThat(out.getPayload().get(2)).isEqualTo("f3");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_1_dirs() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1 -dirs");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out.getPayload()).hasSize(3);
    assertThat(out.getPayload().get(0)).isEqualTo("f1");
    assertThat(out.getPayload().get(1)).isEqualTo("f2");
    assertThat(out.getPayload().get(2)).isEqualTo("f3");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session createMockSession(String path, TestLsEntry[] entries) {
    Session session = mock(Session.class);
    when(session.list(path)).thenReturn(entries);
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_14_9
#### Test Case Name: `testLs_1_dirs_links`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory sessionFactory = mock(SessionFactory.class);
-    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1 -dirs -links");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
-    when(session.list("testremote/")).thenReturn(files);
+    Session session = createMockSession("testremote/", files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out.getPayload()).hasSize(4);
    assertThat(out.getPayload().get(0)).isEqualTo("f1");
    assertThat(out.getPayload().get(1)).isEqualTo("f2");
    assertThat(out.getPayload().get(2)).isEqualTo("f3");
    assertThat(out.getPayload().get(3)).isEqualTo("f4");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_1_dirs_links() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1 -dirs -links");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out.getPayload()).hasSize(4);
    assertThat(out.getPayload().get(0)).isEqualTo("f1");
    assertThat(out.getPayload().get(1)).isEqualTo("f2");
    assertThat(out.getPayload().get(2)).isEqualTo("f3");
    assertThat(out.getPayload().get(3)).isEqualTo("f4");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session createMockSession(String path, TestLsEntry[] entries) {
    Session session = mock(Session.class);
    when(session.list(path)).thenReturn(entries);
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_14_10
#### Test Case Name: `testLs_1_a_f_dirs_links`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory sessionFactory = mock(SessionFactory.class);
-    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1 -a -f -dirs -links");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
-    when(session.list("testremote/")).thenReturn(files);
+    Session session = createMockSession("testremote/", files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out.getPayload()).hasSize(6);
    assertThat(out.getPayload().get(0)).isEqualTo("f2");
    assertThat(out.getPayload().get(1)).isEqualTo("f1");
    assertThat(out.getPayload().get(2)).isEqualTo("f3");
    assertThat(out.getPayload().get(3)).isEqualTo("f4");
    assertThat(out.getPayload().get(4)).isEqualTo(".f5");
    assertThat(out.getPayload().get(5)).isEqualTo(".f6");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_1_a_f_dirs_links() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1 -a -f -dirs -links");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out.getPayload()).hasSize(6);
    assertThat(out.getPayload().get(0)).isEqualTo("f2");
    assertThat(out.getPayload().get(1)).isEqualTo("f1");
    assertThat(out.getPayload().get(2)).isEqualTo("f3");
    assertThat(out.getPayload().get(3)).isEqualTo("f4");
    assertThat(out.getPayload().get(4)).isEqualTo(".f5");
    assertThat(out.getPayload().get(5)).isEqualTo(".f6");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session createMockSession(String path, TestLsEntry[] entries) {
    Session session = mock(Session.class);
    when(session.list(path)).thenReturn(entries);
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_14_11
#### Test Case Name: `testLs_1_a_f_dirs_links_filtered`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory sessionFactory = mock(SessionFactory.class);
-    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1 -a -f -dirs -links");
    gw.setFilter(new TestPatternFilter("*4"));
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
-    when(session.list("testremote/")).thenReturn(files);
+    Session session = createMockSession("testremote/", files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out.getPayload()).hasSize(1);
    assertThat(out.getPayload().get(0)).isEqualTo("f4");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLs_1_a_f_dirs_links_filtered() throws Exception {
    SessionFactory sessionFactory = mock(SessionFactory.class);
    Session session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "ls", "payload");
    gw.setOptions("-1 -a -f -dirs -links");
    gw.setFilter(new TestPatternFilter("*4"));
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    TestLsEntry[] files = fileList();
    when(session.list("testremote/")).thenReturn(files);
    @SuppressWarnings("unchecked")
    MessageBuilder<List<String>> out = (MessageBuilder<List<String>>) gw.handleRequestMessage(new GenericMessage<>("testremote"));
    assertThat(out.getPayload()).hasSize(1);
    assertThat(out.getPayload().get(0)).isEqualTo("f4");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session createMockSession(String path, TestLsEntry[] entries) {
    Session session = mock(Session.class);
    when(session.list(path)).thenReturn(entries);
    return session;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_15
- **Scope**: method level
- **Mocked Class**: `org.springframework.context.ApplicationEventPublisher`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static ApplicationEventPublisher createMockApplicationEventPublisher(CountDownLatch latch) {
    ApplicationEventPublisher publisher = mock(ApplicationEventPublisher.class);
    doAnswer(invocation -> {
        latch.countDown();
        return null;
    }).when(publisher).publishEvent(any(ApplicationEvent.class));
    return publisher;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_15_1
#### Test Case Name: `testTcp`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-syslog\src\test\java\org\springframework\integration\syslog\inbound\SyslogReceivingChannelAdapterTests.java`)
#### Mock Object Variable Name: `publisher`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    factory.setPort(0);
    PollableChannel outputChannel = new QueueChannel();
    factory.setOutputChannel(outputChannel);
-    ApplicationEventPublisher publisher = mock(ApplicationEventPublisher.class);
    final CountDownLatch latch = new CountDownLatch(2);
-    doAnswer(invocation -> {
-        latch.countDown();
-        return null;
-    }).when(publisher).publishEvent(any(ApplicationEvent.class));
+    ApplicationEventPublisher publisher = createMockApplicationEventPublisher(latch);
    factory.setApplicationEventPublisher(publisher);
    factory.setBeanFactory(mock(BeanFactory.class));
    factory.afterPropertiesSet();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testTcp() throws Exception {
    SyslogReceivingChannelAdapterFactoryBean factory = new SyslogReceivingChannelAdapterFactoryBean(SyslogReceivingChannelAdapterFactoryBean.Protocol.tcp);
    factory.setPort(0);
    PollableChannel outputChannel = new QueueChannel();
    factory.setOutputChannel(outputChannel);
    ApplicationEventPublisher publisher = mock(ApplicationEventPublisher.class);
    final CountDownLatch latch = new CountDownLatch(2);
    doAnswer(invocation -> {
        latch.countDown();
        return null;
    }).when(publisher).publishEvent(any(ApplicationEvent.class));
    factory.setApplicationEventPublisher(publisher);
    factory.setBeanFactory(mock(BeanFactory.class));
    factory.afterPropertiesSet();
    factory.start();
    AbstractServerConnectionFactory server = TestUtils.getPropertyValue(factory, "syslogAdapter.connectionFactory", AbstractServerConnectionFactory.class);
    TestingUtilities.waitListening(server, null);
    TcpSyslogReceivingChannelAdapter adapter = (TcpSyslogReceivingChannelAdapter) factory.getObject();
    LogAccessor logger = spy(TestUtils.getPropertyValue(adapter, "logger", LogAccessor.class));
    doReturn(true).when(logger).isDebugEnabled();
    final CountDownLatch sawLog = new CountDownLatch(1);
    doAnswer(invocation -> {
        if (((String) invocation.getArgument(0)).contains("Error on syslog socket")) {
            sawLog.countDown();
        }
        invocation.callRealMethod();
        return null;
    }).when(logger).debug(anyString());
    new DirectFieldAccessor(adapter).setPropertyValue("logger", logger);
    byte[] buf = "<157>JUL 26 22:08:35 WEBERN TESTING[70729]: TEST SYSLOG MESSAGE\n".getBytes(StandardCharsets.UTF_8);
    Socket socket = SocketFactory.getDefault().createSocket("localhost", server.getPort());
    socket.getOutputStream().write(buf);
    socket.close();
    assertThat(sawLog.await(10, TimeUnit.SECONDS)).isTrue();
    Message<?> message = outputChannel.receive(10000);
    assertThat(message).isNotNull();
    assertThat(message.getHeaders().get("syslog_HOST")).isEqualTo("WEBERN");
    assertThat(message.getHeaders().get(IpHeaders.IP_ADDRESS)).isNotNull();
    adapter.stop();
    assertThat(latch.await(10, TimeUnit.SECONDS)).isTrue();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ApplicationEventPublisher createMockApplicationEventPublisher(CountDownLatch latch) {
    ApplicationEventPublisher publisher = mock(ApplicationEventPublisher.class);
    doAnswer(invocation -> {
        latch.countDown();
        return null;
    }).when(publisher).publishEvent(any(ApplicationEvent.class));
    return publisher;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_15_2
#### Test Case Name: `testTcpRFC5424`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-syslog\src\test\java\org\springframework\integration\syslog\inbound\SyslogReceivingChannelAdapterTests.java`)
#### Mock Object Variable Name: `publisher`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    factory.setOutputChannel(outputChannel);
-    ApplicationEventPublisher publisher = mock(ApplicationEventPublisher.class);
     final CountDownLatch latch = new CountDownLatch(2);
-    doAnswer(invocation -> {
-        latch.countDown();
-        return null;
-    }).when(publisher).publishEvent(any(ApplicationEvent.class));
+    ApplicationEventPublisher publisher = createMockApplicationEventPublisher(latch);
     factory.setBeanFactory(mock(BeanFactory.class));
     AbstractServerConnectionFactory connectionFactory = new TcpNioServerConnectionFactory(0);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testTcpRFC5424() throws Exception {
    SyslogReceivingChannelAdapterFactoryBean factory = new SyslogReceivingChannelAdapterFactoryBean(SyslogReceivingChannelAdapterFactoryBean.Protocol.tcp);
    PollableChannel outputChannel = new QueueChannel();
    factory.setOutputChannel(outputChannel);
    ApplicationEventPublisher publisher = mock(ApplicationEventPublisher.class);
    final CountDownLatch latch = new CountDownLatch(2);
    doAnswer(invocation -> {
        latch.countDown();
        return null;
    }).when(publisher).publishEvent(any(ApplicationEvent.class));
    factory.setBeanFactory(mock(BeanFactory.class));
    AbstractServerConnectionFactory connectionFactory = new TcpNioServerConnectionFactory(0);
    connectionFactory.setDeserializer(new RFC6587SyslogDeserializer());
    connectionFactory.setApplicationEventPublisher(publisher);
    factory.setConnectionFactory(connectionFactory);
    factory.setConverter(new RFC5424MessageConverter());
    factory.afterPropertiesSet();
    factory.start();
    TestingUtilities.waitListening(connectionFactory, null);
    TcpSyslogReceivingChannelAdapter adapter = (TcpSyslogReceivingChannelAdapter) factory.getObject();
    LogAccessor logger = spy(TestUtils.getPropertyValue(adapter, "logger", LogAccessor.class));
    doReturn(true).when(logger).isDebugEnabled();
    final CountDownLatch sawLog = new CountDownLatch(1);
    doAnswer(invocation -> {
        if (((String) invocation.getArgument(0)).contains("Error on syslog socket")) {
            sawLog.countDown();
        }
        invocation.callRealMethod();
        return null;
    }).when(logger).debug(anyString());
    new DirectFieldAccessor(adapter).setPropertyValue("logger", logger);
    byte[] buf = ("253 <14>1 2014-06-20T09:14:07+00:00 loggregator d0602076-b14a-4c55-852a-981e7afeed38 DEA - " + "[exampleSDID@32473 iut=\\\"3\\\" eventSource=\\\"Application\\\" eventID=\\\"1011\\\"]" + "[exampleSDID@32473 iut=\\\"3\\\" eventSource=\\\"Application\\\" eventID=\\\"1011\\\"] Removing instance").getBytes(StandardCharsets.UTF_8);
    Socket socket = SocketFactory.getDefault().createSocket("localhost", connectionFactory.getPort());
    socket.getOutputStream().write(buf);
    socket.close();
    assertThat(sawLog.await(10, TimeUnit.SECONDS)).isTrue();
    @SuppressWarnings("unchecked")
    Message<Map<String, ?>> message = (Message<Map<String, ?>>) outputChannel.receive(10000);
    assertThat(message).isNotNull();
    assertThat(message.getPayload().get("syslog_HOST")).isEqualTo("loggregator");
    assertThat(message.getHeaders().get(IpHeaders.IP_ADDRESS)).isNotNull();
    adapter.stop();
    assertThat(latch.await(10, TimeUnit.SECONDS)).isTrue();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ApplicationEventPublisher createMockApplicationEventPublisher(CountDownLatch latch) {
    ApplicationEventPublisher publisher = mock(ApplicationEventPublisher.class);
    doAnswer(invocation -> {
        latch.countDown();
        return null;
    }).when(publisher).publishEvent(any(ApplicationEvent.class));
    return publisher;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_16
- **Scope**: method level
- **Mocked Class**: `org.apache.kafka.clients.consumer.Consumer`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static <K, V> Consumer<K, V> createMockConsumer(final TopicPartition topicPartition, final AtomicReference<Set<TopicPartition>> paused, final Answer<?> pausedAnswer) {
    Consumer<K, V> consumer = mock(Consumer.class);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    willAnswer(i -> {
        paused.set(new HashSet<>(i.getArgument(0)));
        return null;
    }).given(consumer).pause(anyCollection());
    willAnswer(pausedAnswer).given(consumer).paused();
    return consumer;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_16_1
#### Test Case Name: `testAckOutOfOrder`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\inbound\MessageSourceTests.java`)
#### Mock Object Variable Name: `consumer`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testAckOutOfOrder() {
-    Consumer consumer = mock(Consumer.class);
-    TopicPartition topicPartition = new TopicPartition("foo", 0);
-    willAnswer(i -> {
-        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
-        return null;
-    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
+    TopicPartition topicPartition = new TopicPartition("foo", 0);
     AtomicReference<Set<TopicPartition>> paused = new AtomicReference<>(new HashSet<>());
+    Consumer consumer = createMockConsumer(topicPartition, paused, i -> paused.get());
     Map<TopicPartition, List<ConsumerRecord>> records1 = new LinkedHashMap<>();
     records1.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty())));
     Map<TopicPartition, List<ConsumerRecord>> records2 = new LinkedHashMap<>();
     records2.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "bar", new RecordHeaders(), Optional.empty())));
     Map<TopicPartition, List<ConsumerRecord>> records3 = new LinkedHashMap<>();
     records3.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 2L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "baz", new RecordHeaders(), Optional.empty())));
     Map<TopicPartition, List<ConsumerRecord>> records4 = new LinkedHashMap<>();
     records4.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 3L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "qux", new RecordHeaders(), Optional.empty())));
     Map<TopicPartition, List<ConsumerRecord>> records5 = new LinkedHashMap<>();
     records5.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 4L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "fiz", new RecordHeaders(), Optional.empty())));
     Map<TopicPartition, List<ConsumerRecord>> records6 = new LinkedHashMap<>();
     records6.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 5L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "buz", new RecordHeaders(), Optional.empty())));
     ConsumerRecords cr1 = new ConsumerRecords(records1);
     ConsumerRecords cr2 = new ConsumerRecords(records2);
     ConsumerRecords cr3 = new ConsumerRecords(records3);
     ConsumerRecords cr4 = new ConsumerRecords(records4);
     ConsumerRecords cr5 = new ConsumerRecords(records5);
     ConsumerRecords cr6 = new ConsumerRecords(records6);
     ConsumerRecords cr7 = new ConsumerRecords(Collections.emptyMap());
     given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2, cr3, cr4, cr5, cr6, cr7);
     ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
     willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
     given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
     KafkaMessageSource source = new KafkaMessageSource(consumerFactory, new ConsumerProperties("foo"));
     Message<?> received1 = source.receive();
     // need some other interaction with mock between polls for InOrder
     consumer.paused();
     Message<?> received2 = source.receive();
     // need some other interaction with mock between polls for InOrder
     consumer.paused();
     Message<?> received3 = source.receive();
     // need some other interaction with mock between polls for InOrder
     consumer.paused();
     Message<?> received4 = source.receive();
     // need some other interaction with mock between polls for InOrder
     consumer.paused();
     Message<?> received5 = source.receive();
     // need some other interaction with mock between polls for InOrder
     consumer.paused();
     Message<?> received6 = source.receive();
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received3).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received2).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received5).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received1).acknowledge(// should commit offset 3 (received 3)
     AcknowledgmentCallback.Status.ACCEPT);
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received6).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received4).acknowledge(// should commit offset 6 (received 6).
     AcknowledgmentCallback.Status.ACCEPT);
     assertThat(source.receive()).isNull();
     source.destroy();
     InOrder inOrder = inOrder(consumer);
     inOrder.verify(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
     inOrder.verify(consumer).poll(any(Duration.class));
     inOrder.verify(consumer).paused();
     inOrder.verify(consumer).poll(any(Duration.class));
     inOrder.verify(consumer).paused();
     inOrder.verify(consumer).poll(any(Duration.class));
     inOrder.verify(consumer).paused();
     inOrder.verify(consumer).poll(any(Duration.class));
     inOrder.verify(consumer).paused();
     inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(3L)));
     inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(6L)));
     inOrder.verify(consumer).poll(any(Duration.class));
     inOrder.verify(consumer).close(any());
     inOrder.verifyNoMoreInteractions();
}
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testAckOutOfOrder() {
    Consumer consumer = mock(Consumer.class);
    TopicPartition topicPartition = new TopicPartition("foo", 0);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    AtomicReference<Set<TopicPartition>> paused = new AtomicReference<>(new HashSet<>());
    willAnswer(i -> {
        paused.set(new HashSet<>(i.getArgument(0)));
        return null;
    }).given(consumer).pause(anyCollection());
    willAnswer(i -> paused.get()).given(consumer).paused();
    Map<TopicPartition, List<ConsumerRecord>> records1 = new LinkedHashMap<>();
    records1.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty())));
    Map<TopicPartition, List<ConsumerRecord>> records2 = new LinkedHashMap<>();
    records2.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "bar", new RecordHeaders(), Optional.empty())));
    Map<TopicPartition, List<ConsumerRecord>> records3 = new LinkedHashMap<>();
    records3.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 2L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "baz", new RecordHeaders(), Optional.empty())));
    Map<TopicPartition, List<ConsumerRecord>> records4 = new LinkedHashMap<>();
    records4.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 3L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "qux", new RecordHeaders(), Optional.empty())));
    Map<TopicPartition, List<ConsumerRecord>> records5 = new LinkedHashMap<>();
    records5.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 4L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "fiz", new RecordHeaders(), Optional.empty())));
    Map<TopicPartition, List<ConsumerRecord>> records6 = new LinkedHashMap<>();
    records6.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 5L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "buz", new RecordHeaders(), Optional.empty())));
    ConsumerRecords cr1 = new ConsumerRecords(records1);
    ConsumerRecords cr2 = new ConsumerRecords(records2);
    ConsumerRecords cr3 = new ConsumerRecords(records3);
    ConsumerRecords cr4 = new ConsumerRecords(records4);
    ConsumerRecords cr5 = new ConsumerRecords(records5);
    ConsumerRecords cr6 = new ConsumerRecords(records6);
    ConsumerRecords cr7 = new ConsumerRecords(Collections.emptyMap());
    given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2, cr3, cr4, cr5, cr6, cr7);
    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, new ConsumerProperties("foo"));
    Message<?> received1 = source.receive();
    // need some other interaction with mock between polls for InOrder
    consumer.paused();
    Message<?> received2 = source.receive();
    // need some other interaction with mock between polls for InOrder
    consumer.paused();
    Message<?> received3 = source.receive();
    // need some other interaction with mock between polls for InOrder
    consumer.paused();
    Message<?> received4 = source.receive();
    // need some other interaction with mock between polls for InOrder
    consumer.paused();
    Message<?> received5 = source.receive();
    // need some other interaction with mock between polls for InOrder
    consumer.paused();
    Message<?> received6 = source.receive();
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received3).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received2).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received5).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received1).acknowledge(// should commit offset 3 (received 3)
    AcknowledgmentCallback.Status.ACCEPT);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received6).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received4).acknowledge(// should commit offset 6 (received 6).
    AcknowledgmentCallback.Status.ACCEPT);
    assertThat(source.receive()).isNull();
    source.destroy();
    InOrder inOrder = inOrder(consumer);
    inOrder.verify(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).paused();
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).paused();
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).paused();
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).paused();
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(3L)));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(6L)));
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).close(any());
    inOrder.verifyNoMoreInteractions();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static <K, V> Consumer<K, V> createMockConsumer(final TopicPartition topicPartition, final AtomicReference<Set<TopicPartition>> paused, final Answer<?> pausedAnswer) {
    Consumer<K, V> consumer = mock(Consumer.class);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    willAnswer(i -> {
        paused.set(new HashSet<>(i.getArgument(0)));
        return null;
    }).given(consumer).pause(anyCollection());
    willAnswer(pausedAnswer).given(consumer).paused();
    return consumer;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_16_2
#### Test Case Name: `testNack`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\inbound\MessageSourceTests.java`)
#### Mock Object Variable Name: `consumer`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testNack() {
-    Consumer consumer = mock(Consumer.class);
     TopicPartition topicPartition = new TopicPartition("foo", 0);
-    willAnswer(i -> {
-        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
-        return null;
-    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
     AtomicReference<Set<TopicPartition>> paused = new AtomicReference<>(new HashSet<>());
-    willAnswer(i -> {
-        paused.set(new HashSet<>(i.getArgument(0)));
-        return null;
-    }).given(consumer).pause(anyCollection());
-    willAnswer(i -> paused.get()).given(consumer).paused();
+    Consumer consumer = createMockConsumer(topicPartition, paused, i -> paused.get());
     Map<TopicPartition, List<ConsumerRecord>> records1 = new LinkedHashMap<>();
     records1.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty())));
     ConsumerRecords cr1 = new ConsumerRecords(records1);
     Map<TopicPartition, List<ConsumerRecord>> records2 = new LinkedHashMap<>();
     records2.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "bar", new RecordHeaders(), Optional.empty())));
     ConsumerRecords cr2 = new ConsumerRecords(records2);
     ConsumerRecords cr3 = new ConsumerRecords(Collections.emptyMap());
     given(consumer.poll(any(Duration.class))).willReturn(cr1, cr1, cr2, cr2, cr3);
     ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
     willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
     given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
     ConsumerProperties consumerProperties = new ConsumerProperties("foo");
     consumerProperties.setSyncCommitTimeout(Duration.ofSeconds(30));
     KafkaMessageSource source = new KafkaMessageSource(consumerFactory, consumerProperties);
     Message<?> received = source.receive();
     assertThat(received.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(0L);
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.REQUEUE);
     received = source.receive();
     assertThat(received.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(0L);
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     received = source.receive();
     assertThat(received.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(1L);
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.REQUEUE);
     received = source.receive();
     assertThat(received.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(1L);
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     received = source.receive();
     source.destroy();
     assertThat(received).isNull();
     InOrder inOrder = inOrder(consumer);
     inOrder.verify(consumer).poll(any(Duration.class));
     // rollback
     inOrder.verify(consumer).seek(topicPartition, 0L);
     inOrder.verify(consumer).poll(any(Duration.class));
     inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1L)), Duration.ofSeconds(30));
     inOrder.verify(consumer).poll(any(Duration.class));
     // rollback
     inOrder.verify(consumer).seek(topicPartition, 1L);
     inOrder.verify(consumer).poll(any(Duration.class));
     inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(2L)), Duration.ofSeconds(30));
     inOrder.verify(consumer).poll(any(Duration.class));
     inOrder.verify(consumer).close(any());
     inOrder.verifyNoMoreInteractions();
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testNack() {
    Consumer consumer = mock(Consumer.class);
    TopicPartition topicPartition = new TopicPartition("foo", 0);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    AtomicReference<Set<TopicPartition>> paused = new AtomicReference<>(new HashSet<>());
    willAnswer(i -> {
        paused.set(new HashSet<>(i.getArgument(0)));
        return null;
    }).given(consumer).pause(anyCollection());
    willAnswer(i -> paused.get()).given(consumer).paused();
    Map<TopicPartition, List<ConsumerRecord>> records1 = new LinkedHashMap<>();
    records1.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty())));
    ConsumerRecords cr1 = new ConsumerRecords(records1);
    Map<TopicPartition, List<ConsumerRecord>> records2 = new LinkedHashMap<>();
    records2.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "bar", new RecordHeaders(), Optional.empty())));
    ConsumerRecords cr2 = new ConsumerRecords(records2);
    ConsumerRecords cr3 = new ConsumerRecords(Collections.emptyMap());
    given(consumer.poll(any(Duration.class))).willReturn(cr1, cr1, cr2, cr2, cr3);
    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
    ConsumerProperties consumerProperties = new ConsumerProperties("foo");
    consumerProperties.setSyncCommitTimeout(Duration.ofSeconds(30));
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, consumerProperties);
    Message<?> received = source.receive();
    assertThat(received.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(0L);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.REQUEUE);
    received = source.receive();
    assertThat(received.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(0L);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    assertThat(received.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(1L);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.REQUEUE);
    received = source.receive();
    assertThat(received.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(1L);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    source.destroy();
    assertThat(received).isNull();
    InOrder inOrder = inOrder(consumer);
    inOrder.verify(consumer).poll(any(Duration.class));
    // rollback
    inOrder.verify(consumer).seek(topicPartition, 0L);
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1L)), Duration.ofSeconds(30));
    inOrder.verify(consumer).poll(any(Duration.class));
    // rollback
    inOrder.verify(consumer).seek(topicPartition, 1L);
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(2L)), Duration.ofSeconds(30));
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).close(any());
    inOrder.verifyNoMoreInteractions();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static <K, V> Consumer<K, V> createMockConsumer(final TopicPartition topicPartition, final AtomicReference<Set<TopicPartition>> paused, final Answer<?> pausedAnswer) {
    Consumer<K, V> consumer = mock(Consumer.class);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    willAnswer(i -> {
        paused.set(new HashSet<>(i.getArgument(0)));
        return null;
    }).given(consumer).pause(anyCollection());
    willAnswer(pausedAnswer).given(consumer).paused();
    return consumer;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_16_3
#### Test Case Name: `testNackWithLaterInflight`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\inbound\MessageSourceTests.java`)
#### Mock Object Variable Name: `consumer`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testNackWithLaterInflight() {
-    Consumer consumer = mock(Consumer.class);
     TopicPartition topicPartition = new TopicPartition("foo", 0);
-    willAnswer(i -> {
-        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
-        return null;
-    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
     AtomicReference<Set<TopicPartition>> paused = new AtomicReference<>(new HashSet<>());
-    willAnswer(i -> {
-        paused.set(new HashSet<>(i.getArgument(0)));
-        return null;
-    }).given(consumer).pause(anyCollection());
-    willAnswer(i -> paused.get()).given(consumer).paused();
+    Answer<?> pausedAnswer = i -> paused.get();
+    Consumer consumer = createMockConsumer(topicPartition, paused, pausedAnswer);
     Map<TopicPartition, List<ConsumerRecord>> records1 = new LinkedHashMap<>();
     records1.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty())));
     ConsumerRecords cr1 = new ConsumerRecords(records1);
     Map<TopicPartition, List<ConsumerRecord>> records2 = new LinkedHashMap<>();
     records2.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "bar", new RecordHeaders(), Optional.empty())));
     ConsumerRecords cr2 = new ConsumerRecords(records2);
     ConsumerRecords cr3 = new ConsumerRecords(Collections.emptyMap());
     given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2, cr1, cr2, cr3);
     ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
     willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
     given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
     KafkaMessageSource source = new KafkaMessageSource(consumerFactory, new ConsumerProperties("foo"));
     Message<?> received1 = source.receive();
     // need some other interaction with mock between polls for InOrder
     consumer.paused();
     // inflight
     Message<?> received2 = source.receive();
     assertThat(received1.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(0L);
     AcknowledgmentCallback ack1 = StaticMessageHeaderAccessor.getAcknowledgmentCallback(received1);
     Log log1 = spy(KafkaTestUtils.getPropertyValue(ack1, "logger.log", Log.class));
     new DirectFieldAccessor(ack1).setPropertyValue("logger.log", log1);
     given(log1.isWarnEnabled()).willReturn(true);
     willDoNothing().given(log1).warn(any());
     ack1.acknowledge(AcknowledgmentCallback.Status.REQUEUE);
     assertThat(received2.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(1L);
     AcknowledgmentCallback ack2 = StaticMessageHeaderAccessor.getAcknowledgmentCallback(received2);
     Log log2 = spy(KafkaTestUtils.getPropertyValue(ack2, "logger.log", Log.class));
     new DirectFieldAccessor(ack2).setPropertyValue("logger.log", log2);
     given(log2.isWarnEnabled()).willReturn(true);
     willDoNothing().given(log2).warn(any());
     ack2.acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     received1 = source.receive();
     assertThat(received1.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(0L);
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received1).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     received2 = source.receive();
     assertThat(received2.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(1L);
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received2).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     received1 = source.receive();
     source.destroy();
     assertThat(received1).isNull();
     InOrder inOrder = inOrder(consumer, log1, log2);
     inOrder.verify(consumer).poll(any(Duration.class));
     inOrder.verify(consumer).paused();
     inOrder.verify(consumer).poll(any(Duration.class));
     // rollback
     inOrder.verify(consumer).seek(topicPartition, 0L);
     inOrder.verify(log1).isWarnEnabled();
     ArgumentCaptor<LogMessage> captor = ArgumentCaptor.forClass(LogMessage.class);
     inOrder.verify(log1).warn(captor.capture());
     assertThat(captor.getValue().toString()).contains("Rolled back").contains("later in-flight offsets [1] will also be re-fetched");
     inOrder.verify(log2).isWarnEnabled();
     captor = ArgumentCaptor.forClass(LogMessage.class);
     inOrder.verify(log2).warn(captor.capture());
     assertThat(captor.getValue().toString()).contains("Cannot commit offset for").contains("; an earlier offset was rolled back");
     inOrder.verify(consumer).poll(any(Duration.class));
     inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1L)));
     inOrder.verify(consumer).poll(any(Duration.class));
     inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(2L)));
     inOrder.verify(consumer).poll(any(Duration.class));
     inOrder.verify(consumer).close(any());
     inOrder.verifyNoMoreInteractions();
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testNackWithLaterInflight() {
    Consumer consumer = mock(Consumer.class);
    TopicPartition topicPartition = new TopicPartition("foo", 0);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    AtomicReference<Set<TopicPartition>> paused = new AtomicReference<>(new HashSet<>());
    willAnswer(i -> {
        paused.set(new HashSet<>(i.getArgument(0)));
        return null;
    }).given(consumer).pause(anyCollection());
    willAnswer(i -> paused.get()).given(consumer).paused();
    Map<TopicPartition, List<ConsumerRecord>> records1 = new LinkedHashMap<>();
    records1.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty())));
    ConsumerRecords cr1 = new ConsumerRecords(records1);
    Map<TopicPartition, List<ConsumerRecord>> records2 = new LinkedHashMap<>();
    records2.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "bar", new RecordHeaders(), Optional.empty())));
    ConsumerRecords cr2 = new ConsumerRecords(records2);
    ConsumerRecords cr3 = new ConsumerRecords(Collections.emptyMap());
    given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2, cr1, cr2, cr3);
    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, new ConsumerProperties("foo"));
    Message<?> received1 = source.receive();
    // need some other interaction with mock between polls for InOrder
    consumer.paused();
    // inflight
    Message<?> received2 = source.receive();
    assertThat(received1.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(0L);
    AcknowledgmentCallback ack1 = StaticMessageHeaderAccessor.getAcknowledgmentCallback(received1);
    Log log1 = spy(KafkaTestUtils.getPropertyValue(ack1, "logger.log", Log.class));
    new DirectFieldAccessor(ack1).setPropertyValue("logger.log", log1);
    given(log1.isWarnEnabled()).willReturn(true);
    willDoNothing().given(log1).warn(any());
    ack1.acknowledge(AcknowledgmentCallback.Status.REQUEUE);
    assertThat(received2.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(1L);
    AcknowledgmentCallback ack2 = StaticMessageHeaderAccessor.getAcknowledgmentCallback(received2);
    Log log2 = spy(KafkaTestUtils.getPropertyValue(ack2, "logger.log", Log.class));
    new DirectFieldAccessor(ack2).setPropertyValue("logger.log", log2);
    given(log2.isWarnEnabled()).willReturn(true);
    willDoNothing().given(log2).warn(any());
    ack2.acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received1 = source.receive();
    assertThat(received1.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(0L);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received1).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received2 = source.receive();
    assertThat(received2.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(1L);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received2).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received1 = source.receive();
    source.destroy();
    assertThat(received1).isNull();
    InOrder inOrder = inOrder(consumer, log1, log2);
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).paused();
    inOrder.verify(consumer).poll(any(Duration.class));
    // rollback
    inOrder.verify(consumer).seek(topicPartition, 0L);
    inOrder.verify(log1).isWarnEnabled();
    ArgumentCaptor<LogMessage> captor = ArgumentCaptor.forClass(LogMessage.class);
    inOrder.verify(log1).warn(captor.capture());
    assertThat(captor.getValue().toString()).contains("Rolled back").contains("later in-flight offsets [1] will also be re-fetched");
    inOrder.verify(log2).isWarnEnabled();
    captor = ArgumentCaptor.forClass(LogMessage.class);
    inOrder.verify(log2).warn(captor.capture());
    assertThat(captor.getValue().toString()).contains("Cannot commit offset for").contains("; an earlier offset was rolled back");
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1L)));
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(2L)));
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).close(any());
    inOrder.verifyNoMoreInteractions();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static <K, V> Consumer<K, V> createMockConsumer(final TopicPartition topicPartition, final AtomicReference<Set<TopicPartition>> paused, final Answer<?> pausedAnswer) {
    Consumer<K, V> consumer = mock(Consumer.class);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    willAnswer(i -> {
        paused.set(new HashSet<>(i.getArgument(0)));
        return null;
    }).given(consumer).pause(anyCollection());
    willAnswer(pausedAnswer).given(consumer).paused();
    return consumer;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_17
- **Scope**: method level
- **Mocked Class**: `org.apache.kafka.clients.consumer.Consumer`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static <T> Consumer<T> createMockConsumer(List<TopicPartition> assigned) {
    Consumer<T> consumer = mock(Consumer.class);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(assigned);
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    willDoNothing().given(consumer).pause(anyCollection());
    willDoNothing().given(consumer).resume(anyCollection());
    return consumer;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_17_1
#### Test Case Name: `testAckCommon`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\inbound\MessageSourceTests.java`)
#### Mock Object Variable Name: `consumer`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @SuppressWarnings({ "rawtypes", "unchecked" })
 private void testAckCommon(boolean sync, boolean timeout) {
-    Consumer consumer = mock(Consumer.class);
+    Consumer consumer = createMockConsumer(assigned);
     TopicPartition topicPartition = new TopicPartition("foo", 0);
     List<TopicPartition> assigned = Collections.singletonList(topicPartition);
-    willAnswer(i -> {
-        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(assigned);
-        return null;
-    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
     ArgumentCaptor<Collection<TopicPartition>> partitions = ArgumentCaptor.forClass(Collection.class);
-    willDoNothing().given(consumer).pause(partitions.capture());
-    willDoNothing().given(consumer).resume(partitions.capture());
     willAnswer(invoc -> {
         OffsetCommitCallback callback = invoc.getArgument(1);
         callback.onComplete(null, null);
         return null;
     }).given(consumer).commitAsync(any(), any());
     Map<TopicPartition, List<ConsumerRecord>> records1 = new LinkedHashMap<>();
     records1.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty())));
     Map<TopicPartition, List<ConsumerRecord>> records2 = new LinkedHashMap<>();
     records2.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "bar", new RecordHeaders(), Optional.empty())));
     Map<TopicPartition, List<ConsumerRecord>> records3 = new LinkedHashMap<>();
     records3.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 2L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "baz", new RecordHeaders(), Optional.empty())));
     Map<TopicPartition, List<ConsumerRecord>> records4 = new LinkedHashMap<>();
     records4.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 3L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "qux", new RecordHeaders(), Optional.empty())));
     ConsumerRecords cr1 = new ConsumerRecords(records1);
     ConsumerRecords cr2 = new ConsumerRecords(records2);
     ConsumerRecords cr3 = new ConsumerRecords(records3);
     ConsumerRecords cr4 = new ConsumerRecords(records4);
     ConsumerRecords cr5 = new ConsumerRecords(Collections.emptyMap());
     given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2, cr3, cr4, cr5);
     ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
     willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
     given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
     ConsumerProperties consumerProperties = new ConsumerProperties("foo");
     AtomicInteger callbackCount = new AtomicInteger();
     OffsetCommitCallback commitCallback = (offsets, ex) -> {
         callbackCount.incrementAndGet();
     };
     if (!sync) {
         consumerProperties.setSyncCommits(false);
         consumerProperties.setCommitCallback(commitCallback);
     }
     if (timeout) {
         consumerProperties.setSyncCommitTimeout(Duration.ofSeconds(5));
     }
     consumerProperties.setCommitLogLevel(Level.INFO);
     KafkaMessageSource source = new KafkaMessageSource(consumerFactory, consumerProperties);
     source.setRawMessageHeader(true);
     Message<?> received = source.receive();
     assertThat(received).isNotNull();
     assertThat(received.getHeaders().get(KafkaHeaders.RAW_DATA)).isInstanceOf(ConsumerRecord.class);
     assertThat(received.getHeaders().get(IntegrationMessageHeaderAccessor.SOURCE_DATA)).isSameAs(received.getHeaders().get(KafkaHeaders.RAW_DATA));
     assertThat(received.getHeaders()).containsKeys(MessageHeaders.TIMESTAMP, MessageHeaders.ID);
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     received = source.receive();
     assertThat(received).isNotNull();
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     received = source.receive();
     assertThat(received).isNotNull();
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     received = source.receive();
     assertThat(received).isNotNull();
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     received = source.receive();
     assertThat(received).isNull();
     source.pause();
     source.receive();
     source.resume();
     source.receive();
     source.destroy();
     InOrder inOrder = inOrder(consumer);
     inOrder.verify(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
     inOrder.verify(consumer).poll(any(Duration.class));
     checkCommit(sync, timeout, consumer, topicPartition, commitCallback, inOrder, 1L);
     inOrder.verify(consumer).poll(any(Duration.class));
     checkCommit(sync, timeout, consumer, topicPartition, commitCallback, inOrder, 2L);
     inOrder.verify(consumer).poll(any(Duration.class));
     checkCommit(sync, timeout, consumer, topicPartition, commitCallback, inOrder, 3L);
     inOrder.verify(consumer).poll(any(Duration.class));
     checkCommit(sync, timeout, consumer, topicPartition, commitCallback, inOrder, 4L);
     inOrder.verify(consumer).poll(any(Duration.class));
     inOrder.verify(consumer).pause(partitions.getAllValues().get(0));
     inOrder.verify(consumer).poll(any(Duration.class));
     inOrder.verify(consumer).resume(partitions.getAllValues().get(1));
     inOrder.verify(consumer).poll(any(Duration.class));
     inOrder.verify(consumer).close(any());
     inOrder.verifyNoMoreInteractions();
     if (!sync) {
         assertThat(callbackCount.get()).isEqualTo(4);
     }
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
private void testAckCommon(boolean sync, boolean timeout) {
    Consumer consumer = mock(Consumer.class);
    TopicPartition topicPartition = new TopicPartition("foo", 0);
    List<TopicPartition> assigned = Collections.singletonList(topicPartition);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(assigned);
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    ArgumentCaptor<Collection<TopicPartition>> partitions = ArgumentCaptor.forClass(Collection.class);
    willDoNothing().given(consumer).pause(partitions.capture());
    willDoNothing().given(consumer).resume(partitions.capture());
    willAnswer(invoc -> {
        OffsetCommitCallback callback = invoc.getArgument(1);
        callback.onComplete(null, null);
        return null;
    }).given(consumer).commitAsync(any(), any());
    Map<TopicPartition, List<ConsumerRecord>> records1 = new LinkedHashMap<>();
    records1.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty())));
    Map<TopicPartition, List<ConsumerRecord>> records2 = new LinkedHashMap<>();
    records2.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "bar", new RecordHeaders(), Optional.empty())));
    Map<TopicPartition, List<ConsumerRecord>> records3 = new LinkedHashMap<>();
    records3.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 2L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "baz", new RecordHeaders(), Optional.empty())));
    Map<TopicPartition, List<ConsumerRecord>> records4 = new LinkedHashMap<>();
    records4.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 3L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "qux", new RecordHeaders(), Optional.empty())));
    ConsumerRecords cr1 = new ConsumerRecords(records1);
    ConsumerRecords cr2 = new ConsumerRecords(records2);
    ConsumerRecords cr3 = new ConsumerRecords(records3);
    ConsumerRecords cr4 = new ConsumerRecords(records4);
    ConsumerRecords cr5 = new ConsumerRecords(Collections.emptyMap());
    given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2, cr3, cr4, cr5);
    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
    ConsumerProperties consumerProperties = new ConsumerProperties("foo");
    AtomicInteger callbackCount = new AtomicInteger();
    OffsetCommitCallback commitCallback = (offsets, ex) -> {
        callbackCount.incrementAndGet();
    };
    if (!sync) {
        consumerProperties.setSyncCommits(false);
        consumerProperties.setCommitCallback(commitCallback);
    }
    if (timeout) {
        consumerProperties.setSyncCommitTimeout(Duration.ofSeconds(5));
    }
    consumerProperties.setCommitLogLevel(Level.INFO);
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, consumerProperties);
    source.setRawMessageHeader(true);
    Message<?> received = source.receive();
    assertThat(received).isNotNull();
    assertThat(received.getHeaders().get(KafkaHeaders.RAW_DATA)).isInstanceOf(ConsumerRecord.class);
    assertThat(received.getHeaders().get(IntegrationMessageHeaderAccessor.SOURCE_DATA)).isSameAs(received.getHeaders().get(KafkaHeaders.RAW_DATA));
    assertThat(received.getHeaders()).containsKeys(MessageHeaders.TIMESTAMP, MessageHeaders.ID);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    assertThat(received).isNotNull();
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    assertThat(received).isNotNull();
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    assertThat(received).isNotNull();
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    assertThat(received).isNull();
    source.pause();
    source.receive();
    source.resume();
    source.receive();
    source.destroy();
    InOrder inOrder = inOrder(consumer);
    inOrder.verify(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    inOrder.verify(consumer).poll(any(Duration.class));
    checkCommit(sync, timeout, consumer, topicPartition, commitCallback, inOrder, 1L);
    inOrder.verify(consumer).poll(any(Duration.class));
    checkCommit(sync, timeout, consumer, topicPartition, commitCallback, inOrder, 2L);
    inOrder.verify(consumer).poll(any(Duration.class));
    checkCommit(sync, timeout, consumer, topicPartition, commitCallback, inOrder, 3L);
    inOrder.verify(consumer).poll(any(Duration.class));
    checkCommit(sync, timeout, consumer, topicPartition, commitCallback, inOrder, 4L);
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).pause(partitions.getAllValues().get(0));
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).resume(partitions.getAllValues().get(1));
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).close(any());
    inOrder.verifyNoMoreInteractions();
    if (!sync) {
        assertThat(callbackCount.get()).isEqualTo(4);
    }
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static <T> Consumer<T> createMockConsumer(List<TopicPartition> assigned) {
    Consumer<T> consumer = mock(Consumer.class);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(assigned);
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    willDoNothing().given(consumer).pause(anyCollection());
    willDoNothing().given(consumer).resume(anyCollection());
    return consumer;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_17_2
#### Test Case Name: `testAllowMulti`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\inbound\MessageSourceTests.java`)
#### Mock Object Variable Name: `consumer`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testAllowMulti() {
-    Consumer consumer = mock(Consumer.class);
     TopicPartition topicPartition = new TopicPartition("foo", 0);
     List<TopicPartition> assigned = Collections.singletonList(topicPartition);
-    willAnswer(i -> {
-        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(assigned);
-        return null;
-    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
+    Consumer consumer = createMockConsumer(assigned);
     ArgumentCaptor<Collection<TopicPartition>> partitions = ArgumentCaptor.forClass(Collection.class);
-    willDoNothing().given(consumer).pause(partitions.capture());
-    willDoNothing().given(consumer).resume(partitions.capture());
     Map<TopicPartition, List<ConsumerRecord>> records = new LinkedHashMap<>();
     records.put(topicPartition, Arrays.asList(new ConsumerRecord("foo", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty()), new ConsumerRecord("foo", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "bar", new RecordHeaders(), Optional.empty()), new ConsumerRecord("foo", 0, 2L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "baz", new RecordHeaders(), Optional.empty()), new ConsumerRecord("foo", 0, 3L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "qux", new RecordHeaders(), Optional.empty())));
     ConsumerRecords cr1 = new ConsumerRecords(records);
     ConsumerRecords cr2 = new ConsumerRecords(Collections.emptyMap());
     given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2);
     ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
     willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 4)).given(consumerFactory).getConfigurationProperties();
     given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
     KafkaMessageSource source = new KafkaMessageSource(consumerFactory, new ConsumerProperties("foo"), true);
     source.setRawMessageHeader(true);
     Message<?> received = source.receive();
     assertThat(received).isNotNull();
     assertThat(received.getHeaders().get(KafkaMessageSource.REMAINING_RECORDS, Integer.class)).isEqualTo(3);
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     received = source.receive();
     assertThat(received).isNotNull();
     assertThat(received.getHeaders().get(KafkaMessageSource.REMAINING_RECORDS, Integer.class)).isEqualTo(2);
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     received = source.receive();
     assertThat(received).isNotNull();
     assertThat(received.getHeaders().get(KafkaMessageSource.REMAINING_RECORDS, Integer.class)).isEqualTo(1);
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     received = source.receive();
     assertThat(received).isNotNull();
     assertThat(received.getHeaders().get(KafkaMessageSource.REMAINING_RECORDS, Integer.class)).isEqualTo(0);
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     received = source.receive();
     assertThat(received).isNull();
     source.destroy();
     InOrder inOrder = inOrder(consumer);
     inOrder.verify(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
     inOrder.verify(consumer).poll(any(Duration.class));
     inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1L)));
     inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(2L)));
     inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(3L)));
     inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(4L)));
     inOrder.verify(consumer).poll(any(Duration.class));
     inOrder.verify(consumer).close(any());
     inOrder.verifyNoMoreInteractions();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testAllowMulti() {
    Consumer consumer = mock(Consumer.class);
    TopicPartition topicPartition = new TopicPartition("foo", 0);
    List<TopicPartition> assigned = Collections.singletonList(topicPartition);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(assigned);
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    ArgumentCaptor<Collection<TopicPartition>> partitions = ArgumentCaptor.forClass(Collection.class);
    willDoNothing().given(consumer).pause(partitions.capture());
    willDoNothing().given(consumer).resume(partitions.capture());
    Map<TopicPartition, List<ConsumerRecord>> records = new LinkedHashMap<>();
    records.put(topicPartition, Arrays.asList(new ConsumerRecord("foo", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty()), new ConsumerRecord("foo", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "bar", new RecordHeaders(), Optional.empty()), new ConsumerRecord("foo", 0, 2L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "baz", new RecordHeaders(), Optional.empty()), new ConsumerRecord("foo", 0, 3L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "qux", new RecordHeaders(), Optional.empty())));
    ConsumerRecords cr1 = new ConsumerRecords(records);
    ConsumerRecords cr2 = new ConsumerRecords(Collections.emptyMap());
    given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2);
    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 4)).given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, new ConsumerProperties("foo"), true);
    source.setRawMessageHeader(true);
    Message<?> received = source.receive();
    assertThat(received).isNotNull();
    assertThat(received.getHeaders().get(KafkaMessageSource.REMAINING_RECORDS, Integer.class)).isEqualTo(3);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    assertThat(received).isNotNull();
    assertThat(received.getHeaders().get(KafkaMessageSource.REMAINING_RECORDS, Integer.class)).isEqualTo(2);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    assertThat(received).isNotNull();
    assertThat(received.getHeaders().get(KafkaMessageSource.REMAINING_RECORDS, Integer.class)).isEqualTo(1);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    assertThat(received).isNotNull();
    assertThat(received.getHeaders().get(KafkaMessageSource.REMAINING_RECORDS, Integer.class)).isEqualTo(0);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    assertThat(received).isNull();
    source.destroy();
    InOrder inOrder = inOrder(consumer);
    inOrder.verify(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1L)));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(2L)));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(3L)));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(4L)));
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).close(any());
    inOrder.verifyNoMoreInteractions();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static <T> Consumer<T> createMockConsumer(List<TopicPartition> assigned) {
    Consumer<T> consumer = mock(Consumer.class);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(assigned);
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    willDoNothing().given(consumer).pause(anyCollection());
    willDoNothing().given(consumer).resume(anyCollection());
    return consumer;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_18
- **Scope**: method level
- **Mocked Class**: `org.apache.kafka.clients.consumer.Consumer`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static <K, V> Consumer<K, V> createMockConsumerWithSubscribeListener(AtomicReference<ConsumerRebalanceListener> listener) {
    Consumer<K, V> consumer = mock(Consumer.class);
    willAnswer(i -> {
        listener.set(i.getArgument(1));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    return consumer;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_18_1
#### Test Case Name: `testConsumerAwareRebalanceListener`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\inbound\MessageSourceTests.java`)
#### Mock Object Variable Name: `consumer`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testConsumerAwareRebalanceListener() {
-    Consumer consumer = mock(Consumer.class);
     TopicPartition topicPartition = new TopicPartition("foo", 0);
     List<TopicPartition> assigned = Collections.singletonList(topicPartition);
     AtomicReference<ConsumerRebalanceListener> listener = new AtomicReference<>();
+    Consumer consumer = createMockConsumerWithSubscribeListener(listener);
     ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
     willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
     given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
     ConsumerProperties consumerProperties = new ConsumerProperties("foo");
     AtomicBoolean partitionsAssignedCalled = new AtomicBoolean();
     AtomicReference<Consumer> partitionsAssignedConsumer = new AtomicReference<>();
     AtomicBoolean partitionsRevokedCalled = new AtomicBoolean();
     AtomicReference<Consumer> partitionsRevokedConsumer = new AtomicReference<>();
     consumerProperties.setConsumerRebalanceListener(new ConsumerAwareRebalanceListener() {

         @Override
         public void onPartitionsRevokedAfterCommit(Consumer<?, ?> cons, Collection<TopicPartition> partitions) {
             partitionsRevokedCalled.getAndSet(true);
             partitionsRevokedConsumer.set(cons);
         }

         @Override
         public void onPartitionsAssigned(Consumer<?, ?> cons, Collection<TopicPartition> partitions) {
             partitionsAssignedCalled.getAndSet(true);
             partitionsAssignedConsumer.set(cons);
         }
     });
     KafkaMessageSource source = new KafkaMessageSource(consumerFactory, consumerProperties);
     source.setRawMessageHeader(true);
     source.receive();
     listener.get().onPartitionsAssigned(assigned);
     assertThat(partitionsAssignedCalled.get()).isTrue();
     assertThat(partitionsAssignedConsumer.get()).isEqualTo(consumer);
     listener.get().onPartitionsRevoked(assigned);
     assertThat(partitionsRevokedCalled.get()).isTrue();
     assertThat(partitionsRevokedConsumer.get()).isEqualTo(consumer);
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "unchecked", "rawtypes" })
@Test
void testConsumerAwareRebalanceListener() {
    Consumer consumer = mock(Consumer.class);
    TopicPartition topicPartition = new TopicPartition("foo", 0);
    List<TopicPartition> assigned = Collections.singletonList(topicPartition);
    AtomicReference<ConsumerRebalanceListener> listener = new AtomicReference<>();
    willAnswer(i -> {
        listener.set(i.getArgument(1));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
    ConsumerProperties consumerProperties = new ConsumerProperties("foo");
    AtomicBoolean partitionsAssignedCalled = new AtomicBoolean();
    AtomicReference<Consumer> partitionsAssignedConsumer = new AtomicReference<>();
    AtomicBoolean partitionsRevokedCalled = new AtomicBoolean();
    AtomicReference<Consumer> partitionsRevokedConsumer = new AtomicReference<>();
    consumerProperties.setConsumerRebalanceListener(new ConsumerAwareRebalanceListener() {

        @Override
        public void onPartitionsRevokedAfterCommit(Consumer<?, ?> cons, Collection<TopicPartition> partitions) {
            partitionsRevokedCalled.getAndSet(true);
            partitionsRevokedConsumer.set(cons);
        }

        @Override
        public void onPartitionsAssigned(Consumer<?, ?> cons, Collection<TopicPartition> partitions) {
            partitionsAssignedCalled.getAndSet(true);
            partitionsAssignedConsumer.set(cons);
        }
    });
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, consumerProperties);
    source.setRawMessageHeader(true);
    source.receive();
    listener.get().onPartitionsAssigned(assigned);
    assertThat(partitionsAssignedCalled.get()).isTrue();
    assertThat(partitionsAssignedConsumer.get()).isEqualTo(consumer);
    listener.get().onPartitionsRevoked(assigned);
    assertThat(partitionsRevokedCalled.get()).isTrue();
    assertThat(partitionsRevokedConsumer.get()).isEqualTo(consumer);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static <K, V> Consumer<K, V> createMockConsumerWithSubscribeListener(AtomicReference<ConsumerRebalanceListener> listener) {
    Consumer<K, V> consumer = mock(Consumer.class);
    willAnswer(i -> {
        listener.set(i.getArgument(1));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    return consumer;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_18_2
#### Test Case Name: `testRebalanceListener`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\inbound\MessageSourceTests.java`)
#### Mock Object Variable Name: `consumer`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testRebalanceListener() {
-    Consumer consumer = mock(Consumer.class);
     TopicPartition topicPartition1 = new TopicPartition("foo", 0);
     List<TopicPartition> assigned1 = new ArrayList<>(Collections.singletonList(topicPartition1));
     TopicPartition topicPartition2 = new TopicPartition("foo", 1);
     List<TopicPartition> assigned2 = new ArrayList<>(Collections.singletonList(topicPartition2));
     AtomicReference<ConsumerRebalanceListener> listener = new AtomicReference<>();
+    Consumer consumer = createMockConsumerWithSubscribeListener(listener);
-    willAnswer(i -> {
-        listener.set(i.getArgument(1));
-        return null;
-    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
     ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
     willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
     given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
     ConsumerProperties consumerProperties = new ConsumerProperties("foo");
     AtomicBoolean partitionsAssignedCalled = new AtomicBoolean();
     AtomicBoolean partitionsRevokedCalled = new AtomicBoolean();
     consumerProperties.setConsumerRebalanceListener(new ConsumerRebalanceListener() {

         @Override
         public void onPartitionsRevoked(Collection<TopicPartition> partitions) {
             partitionsRevokedCalled.getAndSet(true);
         }

         @Override
         public void onPartitionsAssigned(Collection<TopicPartition> partitions) {
             partitionsAssignedCalled.getAndSet(true);
         }
     });
     KafkaMessageSource source = new KafkaMessageSource(consumerFactory, consumerProperties);
     source.setRawMessageHeader(true);
     source.receive();
     listener.get().onPartitionsAssigned(assigned1);
     assertThat(partitionsAssignedCalled.get()).isTrue();
     assertThat(new ArrayList<>(source.getAssignedPartitions())).isEqualTo(assigned1);
     listener.get().onPartitionsAssigned(assigned2);
     List<TopicPartition> temp = new ArrayList<>(assigned1);
     temp.addAll(assigned2);
     assertThat(new ArrayList<>(source.getAssignedPartitions())).isEqualTo(temp);
     listener.get().onPartitionsRevoked(assigned1);
     assertThat(partitionsRevokedCalled.get()).isTrue();
     assertThat(new ArrayList<>(source.getAssignedPartitions())).isEqualTo(assigned2);
     source.pause();
     assertThat(source.isPaused()).isFalse();
     InOrder inOrder = inOrder(consumer);
     source.receive();
     assertThat(source.isPaused()).isTrue();
     inOrder.verify(consumer).pause(new LinkedHashSet<>(assigned2));
     inOrder.verify(consumer).poll(any());
     listener.get().onPartitionsAssigned(assigned1);
     inOrder.verify(consumer).pause(new LinkedHashSet<>(temp));
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "unchecked", "rawtypes" })
@Test
void testRebalanceListener() {
    Consumer consumer = mock(Consumer.class);
    TopicPartition topicPartition1 = new TopicPartition("foo", 0);
    List<TopicPartition> assigned1 = new ArrayList<>(Collections.singletonList(topicPartition1));
    TopicPartition topicPartition2 = new TopicPartition("foo", 1);
    List<TopicPartition> assigned2 = new ArrayList<>(Collections.singletonList(topicPartition2));
    AtomicReference<ConsumerRebalanceListener> listener = new AtomicReference<>();
    willAnswer(i -> {
        listener.set(i.getArgument(1));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
    ConsumerProperties consumerProperties = new ConsumerProperties("foo");
    AtomicBoolean partitionsAssignedCalled = new AtomicBoolean();
    AtomicBoolean partitionsRevokedCalled = new AtomicBoolean();
    consumerProperties.setConsumerRebalanceListener(new ConsumerRebalanceListener() {

        @Override
        public void onPartitionsRevoked(Collection<TopicPartition> partitions) {
            partitionsRevokedCalled.getAndSet(true);
        }

        @Override
        public void onPartitionsAssigned(Collection<TopicPartition> partitions) {
            partitionsAssignedCalled.getAndSet(true);
        }
    });
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, consumerProperties);
    source.setRawMessageHeader(true);
    source.receive();
    listener.get().onPartitionsAssigned(assigned1);
    assertThat(partitionsAssignedCalled.get()).isTrue();
    assertThat(new ArrayList<>(source.getAssignedPartitions())).isEqualTo(assigned1);
    listener.get().onPartitionsAssigned(assigned2);
    List<TopicPartition> temp = new ArrayList<>(assigned1);
    temp.addAll(assigned2);
    assertThat(new ArrayList<>(source.getAssignedPartitions())).isEqualTo(temp);
    listener.get().onPartitionsRevoked(assigned1);
    assertThat(partitionsRevokedCalled.get()).isTrue();
    assertThat(new ArrayList<>(source.getAssignedPartitions())).isEqualTo(assigned2);
    source.pause();
    assertThat(source.isPaused()).isFalse();
    InOrder inOrder = inOrder(consumer);
    source.receive();
    assertThat(source.isPaused()).isTrue();
    inOrder.verify(consumer).pause(new LinkedHashSet<>(assigned2));
    inOrder.verify(consumer).poll(any());
    listener.get().onPartitionsAssigned(assigned1);
    inOrder.verify(consumer).pause(new LinkedHashSet<>(temp));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static <K, V> Consumer<K, V> createMockConsumerWithSubscribeListener(AtomicReference<ConsumerRebalanceListener> listener) {
    Consumer<K, V> consumer = mock(Consumer.class);
    willAnswer(i -> {
        listener.set(i.getArgument(1));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    return consumer;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_18_3
#### Test Case Name: `testPollTimeouts`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\inbound\MessageSourceTests.java`)
#### Mock Object Variable Name: `consumer`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @SuppressWarnings({ "rawtypes", "unchecked" })
 @Test
 void testPollTimeouts() {
-    Consumer consumer = mock(Consumer.class);
+    Consumer consumer = createMockConsumerWithSubscribeListener(listener);
     TopicPartition topicPartition = new TopicPartition("foo", 0);
     List<TopicPartition> assigned = Collections.singletonList(topicPartition);
     AtomicReference<ConsumerRebalanceListener> listener = new AtomicReference<>();
-    willAnswer(i -> {
-        listener.set(i.getArgument(1));
-        return null;
-    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
     Map<TopicPartition, List<ConsumerRecord>> records1 = new LinkedHashMap<>();
     records1.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty())));
     ConsumerRecords cr1 = new ConsumerRecords(records1);
     given(consumer.poll(Duration.of(20 * 5000, ChronoUnit.MILLIS))).willReturn(cr1, ConsumerRecords.EMPTY);
     Map<TopicPartition, List<ConsumerRecord>> records2 = new LinkedHashMap<>();
     records2.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty())));
     ConsumerRecords cr2 = new ConsumerRecords(records2);
     given(consumer.poll(Duration.of(5000, ChronoUnit.MILLIS))).willReturn(cr2, ConsumerRecords.EMPTY);
     ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
     willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
     given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
     KafkaMessageSource source = new KafkaMessageSource(consumerFactory, new ConsumerProperties("foo"));
     source.setRawMessageHeader(true);
     Message<?> received = source.receive();
     assertThat(received).isNotNull();
     assertThat(received).isNotNull();
     assertThat(received.getHeaders().get(KafkaHeaders.RAW_DATA)).isInstanceOf(ConsumerRecord.class);
     assertThat(received.getHeaders().get(KafkaHeaders.RAW_DATA)).isEqualTo(cr1.records(topicPartition).get(0));
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     listener.get().onPartitionsAssigned(assigned);
     received = source.receive();
     assertThat(received).isNotNull();
     assertThat(received.getHeaders().get(KafkaHeaders.RAW_DATA)).isInstanceOf(ConsumerRecord.class);
     assertThat(received.getHeaders().get(KafkaHeaders.RAW_DATA)).isEqualTo(cr2.records(topicPartition).get(0));
     StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
     listener.get().onPartitionsRevoked(assigned);
     received = source.receive();
     assertThat(received).isNull();
     InOrder inOrder = inOrder(consumer);
     inOrder.verify(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
     // assignTimeout used on initial poll (before partition assigned)
     inOrder.verify(consumer).poll(Duration.of(20 * 5000, ChronoUnit.MILLIS));
     inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1L)));
     // pollTimeout used on subsequent polls
     inOrder.verify(consumer).poll(Duration.of(5000, ChronoUnit.MILLIS));
     inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(2L)));
     // assignTimeout used after partitions revoked
     inOrder.verify(consumer).poll(Duration.of(20 * 5000, ChronoUnit.MILLIS));
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testPollTimeouts() {
    Consumer consumer = mock(Consumer.class);
    TopicPartition topicPartition = new TopicPartition("foo", 0);
    List<TopicPartition> assigned = Collections.singletonList(topicPartition);
    AtomicReference<ConsumerRebalanceListener> listener = new AtomicReference<>();
    willAnswer(i -> {
        listener.set(i.getArgument(1));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    Map<TopicPartition, List<ConsumerRecord>> records1 = new LinkedHashMap<>();
    records1.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty())));
    ConsumerRecords cr1 = new ConsumerRecords(records1);
    given(consumer.poll(Duration.of(20 * 5000, ChronoUnit.MILLIS))).willReturn(cr1, ConsumerRecords.EMPTY);
    Map<TopicPartition, List<ConsumerRecord>> records2 = new LinkedHashMap<>();
    records2.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty())));
    ConsumerRecords cr2 = new ConsumerRecords(records2);
    given(consumer.poll(Duration.of(5000, ChronoUnit.MILLIS))).willReturn(cr2, ConsumerRecords.EMPTY);
    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, new ConsumerProperties("foo"));
    source.setRawMessageHeader(true);
    Message<?> received = source.receive();
    assertThat(received).isNotNull();
    assertThat(received).isNotNull();
    assertThat(received.getHeaders().get(KafkaHeaders.RAW_DATA)).isInstanceOf(ConsumerRecord.class);
    assertThat(received.getHeaders().get(KafkaHeaders.RAW_DATA)).isEqualTo(cr1.records(topicPartition).get(0));
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    listener.get().onPartitionsAssigned(assigned);
    received = source.receive();
    assertThat(received).isNotNull();
    assertThat(received.getHeaders().get(KafkaHeaders.RAW_DATA)).isInstanceOf(ConsumerRecord.class);
    assertThat(received.getHeaders().get(KafkaHeaders.RAW_DATA)).isEqualTo(cr2.records(topicPartition).get(0));
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    listener.get().onPartitionsRevoked(assigned);
    received = source.receive();
    assertThat(received).isNull();
    InOrder inOrder = inOrder(consumer);
    inOrder.verify(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    // assignTimeout used on initial poll (before partition assigned)
    inOrder.verify(consumer).poll(Duration.of(20 * 5000, ChronoUnit.MILLIS));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1L)));
    // pollTimeout used on subsequent polls
    inOrder.verify(consumer).poll(Duration.of(5000, ChronoUnit.MILLIS));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(2L)));
    // assignTimeout used after partitions revoked
    inOrder.verify(consumer).poll(Duration.of(20 * 5000, ChronoUnit.MILLIS));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static <K, V> Consumer<K, V> createMockConsumerWithSubscribeListener(AtomicReference<ConsumerRebalanceListener> listener) {
    Consumer<K, V> consumer = mock(Consumer.class);
    willAnswer(i -> {
        listener.set(i.getArgument(1));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    return consumer;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_19
- **Scope**: method level
- **Mocked Class**: `org.apache.kafka.clients.consumer.Consumer`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static Consumer<String, String> createMockConsumer(
        TopicPartition topicPartition,
        AtomicBoolean done,
        ConsumerRecords<String, String> records,
        ConsumerGroupMetadata meta) {
    Consumer<String, String> mockConsumer = mock(Consumer.class);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(mockConsumer).subscribe(any(Collection.class), any(ConsumerRebalanceListener.class));
    willAnswer(i -> {
        if (done.compareAndSet(false, true)) {
            return records;
        } else {
            Thread.sleep(500);
            return null;
        }
    }).given(mockConsumer).poll(any(Duration.class));
    given(mockConsumer.groupMetadata()).willReturn(meta);
    return mockConsumer;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_19_1
#### Test Case Name: `testConsumeAndProduceTransaction`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `mockConsumer`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testConsumeAndProduceTransaction() throws Exception {
-    Consumer mockConsumer = mock(Consumer.class);
     final TopicPartition topicPartition = new TopicPartition("foo", 0);
+    final AtomicBoolean done = new AtomicBoolean();
+    ConsumerRecords records = new ConsumerRecords(Collections.singletonMap(topicPartition, Collections.singletonList(new ConsumerRecord<>("foo", 0, 0, "key", "value"))));
+    ConsumerGroupMetadata meta = new ConsumerGroupMetadata("group");
+    Consumer mockConsumer = createMockConsumer(topicPartition, done, records, meta);
     willAnswer(i -> {
         ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
         return null;
     }).given(mockConsumer).subscribe(any(Collection.class), any(ConsumerRebalanceListener.class));
     ConsumerRecords records = new ConsumerRecords(Collections.singletonMap(topicPartition, Collections.singletonList(new ConsumerRecord<>("foo", 0, 0, "key", "value"))));
-    final AtomicBoolean done = new AtomicBoolean();
-    willAnswer(i -> {
-        if (done.compareAndSet(false, true)) {
-            return records;
-        } else {
-            Thread.sleep(500);
-            return null;
-        }
-    }).given(mockConsumer).poll(any(Duration.class));
-    ConsumerGroupMetadata meta = new ConsumerGroupMetadata("group");
-    given(mockConsumer.groupMetadata()).willReturn(meta);
     ConsumerFactory cf = mock(ConsumerFactory.class);
     willReturn(mockConsumer).given(cf).createConsumer("group", "", null, KafkaTestUtils.defaultPropertyOverrides());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "unchecked", "rawtypes" })
@Test
void testConsumeAndProduceTransaction() throws Exception {
    Consumer mockConsumer = mock(Consumer.class);
    final TopicPartition topicPartition = new TopicPartition("foo", 0);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(mockConsumer).subscribe(any(Collection.class), any(ConsumerRebalanceListener.class));
    ConsumerRecords records = new ConsumerRecords(Collections.singletonMap(topicPartition, Collections.singletonList(new ConsumerRecord<>("foo", 0, 0, "key", "value"))));
    final AtomicBoolean done = new AtomicBoolean();
    willAnswer(i -> {
        if (done.compareAndSet(false, true)) {
            return records;
        } else {
            Thread.sleep(500);
            return null;
        }
    }).given(mockConsumer).poll(any(Duration.class));
    ConsumerGroupMetadata meta = new ConsumerGroupMetadata("group");
    given(mockConsumer.groupMetadata()).willReturn(meta);
    ConsumerFactory cf = mock(ConsumerFactory.class);
    willReturn(mockConsumer).given(cf).createConsumer("group", "", null, KafkaTestUtils.defaultPropertyOverrides());
    Producer producer = mock(Producer.class);
    given(producer.send(any(), any())).willReturn(mock(Future.class));
    final CountDownLatch closeLatch = new CountDownLatch(2);
    willAnswer(i -> {
        closeLatch.countDown();
        return null;
    }).given(producer).close(any());
    ProducerFactory pf = mock(ProducerFactory.class);
    given(pf.transactionCapable()).willReturn(true);
    willReturn(producer).given(pf).createProducer(isNull());
    KafkaTransactionManager ptm = new KafkaTransactionManager(pf);
    ContainerProperties props = new ContainerProperties("foo");
    props.setGroupId("group");
    props.setKafkaAwareTransactionManager(ptm);
    props.setAssignmentCommitOption(AssignmentCommitOption.ALWAYS);
    final KafkaTemplate template = new KafkaTemplate(pf);
    KafkaMessageListenerContainer container = new KafkaMessageListenerContainer<>(cf, props);
    container.setBeanName("commit");
    KafkaMessageDrivenChannelAdapter inbound = new KafkaMessageDrivenChannelAdapter<>(container);
    DirectChannel channel = new DirectChannel();
    inbound.setOutputChannel(channel);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setMessageKeyExpression(new LiteralExpression("bar"));
    handler.setTopicExpression(new LiteralExpression("topic"));
    channel.subscribe(handler);
    inbound.afterPropertiesSet();
    inbound.start();
    assertThat(closeLatch.await(10, TimeUnit.SECONDS)).isTrue();
    InOrder inOrder = inOrder(producer);
    inOrder.verify(producer).beginTransaction();
    inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(0)), meta);
    inOrder.verify(producer).commitTransaction();
    inOrder.verify(producer).close(any());
    inOrder.verify(producer).beginTransaction();
    ArgumentCaptor<ProducerRecord> captor = ArgumentCaptor.forClass(ProducerRecord.class);
    inOrder.verify(producer).send(captor.capture(), any(Callback.class));
    assertThat(captor.getValue()).isEqualTo(new ProducerRecord("topic", null, "bar", "value"));
    inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1)), meta);
    inOrder.verify(producer).commitTransaction();
    inOrder.verify(producer).close(any());
    container.stop();
    verify(pf, times(2)).createProducer(isNull());
    verifyNoMoreInteractions(producer);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Consumer<String, String> createMockConsumer(
        TopicPartition topicPartition,
        AtomicBoolean done,
        ConsumerRecords<String, String> records,
        ConsumerGroupMetadata meta) {
    Consumer<String, String> mockConsumer = mock(Consumer.class);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(mockConsumer).subscribe(any(Collection.class), any(ConsumerRebalanceListener.class));
    willAnswer(i -> {
        if (done.compareAndSet(false, true)) {
            return records;
        } else {
            Thread.sleep(500);
            return null;
        }
    }).given(mockConsumer).poll(any(Duration.class));
    given(mockConsumer.groupMetadata()).willReturn(meta);
    return mockConsumer;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_19_2
#### Test Case Name: `testConsumeAndProduceTransactionTxIdOverride`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `mockConsumer`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @SuppressWarnings({ "unchecked", "rawtypes" })
 @Test
 void testConsumeAndProduceTransactionTxIdOverride() throws Exception {
-    Consumer mockConsumer = mock(Consumer.class);
     final TopicPartition topicPartition = new TopicPartition("foo", 0);
+    final TopicPartition topicPartition = new TopicPartition("foo", 0);
     willAnswer(i -> {
         ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
         return null;
     }).given(mockConsumer).subscribe(any(Collection.class), any(ConsumerRebalanceListener.class));
     ConsumerRecords records = new ConsumerRecords(Collections.singletonMap(topicPartition, Collections.singletonList(new ConsumerRecord<>("foo", 0, 0, "key", "value"))));
     final AtomicBoolean done = new AtomicBoolean();
     willAnswer(i -> {
         if (done.compareAndSet(false, true)) {
             return records;
         } else {
             Thread.sleep(500);
             return null;
         }
     }).given(mockConsumer).poll(any(Duration.class));
     ConsumerGroupMetadata meta = new ConsumerGroupMetadata("group");
-    given(mockConsumer.groupMetadata()).willReturn(meta);
+    Consumer mockConsumer = createMockConsumer(topicPartition, done, records, meta);
     ConsumerFactory cf = mock(ConsumerFactory.class);
     willReturn(mockConsumer).given(cf).createConsumer("group", "", null, KafkaTestUtils.defaultPropertyOverrides());
     Producer producer = mock(Producer.class);
     given(producer.send(any(), any())).willReturn(mock(Future.class));
     final CountDownLatch closeLatch = new CountDownLatch(2);
     willAnswer(i -> {
         closeLatch.countDown();
         return null;
     }).given(producer).close(any());
     AtomicReference<String> txId = new AtomicReference<>();
     DefaultKafkaProducerFactory pf = new DefaultKafkaProducerFactory(Collections.emptyMap()) {

         @Override
         protected Producer createTransactionalProducer(String txIdPrefix) {
             txId.set(txIdPrefix);
             return producer;
         }
     };
     pf.setTransactionIdPrefix("default.tx.id.");
     KafkaTransactionManager tm = new KafkaTransactionManager(pf);
     tm.setTransactionIdPrefix("tm.tx.id.");
     ContainerProperties props = new ContainerProperties("foo");
     props.setGroupId("group");
     props.setKafkaAwareTransactionManager(tm);
     props.setAssignmentCommitOption(AssignmentCommitOption.ALWAYS);
     final KafkaTemplate template = new KafkaTemplate(pf);
     template.setTransactionIdPrefix("template.tx.id.");
     KafkaMessageListenerContainer container = new KafkaMessageListenerContainer<>(cf, props);
     container.setBeanName("commit");
     KafkaMessageDrivenChannelAdapter inbound = new KafkaMessageDrivenChannelAdapter<>(container);
     DirectChannel channel = new DirectChannel();
     inbound.setOutputChannel(channel);
     KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
     handler.setMessageKeyExpression(new LiteralExpression("bar"));
     handler.setTopicExpression(new LiteralExpression("topic"));
     channel.subscribe(handler);
     inbound.afterPropertiesSet();
     inbound.start();
     assertThat(closeLatch.await(10, TimeUnit.SECONDS)).isTrue();
     InOrder inOrder = inOrder(producer);
     inOrder.verify(producer).beginTransaction();
     inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(0)), meta);
     inOrder.verify(producer).commitTransaction();
     inOrder.verify(producer).close(any());
     inOrder.verify(producer).beginTransaction();
     ArgumentCaptor<ProducerRecord> captor = ArgumentCaptor.forClass(ProducerRecord.class);
     inOrder.verify(producer).send(captor.capture(), any(Callback.class));
     assertThat(captor.getValue()).isEqualTo(new ProducerRecord("topic", null, "bar", "value"));
     inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1)), meta);
     inOrder.verify(producer).commitTransaction();
     inOrder.verify(producer).close(any());
     container.stop();
     verifyNoMoreInteractions(producer);
     assertThat(txId.get()).isEqualTo("tm.tx.id.");
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "unchecked", "rawtypes" })
@Test
void testConsumeAndProduceTransactionTxIdOverride() throws Exception {
    Consumer mockConsumer = mock(Consumer.class);
    final TopicPartition topicPartition = new TopicPartition("foo", 0);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(mockConsumer).subscribe(any(Collection.class), any(ConsumerRebalanceListener.class));
    ConsumerRecords records = new ConsumerRecords(Collections.singletonMap(topicPartition, Collections.singletonList(new ConsumerRecord<>("foo", 0, 0, "key", "value"))));
    final AtomicBoolean done = new AtomicBoolean();
    willAnswer(i -> {
        if (done.compareAndSet(false, true)) {
            return records;
        } else {
            Thread.sleep(500);
            return null;
        }
    }).given(mockConsumer).poll(any(Duration.class));
    ConsumerGroupMetadata meta = new ConsumerGroupMetadata("group");
    given(mockConsumer.groupMetadata()).willReturn(meta);
    ConsumerFactory cf = mock(ConsumerFactory.class);
    willReturn(mockConsumer).given(cf).createConsumer("group", "", null, KafkaTestUtils.defaultPropertyOverrides());
    Producer producer = mock(Producer.class);
    given(producer.send(any(), any())).willReturn(mock(Future.class));
    final CountDownLatch closeLatch = new CountDownLatch(2);
    willAnswer(i -> {
        closeLatch.countDown();
        return null;
    }).given(producer).close(any());
    AtomicReference<String> txId = new AtomicReference<>();
    DefaultKafkaProducerFactory pf = new DefaultKafkaProducerFactory(Collections.emptyMap()) {

        @Override
        protected Producer createTransactionalProducer(String txIdPrefix) {
            txId.set(txIdPrefix);
            return producer;
        }
    };
    pf.setTransactionIdPrefix("default.tx.id.");
    KafkaTransactionManager tm = new KafkaTransactionManager(pf);
    tm.setTransactionIdPrefix("tm.tx.id.");
    ContainerProperties props = new ContainerProperties("foo");
    props.setGroupId("group");
    props.setKafkaAwareTransactionManager(tm);
    props.setAssignmentCommitOption(AssignmentCommitOption.ALWAYS);
    final KafkaTemplate template = new KafkaTemplate(pf);
    template.setTransactionIdPrefix("template.tx.id.");
    KafkaMessageListenerContainer container = new KafkaMessageListenerContainer<>(cf, props);
    container.setBeanName("commit");
    KafkaMessageDrivenChannelAdapter inbound = new KafkaMessageDrivenChannelAdapter<>(container);
    DirectChannel channel = new DirectChannel();
    inbound.setOutputChannel(channel);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setMessageKeyExpression(new LiteralExpression("bar"));
    handler.setTopicExpression(new LiteralExpression("topic"));
    channel.subscribe(handler);
    inbound.afterPropertiesSet();
    inbound.start();
    assertThat(closeLatch.await(10, TimeUnit.SECONDS)).isTrue();
    InOrder inOrder = inOrder(producer);
    inOrder.verify(producer).beginTransaction();
    inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(0)), meta);
    inOrder.verify(producer).commitTransaction();
    inOrder.verify(producer).close(any());
    inOrder.verify(producer).beginTransaction();
    ArgumentCaptor<ProducerRecord> captor = ArgumentCaptor.forClass(ProducerRecord.class);
    inOrder.verify(producer).send(captor.capture(), any(Callback.class));
    assertThat(captor.getValue()).isEqualTo(new ProducerRecord("topic", null, "bar", "value"));
    inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1)), meta);
    inOrder.verify(producer).commitTransaction();
    inOrder.verify(producer).close(any());
    container.stop();
    verifyNoMoreInteractions(producer);
    assertThat(txId.get()).isEqualTo("tm.tx.id.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Consumer<String, String> createMockConsumer(
        TopicPartition topicPartition,
        AtomicBoolean done,
        ConsumerRecords<String, String> records,
        ConsumerGroupMetadata meta) {
    Consumer<String, String> mockConsumer = mock(Consumer.class);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(mockConsumer).subscribe(any(Collection.class), any(ConsumerRebalanceListener.class));
    willAnswer(i -> {
        if (done.compareAndSet(false, true)) {
            return records;
        } else {
            Thread.sleep(500);
            return null;
        }
    }).given(mockConsumer).poll(any(Duration.class));
    given(mockConsumer.groupMetadata()).willReturn(meta);
    return mockConsumer;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_20
- **Scope**: method level
- **Mocked Class**: `org.springframework.amqp.rabbit.connection.Connection`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static Connection createMockConnection(Channel channel) {
    Connection connection = mock(Connection.class);
    doAnswer(invocation -> channel).when(connection).createChannel(anyBoolean());
    return connection;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_20_1
#### Test Case Name: `testPtP`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\channel\DispatcherHasNoSubscribersTests.java`)
#### Mock Object Variable Name: `connection`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(channel.queueDeclare(anyString(), anyBoolean(), anyBoolean(), anyBoolean(), isNull())).thenReturn(declareOk);
-    Connection connection = mock(Connection.class);
-    doAnswer(invocation -> channel).when(connection).createChannel(anyBoolean());
+    Connection connection = createMockConnection(channel);
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    when(connectionFactory.createConnection()).thenReturn(connection);
    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testPtP() throws Exception {
    final Channel channel = mock(Channel.class);
    DeclareOk declareOk = mock(DeclareOk.class);
    when(declareOk.getQueue()).thenReturn("noSubscribersChannel");
    when(channel.queueDeclare(anyString(), anyBoolean(), anyBoolean(), anyBoolean(), isNull())).thenReturn(declareOk);
    Connection connection = mock(Connection.class);
    doAnswer(invocation -> channel).when(connection).createChannel(anyBoolean());
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    when(connectionFactory.createConnection()).thenReturn(connection);
    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
    container.setConnectionFactory(connectionFactory);
    AmqpTemplate amqpTemplate = mock(AmqpTemplate.class);
    PointToPointSubscribableAmqpChannel amqpChannel = new PointToPointSubscribableAmqpChannel("noSubscribersChannel", container, amqpTemplate);
    amqpChannel.setBeanName("noSubscribersChannel");
    amqpChannel.setBeanFactory(mock(BeanFactory.class));
    amqpChannel.afterPropertiesSet();
    MessageListener listener = container.getMessageListener();
    assertThatExceptionOfType(MessageDeliveryException.class).isThrownBy(() -> listener.onMessage(new Message("Hello world!".getBytes()))).withMessageContaining("Dispatcher has no subscribers for amqp-channel 'noSubscribersChannel'.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Connection createMockConnection(Channel channel) {
    Connection connection = mock(Connection.class);
    doAnswer(invocation -> channel).when(connection).createChannel(anyBoolean());
    return connection;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_20_2
#### Test Case Name: `testPubSub`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\channel\DispatcherHasNoSubscribersTests.java`)
#### Mock Object Variable Name: `connection`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    final Channel channel = mock(Channel.class);
-    Connection connection = mock(Connection.class);
-    doAnswer(invocation -> channel).when(connection).createChannel(anyBoolean());
+    Connection connection = createMockConnection(channel);
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    when(connectionFactory.createConnection()).thenReturn(connection);
    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
    container.setConnectionFactory(connectionFactory);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testPubSub() {
    final Channel channel = mock(Channel.class);
    Connection connection = mock(Connection.class);
    doAnswer(invocation -> channel).when(connection).createChannel(anyBoolean());
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    when(connectionFactory.createConnection()).thenReturn(connection);
    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
    container.setConnectionFactory(connectionFactory);
    AmqpTemplate amqpTemplate = mock(AmqpTemplate.class);
    PublishSubscribeAmqpChannel amqpChannel = new PublishSubscribeAmqpChannel("noSubscribersChannel", container, amqpTemplate);
    amqpChannel.setBeanName("noSubscribersChannel");
    amqpChannel.setBeanFactory(mock(BeanFactory.class));
    amqpChannel.afterPropertiesSet();
    List<String> logList = insertMockLoggerInListener(amqpChannel);
    MessageListener listener = container.getMessageListener();
    listener.onMessage(new Message("Hello world!".getBytes()));
    verifyLogReceived(logList);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Connection createMockConnection(Channel channel) {
    Connection connection = mock(Connection.class);
    doAnswer(invocation -> channel).when(connection).createChannel(anyBoolean());
    return connection;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_21
- **Scope**: method level
- **Mocked Class**: `org.springframework.amqp.rabbit.connection.Connection`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static Connection createMockConnection(PublisherCallbackChannelImpl publisherCallbackChannel) {
    Connection mockConnection = mock(Connection.class);
    when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);
    return mockConnection;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_21_1
#### Test Case Name: `testInt2773UseDefaultAmqpTemplateExchangeAndRoutingLey`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\config\AmqpOutboundChannelAdapterParserTests.java`)
#### Mock Object Variable Name: `mockConnection`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
-    Connection mockConnection = mock(Connection.class);
    Channel mockChannel = mock(Channel.class);
    when(connectionFactory.createConnection()).thenReturn(mockConnection);
    PublisherCallbackChannelImpl publisherCallbackChannel = new PublisherCallbackChannelImpl(mockChannel, mock(ExecutorService.class));
-    when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);
+    Connection mockConnection = createMockConnection(publisherCallbackChannel);
    MessageChannel requestChannel = context.getBean("toRabbitOnlyWithTemplateChannel", MessageChannel.class);
    requestChannel.send(MessageBuilder.withPayload("test").build());
    Mockito.verify(mockChannel, Mockito.times(1)).basicPublish(Mockito.eq("default.test.exchange"), Mockito.eq("default.routing.key"), Mockito.anyBoolean(), Mockito.any(BasicProperties.class), Mockito.any(byte[].class));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testInt2773UseDefaultAmqpTemplateExchangeAndRoutingLey() throws IOException {
    ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
    Connection mockConnection = mock(Connection.class);
    Channel mockChannel = mock(Channel.class);
    when(connectionFactory.createConnection()).thenReturn(mockConnection);
    PublisherCallbackChannelImpl publisherCallbackChannel = new PublisherCallbackChannelImpl(mockChannel, mock(ExecutorService.class));
    when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);
    MessageChannel requestChannel = context.getBean("toRabbitOnlyWithTemplateChannel", MessageChannel.class);
    requestChannel.send(MessageBuilder.withPayload("test").build());
    Mockito.verify(mockChannel, Mockito.times(1)).basicPublish(Mockito.eq("default.test.exchange"), Mockito.eq("default.routing.key"), Mockito.anyBoolean(), Mockito.any(BasicProperties.class), Mockito.any(byte[].class));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Connection createMockConnection(PublisherCallbackChannelImpl publisherCallbackChannel) {
    Connection mockConnection = mock(Connection.class);
    when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);
    return mockConnection;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_21_2
#### Test Case Name: `testInt2773WithDefaultAmqpTemplateExchangeAndRoutingKey`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\config\AmqpOutboundChannelAdapterParserTests.java`)
#### Mock Object Variable Name: `mockConnection`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
-    Connection mockConnection = mock(Connection.class);
    Channel mockChannel = mock(Channel.class);
    when(connectionFactory.createConnection()).thenReturn(mockConnection);
    PublisherCallbackChannelImpl publisherCallbackChannel = new PublisherCallbackChannelImpl(mockChannel, mock(ExecutorService.class));
-    when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);
+    Connection mockConnection = createMockConnection(publisherCallbackChannel);
    MessageChannel requestChannel = context.getBean("withDefaultAmqpTemplateExchangeAndRoutingKey", MessageChannel.class);
    requestChannel.send(MessageBuilder.withPayload("test").build());
    Mockito.verify(mockChannel, Mockito.times(1)).basicPublish(Mockito.eq(""), Mockito.eq(""), Mockito.anyBoolean(), Mockito.any(BasicProperties.class), Mockito.any(byte[].class));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testInt2773WithDefaultAmqpTemplateExchangeAndRoutingKey() throws IOException {
    ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
    Connection mockConnection = mock(Connection.class);
    Channel mockChannel = mock(Channel.class);
    when(connectionFactory.createConnection()).thenReturn(mockConnection);
    PublisherCallbackChannelImpl publisherCallbackChannel = new PublisherCallbackChannelImpl(mockChannel, mock(ExecutorService.class));
    when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);
    MessageChannel requestChannel = context.getBean("withDefaultAmqpTemplateExchangeAndRoutingKey", MessageChannel.class);
    requestChannel.send(MessageBuilder.withPayload("test").build());
    Mockito.verify(mockChannel, Mockito.times(1)).basicPublish(Mockito.eq(""), Mockito.eq(""), Mockito.anyBoolean(), Mockito.any(BasicProperties.class), Mockito.any(byte[].class));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Connection createMockConnection(PublisherCallbackChannelImpl publisherCallbackChannel) {
    Connection mockConnection = mock(Connection.class);
    when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);
    return mockConnection;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_21_3
#### Test Case Name: `testInt2773WithOverrideToDefaultAmqpTemplateExchangeAndRoutingLey`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\config\AmqpOutboundChannelAdapterParserTests.java`)
#### Mock Object Variable Name: `mockConnection`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
-    Connection mockConnection = mock(Connection.class);
    Channel mockChannel = mock(Channel.class);
    when(connectionFactory.createConnection()).thenReturn(mockConnection);
    PublisherCallbackChannelImpl publisherCallbackChannel = new PublisherCallbackChannelImpl(mockChannel, mock(ExecutorService.class));
-    when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);
+    Connection mockConnection = createMockConnection(publisherCallbackChannel);
    MessageChannel requestChannel = context.getBean("overrideTemplateAttributesToEmpty", MessageChannel.class);
    requestChannel.send(MessageBuilder.withPayload("test").build());
    Mockito.verify(mockChannel, Mockito.times(1)).basicPublish(Mockito.eq(""), Mockito.eq(""), Mockito.anyBoolean(), Mockito.any(BasicProperties.class), Mockito.any(byte[].class));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testInt2773WithOverrideToDefaultAmqpTemplateExchangeAndRoutingLey() throws IOException {
    ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
    Connection mockConnection = mock(Connection.class);
    Channel mockChannel = mock(Channel.class);
    when(connectionFactory.createConnection()).thenReturn(mockConnection);
    PublisherCallbackChannelImpl publisherCallbackChannel = new PublisherCallbackChannelImpl(mockChannel, mock(ExecutorService.class));
    when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);
    MessageChannel requestChannel = context.getBean("overrideTemplateAttributesToEmpty", MessageChannel.class);
    requestChannel.send(MessageBuilder.withPayload("test").build());
    Mockito.verify(mockChannel, Mockito.times(1)).basicPublish(Mockito.eq(""), Mockito.eq(""), Mockito.anyBoolean(), Mockito.any(BasicProperties.class), Mockito.any(byte[].class));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Connection createMockConnection(PublisherCallbackChannelImpl publisherCallbackChannel) {
    Connection mockConnection = mock(Connection.class);
    when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);
    return mockConnection;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_22
- **Scope**: method level
- **Mocked Class**: `jakarta.mail.Store`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static Store createMockStore(IMAPFolder folder, boolean isConnected) {
    Store store = mock(Store.class);
    given(store.isConnected()).willReturn(isConnected);
    given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);
    return store;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_22_1
#### Test Case Name: `testNoInitialIdleDelayWhenRecentNotSupported`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\ImapMailReceiverTests.java`)
#### Mock Object Variable Name: `store`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Field storeField = AbstractMailReceiver.class.getDeclaredField("store");
    storeField.setAccessible(true);
-    Store store = mock(Store.class);
-    given(store.isConnected()).willReturn(true);
-    given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);
+    Store store = createMockStore(folder, true);
    storeField.set(receiver, store);
    receiver.afterPropertiesSet();
    DirectFieldAccessor adapterAccessor = new DirectFieldAccessor(adapter);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("resource")
@Test
public void testNoInitialIdleDelayWhenRecentNotSupported() throws Exception {
    ImapIdleChannelAdapter adapter = this.context.getBean("simpleAdapter", ImapIdleChannelAdapter.class);
    QueueChannel channel = new QueueChannel();
    adapter.setOutputChannel(channel);
    adapter.setReconnectDelay(10);
    ImapMailReceiver receiver = new ImapMailReceiver("imap:foo");
    ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();
    setUpScheduler(receiver, taskScheduler);
    final IMAPFolder folder = mock(IMAPFolder.class);
    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
    given(folder.isOpen()).willReturn(false).willReturn(true);
    given(folder.exists()).willReturn(true);
    Field storeField = AbstractMailReceiver.class.getDeclaredField("store");
    storeField.setAccessible(true);
    Store store = mock(Store.class);
    given(store.isConnected()).willReturn(true);
    given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);
    storeField.set(receiver, store);
    receiver.afterPropertiesSet();
    DirectFieldAccessor adapterAccessor = new DirectFieldAccessor(adapter);
    adapterAccessor.setPropertyValue("mailReceiver", receiver);
    Message mailMessage = GreenMailUtil.newMimeMessage("test1");
    final Message[] messages = new Message[] { mailMessage };
    final AtomicInteger shouldFindMessagesCounter = new AtomicInteger(2);
    willAnswer(invocation -> {
        /*
			 * Return the message from first invocation of waitForMessages()
			 * and in receive(); then return false in the next call to
			 * waitForMessages() so we enter idle(); counter will be reset
			 * to 1 in the mocked idle().
			 */
        if (shouldFindMessagesCounter.decrementAndGet() >= 0) {
            return messages;
        } else {
            return new Message[0];
        }
    }).given(folder).search(any(SearchTerm.class));
    willAnswer(invocation -> {
        Thread.sleep(300);
        shouldFindMessagesCounter.set(1);
        return null;
    }).given(folder).idle(true);
    adapter.start();
    /*
		 * Idle takes 5 seconds; if all is well, we should receive the first message
		 * before then.
		 */
    assertThat(channel.receive(20000)).isNotNull();
    // We should not receive any more until the next idle elapses
    assertThat(channel.receive(100)).isNull();
    assertThat(channel.receive(10000)).isNotNull();
    adapter.stop();
    taskScheduler.shutdown();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Store createMockStore(IMAPFolder folder, boolean isConnected) {
    Store store = mock(Store.class);
    given(store.isConnected()).willReturn(isConnected);
    given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);
    return store;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_22_2
#### Test Case Name: `testInitialIdleDelayWhenRecentIsSupported`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\ImapMailReceiverTests.java`)
#### Mock Object Variable Name: `store`
<summary>Suggested Diff</summary>

```diff
@@
    Field storeField = AbstractMailReceiver.class.getDeclaredField("store");
    storeField.setAccessible(true);
-    Store store = mock(Store.class);
-    given(store.isConnected()).willReturn(true);
-    given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);
+    Store store = createMockStore(folder, true);
    storeField.set(receiver, store);
    receiver.afterPropertiesSet();
    DirectFieldAccessor adapterAccessor = new DirectFieldAccessor(adapter);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testInitialIdleDelayWhenRecentIsSupported() throws Exception {
    ImapIdleChannelAdapter adapter = this.context.getBean("simpleAdapter", ImapIdleChannelAdapter.class);
    QueueChannel channel = new QueueChannel();
    adapter.setOutputChannel(channel);
    adapter.setReconnectDelay(100);
    adapter.afterPropertiesSet();
    ImapMailReceiver receiver = new ImapMailReceiver("imap:foo");
    receiver.setCancelIdleInterval(10);
    ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();
    setUpScheduler(receiver, taskScheduler);
    IMAPFolder folder = mock(IMAPFolder.class);
    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.RECENT));
    given(folder.isOpen()).willReturn(false).willReturn(true);
    given(folder.exists()).willReturn(true);
    Field storeField = AbstractMailReceiver.class.getDeclaredField("store");
    storeField.setAccessible(true);
    Store store = mock(Store.class);
    given(store.isConnected()).willReturn(true);
    given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);
    storeField.set(receiver, store);
    receiver.afterPropertiesSet();
    DirectFieldAccessor adapterAccessor = new DirectFieldAccessor(adapter);
    adapterAccessor.setPropertyValue("mailReceiver", receiver);
    Message mailMessage = GreenMailUtil.newMimeMessage("test1");
    Message[] messages = new Message[] { mailMessage };
    willAnswer(invocation -> messages).given(folder).search(any(SearchTerm.class));
    CountDownLatch idles = new CountDownLatch(2);
    willAnswer(invocation -> {
        idles.countDown();
        Thread.sleep(500);
        return null;
    }).given(folder).idle(true);
    adapter.start();
    /*
		 * Idle takes 5 seconds; since this server supports RECENT, we should
		 * not receive any early messages.
		 */
    assertThat(channel.receive(100)).isNull();
    assertThat(channel.receive(20000)).isNotNull();
    assertThat(idles.await(10, TimeUnit.SECONDS)).isTrue();
    adapter.stop();
    taskScheduler.shutdown();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Store createMockStore(IMAPFolder folder, boolean isConnected) {
    Store store = mock(Store.class);
    given(store.isConnected()).willReturn(isConnected);
    given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);
    return store;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_22_3
#### Test Case Name: `testIdleReconnects`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\ImapMailReceiverTests.java`)
#### Mock Object Variable Name: `store`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Field storeField = AbstractMailReceiver.class.getDeclaredField("store");
    storeField.setAccessible(true);
-    Store store = mock(Store.class);
-    given(store.isConnected()).willReturn(false);
-    given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);
+    Store store = createMockStore(folder, false);
    storeField.set(receiver, store);
    ImapIdleChannelAdapter adapter = new ImapIdleChannelAdapter(receiver);
    LogAccessor logger = spy(TestUtils.getPropertyValue(adapter, "logger", LogAccessor.class));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testIdleReconnects() throws Exception {
    ImapMailReceiver receiver = spy(new ImapMailReceiver("imap:foo"));
    receiver.setBeanFactory(mock(BeanFactory.class));
    receiver.afterPropertiesSet();
    IMAPFolder folder = mock(IMAPFolder.class);
    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
    given(folder.isOpen()).willReturn(false).willReturn(true);
    given(folder.exists()).willReturn(true);
    given(folder.hasNewMessages()).willReturn(true);
    Field storeField = AbstractMailReceiver.class.getDeclaredField("store");
    storeField.setAccessible(true);
    Store store = mock(Store.class);
    given(store.isConnected()).willReturn(false);
    given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);
    storeField.set(receiver, store);
    ImapIdleChannelAdapter adapter = new ImapIdleChannelAdapter(receiver);
    LogAccessor logger = spy(TestUtils.getPropertyValue(adapter, "logger", LogAccessor.class));
    new DirectFieldAccessor(adapter).setPropertyValue("logger", logger);
    willDoNothing().given(logger).warn(any(Throwable.class), anyString());
    willAnswer(i -> {
        i.callRealMethod();
        throw new FolderClosedException(folder, "test");
    }).given(receiver).waitForNewMessages();
    adapter.setReconnectDelay(10);
    CountDownLatch latch = new CountDownLatch(3);
    adapter.setApplicationEventPublisher(e -> latch.countDown());
    adapter.afterPropertiesSet();
    adapter.start();
    assertThat(latch.await(60, TimeUnit.SECONDS)).isTrue();
    verify(store, atLeast(3)).connect();
    adapter.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Store createMockStore(IMAPFolder folder, boolean isConnected) {
    Store store = mock(Store.class);
    given(store.isConnected()).willReturn(isConnected);
    given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);
    return store;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_23
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.file.remote.session.Session<org.apache.commons.net.ftp.FTPFile>`
- **Test Case Count**: 1
- **MO Count**: 2

### Reusable Method
```java
private static Session<FTPFile> createMockSession(boolean isOpenReturn) {
    Session<FTPFile> session = Mockito.mock(Session.class);
    Mockito.when(session.isOpen()).thenReturn(isOpenReturn);
    return session;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_23_1
#### Test Case Name: `testStaleConnection`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ftp\src\test\java\org\springframework\integration\ftp\session\SessionFactoryTests.java`)
#### Mock Object Variable Name: `sessionA`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory<FTPFile> sessionFactory = Mockito.mock(SessionFactory.class);
-    Session<FTPFile> sessionA = Mockito.mock(Session.class);
+    Session<FTPFile> sessionA = createMockSession(true);
    Session<FTPFile> sessionB = Mockito.mock(Session.class);
-    Mockito.when(sessionA.isOpen()).thenReturn(true);
    Mockito.when(sessionB.isOpen()).thenReturn(false);
    Mockito.when(sessionFactory.getSession()).thenReturn(sessionA);
    Mockito.when(sessionFactory.getSession()).thenReturn(sessionB);
    CachingSessionFactory<FTPFile> cachingFactory = new CachingSessionFactory<>(sessionFactory, 2);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@SuppressWarnings("unchecked")
void testStaleConnection() {
    SessionFactory<FTPFile> sessionFactory = Mockito.mock(SessionFactory.class);
    Session<FTPFile> sessionA = Mockito.mock(Session.class);
    Session<FTPFile> sessionB = Mockito.mock(Session.class);
    Mockito.when(sessionA.isOpen()).thenReturn(true);
    Mockito.when(sessionB.isOpen()).thenReturn(false);
    Mockito.when(sessionFactory.getSession()).thenReturn(sessionA);
    Mockito.when(sessionFactory.getSession()).thenReturn(sessionB);
    CachingSessionFactory<FTPFile> cachingFactory = new CachingSessionFactory<>(sessionFactory, 2);
    Session<FTPFile> firstSession = cachingFactory.getSession();
    Session<FTPFile> secondSession = cachingFactory.getSession();
    secondSession.close();
    Session<FTPFile> nonStaleSession = cachingFactory.getSession();
    assertThat(TestUtils.getPropertyValue(nonStaleSession, "targetSession")).isEqualTo(TestUtils.getPropertyValue(firstSession, "targetSession"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session<FTPFile> createMockSession(boolean isOpenReturn) {
    Session<FTPFile> session = Mockito.mock(Session.class);
    Mockito.when(session.isOpen()).thenReturn(isOpenReturn);
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_23_2
#### Test Case Name: `testStaleConnection`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ftp\src\test\java\org\springframework\integration\ftp\session\SessionFactoryTests.java`)
#### Mock Object Variable Name: `sessionB`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory<FTPFile> sessionFactory = Mockito.mock(SessionFactory.class);
    Session<FTPFile> sessionA = Mockito.mock(Session.class);
-    Session<FTPFile> sessionB = Mockito.mock(Session.class);
    Mockito.when(sessionA.isOpen()).thenReturn(true);
-    Mockito.when(sessionB.isOpen()).thenReturn(false);
+    Session<FTPFile> sessionB = createMockSession(false);
    Mockito.when(sessionFactory.getSession()).thenReturn(sessionA);
    Mockito.when(sessionFactory.getSession()).thenReturn(sessionB);
    CachingSessionFactory<FTPFile> cachingFactory = new CachingSessionFactory<>(sessionFactory, 2);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@SuppressWarnings("unchecked")
void testStaleConnection() {
    SessionFactory<FTPFile> sessionFactory = Mockito.mock(SessionFactory.class);
    Session<FTPFile> sessionA = Mockito.mock(Session.class);
    Session<FTPFile> sessionB = Mockito.mock(Session.class);
    Mockito.when(sessionA.isOpen()).thenReturn(true);
    Mockito.when(sessionB.isOpen()).thenReturn(false);
    Mockito.when(sessionFactory.getSession()).thenReturn(sessionA);
    Mockito.when(sessionFactory.getSession()).thenReturn(sessionB);
    CachingSessionFactory<FTPFile> cachingFactory = new CachingSessionFactory<>(sessionFactory, 2);
    Session<FTPFile> firstSession = cachingFactory.getSession();
    Session<FTPFile> secondSession = cachingFactory.getSession();
    secondSession.close();
    Session<FTPFile> nonStaleSession = cachingFactory.getSession();
    assertThat(TestUtils.getPropertyValue(nonStaleSession, "targetSession")).isEqualTo(TestUtils.getPropertyValue(firstSession, "targetSession"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session<FTPFile> createMockSession(boolean isOpenReturn) {
    Session<FTPFile> session = Mockito.mock(Session.class);
    Mockito.when(session.isOpen()).thenReturn(isOpenReturn);
    return session;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_24
- **Scope**: method level
- **Mocked Class**: `org.springframework.core.log.LogAccessor`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static LogAccessor createMockLogAccessor() {
    LogAccessor logger = mock(LogAccessor.class);
    when(logger.isInfoEnabled()).thenReturn(true);
    return logger;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_24_1
#### Test Case Name: `testExecutorChannelLoggingWithMoreThenOneSubscriber`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\channel\P2pChannelTests.java`)
#### Mock Object Variable Name: `logger`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    channel.setBeanName("executorChannel");
-    final LogAccessor logger = mock(LogAccessor.class);
-    when(logger.isInfoEnabled()).thenReturn(true);
+    final LogAccessor logger = createMockLogAccessor();
    ReflectionUtils.doWithFields(AbstractMessageChannel.class, field -> {
        if ("logger".equals(field.getName())) {
            field.setAccessible(true);
            field.set(channel, logger);
        }
    });
    channel.subscribe(mock(MessageHandler.class));
    channel.subscribe(mock(MessageHandler.class));
    verify(logger, times(2)).info(Mockito.anyString());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testExecutorChannelLoggingWithMoreThenOneSubscriber() {
    final ExecutorChannel channel = new ExecutorChannel(mock(Executor.class));
    channel.setBeanName("executorChannel");
    final LogAccessor logger = mock(LogAccessor.class);
    when(logger.isInfoEnabled()).thenReturn(true);
    ReflectionUtils.doWithFields(AbstractMessageChannel.class, field -> {
        if ("logger".equals(field.getName())) {
            field.setAccessible(true);
            field.set(channel, logger);
        }
    });
    channel.subscribe(mock(MessageHandler.class));
    channel.subscribe(mock(MessageHandler.class));
    verify(logger, times(2)).info(Mockito.anyString());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static LogAccessor createMockLogAccessor() {
    LogAccessor logger = mock(LogAccessor.class);
    when(logger.isInfoEnabled()).thenReturn(true);
    return logger;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_24_2
#### Test Case Name: `testPubSubChannelLoggingWithMoreThenOneSubscriber`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\channel\P2pChannelTests.java`)
#### Mock Object Variable Name: `logger`
<summary>Suggested Diff</summary>

```diff
@@
     final PublishSubscribeChannel channel = new PublishSubscribeChannel();
     channel.setBeanName("pubSubChannel");
-    final LogAccessor logger = mock(LogAccessor.class);
-    when(logger.isInfoEnabled()).thenReturn(true);
+    final LogAccessor logger = createMockLogAccessor();
     ReflectionUtils.doWithFields(AbstractMessageChannel.class, field -> {
         if ("logger".equals(field.getName())) {
             field.setAccessible(true);
             field.set(channel, logger);
         }
     });
     channel.subscribe(mock(MessageHandler.class));
     channel.subscribe(mock(MessageHandler.class));
     verify(logger, times(2)).info(Mockito.anyString());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testPubSubChannelLoggingWithMoreThenOneSubscriber() {
    final PublishSubscribeChannel channel = new PublishSubscribeChannel();
    channel.setBeanName("pubSubChannel");
    final LogAccessor logger = mock(LogAccessor.class);
    when(logger.isInfoEnabled()).thenReturn(true);
    ReflectionUtils.doWithFields(AbstractMessageChannel.class, field -> {
        if ("logger".equals(field.getName())) {
            field.setAccessible(true);
            field.set(channel, logger);
        }
    });
    channel.subscribe(mock(MessageHandler.class));
    channel.subscribe(mock(MessageHandler.class));
    verify(logger, times(2)).info(Mockito.anyString());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static LogAccessor createMockLogAccessor() {
    LogAccessor logger = mock(LogAccessor.class);
    when(logger.isInfoEnabled()).thenReturn(true);
    return logger;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_25
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.file.remote.session.SessionFactory<F>`
- **Test Case Count**: 5
- **MO Count**: 5

### Reusable Method
```java
private static <F> SessionFactory<F> createMockSessionFactory(Session<F> session) {
    SessionFactory<F> sf = mock(SessionFactory.class);
    when(sf.getSession()).thenReturn(session);
    return sf;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_25_1
#### Test Case Name: `testRemoteDirWithEmptyString`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\handler\FileTransferringMessageHandlerTests.java`)
#### Mock Object Variable Name: `sf`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public <F> void testRemoteDirWithEmptyString() throws Exception {
-    SessionFactory<F> sf = mock(SessionFactory.class);
    Session<F> session = mock(Session.class);
-    when(sf.getSession()).thenReturn(session);
+    SessionFactory<F> sf = createMockSessionFactory(session);
    doAnswer(invocation -> {
        String path = invocation.getArgument(1);
        assertThat(path.startsWith("/")).isFalse();
        return null;
    }).when(session).rename(Mockito.anyString(), Mockito.anyString());
    ExpressionParser parser = new SpelExpressionParser();
    FileTransferringMessageHandler<F> handler = new FileTransferringMessageHandler<F>(sf);
    handler.setRemoteDirectoryExpression(parser.parseExpression("''"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.handleMessage(new GenericMessage<String>("hello"));
    verify(session, times(1)).write(Mockito.any(InputStream.class), Mockito.anyString());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("unchecked")
@Test
public <F> void testRemoteDirWithEmptyString() throws Exception {
    SessionFactory<F> sf = mock(SessionFactory.class);
    Session<F> session = mock(Session.class);
    when(sf.getSession()).thenReturn(session);
    doAnswer(invocation -> {
        String path = invocation.getArgument(1);
        assertThat(path.startsWith("/")).isFalse();
        return null;
    }).when(session).rename(Mockito.anyString(), Mockito.anyString());
    ExpressionParser parser = new SpelExpressionParser();
    FileTransferringMessageHandler<F> handler = new FileTransferringMessageHandler<F>(sf);
    handler.setRemoteDirectoryExpression(parser.parseExpression("''"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.handleMessage(new GenericMessage<String>("hello"));
    verify(session, times(1)).write(Mockito.any(InputStream.class), Mockito.anyString());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static <F> SessionFactory<F> createMockSessionFactory(Session<F> session) {
    SessionFactory<F> sf = mock(SessionFactory.class);
    when(sf.getSession()).thenReturn(session);
    return sf;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_25_2
#### Test Case Name: `testTemporaryRemoteDir`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\handler\FileTransferringMessageHandlerTests.java`)
#### Mock Object Variable Name: `sf`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @SuppressWarnings("unchecked")
 @Test
 public <F> void testTemporaryRemoteDir() throws Exception {
-    SessionFactory<F> sf = mock(SessionFactory.class);
     Session<F> session = mock(Session.class);
     final AtomicReference<String> temporaryPath = new AtomicReference<String>();
     final AtomicReference<String> finalPath = new AtomicReference<String>();
-    when(sf.getSession()).thenReturn(session);
+    SessionFactory<F> sf = createMockSessionFactory(session);
     doAnswer(invocation -> {
         temporaryPath.set(invocation.getArgument(0));
         finalPath.set(invocation.getArgument(1));
         return null;
     }).when(session).rename(Mockito.anyString(), Mockito.anyString());
     FileTransferringMessageHandler<F> handler = new FileTransferringMessageHandler<F>(sf);
     handler.setRemoteDirectoryExpression(new LiteralExpression("foo"));
     handler.setTemporaryRemoteDirectoryExpression(new LiteralExpression("bar"));
     handler.setBeanFactory(mock(BeanFactory.class));
     handler.afterPropertiesSet();
     handler.handleMessage(new GenericMessage<String>("hello"));
     verify(session, times(1)).write(Mockito.any(InputStream.class), Mockito.anyString());
     assertThat(temporaryPath.get().substring(0, 3)).isEqualTo("bar");
     assertThat(finalPath.get().substring(0, 3)).isEqualTo("foo");
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("unchecked")
@Test
public <F> void testTemporaryRemoteDir() throws Exception {
    SessionFactory<F> sf = mock(SessionFactory.class);
    Session<F> session = mock(Session.class);
    final AtomicReference<String> temporaryPath = new AtomicReference<String>();
    final AtomicReference<String> finalPath = new AtomicReference<String>();
    when(sf.getSession()).thenReturn(session);
    doAnswer(invocation -> {
        temporaryPath.set(invocation.getArgument(0));
        finalPath.set(invocation.getArgument(1));
        return null;
    }).when(session).rename(Mockito.anyString(), Mockito.anyString());
    FileTransferringMessageHandler<F> handler = new FileTransferringMessageHandler<F>(sf);
    handler.setRemoteDirectoryExpression(new LiteralExpression("foo"));
    handler.setTemporaryRemoteDirectoryExpression(new LiteralExpression("bar"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.handleMessage(new GenericMessage<String>("hello"));
    verify(session, times(1)).write(Mockito.any(InputStream.class), Mockito.anyString());
    assertThat(temporaryPath.get().substring(0, 3)).isEqualTo("bar");
    assertThat(finalPath.get().substring(0, 3)).isEqualTo("foo");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static <F> SessionFactory<F> createMockSessionFactory(Session<F> session) {
    SessionFactory<F> sf = mock(SessionFactory.class);
    when(sf.getSession()).thenReturn(session);
    return sf;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_25_3
#### Test Case Name: `testRemoteDirWithNull`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\handler\FileTransferringMessageHandlerTests.java`)
#### Mock Object Variable Name: `sf`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public <F> void testRemoteDirWithNull() throws Exception {
-    SessionFactory<F> sf = mock(SessionFactory.class);
     Session<F> session = mock(Session.class);
-    when(sf.getSession()).thenReturn(session);
+    SessionFactory<F> sf = createMockSessionFactory(session);
     doAnswer(invocation -> {
         String path = invocation.getArgument(1);
         assertThat(path.startsWith("/")).isFalse();
         return null;
     }).when(session).rename(Mockito.anyString(), Mockito.anyString());
     ExpressionParser parser = new SpelExpressionParser();
     FileTransferringMessageHandler<F> handler = new FileTransferringMessageHandler<F>(sf);
     handler.setRemoteDirectoryExpression(parser.parseExpression("headers['path']"));
     handler.setBeanFactory(mock(BeanFactory.class));
     handler.afterPropertiesSet();
     Message<?> message = MessageBuilder.withPayload("hello").setHeader("path", null).build();
     handler.handleMessage(message);
     verify(session, times(1)).write(Mockito.any(InputStream.class), Mockito.anyString());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("unchecked")
@Test
public <F> void testRemoteDirWithNull() throws Exception {
    SessionFactory<F> sf = mock(SessionFactory.class);
    Session<F> session = mock(Session.class);
    when(sf.getSession()).thenReturn(session);
    doAnswer(invocation -> {
        String path = invocation.getArgument(1);
        assertThat(path.startsWith("/")).isFalse();
        return null;
    }).when(session).rename(Mockito.anyString(), Mockito.anyString());
    ExpressionParser parser = new SpelExpressionParser();
    FileTransferringMessageHandler<F> handler = new FileTransferringMessageHandler<F>(sf);
    handler.setRemoteDirectoryExpression(parser.parseExpression("headers['path']"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    Message<?> message = MessageBuilder.withPayload("hello").setHeader("path", null).build();
    handler.handleMessage(message);
    verify(session, times(1)).write(Mockito.any(InputStream.class), Mockito.anyString());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static <F> SessionFactory<F> createMockSessionFactory(Session<F> session) {
    SessionFactory<F> sf = mock(SessionFactory.class);
    when(sf.getSession()).thenReturn(session);
    return sf;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_25_4
#### Test Case Name: `testEmptyTemporaryFileSuffixCannotBeNull`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\handler\FileTransferringMessageHandlerTests.java`)
#### Mock Object Variable Name: `sf`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @SuppressWarnings("unchecked")
 @Test
 public <F> void testEmptyTemporaryFileSuffixCannotBeNull() throws Exception {
-    SessionFactory<F> sf = mock(SessionFactory.class);
     Session<F> session = mock(Session.class);
-    when(sf.getSession()).thenReturn(session);
+    SessionFactory<F> sf = createMockSessionFactory(session);
     FileTransferringMessageHandler<F> handler = new FileTransferringMessageHandler<F>(sf);
     handler.setBeanFactory(mock(BeanFactory.class));
     handler.setRemoteDirectoryExpressionString("headers['path']");
     assertThatIllegalArgumentException().isThrownBy(() -> handler.setTemporaryFileSuffix(null));
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("unchecked")
@Test
public <F> void testEmptyTemporaryFileSuffixCannotBeNull() throws Exception {
    SessionFactory<F> sf = mock(SessionFactory.class);
    Session<F> session = mock(Session.class);
    when(sf.getSession()).thenReturn(session);
    FileTransferringMessageHandler<F> handler = new FileTransferringMessageHandler<F>(sf);
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.setRemoteDirectoryExpressionString("headers['path']");
    assertThatIllegalArgumentException().isThrownBy(() -> handler.setTemporaryFileSuffix(null));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static <F> SessionFactory<F> createMockSessionFactory(Session<F> session) {
    SessionFactory<F> sf = mock(SessionFactory.class);
    when(sf.getSession()).thenReturn(session);
    return sf;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_25_5
#### Test Case Name: `testUseTemporaryFileNameFalse`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\handler\FileTransferringMessageHandlerTests.java`)
#### Mock Object Variable Name: `sf`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public <F> void testUseTemporaryFileNameFalse() throws Exception {
-    SessionFactory<F> sf = mock(SessionFactory.class);
    Session<F> session = mock(Session.class);
-    when(sf.getSession()).thenReturn(session);
+    SessionFactory<F> sf = createMockSessionFactory(session);
    ExpressionParser parser = new SpelExpressionParser();
    FileTransferringMessageHandler<F> handler = new FileTransferringMessageHandler<F>(sf);
    handler.setRemoteDirectoryExpression(parser.parseExpression("headers['path']"));
    handler.setUseTemporaryFileName(false);
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    Message<?> message = MessageBuilder.withPayload("hello").setHeader("path", null).build();
    handler.handleMessage(message);
    verify(session, times(1)).write(Mockito.any(InputStream.class), Mockito.anyString());
    verify(session, times(0)).rename(Mockito.anyString(), Mockito.anyString());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("unchecked")
@Test
public <F> void testUseTemporaryFileNameFalse() throws Exception {
    SessionFactory<F> sf = mock(SessionFactory.class);
    Session<F> session = mock(Session.class);
    when(sf.getSession()).thenReturn(session);
    ExpressionParser parser = new SpelExpressionParser();
    FileTransferringMessageHandler<F> handler = new FileTransferringMessageHandler<F>(sf);
    handler.setRemoteDirectoryExpression(parser.parseExpression("headers['path']"));
    handler.setUseTemporaryFileName(false);
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    Message<?> message = MessageBuilder.withPayload("hello").setHeader("path", null).build();
    handler.handleMessage(message);
    verify(session, times(1)).write(Mockito.any(InputStream.class), Mockito.anyString());
    verify(session, times(0)).rename(Mockito.anyString(), Mockito.anyString());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static <F> SessionFactory<F> createMockSessionFactory(Session<F> session) {
    SessionFactory<F> sf = mock(SessionFactory.class);
    when(sf.getSession()).thenReturn(session);
    return sf;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_26
- **Scope**: method level
- **Mocked Class**: `org.eclipse.paho.client.mqttv3.MqttAsyncClient`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static MqttAsyncClient createMockMqttAsyncClient(IMqttToken connectToken, IMqttToken subscribeToken) {
    MqttAsyncClient client = mock(MqttAsyncClient.class);
    given(client.isConnected()).willReturn(true);
    willReturn(connectToken).given(client).connect(any(MqttConnectOptions.class));
    willReturn(subscribeToken).given(client).subscribe(any(String[].class), any(int[].class), any());
    return client;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_26_1
#### Test Case Name: `testSubscribeFailure`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mqtt\src\test\java\org\springframework\integration\mqtt\MqttAdapterTests.java`)
#### Mock Object Variable Name: `client`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    factory = spy(factory);
-    final MqttAsyncClient client = mock(MqttAsyncClient.class);
-    willReturn(client).given(factory).getAsyncClientInstance(anyString(), anyString());
-    given(client.isConnected()).willReturn(true);
-    willReturn(alwaysComplete).given(client).connect(any(MqttConnectOptions.class));
    IMqttToken token = mock(IMqttToken.class);
    given(token.getGrantedQos()).willReturn(new int[] { 0x80 });
-    willReturn(token).given(client).subscribe(any(String[].class), any(int[].class), any());
+    final MqttAsyncClient client = createMockMqttAsyncClient(alwaysComplete, token);
+    willReturn(client).given(factory).getAsyncClientInstance(anyString(), anyString());
    MqttPahoMessageDrivenChannelAdapter adapter = new MqttPahoMessageDrivenChannelAdapter("foo", "bar", factory, "baz", "fix");
    AtomicReference<Method> method = new AtomicReference<>();
    ReflectionUtils.doWithMethods(MqttPahoMessageDrivenChannelAdapter.class, m -> {
        m.setAccessible(true);
        method.set(m);
    }, m -> m.getName().equals("connect"));
    assertThat(method.get()).isNotNull();
    method.get().invoke(adapter);
    ReflectionUtils.doWithMethods(MqttPahoMessageDrivenChannelAdapter.class, m -> {
        m.setAccessible(true);
        method.set(m);
    }, m -> m.getName().equals("subscribe"));
    assertThat(method.get()).isNotNull();
    ApplicationEventPublisher eventPublisher = mock(ApplicationEventPublisher.class);
    adapter.setApplicationEventPublisher(eventPublisher);
    method.get().invoke(adapter);
    verify(eventPublisher).publishEvent(any(MqttConnectionFailedEvent.class));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testSubscribeFailure() throws Exception {
    DefaultMqttPahoClientFactory factory = new DefaultMqttPahoClientFactory();
    MqttConnectOptions connectOptions = new MqttConnectOptions();
    connectOptions.setCleanSession(false);
    connectOptions.setConnectionTimeout(23);
    connectOptions.setKeepAliveInterval(45);
    connectOptions.setPassword("pass".toCharArray());
    MemoryPersistence persistence = new MemoryPersistence();
    factory.setPersistence(persistence);
    final SocketFactory socketFactory = SocketFactory.getDefault();
    connectOptions.setSocketFactory(socketFactory);
    final Properties props = new Properties();
    connectOptions.setSSLProperties(props);
    connectOptions.setUserName("user");
    connectOptions.setWill("foo", "bar".getBytes(), 2, true);
    factory = spy(factory);
    final MqttAsyncClient client = mock(MqttAsyncClient.class);
    willReturn(client).given(factory).getAsyncClientInstance(anyString(), anyString());
    given(client.isConnected()).willReturn(true);
    willReturn(alwaysComplete).given(client).connect(any(MqttConnectOptions.class));
    IMqttToken token = mock(IMqttToken.class);
    given(token.getGrantedQos()).willReturn(new int[] { 0x80 });
    willReturn(token).given(client).subscribe(any(String[].class), any(int[].class), any());
    MqttPahoMessageDrivenChannelAdapter adapter = new MqttPahoMessageDrivenChannelAdapter("foo", "bar", factory, "baz", "fix");
    AtomicReference<Method> method = new AtomicReference<>();
    ReflectionUtils.doWithMethods(MqttPahoMessageDrivenChannelAdapter.class, m -> {
        m.setAccessible(true);
        method.set(m);
    }, m -> m.getName().equals("connect"));
    assertThat(method.get()).isNotNull();
    method.get().invoke(adapter);
    ReflectionUtils.doWithMethods(MqttPahoMessageDrivenChannelAdapter.class, m -> {
        m.setAccessible(true);
        method.set(m);
    }, m -> m.getName().equals("subscribe"));
    assertThat(method.get()).isNotNull();
    ApplicationEventPublisher eventPublisher = mock(ApplicationEventPublisher.class);
    adapter.setApplicationEventPublisher(eventPublisher);
    method.get().invoke(adapter);
    verify(eventPublisher).publishEvent(any(MqttConnectionFailedEvent.class));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static MqttAsyncClient createMockMqttAsyncClient(IMqttToken connectToken, IMqttToken subscribeToken) {
    MqttAsyncClient client = mock(MqttAsyncClient.class);
    given(client.isConnected()).willReturn(true);
    willReturn(connectToken).given(client).connect(any(MqttConnectOptions.class));
    willReturn(subscribeToken).given(client).subscribe(any(String[].class), any(int[].class), any());
    return client;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_26_2
#### Test Case Name: `testDifferentQos`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mqtt\src\test\java\org\springframework\integration\mqtt\MqttAdapterTests.java`)
#### Mock Object Variable Name: `client`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    factory = spy(factory);
-    final MqttAsyncClient client = mock(MqttAsyncClient.class);
-    willReturn(client).given(factory).getAsyncClientInstance(anyString(), anyString());
-    given(client.isConnected()).willReturn(true);
-    willReturn(alwaysComplete).given(client).connect(any(MqttConnectOptions.class));
    IMqttToken token = mock(IMqttToken.class);
    given(token.getGrantedQos()).willReturn(new int[] { 2, 0 });
-    willReturn(token).given(client).subscribe(any(String[].class), any(int[].class), any());
+    final MqttAsyncClient client = createMockMqttAsyncClient(alwaysComplete, token);
+    willReturn(client).given(factory).getAsyncClientInstance(anyString(), anyString());
    MqttPahoMessageDrivenChannelAdapter adapter = new MqttPahoMessageDrivenChannelAdapter("tcp://mqtt.host", "bar", factory, "baz", "fix");
    AtomicReference<Method> method = new AtomicReference<>();
    ReflectionUtils.doWithMethods(MqttPahoMessageDrivenChannelAdapter.class, m -> {
        m.setAccessible(true);
        method.set(m);
    }, m -> m.getName().equals("connect"));
    assertThat(method.get()).isNotNull();
    method.get().invoke(adapter);
    ReflectionUtils.doWithMethods(MqttPahoMessageDrivenChannelAdapter.class, m -> {
        m.setAccessible(true);
        method.set(m);
    }, m -> m.getName().equals("subscribe"));
    assertThat(method.get()).isNotNull();
    LogAccessor logger = spy(TestUtils.getPropertyValue(adapter, "logger", LogAccessor.class));
    new DirectFieldAccessor(adapter).setPropertyValue("logger", logger);
    given(logger.isWarnEnabled()).willReturn(true);
    method.get().invoke(adapter);
    verify(logger, atLeastOnce()).warn(ArgumentMatchers.<Supplier<? extends CharSequence>>argThat(logMessage -> logMessage.get().equals("Granted QOS different to Requested QOS; topics: [baz, fix] " + "requested: [1, 1] granted: [2, 0]")));
    new DirectFieldAccessor(adapter).setPropertyValue("running", Boolean.TRUE);
    adapter.stop();
    verify(client).disconnectForcibly(5_000L);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testDifferentQos() throws Exception {
    DefaultMqttPahoClientFactory factory = new DefaultMqttPahoClientFactory();
    MqttConnectOptions connectOptions = new MqttConnectOptions();
    connectOptions.setCleanSession(false);
    connectOptions.setConnectionTimeout(23);
    connectOptions.setKeepAliveInterval(45);
    connectOptions.setPassword("pass".toCharArray());
    MemoryPersistence persistence = new MemoryPersistence();
    factory.setPersistence(persistence);
    final SocketFactory socketFactory = SocketFactory.getDefault();
    connectOptions.setSocketFactory(socketFactory);
    final Properties props = new Properties();
    connectOptions.setSSLProperties(props);
    connectOptions.setUserName("user");
    connectOptions.setWill("foo", "bar".getBytes(), 2, true);
    factory = spy(factory);
    final MqttAsyncClient client = mock(MqttAsyncClient.class);
    willReturn(client).given(factory).getAsyncClientInstance(anyString(), anyString());
    given(client.isConnected()).willReturn(true);
    willReturn(alwaysComplete).given(client).connect(any(MqttConnectOptions.class));
    IMqttToken token = mock(IMqttToken.class);
    given(token.getGrantedQos()).willReturn(new int[] { 2, 0 });
    willReturn(token).given(client).subscribe(any(String[].class), any(int[].class), any());
    MqttPahoMessageDrivenChannelAdapter adapter = new MqttPahoMessageDrivenChannelAdapter("tcp://mqtt.host", "bar", factory, "baz", "fix");
    AtomicReference<Method> method = new AtomicReference<>();
    ReflectionUtils.doWithMethods(MqttPahoMessageDrivenChannelAdapter.class, m -> {
        m.setAccessible(true);
        method.set(m);
    }, m -> m.getName().equals("connect"));
    assertThat(method.get()).isNotNull();
    method.get().invoke(adapter);
    ReflectionUtils.doWithMethods(MqttPahoMessageDrivenChannelAdapter.class, m -> {
        m.setAccessible(true);
        method.set(m);
    }, m -> m.getName().equals("subscribe"));
    assertThat(method.get()).isNotNull();
    LogAccessor logger = spy(TestUtils.getPropertyValue(adapter, "logger", LogAccessor.class));
    new DirectFieldAccessor(adapter).setPropertyValue("logger", logger);
    given(logger.isWarnEnabled()).willReturn(true);
    method.get().invoke(adapter);
    verify(logger, atLeastOnce()).warn(ArgumentMatchers.<Supplier<? extends CharSequence>>argThat(logMessage -> logMessage.get().equals("Granted QOS different to Requested QOS; topics: [baz, fix] " + "requested: [1, 1] granted: [2, 0]")));
    new DirectFieldAccessor(adapter).setPropertyValue("running", Boolean.TRUE);
    adapter.stop();
    verify(client).disconnectForcibly(5_000L);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static MqttAsyncClient createMockMqttAsyncClient(IMqttToken connectToken, IMqttToken subscribeToken) {
    MqttAsyncClient client = mock(MqttAsyncClient.class);
    given(client.isConnected()).willReturn(true);
    willReturn(connectToken).given(client).connect(any(MqttConnectOptions.class));
    willReturn(subscribeToken).given(client).subscribe(any(String[].class), any(int[].class), any());
    return client;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_27
- **Scope**: method level
- **Mocked Class**: `javax.net.SocketFactory`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static SocketFactory createMockSocketFactory(Socket socket) {
    SocketFactory factory = Mockito.mock(SocketFactory.class);
    when(factory.createSocket()).thenReturn(socket);
    return factory;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_27_1
#### Test Case Name: `testNetClient`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\SocketSupportTests.java`)
#### Mock Object Variable Name: `factory`
<summary>Suggested Diff</summary>

```diff
@@
     TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
-    SocketFactory factory = Mockito.mock(SocketFactory.class);
     when(factorySupport.getSocketFactory()).thenReturn(factory);
     Socket socket = mock(Socket.class);
     InputStream is = mock(InputStream.class);
     when(is.read()).thenReturn(-1);
     when(socket.getInputStream()).thenReturn(is);
     InetAddress inetAddress = InetAddress.getLocalHost();
     when(socket.getInetAddress()).thenReturn(inetAddress);
-    when(factory.createSocket()).thenReturn(socket);
+    SocketFactory factory = createMockSocketFactory(socket);
     TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);
     TcpNetClientConnectionFactory connectionFactory = new TcpNetClientConnectionFactory("x", 0);
     connectionFactory.setTcpSocketFactorySupport(factorySupport);
     connectionFactory.setTcpSocketSupport(socketSupport);
     connectionFactory.start();
     connectionFactory.getConnection();
     verify(socketSupport).postProcessSocket(socket);
     connectionFactory.stop();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testNetClient() throws Exception {
    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
    SocketFactory factory = Mockito.mock(SocketFactory.class);
    when(factorySupport.getSocketFactory()).thenReturn(factory);
    Socket socket = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
    when(socket.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
    when(socket.getInetAddress()).thenReturn(inetAddress);
    when(factory.createSocket()).thenReturn(socket);
    TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);
    TcpNetClientConnectionFactory connectionFactory = new TcpNetClientConnectionFactory("x", 0);
    connectionFactory.setTcpSocketFactorySupport(factorySupport);
    connectionFactory.setTcpSocketSupport(socketSupport);
    connectionFactory.start();
    connectionFactory.getConnection();
    verify(socketSupport).postProcessSocket(socket);
    connectionFactory.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SocketFactory createMockSocketFactory(Socket socket) {
    SocketFactory factory = Mockito.mock(SocketFactory.class);
    when(factory.createSocket()).thenReturn(socket);
    return factory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_27_2
#### Test Case Name: `testNetClientSocketTimeout`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\SocketSupportTests.java`)
#### Mock Object Variable Name: `factory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
-    SocketFactory factory = Mockito.mock(SocketFactory.class);
+    SocketFactory factory = createMockSocketFactory(socket);
    when(factorySupport.getSocketFactory()).thenReturn(factory);
    Socket socket = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
    when(socket.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
    when(socket.getInetAddress()).thenReturn(inetAddress);
-    when(factory.createSocket()).thenReturn(socket);
    doThrow(new SocketTimeoutException()).when(socket).connect(any(), eq(1000));
    TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);
    TcpNetClientConnectionFactory connectionFactory = new TcpNetClientConnectionFactory("x", 0);
    connectionFactory.setConnectTimeout(1);
    connectionFactory.setTcpSocketFactorySupport(factorySupport);
    connectionFactory.setTcpSocketSupport(socketSupport);
    connectionFactory.start();
    assertThatThrownBy(connectionFactory::getConnection).isInstanceOf(UncheckedIOException.class).hasCauseInstanceOf(SocketTimeoutException.class);
    connectionFactory.stop();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testNetClientSocketTimeout() throws Exception {
    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
    SocketFactory factory = Mockito.mock(SocketFactory.class);
    when(factorySupport.getSocketFactory()).thenReturn(factory);
    Socket socket = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
    when(socket.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
    when(socket.getInetAddress()).thenReturn(inetAddress);
    when(factory.createSocket()).thenReturn(socket);
    doThrow(new SocketTimeoutException()).when(socket).connect(any(), eq(1000));
    TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);
    TcpNetClientConnectionFactory connectionFactory = new TcpNetClientConnectionFactory("x", 0);
    connectionFactory.setConnectTimeout(1);
    connectionFactory.setTcpSocketFactorySupport(factorySupport);
    connectionFactory.setTcpSocketSupport(socketSupport);
    connectionFactory.start();
    assertThatThrownBy(connectionFactory::getConnection).isInstanceOf(UncheckedIOException.class).hasCauseInstanceOf(SocketTimeoutException.class);
    connectionFactory.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SocketFactory createMockSocketFactory(Socket socket) {
    SocketFactory factory = Mockito.mock(SocketFactory.class);
    when(factory.createSocket()).thenReturn(socket);
    return factory;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_28
- **Scope**: method level
- **Mocked Class**: `org.springframework.messaging.MessageHandler`
- **Test Case Count**: 9
- **MO Count**: 9

### Reusable Method
```java
// === Declare in class scope ===
private MessageHandler handler;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    handler = mock(MessageHandler.class);
}

// === Replace local variable in test with ===
handler;

```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_28_1
#### Test Case Name: `testWithServiceAnnotatedMethod`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\gateway\GatewayInterfaceTests.java`)
#### Mock Object Variable Name: `handler`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testWithServiceAnnotatedMethod() {
     ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext("GatewayInterfaceTests-context.xml", getClass());
     DirectChannel channel = ac.getBean("requestChannelBar", DirectChannel.class);
-    MessageHandler handler = mock(MessageHandler.class);
+    // removed local mock; replaced with global field `handler`
     channel.subscribe(handler);
     Bar bar = ac.getBean(Bar.class);
     bar.bar("hello");
     verify(handler, times(1)).handleMessage(Mockito.any(Message.class));
     ac.close();
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testWithServiceAnnotatedMethod() {
    ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext("GatewayInterfaceTests-context.xml", getClass());
    DirectChannel channel = ac.getBean("requestChannelBar", DirectChannel.class);
    MessageHandler handler = mock(MessageHandler.class);
    channel.subscribe(handler);
    Bar bar = ac.getBean(Bar.class);
    bar.bar("hello");
    verify(handler, times(1)).handleMessage(Mockito.any(Message.class));
    ac.close();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MessageHandler handler;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    handler = mock(MessageHandler.class);
}

// === Replace local variable in test with ===
handler;

```
</details>

---
#### Test Case ID #spring-integration_Test_28_2
#### Test Case Name: `testWithServiceCastAsSuperclassAnnotatedMethod`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\gateway\GatewayInterfaceTests.java`)
#### Mock Object Variable Name: `handler`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testWithServiceCastAsSuperclassAnnotatedMethod() {
     ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext("GatewayInterfaceTests-context.xml", getClass());
     DirectChannel channel = ac.getBean("requestChannelFoo", DirectChannel.class);
-    MessageHandler handler = mock(MessageHandler.class);
+    // removed local mock; replaced with global field `handler`
     channel.subscribe(handler);
     Foo foo = ac.getBean(Foo.class);
     foo.foo("hello");
     verify(handler, times(1)).handleMessage(Mockito.any(Message.class));
     ac.close();
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testWithServiceCastAsSuperclassAnnotatedMethod() {
    ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext("GatewayInterfaceTests-context.xml", getClass());
    DirectChannel channel = ac.getBean("requestChannelFoo", DirectChannel.class);
    MessageHandler handler = mock(MessageHandler.class);
    channel.subscribe(handler);
    Foo foo = ac.getBean(Foo.class);
    foo.foo("hello");
    verify(handler, times(1)).handleMessage(Mockito.any(Message.class));
    ac.close();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MessageHandler handler;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    handler = mock(MessageHandler.class);
}

// === Replace local variable in test with ===
handler;

```
</details>

---
#### Test Case ID #spring-integration_Test_28_3
#### Test Case Name: `testWithServiceCastAsSuperclassUnAnnotatedMethod`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\gateway\GatewayInterfaceTests.java`)
#### Mock Object Variable Name: `handler`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testWithServiceCastAsSuperclassUnAnnotatedMethod() {
     ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext("GatewayInterfaceTests-context.xml", getClass());
     DirectChannel channel = ac.getBean("requestChannelBaz", DirectChannel.class);
-    MessageHandler handler = mock(MessageHandler.class);
+    // removed local mock; replaced with global field `handler`
     channel.subscribe(handler);
     Foo foo = ac.getBean(Foo.class);
     foo.baz("hello");
     verify(handler, times(1)).handleMessage(Mockito.any(Message.class));
     ac.close();
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testWithServiceCastAsSuperclassUnAnnotatedMethod() {
    ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext("GatewayInterfaceTests-context.xml", getClass());
    DirectChannel channel = ac.getBean("requestChannelBaz", DirectChannel.class);
    MessageHandler handler = mock(MessageHandler.class);
    channel.subscribe(handler);
    Foo foo = ac.getBean(Foo.class);
    foo.baz("hello");
    verify(handler, times(1)).handleMessage(Mockito.any(Message.class));
    ac.close();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MessageHandler handler;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    handler = mock(MessageHandler.class);
}

// === Replace local variable in test with ===
handler;

```
</details>

---
#### Test Case ID #spring-integration_Test_28_4
#### Test Case Name: `testWithServiceHashcode`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\gateway\GatewayInterfaceTests.java`)
#### Mock Object Variable Name: `handler`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testWithServiceHashcode() {
     ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext("GatewayInterfaceTests-context.xml", getClass());
     DirectChannel channel = ac.getBean("requestChannelBaz", DirectChannel.class);
-    MessageHandler handler = mock(MessageHandler.class);
+    // removed local mock; replaced with global field `handler`
     channel.subscribe(handler);
     Bar bar = ac.getBean(Bar.class);
     assertThat(ac.getBean(Bar.class).hashCode()).isEqualTo(bar.hashCode());
     verify(handler, times(0)).handleMessage(Mockito.any(Message.class));
     ac.close();
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testWithServiceHashcode() {
    ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext("GatewayInterfaceTests-context.xml", getClass());
    DirectChannel channel = ac.getBean("requestChannelBaz", DirectChannel.class);
    MessageHandler handler = mock(MessageHandler.class);
    channel.subscribe(handler);
    Bar bar = ac.getBean(Bar.class);
    assertThat(ac.getBean(Bar.class).hashCode()).isEqualTo(bar.hashCode());
    verify(handler, times(0)).handleMessage(Mockito.any(Message.class));
    ac.close();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MessageHandler handler;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    handler = mock(MessageHandler.class);
}

// === Replace local variable in test with ===
handler;

```
</details>

---
#### Test Case ID #spring-integration_Test_28_5
#### Test Case Name: `testWithServiceToString`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\gateway\GatewayInterfaceTests.java`)
#### Mock Object Variable Name: `handler`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testWithServiceToString() {
     ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext("GatewayInterfaceTests-context.xml", getClass());
     DirectChannel channel = ac.getBean("requestChannelBaz", DirectChannel.class);
-    MessageHandler handler = mock(MessageHandler.class);
+    // removed local mock; replaced with global field `handler`
     channel.subscribe(handler);
     Bar bar = ac.getBean(Bar.class);
     bar.toString();
-    verify(handler, times(0)).handleMessage(Mockito.any(Message.class));
+    verify(handler, times(0)).handleMessage(Mockito.any(Message.class));
     ac.close();
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testWithServiceToString() {
    ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext("GatewayInterfaceTests-context.xml", getClass());
    DirectChannel channel = ac.getBean("requestChannelBaz", DirectChannel.class);
    MessageHandler handler = mock(MessageHandler.class);
    channel.subscribe(handler);
    Bar bar = ac.getBean(Bar.class);
    bar.toString();
    verify(handler, times(0)).handleMessage(Mockito.any(Message.class));
    ac.close();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MessageHandler handler;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    handler = mock(MessageHandler.class);
}

// === Replace local variable in test with ===
handler;

```
</details>

---
#### Test Case ID #spring-integration_Test_28_6
#### Test Case Name: `testWithServiceEquals`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\gateway\GatewayInterfaceTests.java`)
#### Mock Object Variable Name: `handler`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testWithServiceEquals() {
     ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext("GatewayInterfaceTests-context.xml", getClass());
     DirectChannel channel = ac.getBean("requestChannelBaz", DirectChannel.class);
-    MessageHandler handler = mock(MessageHandler.class);
+    // removed local mock; replaced with global field `handler`
     channel.subscribe(handler);
     Bar bar = ac.getBean(Bar.class);
     assertThat(ac.getBean(Bar.class)).isSameAs(bar);
     GatewayProxyFactoryBean<Bar> fb = new GatewayProxyFactoryBean<>(Bar.class);
     DefaultListableBeanFactory bf = new DefaultListableBeanFactory();
     bf.registerSingleton("requestChannelBar", channel);
     bf.registerSingleton("requestChannelBaz", channel);
     bf.registerSingleton("requestChannelFoo", channel);
     fb.setBeanFactory(bf);
     fb.afterPropertiesSet();
     assertThat(fb.getObject()).isNotSameAs(bar);
-    verify(handler, times(0)).handleMessage(Mockito.any(Message.class));
+    verify(handler, times(0)).handleMessage(Mockito.any(Message.class));
     ac.close();
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testWithServiceEquals() {
    ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext("GatewayInterfaceTests-context.xml", getClass());
    DirectChannel channel = ac.getBean("requestChannelBaz", DirectChannel.class);
    MessageHandler handler = mock(MessageHandler.class);
    channel.subscribe(handler);
    Bar bar = ac.getBean(Bar.class);
    assertThat(ac.getBean(Bar.class)).isSameAs(bar);
    GatewayProxyFactoryBean<Bar> fb = new GatewayProxyFactoryBean<>(Bar.class);
    DefaultListableBeanFactory bf = new DefaultListableBeanFactory();
    bf.registerSingleton("requestChannelBar", channel);
    bf.registerSingleton("requestChannelBaz", channel);
    bf.registerSingleton("requestChannelFoo", channel);
    fb.setBeanFactory(bf);
    fb.afterPropertiesSet();
    assertThat(fb.getObject()).isNotSameAs(bar);
    verify(handler, times(0)).handleMessage(Mockito.any(Message.class));
    ac.close();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MessageHandler handler;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    handler = mock(MessageHandler.class);
}

// === Replace local variable in test with ===
handler;

```
</details>

---
#### Test Case ID #spring-integration_Test_28_7
#### Test Case Name: `testWithServiceGetClass`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\gateway\GatewayInterfaceTests.java`)
#### Mock Object Variable Name: `handler`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testWithServiceGetClass() {
     ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext("GatewayInterfaceTests-context.xml", getClass());
     DirectChannel channel = ac.getBean("requestChannelBaz", DirectChannel.class);
-    MessageHandler handler = mock(MessageHandler.class);
+    // removed local mock; replaced with global field `handler`
     channel.subscribe(handler);
     Bar bar = ac.getBean(Bar.class);
     bar.getClass();
-    verify(handler, times(0)).handleMessage(Mockito.any(Message.class));
+    verify(handler, times(0)).handleMessage(Mockito.any(Message.class));
     ac.close();
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testWithServiceGetClass() {
    ConfigurableApplicationContext ac = new ClassPathXmlApplicationContext("GatewayInterfaceTests-context.xml", getClass());
    DirectChannel channel = ac.getBean("requestChannelBaz", DirectChannel.class);
    MessageHandler handler = mock(MessageHandler.class);
    channel.subscribe(handler);
    Bar bar = ac.getBean(Bar.class);
    bar.getClass();
    verify(handler, times(0)).handleMessage(Mockito.any(Message.class));
    ac.close();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MessageHandler handler;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    handler = mock(MessageHandler.class);
}

// === Replace local variable in test with ===
handler;

```
</details>

---
#### Test Case ID #spring-integration_Test_28_8
#### Test Case Name: `testIgnoredHeader`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\gateway\GatewayInterfaceTests.java`)
#### Mock Object Variable Name: `messageHandler`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 @SuppressWarnings("unchecked")
 public void testIgnoredHeader() {
-    MessageHandler messageHandler = mock(MessageHandler.class);
+    // removed local mock; replaced with global field `handler`
     ((SubscribableChannel) this.errorChannel).subscribe(handler);
     this.ignoredHeaderGateway.service("foo", "theHeaderValue");
     ArgumentCaptor<Message<?>> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
-    verify(messageHandler).handleMessage(messageArgumentCaptor.capture());
+    verify(handler).handleMessage(messageArgumentCaptor.capture());
     Message<?> message = messageArgumentCaptor.getValue();
     assertThat(message.getHeaders().containsKey(IGNORE_HEADER)).isFalse();
-    ((SubscribableChannel) this.errorChannel).unsubscribe(messageHandler);
+    ((SubscribableChannel) this.errorChannel).unsubscribe(handler);
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@SuppressWarnings("unchecked")
public void testIgnoredHeader() {
    MessageHandler messageHandler = mock(MessageHandler.class);
    ((SubscribableChannel) this.errorChannel).subscribe(messageHandler);
    this.ignoredHeaderGateway.service("foo", "theHeaderValue");
    ArgumentCaptor<Message<?>> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
    verify(messageHandler).handleMessage(messageArgumentCaptor.capture());
    Message<?> message = messageArgumentCaptor.getValue();
    assertThat(message.getHeaders().containsKey(IGNORE_HEADER)).isFalse();
    ((SubscribableChannel) this.errorChannel).unsubscribe(messageHandler);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MessageHandler handler;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    handler = mock(MessageHandler.class);
}

// === Replace local variable in test with ===
handler;

```
</details>

---
#### Test Case ID #spring-integration_Test_28_9
#### Test Case Name: `primaryMarkerWins`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\gateway\GatewayInterfaceTests.java`)
#### Mock Object Variable Name: `messageHandler`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 @SuppressWarnings("unchecked")
 void primaryMarkerWins() {
     PrimaryGateway primaryGateway = this.beanFactory.getBean(PrimaryGateway.class);
     assertThat(AopUtils.isAopProxy(primaryGateway)).isTrue();
-    MessageHandler messageHandler = mock(MessageHandler.class);
+    // removed local mock; replaced with global field `handler`
     ((SubscribableChannel) this.errorChannel).subscribe(handler);
     primaryGateway.testGateway("test data");
     ArgumentCaptor<Message<?>> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
-    verify(messageHandler).handleMessage(messageArgumentCaptor.capture());
+    verify(handler).handleMessage(messageArgumentCaptor.capture());
     Message<?> receive = messageArgumentCaptor.getValue();
     assertThat(receive).isNotNull().extracting(Message::getPayload).isEqualTo("test data");
     PrimaryGateway notPrimaryGateway = this.beanFactory.getBean("notPrimaryGatewayInstance", PrimaryGateway.class);
     assertThat(AopUtils.isAopProxy(notPrimaryGateway)).isFalse();
-    ((SubscribableChannel) this.errorChannel).unsubscribe(messageHandler);
+    ((SubscribableChannel) this.errorChannel).unsubscribe(handler);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@SuppressWarnings("unchecked")
void primaryMarkerWins() {
    PrimaryGateway primaryGateway = this.beanFactory.getBean(PrimaryGateway.class);
    assertThat(AopUtils.isAopProxy(primaryGateway)).isTrue();
    MessageHandler messageHandler = mock(MessageHandler.class);
    ((SubscribableChannel) this.errorChannel).subscribe(messageHandler);
    primaryGateway.testGateway("test data");
    ArgumentCaptor<Message<?>> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);
    verify(messageHandler).handleMessage(messageArgumentCaptor.capture());
    Message<?> receive = messageArgumentCaptor.getValue();
    assertThat(receive).isNotNull().extracting(Message::getPayload).isEqualTo("test data");
    PrimaryGateway notPrimaryGateway = this.beanFactory.getBean("notPrimaryGatewayInstance", PrimaryGateway.class);
    assertThat(AopUtils.isAopProxy(notPrimaryGateway)).isFalse();
    ((SubscribableChannel) this.errorChannel).unsubscribe(messageHandler);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MessageHandler handler;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    handler = mock(MessageHandler.class);
}

// === Replace local variable in test with ===
handler;

```
</details>

---
## Mock Clone Instance #spring-integration_MCI_29
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.ws.SoapHeaderMapper`
- **Test Case Count**: 4
- **MO Count**: 4

### Reusable Method
```java
// === Declare in class scope ===
private SoapHeaderMapper headerMapper;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    headerMapper = mock(SoapHeaderMapper.class);
}

// === Replace local variable in test with ===
headerMapper

```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_29_1
#### Test Case Name: `marshallingOutbound`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ws\src\test\java\org\springframework\integration\ws\dsl\WsDslTests.java`)
#### Mock Object Variable Name: `headerMapper`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void marshallingOutbound() {
     DestinationProvider destinationProvider = mock(DestinationProvider.class);
     Marshaller marshaller = mock(Marshaller.class);
     Unmarshaller unmarshaller = mock(Unmarshaller.class);
     WebServiceMessageFactory messageFactory = mock(WebServiceMessageFactory.class);
     FaultMessageResolver faultMessageResolver = mock(FaultMessageResolver.class);
-    SoapHeaderMapper headerMapper = mock(SoapHeaderMapper.class);
+    // removed local mock; replaced with global field `headerMapper`
     ClientInterceptor interceptor = mock(ClientInterceptor.class);
     WebServiceMessageSender messageSender = mock(WebServiceMessageSender.class);
     WebServiceMessageCallback requestCallback = msg -> {
     };
     Map<String, Expression> uriVariableExpressions = new HashMap<>();
     uriVariableExpressions.put("foo", new LiteralExpression("bar"));
     MarshallingWebServiceOutboundGateway gateway = Ws.marshallingOutboundGateway().destinationProvider(destinationProvider).marshaller(marshaller).unmarshaller(unmarshaller).messageFactory(messageFactory).faultMessageResolver(faultMessageResolver).headerMapper(headerMapper).ignoreEmptyResponses(true).interceptors(interceptor).messageSenders(messageSender).requestCallback(requestCallback).uriVariableExpressions(uriVariableExpressions).getObject();
     assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.marshaller")).isSameAs(marshaller);
     assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.unmarshaller")).isSameAs(unmarshaller);
     assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.messageFactory")).isSameAs(messageFactory);
     assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.faultMessageResolver")).isSameAs(faultMessageResolver);
     assertThat(TestUtils.getPropertyValue(gateway, "headerMapper")).isSameAs(headerMapper);
     assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.interceptors", ClientInterceptor[].class)[0]).isSameAs(interceptor);
     assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.messageSenders", WebServiceMessageSender[].class)[0]).isSameAs(messageSender);
     assertThat(TestUtils.getPropertyValue(gateway, "requestCallback")).isSameAs(requestCallback);
     assertThat(TestUtils.getPropertyValue(gateway, "uriVariableExpressions")).isEqualTo(uriVariableExpressions);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void marshallingOutbound() {
    DestinationProvider destinationProvider = mock(DestinationProvider.class);
    Marshaller marshaller = mock(Marshaller.class);
    Unmarshaller unmarshaller = mock(Unmarshaller.class);
    WebServiceMessageFactory messageFactory = mock(WebServiceMessageFactory.class);
    FaultMessageResolver faultMessageResolver = mock(FaultMessageResolver.class);
    SoapHeaderMapper headerMapper = mock(SoapHeaderMapper.class);
    ClientInterceptor interceptor = mock(ClientInterceptor.class);
    WebServiceMessageSender messageSender = mock(WebServiceMessageSender.class);
    WebServiceMessageCallback requestCallback = msg -> {
    };
    Map<String, Expression> uriVariableExpressions = new HashMap<>();
    uriVariableExpressions.put("foo", new LiteralExpression("bar"));
    MarshallingWebServiceOutboundGateway gateway = Ws.marshallingOutboundGateway().destinationProvider(destinationProvider).marshaller(marshaller).unmarshaller(unmarshaller).messageFactory(messageFactory).faultMessageResolver(faultMessageResolver).headerMapper(headerMapper).ignoreEmptyResponses(true).interceptors(interceptor).messageSenders(messageSender).requestCallback(requestCallback).uriVariableExpressions(uriVariableExpressions).getObject();
    assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.marshaller")).isSameAs(marshaller);
    assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.unmarshaller")).isSameAs(unmarshaller);
    assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.messageFactory")).isSameAs(messageFactory);
    assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.faultMessageResolver")).isSameAs(faultMessageResolver);
    assertThat(TestUtils.getPropertyValue(gateway, "headerMapper")).isSameAs(headerMapper);
    assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.interceptors", ClientInterceptor[].class)[0]).isSameAs(interceptor);
    assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.messageSenders", WebServiceMessageSender[].class)[0]).isSameAs(messageSender);
    assertThat(TestUtils.getPropertyValue(gateway, "requestCallback")).isSameAs(requestCallback);
    assertThat(TestUtils.getPropertyValue(gateway, "uriVariableExpressions")).isEqualTo(uriVariableExpressions);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private SoapHeaderMapper headerMapper;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    headerMapper = mock(SoapHeaderMapper.class);
}

// === Replace local variable in test with ===
headerMapper

```
</details>

---
#### Test Case ID #spring-integration_Test_29_2
#### Test Case Name: `simpleOutbound`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ws\src\test\java\org\springframework\integration\ws\dsl\WsDslTests.java`)
#### Mock Object Variable Name: `headerMapper`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void simpleOutbound() {
     DestinationProvider destinationProvider = mock(DestinationProvider.class);
     WebServiceMessageFactory messageFactory = mock(WebServiceMessageFactory.class);
     FaultMessageResolver faultMessageResolver = mock(FaultMessageResolver.class);
-    SoapHeaderMapper headerMapper = mock(SoapHeaderMapper.class);
+    // removed local mock; replaced with global field `headerMapper`
     ClientInterceptor interceptor = mock(ClientInterceptor.class);
     WebServiceMessageSender messageSender = mock(WebServiceMessageSender.class);
     WebServiceMessageCallback requestCallback = msg -> {
     };
     Map<String, Expression> uriVariableExpressions = new HashMap<>();
     uriVariableExpressions.put("foo", new LiteralExpression("bar"));
     SourceExtractor<?> sourceExtractor = mock(SourceExtractor.class);
     SimpleWebServiceOutboundGateway gateway = Ws.simpleOutboundGateway()
         .destinationProvider(destinationProvider)
         .sourceExtractor(sourceExtractor)
         .messageFactory(messageFactory)
         .encodingMode(DefaultUriBuilderFactory.EncodingMode.VALUES_ONLY)
         .faultMessageResolver(faultMessageResolver)
-        .headerMapper(headerMapper)
+        .headerMapper(headerMapper)
         .ignoreEmptyResponses(true)
         .interceptors(interceptor)
         .messageSenders(messageSender)
         .requestCallback(requestCallback)
         .uriVariableExpressions(uriVariableExpressions)
         .extractPayload(false)
         .getObject();
     assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.messageFactory")).isSameAs(messageFactory);
     assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.faultMessageResolver")).isSameAs(faultMessageResolver);
-    assertThat(TestUtils.getPropertyValue(gateway, "headerMapper")).isSameAs(headerMapper);
+    assertThat(TestUtils.getPropertyValue(gateway, "headerMapper")).isSameAs(headerMapper);
     assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.interceptors", ClientInterceptor[].class)[0]).isSameAs(interceptor);
     assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.messageSenders", WebServiceMessageSender[].class)[0]).isSameAs(messageSender);
     assertThat(TestUtils.getPropertyValue(gateway, "requestCallback")).isSameAs(requestCallback);
     assertThat(TestUtils.getPropertyValue(gateway, "uriVariableExpressions")).isEqualTo(uriVariableExpressions);
     assertThat(TestUtils.getPropertyValue(gateway, "extractPayload", Boolean.class)).isFalse();
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void simpleOutbound() {
    DestinationProvider destinationProvider = mock(DestinationProvider.class);
    WebServiceMessageFactory messageFactory = mock(WebServiceMessageFactory.class);
    FaultMessageResolver faultMessageResolver = mock(FaultMessageResolver.class);
    SoapHeaderMapper headerMapper = mock(SoapHeaderMapper.class);
    ClientInterceptor interceptor = mock(ClientInterceptor.class);
    WebServiceMessageSender messageSender = mock(WebServiceMessageSender.class);
    WebServiceMessageCallback requestCallback = msg -> {
    };
    Map<String, Expression> uriVariableExpressions = new HashMap<>();
    uriVariableExpressions.put("foo", new LiteralExpression("bar"));
    SourceExtractor<?> sourceExtractor = mock(SourceExtractor.class);
    SimpleWebServiceOutboundGateway gateway = Ws.simpleOutboundGateway().destinationProvider(destinationProvider).sourceExtractor(sourceExtractor).messageFactory(messageFactory).encodingMode(DefaultUriBuilderFactory.EncodingMode.VALUES_ONLY).faultMessageResolver(faultMessageResolver).headerMapper(headerMapper).ignoreEmptyResponses(true).interceptors(interceptor).messageSenders(messageSender).requestCallback(requestCallback).uriVariableExpressions(uriVariableExpressions).extractPayload(false).getObject();
    assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.messageFactory")).isSameAs(messageFactory);
    assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.faultMessageResolver")).isSameAs(faultMessageResolver);
    assertThat(TestUtils.getPropertyValue(gateway, "headerMapper")).isSameAs(headerMapper);
    assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.interceptors", ClientInterceptor[].class)[0]).isSameAs(interceptor);
    assertThat(TestUtils.getPropertyValue(gateway, "webServiceTemplate.messageSenders", WebServiceMessageSender[].class)[0]).isSameAs(messageSender);
    assertThat(TestUtils.getPropertyValue(gateway, "requestCallback")).isSameAs(requestCallback);
    assertThat(TestUtils.getPropertyValue(gateway, "uriVariableExpressions")).isEqualTo(uriVariableExpressions);
    assertThat(TestUtils.getPropertyValue(gateway, "extractPayload", Boolean.class)).isFalse();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private SoapHeaderMapper headerMapper;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    headerMapper = mock(SoapHeaderMapper.class);
}

// === Replace local variable in test with ===
headerMapper

```
</details>

---
#### Test Case ID #spring-integration_Test_29_3
#### Test Case Name: `marshallingOutboundTemplate`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ws\src\test\java\org\springframework\integration\ws\dsl\WsDslTests.java`)
#### Mock Object Variable Name: `headerMapper`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void marshallingOutboundTemplate() {
-    SoapHeaderMapper headerMapper = mock(SoapHeaderMapper.class);
+    // removed local mock; replaced with global field `headerMapper`
     WebServiceMessageCallback requestCallback = msg -> {
     };
     Map<String, Expression> uriVariableExpressions = new HashMap<>();
     uriVariableExpressions.put("foo", new LiteralExpression("bar"));
     WebServiceTemplate template = mock(WebServiceTemplate.class);
     String uri = "foo";
     MarshallingWebServiceOutboundGateway gateway = Ws.marshallingOutboundGateway(template).uri(uri).headerMapper(headerMapper).ignoreEmptyResponses(true).requestCallback(requestCallback).uriVariableExpressions(uriVariableExpressions).getObject();
     assertThat(TestUtils.getPropertyValue(gateway, "uri")).isSameAs(uri);
     assertThat(TestUtils.getPropertyValue(gateway, "headerMapper")).isSameAs(headerMapper);
     assertThat(TestUtils.getPropertyValue(gateway, "requestCallback")).isSameAs(requestCallback);
     assertThat(TestUtils.getPropertyValue(gateway, "uriVariableExpressions")).isEqualTo(uriVariableExpressions);
     assertThat(TestUtils.getPropertyValue(gateway, "uriFactory.encodingMode", DefaultUriBuilderFactory.EncodingMode.class)).isEqualTo(DefaultUriBuilderFactory.EncodingMode.TEMPLATE_AND_VALUES);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void marshallingOutboundTemplate() {
    SoapHeaderMapper headerMapper = mock(SoapHeaderMapper.class);
    WebServiceMessageCallback requestCallback = msg -> {
    };
    Map<String, Expression> uriVariableExpressions = new HashMap<>();
    uriVariableExpressions.put("foo", new LiteralExpression("bar"));
    WebServiceTemplate template = mock(WebServiceTemplate.class);
    String uri = "foo";
    MarshallingWebServiceOutboundGateway gateway = Ws.marshallingOutboundGateway(template).uri(uri).headerMapper(headerMapper).ignoreEmptyResponses(true).requestCallback(requestCallback).uriVariableExpressions(uriVariableExpressions).getObject();
    assertThat(TestUtils.getPropertyValue(gateway, "uri")).isSameAs(uri);
    assertThat(TestUtils.getPropertyValue(gateway, "headerMapper")).isSameAs(headerMapper);
    assertThat(TestUtils.getPropertyValue(gateway, "requestCallback")).isSameAs(requestCallback);
    assertThat(TestUtils.getPropertyValue(gateway, "uriVariableExpressions")).isEqualTo(uriVariableExpressions);
    assertThat(TestUtils.getPropertyValue(gateway, "uriFactory.encodingMode", DefaultUriBuilderFactory.EncodingMode.class)).isEqualTo(DefaultUriBuilderFactory.EncodingMode.TEMPLATE_AND_VALUES);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private SoapHeaderMapper headerMapper;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    headerMapper = mock(SoapHeaderMapper.class);
}

// === Replace local variable in test with ===
headerMapper

```
</details>

---
#### Test Case ID #spring-integration_Test_29_4
#### Test Case Name: `simpleOutboundTemplate`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ws\src\test\java\org\springframework\integration\ws\dsl\WsDslTests.java`)
#### Mock Object Variable Name: `headerMapper`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void simpleOutboundTemplate() {
-    SoapHeaderMapper headerMapper = mock(SoapHeaderMapper.class);
+    // removed local mock; replaced with global field `headerMapper`
     WebServiceMessageCallback requestCallback = msg -> {
     };
     Map<String, Expression> uriVariableExpressions = new HashMap<>();
     uriVariableExpressions.put("foo", new LiteralExpression("bar"));
     SourceExtractor<?> sourceExtractor = mock(SourceExtractor.class);
     WebServiceTemplate template = mock(WebServiceTemplate.class);
     String uri = "foo";
     SimpleWebServiceOutboundGateway gateway = Ws.simpleOutboundGateway(template).uri(uri).sourceExtractor(sourceExtractor).encodingMode(DefaultUriBuilderFactory.EncodingMode.VALUES_ONLY).headerMapper(headerMapper).ignoreEmptyResponses(true).requestCallback(requestCallback).uriVariableExpressions(uriVariableExpressions).extractPayload(false).getObject();
     assertThat(TestUtils.getPropertyValue(gateway, "headerMapper")).isSameAs(headerMapper);
     assertThat(TestUtils.getPropertyValue(gateway, "requestCallback")).isSameAs(requestCallback);
     assertThat(TestUtils.getPropertyValue(gateway, "uriVariableExpressions")).isEqualTo(uriVariableExpressions);
     assertThat(TestUtils.getPropertyValue(gateway, "extractPayload", Boolean.class)).isFalse();
     assertThat(TestUtils.getPropertyValue(gateway, "uriFactory.encodingMode", DefaultUriBuilderFactory.EncodingMode.class)).isEqualTo(DefaultUriBuilderFactory.EncodingMode.VALUES_ONLY);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void simpleOutboundTemplate() {
    SoapHeaderMapper headerMapper = mock(SoapHeaderMapper.class);
    WebServiceMessageCallback requestCallback = msg -> {
    };
    Map<String, Expression> uriVariableExpressions = new HashMap<>();
    uriVariableExpressions.put("foo", new LiteralExpression("bar"));
    SourceExtractor<?> sourceExtractor = mock(SourceExtractor.class);
    WebServiceTemplate template = mock(WebServiceTemplate.class);
    String uri = "foo";
    SimpleWebServiceOutboundGateway gateway = Ws.simpleOutboundGateway(template).uri(uri).sourceExtractor(sourceExtractor).encodingMode(DefaultUriBuilderFactory.EncodingMode.VALUES_ONLY).headerMapper(headerMapper).ignoreEmptyResponses(true).requestCallback(requestCallback).uriVariableExpressions(uriVariableExpressions).extractPayload(false).getObject();
    assertThat(TestUtils.getPropertyValue(gateway, "headerMapper")).isSameAs(headerMapper);
    assertThat(TestUtils.getPropertyValue(gateway, "requestCallback")).isSameAs(requestCallback);
    assertThat(TestUtils.getPropertyValue(gateway, "uriVariableExpressions")).isEqualTo(uriVariableExpressions);
    assertThat(TestUtils.getPropertyValue(gateway, "extractPayload", Boolean.class)).isFalse();
    assertThat(TestUtils.getPropertyValue(gateway, "uriFactory.encodingMode", DefaultUriBuilderFactory.EncodingMode.class)).isEqualTo(DefaultUriBuilderFactory.EncodingMode.VALUES_ONLY);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private SoapHeaderMapper headerMapper;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    headerMapper = mock(SoapHeaderMapper.class);
}

// === Replace local variable in test with ===
headerMapper

```
</details>

---
## Mock Clone Instance #spring-integration_MCI_30
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.file.remote.session.SessionFactory<org.apache.commons.net.ftp.FTPFile>`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static SessionFactory<FTPFile> createMockSessionFactory(Session<FTPFile> sessionToReturn) {
    SessionFactory<FTPFile> sessionFactory = Mockito.mock(SessionFactory.class);
    Mockito.when(sessionFactory.getSession()).thenReturn(sessionToReturn);
    return sessionFactory;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_30_1
#### Test Case Name: `testStaleConnection`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ftp\src\test\java\org\springframework\integration\ftp\session\SessionFactoryTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
@@
 void testStaleConnection() {
-    SessionFactory<FTPFile> sessionFactory = Mockito.mock(SessionFactory.class);
     Session<FTPFile> sessionA = Mockito.mock(Session.class);
     Session<FTPFile> sessionB = Mockito.mock(Session.class);
     Mockito.when(sessionA.isOpen()).thenReturn(true);
     Mockito.when(sessionB.isOpen()).thenReturn(false);
+    SessionFactory<FTPFile> sessionFactory = createMockSessionFactory(sessionA);
     Mockito.when(sessionFactory.getSession()).thenReturn(sessionB);
     CachingSessionFactory<FTPFile> cachingFactory = new CachingSessionFactory<>(sessionFactory, 2);
     Session<FTPFile> firstSession = cachingFactory.getSession();
     Session<FTPFile> secondSession = cachingFactory.getSession();
     secondSession.close();
     Session<FTPFile> nonStaleSession = cachingFactory.getSession();
     assertThat(TestUtils.getPropertyValue(nonStaleSession, "targetSession")).isEqualTo(TestUtils.getPropertyValue(firstSession, "targetSession"));
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@SuppressWarnings("unchecked")
void testStaleConnection() {
    SessionFactory<FTPFile> sessionFactory = Mockito.mock(SessionFactory.class);
    Session<FTPFile> sessionA = Mockito.mock(Session.class);
    Session<FTPFile> sessionB = Mockito.mock(Session.class);
    Mockito.when(sessionA.isOpen()).thenReturn(true);
    Mockito.when(sessionB.isOpen()).thenReturn(false);
    Mockito.when(sessionFactory.getSession()).thenReturn(sessionA);
    Mockito.when(sessionFactory.getSession()).thenReturn(sessionB);
    CachingSessionFactory<FTPFile> cachingFactory = new CachingSessionFactory<>(sessionFactory, 2);
    Session<FTPFile> firstSession = cachingFactory.getSession();
    Session<FTPFile> secondSession = cachingFactory.getSession();
    secondSession.close();
    Session<FTPFile> nonStaleSession = cachingFactory.getSession();
    assertThat(TestUtils.getPropertyValue(nonStaleSession, "targetSession")).isEqualTo(TestUtils.getPropertyValue(firstSession, "targetSession"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory<FTPFile> createMockSessionFactory(Session<FTPFile> sessionToReturn) {
    SessionFactory<FTPFile> sessionFactory = Mockito.mock(SessionFactory.class);
    Mockito.when(sessionFactory.getSession()).thenReturn(sessionToReturn);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_30_2
#### Test Case Name: `testSameSessionFromThePool`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ftp\src\test\java\org\springframework\integration\ftp\session\SessionFactoryTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testSameSessionFromThePool() {
-    SessionFactory<FTPFile> sessionFactory = Mockito.mock(SessionFactory.class);
     Session<FTPFile> session = Mockito.mock(Session.class);
-    Mockito.when(sessionFactory.getSession()).thenReturn(session);
+    SessionFactory<FTPFile> sessionFactory = createMockSessionFactory(session);
     CachingSessionFactory<FTPFile> cachingFactory = new CachingSessionFactory<>(sessionFactory, 2);
     Session<FTPFile> s1 = cachingFactory.getSession();
     s1.close();
     Session<FTPFile> s2 = cachingFactory.getSession();
     s2.close();
     assertThat(TestUtils.getPropertyValue(s2, "targetSession")).isEqualTo(TestUtils.getPropertyValue(s1, "targetSession"));
     Mockito.verify(sessionFactory, Mockito.times(2)).getSession();
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@SuppressWarnings("unchecked")
void testSameSessionFromThePool() {
    SessionFactory<FTPFile> sessionFactory = Mockito.mock(SessionFactory.class);
    Session<FTPFile> session = Mockito.mock(Session.class);
    Mockito.when(sessionFactory.getSession()).thenReturn(session);
    CachingSessionFactory<FTPFile> cachingFactory = new CachingSessionFactory<>(sessionFactory, 2);
    Session<FTPFile> s1 = cachingFactory.getSession();
    s1.close();
    Session<FTPFile> s2 = cachingFactory.getSession();
    s2.close();
    assertThat(TestUtils.getPropertyValue(s2, "targetSession")).isEqualTo(TestUtils.getPropertyValue(s1, "targetSession"));
    Mockito.verify(sessionFactory, Mockito.times(2)).getSession();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory<FTPFile> createMockSessionFactory(Session<FTPFile> sessionToReturn) {
    SessionFactory<FTPFile> sessionFactory = Mockito.mock(SessionFactory.class);
    Mockito.when(sessionFactory.getSession()).thenReturn(sessionToReturn);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_30_3
#### Test Case Name: `testSessionWaitExpire`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ftp\src\test\java\org\springframework\integration\ftp\session\SessionFactoryTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testSessionWaitExpire() {
-    SessionFactory<FTPFile> sessionFactory = Mockito.mock(SessionFactory.class);
    Session<FTPFile> session = Mockito.mock(Session.class);
-    Mockito.when(sessionFactory.getSession()).thenReturn(session);
+    SessionFactory<FTPFile> sessionFactory = createMockSessionFactory(session);
    CachingSessionFactory<FTPFile> cachingFactory = new CachingSessionFactory<>(sessionFactory, 2);
    cachingFactory.setSessionWaitTimeout(3000);
    cachingFactory.getSession();
    cachingFactory.getSession();
    // timeout expire
    assertThatExceptionOfType(PoolItemNotAvailableException.class).isThrownBy(cachingFactory::getSession);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@SuppressWarnings("unchecked")
void testSessionWaitExpire() {
    SessionFactory<FTPFile> sessionFactory = Mockito.mock(SessionFactory.class);
    Session<FTPFile> session = Mockito.mock(Session.class);
    Mockito.when(sessionFactory.getSession()).thenReturn(session);
    CachingSessionFactory<FTPFile> cachingFactory = new CachingSessionFactory<>(sessionFactory, 2);
    cachingFactory.setSessionWaitTimeout(3000);
    cachingFactory.getSession();
    cachingFactory.getSession();
    // timeout expire
    assertThatExceptionOfType(PoolItemNotAvailableException.class).isThrownBy(cachingFactory::getSession);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory<FTPFile> createMockSessionFactory(Session<FTPFile> sessionToReturn) {
    SessionFactory<FTPFile> sessionFactory = Mockito.mock(SessionFactory.class);
    Mockito.when(sessionFactory.getSession()).thenReturn(sessionToReturn);
    return sessionFactory;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_31
- **Scope**: method level
- **Mocked Class**: `com.rabbitmq.client.Channel`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static Channel createMockChannel(GetResponse getResponse) {
    Channel channel = mock(Channel.class);
    willReturn(true).given(channel).isOpen();
    willReturn(getResponse).given(channel).basicGet("foo", false);
    return channel;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_31_1
#### Test Case Name: `testAck`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\inbound\AmqpMessageSourceTests.java`)
#### Mock Object Variable Name: `channel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void testAck() throws Exception {
-    Channel channel = mock(Channel.class);
-    willReturn(true).given(channel).isOpen();
    Envelope envelope = new Envelope(123L, false, "ex", "rk");
    BasicProperties props = new BasicProperties.Builder().contentType(MessageProperties.DEFAULT_CONTENT_TYPE).build();
    GetResponse getResponse = new GetResponse(envelope, props, "bar".getBytes(), 0);
+    Channel channel = createMockChannel(getResponse);
    Connection connection = mock(Connection.class);
    willReturn(true).given(connection).isOpen();
    willReturn(channel).given(connection).createChannel();
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
    CachingConnectionFactory ccf = new CachingConnectionFactory(connectionFactory);
    AmqpMessageSource source = new AmqpMessageSource(ccf, "foo");
    source.setRawMessageHeader(true);
    Message<?> received = source.receive();
    assertThat(received.getHeaders().get(AmqpMessageHeaderErrorMessageStrategy.AMQP_RAW_MESSAGE)).isInstanceOf(org.springframework.amqp.core.Message.class);
    assertThat(received.getHeaders().get(IntegrationMessageHeaderAccessor.SOURCE_DATA)).isSameAs(received.getHeaders().get(AmqpMessageHeaderErrorMessageStrategy.AMQP_RAW_MESSAGE));
    assertThat(received.getHeaders().get(AmqpHeaders.CONSUMER_QUEUE)).isEqualTo("foo");
    // make sure channel is not cached
    org.springframework.amqp.rabbit.connection.Connection conn = ccf.createConnection();
    // should not have been "closed"
    Channel notCached = conn.createChannel(false);
    verify(connection, times(2)).createChannel();
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(Status.ACCEPT);
    verify(channel).basicAck(123L, false);
    // should have been "closed"
    Channel cached = conn.createChannel(false);
    verify(connection, times(2)).createChannel();
    notCached.close();
    cached.close();
    ccf.destroy();
    verify(channel, times(2)).close();
    verify(connection).close(30000);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testAck() throws Exception {
    Channel channel = mock(Channel.class);
    willReturn(true).given(channel).isOpen();
    Envelope envelope = new Envelope(123L, false, "ex", "rk");
    BasicProperties props = new BasicProperties.Builder().contentType(MessageProperties.DEFAULT_CONTENT_TYPE).build();
    GetResponse getResponse = new GetResponse(envelope, props, "bar".getBytes(), 0);
    willReturn(getResponse).given(channel).basicGet("foo", false);
    Connection connection = mock(Connection.class);
    willReturn(true).given(connection).isOpen();
    willReturn(channel).given(connection).createChannel();
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
    CachingConnectionFactory ccf = new CachingConnectionFactory(connectionFactory);
    AmqpMessageSource source = new AmqpMessageSource(ccf, "foo");
    source.setRawMessageHeader(true);
    Message<?> received = source.receive();
    assertThat(received.getHeaders().get(AmqpMessageHeaderErrorMessageStrategy.AMQP_RAW_MESSAGE)).isInstanceOf(org.springframework.amqp.core.Message.class);
    assertThat(received.getHeaders().get(IntegrationMessageHeaderAccessor.SOURCE_DATA)).isSameAs(received.getHeaders().get(AmqpMessageHeaderErrorMessageStrategy.AMQP_RAW_MESSAGE));
    assertThat(received.getHeaders().get(AmqpHeaders.CONSUMER_QUEUE)).isEqualTo("foo");
    // make sure channel is not cached
    org.springframework.amqp.rabbit.connection.Connection conn = ccf.createConnection();
    // should not have been "closed"
    Channel notCached = conn.createChannel(false);
    verify(connection, times(2)).createChannel();
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(Status.ACCEPT);
    verify(channel).basicAck(123L, false);
    // should have been "closed"
    Channel cached = conn.createChannel(false);
    verify(connection, times(2)).createChannel();
    notCached.close();
    cached.close();
    ccf.destroy();
    verify(channel, times(2)).close();
    verify(connection).close(30000);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Channel createMockChannel(GetResponse getResponse) {
    Channel channel = mock(Channel.class);
    willReturn(true).given(channel).isOpen();
    willReturn(getResponse).given(channel).basicGet("foo", false);
    return channel;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_31_2
#### Test Case Name: `testNackOrRequeue`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\inbound\AmqpMessageSourceTests.java`)
#### Mock Object Variable Name: `channel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
private void testNackOrRequeue(boolean requeue) throws Exception {
-    Channel channel = mock(Channel.class);
-    willReturn(true).given(channel).isOpen();
    Envelope envelope = new Envelope(123L, false, "ex", "rk");
    BasicProperties props = new BasicProperties.Builder().contentType(MessageProperties.DEFAULT_CONTENT_TYPE).build();
    GetResponse getResponse = new GetResponse(envelope, props, "bar".getBytes(), 0);
-    willReturn(getResponse).given(channel).basicGet("foo", false);
+    Channel channel = createMockChannel(getResponse);
    Connection connection = mock(Connection.class);
    willReturn(true).given(connection).isOpen();
    willReturn(channel).given(connection).createChannel();
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
    CachingConnectionFactory ccf = new CachingConnectionFactory(connectionFactory);
    AmqpMessageSource source = new AmqpMessageSource(ccf, "foo");
    Message<?> received = source.receive();
    verify(connection).createChannel();
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(requeue ? Status.REQUEUE : Status.REJECT);
    verify(channel).basicReject(123L, requeue);
    verify(connection).createChannel();
    ccf.destroy();
    verify(channel).close();
    verify(connection).close(30000);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
private void testNackOrRequeue(boolean requeue) throws Exception {
    Channel channel = mock(Channel.class);
    willReturn(true).given(channel).isOpen();
    Envelope envelope = new Envelope(123L, false, "ex", "rk");
    BasicProperties props = new BasicProperties.Builder().contentType(MessageProperties.DEFAULT_CONTENT_TYPE).build();
    GetResponse getResponse = new GetResponse(envelope, props, "bar".getBytes(), 0);
    willReturn(getResponse).given(channel).basicGet("foo", false);
    Connection connection = mock(Connection.class);
    willReturn(true).given(connection).isOpen();
    willReturn(channel).given(connection).createChannel();
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
    CachingConnectionFactory ccf = new CachingConnectionFactory(connectionFactory);
    AmqpMessageSource source = new AmqpMessageSource(ccf, "foo");
    Message<?> received = source.receive();
    verify(connection).createChannel();
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(requeue ? Status.REQUEUE : Status.REJECT);
    verify(channel).basicReject(123L, requeue);
    verify(connection).createChannel();
    ccf.destroy();
    verify(channel).close();
    verify(connection).close(30000);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Channel createMockChannel(GetResponse getResponse) {
    Channel channel = mock(Channel.class);
    willReturn(true).given(channel).isOpen();
    willReturn(getResponse).given(channel).basicGet("foo", false);
    return channel;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_31_3
#### Test Case Name: `testBatch`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\inbound\AmqpMessageSourceTests.java`)
#### Mock Object Variable Name: `channel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    MessageBatch batched = bs.addToBatch("foo", "bar", message);
-    Channel channel = mock(Channel.class);
-    willReturn(true).given(channel).isOpen();
    Envelope envelope = new Envelope(123L, false, "ex", "rk");
    BasicProperties props = new BasicProperties.Builder().headers(batched.message().getMessageProperties().getHeaders()).contentType("text/plain").build();
    GetResponse getResponse = new GetResponse(envelope, props, batched.message().getBody(), 0);
-    willReturn(getResponse).given(channel).basicGet("foo", false);
+    Channel channel = createMockChannel(getResponse);
    Connection connection = mock(Connection.class);
    willReturn(true).given(connection).isOpen();
    willReturn(channel).given(connection).createChannel();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "unchecked" })
@Test
public void testBatch() throws Exception {
    SimpleBatchingStrategy bs = new SimpleBatchingStrategy(2, 10_000, 10_000L);
    MessageProperties messageProperties = new MessageProperties();
    messageProperties.setContentType("text/plain");
    org.springframework.amqp.core.Message message = new org.springframework.amqp.core.Message("test1".getBytes(), messageProperties);
    bs.addToBatch("foo", "bar", message);
    message = new org.springframework.amqp.core.Message("test2".getBytes(), messageProperties);
    MessageBatch batched = bs.addToBatch("foo", "bar", message);
    Channel channel = mock(Channel.class);
    willReturn(true).given(channel).isOpen();
    Envelope envelope = new Envelope(123L, false, "ex", "rk");
    BasicProperties props = new BasicProperties.Builder().headers(batched.message().getMessageProperties().getHeaders()).contentType("text/plain").build();
    GetResponse getResponse = new GetResponse(envelope, props, batched.message().getBody(), 0);
    willReturn(getResponse).given(channel).basicGet("foo", false);
    Connection connection = mock(Connection.class);
    willReturn(true).given(connection).isOpen();
    willReturn(channel).given(connection).createChannel();
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
    CachingConnectionFactory ccf = new CachingConnectionFactory(connectionFactory);
    AmqpMessageSource source = new AmqpMessageSource(ccf, "foo");
    Message<?> received = source.receive();
    assertThat(received).isNotNull();
    assertThat(((List<String>) received.getPayload())).contains("test1", "test2");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Channel createMockChannel(GetResponse getResponse) {
    Channel channel = mock(Channel.class);
    willReturn(true).given(channel).isOpen();
    willReturn(getResponse).given(channel).basicGet("foo", false);
    return channel;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_32
- **Scope**: method level
- **Mocked Class**: `com.rabbitmq.client.Channel`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
// === Declare in class scope ===
private Channel mockChannel;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    mockChannel = mock(Channel.class);
}

// === Replace local variable in test with ===
mockChannel;

```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_32_1
#### Test Case Name: `testInt2773UseDefaultAmqpTemplateExchangeAndRoutingLey`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\config\AmqpOutboundChannelAdapterParserTests.java`)
#### Mock Object Variable Name: `mockChannel`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testInt2773UseDefaultAmqpTemplateExchangeAndRoutingLey() throws IOException {
     ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
     Connection mockConnection = mock(Connection.class);
-    Channel mockChannel = mock(Channel.class);
+    // removed local mock; replaced with global field `mockChannel`
     when(connectionFactory.createConnection()).thenReturn(mockConnection);
     PublisherCallbackChannelImpl publisherCallbackChannel = new PublisherCallbackChannelImpl(mockChannel, mock(ExecutorService.class));
     when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);
     MessageChannel requestChannel = context.getBean("toRabbitOnlyWithTemplateChannel", MessageChannel.class);
     requestChannel.send(MessageBuilder.withPayload("test").build());
-    Mockito.verify(mockChannel, Mockito.times(1)).basicPublish(Mockito.eq("default.test.exchange"), Mockito.eq("default.routing.key"), Mockito.anyBoolean(), Mockito.any(BasicProperties.class), Mockito.any(byte[].class));
+    Mockito.verify(mockChannel, Mockito.times(1)).basicPublish(Mockito.eq("default.test.exchange"), Mockito.eq("default.routing.key"), Mockito.anyBoolean(), Mockito.any(BasicProperties.class), Mockito.any(byte[].class));
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testInt2773UseDefaultAmqpTemplateExchangeAndRoutingLey() throws IOException {
    ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
    Connection mockConnection = mock(Connection.class);
    Channel mockChannel = mock(Channel.class);
    when(connectionFactory.createConnection()).thenReturn(mockConnection);
    PublisherCallbackChannelImpl publisherCallbackChannel = new PublisherCallbackChannelImpl(mockChannel, mock(ExecutorService.class));
    when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);
    MessageChannel requestChannel = context.getBean("toRabbitOnlyWithTemplateChannel", MessageChannel.class);
    requestChannel.send(MessageBuilder.withPayload("test").build());
    Mockito.verify(mockChannel, Mockito.times(1)).basicPublish(Mockito.eq("default.test.exchange"), Mockito.eq("default.routing.key"), Mockito.anyBoolean(), Mockito.any(BasicProperties.class), Mockito.any(byte[].class));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Channel mockChannel;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    mockChannel = mock(Channel.class);
}

// === Replace local variable in test with ===
mockChannel;

```
</details>

---
#### Test Case ID #spring-integration_Test_32_2
#### Test Case Name: `testInt2773WithDefaultAmqpTemplateExchangeAndRoutingKey`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\config\AmqpOutboundChannelAdapterParserTests.java`)
#### Mock Object Variable Name: `mockChannel`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testInt2773WithDefaultAmqpTemplateExchangeAndRoutingKey() throws IOException {
     ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
     Connection mockConnection = mock(Connection.class);
-    Channel mockChannel = mock(Channel.class);
+    // removed local mock; replaced with global field `mockChannel`
     when(connectionFactory.createConnection()).thenReturn(mockConnection);
     PublisherCallbackChannelImpl publisherCallbackChannel = new PublisherCallbackChannelImpl(mockChannel, mock(ExecutorService.class));
     when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);
     MessageChannel requestChannel = context.getBean("withDefaultAmqpTemplateExchangeAndRoutingKey", MessageChannel.class);
     requestChannel.send(MessageBuilder.withPayload("test").build());
-    Mockito.verify(mockChannel, Mockito.times(1)).basicPublish(Mockito.eq(""), Mockito.eq(""), Mockito.anyBoolean(), Mockito.any(BasicProperties.class), Mockito.any(byte[].class));
+    Mockito.verify(mockChannel, Mockito.times(1)).basicPublish(Mockito.eq(""), Mockito.eq(""), Mockito.anyBoolean(), Mockito.any(BasicProperties.class), Mockito.any(byte[].class));
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testInt2773WithDefaultAmqpTemplateExchangeAndRoutingKey() throws IOException {
    ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
    Connection mockConnection = mock(Connection.class);
    Channel mockChannel = mock(Channel.class);
    when(connectionFactory.createConnection()).thenReturn(mockConnection);
    PublisherCallbackChannelImpl publisherCallbackChannel = new PublisherCallbackChannelImpl(mockChannel, mock(ExecutorService.class));
    when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);
    MessageChannel requestChannel = context.getBean("withDefaultAmqpTemplateExchangeAndRoutingKey", MessageChannel.class);
    requestChannel.send(MessageBuilder.withPayload("test").build());
    Mockito.verify(mockChannel, Mockito.times(1)).basicPublish(Mockito.eq(""), Mockito.eq(""), Mockito.anyBoolean(), Mockito.any(BasicProperties.class), Mockito.any(byte[].class));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Channel mockChannel;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    mockChannel = mock(Channel.class);
}

// === Replace local variable in test with ===
mockChannel;

```
</details>

---
#### Test Case ID #spring-integration_Test_32_3
#### Test Case Name: `testInt2773WithOverrideToDefaultAmqpTemplateExchangeAndRoutingLey`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\config\AmqpOutboundChannelAdapterParserTests.java`)
#### Mock Object Variable Name: `mockChannel`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testInt2773WithOverrideToDefaultAmqpTemplateExchangeAndRoutingLey() throws IOException {
     ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
     Connection mockConnection = mock(Connection.class);
-    Channel mockChannel = mock(Channel.class);
+    // removed local mock; replaced with global field `mockChannel`
     when(connectionFactory.createConnection()).thenReturn(mockConnection);
     PublisherCallbackChannelImpl publisherCallbackChannel = new PublisherCallbackChannelImpl(mockChannel, mock(ExecutorService.class));
     when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);
     MessageChannel requestChannel = context.getBean("overrideTemplateAttributesToEmpty", MessageChannel.class);
     requestChannel.send(MessageBuilder.withPayload("test").build());
-    Mockito.verify(mockChannel, Mockito.times(1)).basicPublish(Mockito.eq(""), Mockito.eq(""), Mockito.anyBoolean(), Mockito.any(BasicProperties.class), Mockito.any(byte[].class));
+    Mockito.verify(mockChannel, Mockito.times(1)).basicPublish(Mockito.eq(""), Mockito.eq(""), Mockito.anyBoolean(), Mockito.any(BasicProperties.class), Mockito.any(byte[].class));
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testInt2773WithOverrideToDefaultAmqpTemplateExchangeAndRoutingLey() throws IOException {
    ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
    Connection mockConnection = mock(Connection.class);
    Channel mockChannel = mock(Channel.class);
    when(connectionFactory.createConnection()).thenReturn(mockConnection);
    PublisherCallbackChannelImpl publisherCallbackChannel = new PublisherCallbackChannelImpl(mockChannel, mock(ExecutorService.class));
    when(mockConnection.createChannel(false)).thenReturn(publisherCallbackChannel);
    MessageChannel requestChannel = context.getBean("overrideTemplateAttributesToEmpty", MessageChannel.class);
    requestChannel.send(MessageBuilder.withPayload("test").build());
    Mockito.verify(mockChannel, Mockito.times(1)).basicPublish(Mockito.eq(""), Mockito.eq(""), Mockito.anyBoolean(), Mockito.any(BasicProperties.class), Mockito.any(byte[].class));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Channel mockChannel;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    mockChannel = mock(Channel.class);
}

// === Replace local variable in test with ===
mockChannel;

```
</details>

---
## Mock Clone Instance #spring-integration_MCI_33
- **Scope**: method level
- **Mocked Class**: `org.eclipse.paho.client.mqttv3.IMqttToken`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static IMqttToken createMockIMqttToken(int[] grantedQos) {
    IMqttToken token = mock(IMqttToken.class);
    given(token.getGrantedQos()).willReturn(grantedQos);
    return token;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_33_1
#### Test Case Name: `testInboundOptionsApplied`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mqtt\src\test\java\org\springframework\integration\mqtt\MqttAdapterTests.java`)
#### Mock Object Variable Name: `token`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    final AtomicBoolean connectCalled = new AtomicBoolean();
-    IMqttToken token = mock(IMqttToken.class);
+    IMqttToken token = createMockIMqttToken(new int[] { 2 });
    willAnswer(invocation -> {
        MqttConnectOptions options = invocation.getArgument(0);
        assertThat(options.getConnectionTimeout()).isEqualTo(23);
        assertThat(options.getKeepAliveInterval()).isEqualTo(45);
        assertThat(new String(options.getPassword())).isEqualTo("pass");
        assertThat(options.getSocketFactory()).isSameAs(socketFactory);
        assertThat(options.getSSLProperties()).isSameAs(props);
        assertThat(options.getUserName()).isEqualTo("user");
        assertThat(options.getWillDestination()).isEqualTo("foo");
        assertThat(new String(options.getWillMessage().getPayload())).isEqualTo("bar");
        assertThat(options.getWillMessage().getQos()).isEqualTo(2);
        connectCalled.set(true);
        return token;
    }).given(client).connect(any(MqttConnectOptions.class));
    given(client.subscribe(any(String[].class), any(int[].class), any())).willReturn(token);
-    given(token.getGrantedQos()).willReturn(new int[] { 2 });
    final AtomicReference<MqttCallbackExtended> callback = new AtomicReference<>();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testInboundOptionsApplied() throws Exception {
    DefaultMqttPahoClientFactory factory = new DefaultMqttPahoClientFactory();
    MqttConnectOptions connectOptions = new MqttConnectOptions();
    connectOptions.setCleanSession(false);
    connectOptions.setConnectionTimeout(23);
    connectOptions.setKeepAliveInterval(45);
    connectOptions.setPassword("pass".toCharArray());
    MemoryPersistence persistence = new MemoryPersistence();
    factory.setPersistence(persistence);
    final SocketFactory socketFactory = SocketFactory.getDefault();
    connectOptions.setSocketFactory(socketFactory);
    final Properties props = new Properties();
    connectOptions.setSSLProperties(props);
    connectOptions.setUserName("user");
    connectOptions.setWill("foo", "bar".getBytes(), 2, true);
    factory.setConnectionOptions(connectOptions);
    factory = spy(factory);
    final IMqttAsyncClient client = mock(IMqttAsyncClient.class);
    willReturn(client).given(factory).getAsyncClientInstance(anyString(), anyString());
    final AtomicBoolean connectCalled = new AtomicBoolean();
    IMqttToken token = mock(IMqttToken.class);
    willAnswer(invocation -> {
        MqttConnectOptions options = invocation.getArgument(0);
        assertThat(options.getConnectionTimeout()).isEqualTo(23);
        assertThat(options.getKeepAliveInterval()).isEqualTo(45);
        assertThat(new String(options.getPassword())).isEqualTo("pass");
        assertThat(options.getSocketFactory()).isSameAs(socketFactory);
        assertThat(options.getSSLProperties()).isSameAs(props);
        assertThat(options.getUserName()).isEqualTo("user");
        assertThat(options.getWillDestination()).isEqualTo("foo");
        assertThat(new String(options.getWillMessage().getPayload())).isEqualTo("bar");
        assertThat(options.getWillMessage().getQos()).isEqualTo(2);
        connectCalled.set(true);
        return token;
    }).given(client).connect(any(MqttConnectOptions.class));
    given(client.subscribe(any(String[].class), any(int[].class), any())).willReturn(token);
    given(token.getGrantedQos()).willReturn(new int[] { 2 });
    final AtomicReference<MqttCallbackExtended> callback = new AtomicReference<>();
    willAnswer(invocation -> {
        callback.set(invocation.getArgument(0));
        return null;
    }).given(client).setCallback(any(MqttCallbackExtended.class));
    given(client.isConnected()).willReturn(true);
    MqttPahoMessageDrivenChannelAdapter adapter = new MqttPahoMessageDrivenChannelAdapter("foo", "bar", factory, "baz", "fix");
    adapter.setManualAcks(true);
    QueueChannel outputChannel = new QueueChannel();
    adapter.setOutputChannel(outputChannel);
    QueueChannel errorChannel = new QueueChannel();
    adapter.setErrorChannel(errorChannel);
    adapter.setBeanFactory(mock(BeanFactory.class));
    ApplicationEventPublisher applicationEventPublisher = mock(ApplicationEventPublisher.class);
    final BlockingQueue<MqttIntegrationEvent> events = new LinkedBlockingQueue<>();
    willAnswer(invocation -> {
        events.add(invocation.getArgument(0));
        return null;
    }).given(applicationEventPublisher).publishEvent(any(MqttIntegrationEvent.class));
    adapter.setApplicationEventPublisher(applicationEventPublisher);
    adapter.afterPropertiesSet();
    adapter.start();
    adapter.connectComplete(false, null);
    verify(client, times(1)).connect(any(MqttConnectOptions.class));
    assertThat(connectCalled.get()).isTrue();
    MqttMessage message = new MqttMessage("qux".getBytes());
    callback.get().messageArrived("baz", message);
    Message<?> outMessage = outputChannel.receive(0);
    assertThat(outMessage).isNotNull();
    assertThat(outMessage.getPayload()).isEqualTo("qux");
    StaticMessageHeaderAccessor.getAcknowledgment(outMessage).acknowledge();
    verify(client).setManualAcks(true);
    verify(client).messageArrivedComplete(MqttHeaderAccessor.id(outMessage), MqttHeaderAccessor.receivedQos(outMessage));
    MqttIntegrationEvent event = events.poll(10, TimeUnit.SECONDS);
    assertThat(event).isInstanceOf(MqttSubscribedEvent.class);
    assertThat(((MqttSubscribedEvent) event).getMessage()).isEqualTo("Connected and subscribed to [baz, fix]");
    adapter.setConverter(new MqttMessageConverter() {

        @Override
        public AbstractIntegrationMessageBuilder<?> toMessageBuilder(String topic, MqttMessage mqttMessage) {
            return null;
        }

        @Override
        public Object fromMessage(Message<?> message, Class<?> targetClass) {
            return null;
        }

        @Override
        public Message<?> toMessage(Object payload, MessageHeaders headers) {
            return null;
        }
    });
    callback.get().messageArrived("baz", message);
    ErrorMessage errorMessage = (ErrorMessage) errorChannel.receive(0);
    assertThat(errorMessage).isNotNull().extracting(Message::getPayload).isInstanceOf(IllegalStateException.class);
    IllegalStateException exception = (IllegalStateException) errorMessage.getPayload();
    assertThat(exception).hasMessage("'MqttMessageConverter' returned 'null'");
    assertThat(errorMessage.getOriginalMessage().getPayload()).isSameAs(message);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static IMqttToken createMockIMqttToken(int[] grantedQos) {
    IMqttToken token = mock(IMqttToken.class);
    given(token.getGrantedQos()).willReturn(grantedQos);
    return token;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_33_2
#### Test Case Name: `testSubscribeFailure`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mqtt\src\test\java\org\springframework\integration\mqtt\MqttAdapterTests.java`)
#### Mock Object Variable Name: `token`
<summary>Suggested Diff</summary>

```diff
@@
     willReturn(alwaysComplete).given(client).connect(any(MqttConnectOptions.class));
-    IMqttToken token = mock(IMqttToken.class);
-    given(token.getGrantedQos()).willReturn(new int[] { 0x80 });
+    IMqttToken token = createMockIMqttToken(new int[] { 0x80 });
     willReturn(token).given(client).subscribe(any(String[].class), any(int[].class), any());
     MqttPahoMessageDrivenChannelAdapter adapter = new MqttPahoMessageDrivenChannelAdapter("foo", "bar", factory, "baz", "fix");
     AtomicReference<Method> method = new AtomicReference<>();
     ReflectionUtils.doWithMethods(MqttPahoMessageDrivenChannelAdapter.class, m -> {
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testSubscribeFailure() throws Exception {
    DefaultMqttPahoClientFactory factory = new DefaultMqttPahoClientFactory();
    MqttConnectOptions connectOptions = new MqttConnectOptions();
    connectOptions.setCleanSession(false);
    connectOptions.setConnectionTimeout(23);
    connectOptions.setKeepAliveInterval(45);
    connectOptions.setPassword("pass".toCharArray());
    MemoryPersistence persistence = new MemoryPersistence();
    factory.setPersistence(persistence);
    final SocketFactory socketFactory = SocketFactory.getDefault();
    connectOptions.setSocketFactory(socketFactory);
    final Properties props = new Properties();
    connectOptions.setSSLProperties(props);
    connectOptions.setUserName("user");
    connectOptions.setWill("foo", "bar".getBytes(), 2, true);
    factory = spy(factory);
    final MqttAsyncClient client = mock(MqttAsyncClient.class);
    willReturn(client).given(factory).getAsyncClientInstance(anyString(), anyString());
    given(client.isConnected()).willReturn(true);
    willReturn(alwaysComplete).given(client).connect(any(MqttConnectOptions.class));
    IMqttToken token = mock(IMqttToken.class);
    given(token.getGrantedQos()).willReturn(new int[] { 0x80 });
    willReturn(token).given(client).subscribe(any(String[].class), any(int[].class), any());
    MqttPahoMessageDrivenChannelAdapter adapter = new MqttPahoMessageDrivenChannelAdapter("foo", "bar", factory, "baz", "fix");
    AtomicReference<Method> method = new AtomicReference<>();
    ReflectionUtils.doWithMethods(MqttPahoMessageDrivenChannelAdapter.class, m -> {
        m.setAccessible(true);
        method.set(m);
    }, m -> m.getName().equals("connect"));
    assertThat(method.get()).isNotNull();
    method.get().invoke(adapter);
    ReflectionUtils.doWithMethods(MqttPahoMessageDrivenChannelAdapter.class, m -> {
        m.setAccessible(true);
        method.set(m);
    }, m -> m.getName().equals("subscribe"));
    assertThat(method.get()).isNotNull();
    ApplicationEventPublisher eventPublisher = mock(ApplicationEventPublisher.class);
    adapter.setApplicationEventPublisher(eventPublisher);
    method.get().invoke(adapter);
    verify(eventPublisher).publishEvent(any(MqttConnectionFailedEvent.class));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static IMqttToken createMockIMqttToken(int[] grantedQos) {
    IMqttToken token = mock(IMqttToken.class);
    given(token.getGrantedQos()).willReturn(grantedQos);
    return token;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_33_3
#### Test Case Name: `testDifferentQos`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mqtt\src\test\java\org\springframework\integration\mqtt\MqttAdapterTests.java`)
#### Mock Object Variable Name: `token`
<summary>Suggested Diff</summary>

```diff
@@
     willReturn(alwaysComplete).given(client).connect(any(MqttConnectOptions.class));
-    IMqttToken token = mock(IMqttToken.class);
-    given(token.getGrantedQos()).willReturn(new int[] { 2, 0 });
+    IMqttToken token = createMockIMqttToken(new int[] { 2, 0 });
     willReturn(token).given(client).subscribe(any(String[].class), any(int[].class), any());
     MqttPahoMessageDrivenChannelAdapter adapter = new MqttPahoMessageDrivenChannelAdapter("tcp://mqtt.host", "bar", factory, "baz", "fix");
     AtomicReference<Method> method = new AtomicReference<>();
     ReflectionUtils.doWithMethods(MqttPahoMessageDrivenChannelAdapter.class, m -> {
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testDifferentQos() throws Exception {
    DefaultMqttPahoClientFactory factory = new DefaultMqttPahoClientFactory();
    MqttConnectOptions connectOptions = new MqttConnectOptions();
    connectOptions.setCleanSession(false);
    connectOptions.setConnectionTimeout(23);
    connectOptions.setKeepAliveInterval(45);
    connectOptions.setPassword("pass".toCharArray());
    MemoryPersistence persistence = new MemoryPersistence();
    factory.setPersistence(persistence);
    final SocketFactory socketFactory = SocketFactory.getDefault();
    connectOptions.setSocketFactory(socketFactory);
    final Properties props = new Properties();
    connectOptions.setSSLProperties(props);
    connectOptions.setUserName("user");
    connectOptions.setWill("foo", "bar".getBytes(), 2, true);
    factory = spy(factory);
    final MqttAsyncClient client = mock(MqttAsyncClient.class);
    willReturn(client).given(factory).getAsyncClientInstance(anyString(), anyString());
    given(client.isConnected()).willReturn(true);
    willReturn(alwaysComplete).given(client).connect(any(MqttConnectOptions.class));
    IMqttToken token = mock(IMqttToken.class);
    given(token.getGrantedQos()).willReturn(new int[] { 2, 0 });
    willReturn(token).given(client).subscribe(any(String[].class), any(int[].class), any());
    MqttPahoMessageDrivenChannelAdapter adapter = new MqttPahoMessageDrivenChannelAdapter("tcp://mqtt.host", "bar", factory, "baz", "fix");
    AtomicReference<Method> method = new AtomicReference<>();
    ReflectionUtils.doWithMethods(MqttPahoMessageDrivenChannelAdapter.class, m -> {
        m.setAccessible(true);
        method.set(m);
    }, m -> m.getName().equals("connect"));
    assertThat(method.get()).isNotNull();
    method.get().invoke(adapter);
    ReflectionUtils.doWithMethods(MqttPahoMessageDrivenChannelAdapter.class, m -> {
        m.setAccessible(true);
        method.set(m);
    }, m -> m.getName().equals("subscribe"));
    assertThat(method.get()).isNotNull();
    LogAccessor logger = spy(TestUtils.getPropertyValue(adapter, "logger", LogAccessor.class));
    new DirectFieldAccessor(adapter).setPropertyValue("logger", logger);
    given(logger.isWarnEnabled()).willReturn(true);
    method.get().invoke(adapter);
    verify(logger, atLeastOnce()).warn(ArgumentMatchers.<Supplier<? extends CharSequence>>argThat(logMessage -> logMessage.get().equals("Granted QOS different to Requested QOS; topics: [baz, fix] " + "requested: [1, 1] granted: [2, 0]")));
    new DirectFieldAccessor(adapter).setPropertyValue("running", Boolean.TRUE);
    adapter.stop();
    verify(client).disconnectForcibly(5_000L);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static IMqttToken createMockIMqttToken(int[] grantedQos) {
    IMqttToken token = mock(IMqttToken.class);
    given(token.getGrantedQos()).willReturn(grantedQos);
    return token;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_34
- **Scope**: method level
- **Mocked Class**: `java.net.Socket`
- **Test Case Count**: 3
- **MO Count**: 4

### Reusable Method
```java
private static Socket createMockSocket(InputStream inputStream, InetAddress inetAddress) {
    Socket socket = mock(Socket.class);
    when(socket.getInputStream()).thenReturn(inputStream);
    when(socket.getInetAddress()).thenReturn(inetAddress);
    return socket;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_34_1
#### Test Case Name: `testNetClient`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\SocketSupportTests.java`)
#### Mock Object Variable Name: `socket`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SocketFactory factory = Mockito.mock(SocketFactory.class);
    when(factorySupport.getSocketFactory()).thenReturn(factory);
-    Socket socket = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
-    when(socket.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
-    when(socket.getInetAddress()).thenReturn(inetAddress);
+    Socket socket = createMockSocket(is, inetAddress);
    when(factory.createSocket()).thenReturn(socket);
    TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);
    TcpNetClientConnectionFactory connectionFactory = new TcpNetClientConnectionFactory("x", 0);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testNetClient() throws Exception {
    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
    SocketFactory factory = Mockito.mock(SocketFactory.class);
    when(factorySupport.getSocketFactory()).thenReturn(factory);
    Socket socket = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
    when(socket.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
    when(socket.getInetAddress()).thenReturn(inetAddress);
    when(factory.createSocket()).thenReturn(socket);
    TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);
    TcpNetClientConnectionFactory connectionFactory = new TcpNetClientConnectionFactory("x", 0);
    connectionFactory.setTcpSocketFactorySupport(factorySupport);
    connectionFactory.setTcpSocketSupport(socketSupport);
    connectionFactory.start();
    connectionFactory.getConnection();
    verify(socketSupport).postProcessSocket(socket);
    connectionFactory.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Socket createMockSocket(InputStream inputStream, InetAddress inetAddress) {
    Socket socket = mock(Socket.class);
    when(socket.getInputStream()).thenReturn(inputStream);
    when(socket.getInetAddress()).thenReturn(inetAddress);
    return socket;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_34_2
#### Test Case Name: `testNetClientSocketTimeout`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\SocketSupportTests.java`)
#### Mock Object Variable Name: `socket`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SocketFactory factory = Mockito.mock(SocketFactory.class);
    when(factorySupport.getSocketFactory()).thenReturn(factory);
-    Socket socket = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
-    when(socket.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
-    when(socket.getInetAddress()).thenReturn(inetAddress);
+    Socket socket = createMockSocket(is, inetAddress);
    when(factory.createSocket()).thenReturn(socket);
    doThrow(new SocketTimeoutException()).when(socket).connect(any(), eq(1000));
    TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);
    TcpNetClientConnectionFactory connectionFactory = new TcpNetClientConnectionFactory("x", 0);
    connectionFactory.setConnectTimeout(1);
    connectionFactory.setTcpSocketFactorySupport(factorySupport);
    connectionFactory.setTcpSocketSupport(socketSupport);
    connectionFactory.start();
    assertThatThrownBy(connectionFactory::getConnection).isInstanceOf(UncheckedIOException.class).hasCauseInstanceOf(SocketTimeoutException.class);
    connectionFactory.stop();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testNetClientSocketTimeout() throws Exception {
    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
    SocketFactory factory = Mockito.mock(SocketFactory.class);
    when(factorySupport.getSocketFactory()).thenReturn(factory);
    Socket socket = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
    when(socket.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
    when(socket.getInetAddress()).thenReturn(inetAddress);
    when(factory.createSocket()).thenReturn(socket);
    doThrow(new SocketTimeoutException()).when(socket).connect(any(), eq(1000));
    TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);
    TcpNetClientConnectionFactory connectionFactory = new TcpNetClientConnectionFactory("x", 0);
    connectionFactory.setConnectTimeout(1);
    connectionFactory.setTcpSocketFactorySupport(factorySupport);
    connectionFactory.setTcpSocketSupport(socketSupport);
    connectionFactory.start();
    assertThatThrownBy(connectionFactory::getConnection).isInstanceOf(UncheckedIOException.class).hasCauseInstanceOf(SocketTimeoutException.class);
    connectionFactory.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Socket createMockSocket(InputStream inputStream, InetAddress inetAddress) {
    Socket socket = mock(Socket.class);
    when(socket.getInputStream()).thenReturn(inputStream);
    when(socket.getInetAddress()).thenReturn(inetAddress);
    return socket;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_34_3
#### Test Case Name: `testNetServer`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\SocketSupportTests.java`)
#### Mock Object Variable Name: `socket`
<summary>Suggested Diff</summary>

```diff
@@
    when(factorySupport.getServerSocketFactory()).thenReturn(factory);
-    Socket socket = mock(Socket.class);
+    Socket socket = createMockSocket(is, inetAddress);
    Socket socket1 = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
-    when(socket.getInputStream()).thenReturn(is);
    when(socket1.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
-    when(socket.getInetAddress()).thenReturn(inetAddress);
    when(socket1.getInetAddress()).thenReturn(inetAddress);
    ServerSocket serverSocket = mock(ServerSocket.class);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testNetServer() throws Exception {
    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
    ServerSocketFactory factory = mock(ServerSocketFactory.class);
    when(factorySupport.getServerSocketFactory()).thenReturn(factory);
    Socket socket = mock(Socket.class);
    Socket socket1 = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
    when(socket.getInputStream()).thenReturn(is);
    when(socket1.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
    when(socket.getInetAddress()).thenReturn(inetAddress);
    when(socket1.getInetAddress()).thenReturn(inetAddress);
    ServerSocket serverSocket = mock(ServerSocket.class);
    AtomicBoolean closed = new AtomicBoolean();
    doAnswer(invoc -> {
        closed.set(true);
        return null;
    }).when(serverSocket).close();
    when(serverSocket.getInetAddress()).thenReturn(inetAddress);
    when(factory.createServerSocket(0, 5)).thenReturn(serverSocket);
    final CountDownLatch latch1 = new CountDownLatch(1);
    final CountDownLatch latch2 = new CountDownLatch(1);
    when(serverSocket.accept()).thenReturn(socket).then(invocation -> {
        if (closed.get()) {
            throw new SocketException();
        }
        latch1.countDown();
        latch2.await(10, TimeUnit.SECONDS);
        Thread.sleep(50);
        return socket1;
    });
    TcpSocketSupport socketSupport = mock(TcpSocketSupport.class);
    TcpNetServerConnectionFactory connectionFactory = new TcpNetServerConnectionFactory(0);
    connectionFactory.setTcpSocketFactorySupport(factorySupport);
    connectionFactory.setTcpSocketSupport(socketSupport);
    connectionFactory.registerListener(mock(TcpListener.class));
    connectionFactory.start();
    assertThat(latch1.await(10, TimeUnit.SECONDS)).isTrue();
    verify(socketSupport).postProcessServerSocket(serverSocket);
    verify(socketSupport).postProcessSocket(socket);
    latch2.countDown();
    connectionFactory.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Socket createMockSocket(InputStream inputStream, InetAddress inetAddress) {
    Socket socket = mock(Socket.class);
    when(socket.getInputStream()).thenReturn(inputStream);
    when(socket.getInetAddress()).thenReturn(inetAddress);
    return socket;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_34_4
#### Test Case Name: `testNetServer`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\SocketSupportTests.java`)
#### Mock Object Variable Name: `socket1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Socket socket = mock(Socket.class);
-    Socket socket1 = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
    when(socket.getInputStream()).thenReturn(is);
+    Socket socket1 = createMockSocket(is, inetAddress);
    InetAddress inetAddress = InetAddress.getLocalHost();
    when(socket.getInetAddress()).thenReturn(inetAddress);
-    when(socket1.getInputStream()).thenReturn(is);
-    when(socket1.getInetAddress()).thenReturn(inetAddress);
    ServerSocket serverSocket = mock(ServerSocket.class);
    AtomicBoolean closed = new AtomicBoolean();
    doAnswer(invoc -> {
        closed.set(true);
        return null;
    }).when(serverSocket).close();
    when(serverSocket.getInetAddress()).thenReturn(inetAddress);
    when(factory.createServerSocket(0, 5)).thenReturn(serverSocket);
    final CountDownLatch latch1 = new CountDownLatch(1);
    final CountDownLatch latch2 = new CountDownLatch(1);
    when(serverSocket.accept()).thenReturn(socket).then(invocation -> {
        if (closed.get()) {
            throw new SocketException();
        }
        latch1.countDown();
        latch2.await(10, TimeUnit.SECONDS);
        Thread.sleep(50);
        return socket1;
    });
    TcpSocketSupport socketSupport = mock(TcpSocketSupport.class);
    TcpNetServerConnectionFactory connectionFactory = new TcpNetServerConnectionFactory(0);
    connectionFactory.setTcpSocketFactorySupport(factorySupport);
    connectionFactory.setTcpSocketSupport(socketSupport);
    connectionFactory.registerListener(mock(TcpListener.class));
    connectionFactory.start();
    assertThat(latch1.await(10, TimeUnit.SECONDS)).isTrue();
    verify(socketSupport).postProcessServerSocket(serverSocket);
    verify(socketSupport).postProcessSocket(socket);
    latch2.countDown();
    connectionFactory.stop();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testNetServer() throws Exception {
    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
    ServerSocketFactory factory = mock(ServerSocketFactory.class);
    when(factorySupport.getServerSocketFactory()).thenReturn(factory);
    Socket socket = mock(Socket.class);
    Socket socket1 = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
    when(socket.getInputStream()).thenReturn(is);
    when(socket1.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
    when(socket.getInetAddress()).thenReturn(inetAddress);
    when(socket1.getInetAddress()).thenReturn(inetAddress);
    ServerSocket serverSocket = mock(ServerSocket.class);
    AtomicBoolean closed = new AtomicBoolean();
    doAnswer(invoc -> {
        closed.set(true);
        return null;
    }).when(serverSocket).close();
    when(serverSocket.getInetAddress()).thenReturn(inetAddress);
    when(factory.createServerSocket(0, 5)).thenReturn(serverSocket);
    final CountDownLatch latch1 = new CountDownLatch(1);
    final CountDownLatch latch2 = new CountDownLatch(1);
    when(serverSocket.accept()).thenReturn(socket).then(invocation -> {
        if (closed.get()) {
            throw new SocketException();
        }
        latch1.countDown();
        latch2.await(10, TimeUnit.SECONDS);
        Thread.sleep(50);
        return socket1;
    });
    TcpSocketSupport socketSupport = mock(TcpSocketSupport.class);
    TcpNetServerConnectionFactory connectionFactory = new TcpNetServerConnectionFactory(0);
    connectionFactory.setTcpSocketFactorySupport(factorySupport);
    connectionFactory.setTcpSocketSupport(socketSupport);
    connectionFactory.registerListener(mock(TcpListener.class));
    connectionFactory.start();
    assertThat(latch1.await(10, TimeUnit.SECONDS)).isTrue();
    verify(socketSupport).postProcessServerSocket(serverSocket);
    verify(socketSupport).postProcessSocket(socket);
    latch2.countDown();
    connectionFactory.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Socket createMockSocket(InputStream inputStream, InetAddress inetAddress) {
    Socket socket = mock(Socket.class);
    when(socket.getInputStream()).thenReturn(inputStream);
    when(socket.getInetAddress()).thenReturn(inetAddress);
    return socket;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_35
- **Scope**: method level
- **Mocked Class**: `java.net.Socket`
- **Test Case Count**: 6
- **MO Count**: 6

### Reusable Method
```java
// === Declare in class scope ===
private Socket socket;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    socket = mock(Socket.class);
}

// === Replace local variable in test with ===
socket;

```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_35_1
#### Test Case Name: `testByteArrayRead`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpNioConnectionTests.java`)
#### Mock Object Variable Name: `socket`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testByteArrayRead() throws Exception {
     SocketChannel socketChannel = mock(SocketChannel.class);
-    Socket socket = mock(Socket.class);
+    // removed local mock; replaced with global field `socket`
     when(socketChannel.socket()).thenReturn(socket);
     TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
     TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
     stream.write(ByteBuffer.wrap("foo".getBytes()));
     byte[] out = new byte[2];
     int n = stream.read(out);
     assertThat(n).isEqualTo(2);
     assertThat(new String(out)).isEqualTo("fo");
     out = new byte[2];
     n = stream.read(out);
     assertThat(n).isEqualTo(1);
     assertThat(new String(out)).isEqualTo("o\u0000");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testByteArrayRead() throws Exception {
    SocketChannel socketChannel = mock(SocketChannel.class);
    Socket socket = mock(Socket.class);
    when(socketChannel.socket()).thenReturn(socket);
    TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
    TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
    stream.write(ByteBuffer.wrap("foo".getBytes()));
    byte[] out = new byte[2];
    int n = stream.read(out);
    assertThat(n).isEqualTo(2);
    assertThat(new String(out)).isEqualTo("fo");
    out = new byte[2];
    n = stream.read(out);
    assertThat(n).isEqualTo(1);
    assertThat(new String(out)).isEqualTo("o\u0000");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Socket socket;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    socket = mock(Socket.class);
}

// === Replace local variable in test with ===
socket;

```
</details>

---
#### Test Case ID #spring-integration_Test_35_2
#### Test Case Name: `testByteArrayReadMulti`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpNioConnectionTests.java`)
#### Mock Object Variable Name: `socket`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testByteArrayReadMulti() throws Exception {
     SocketChannel socketChannel = mock(SocketChannel.class);
-    Socket socket = mock(Socket.class);
+    // removed local mock; replaced with global field `socket`
     when(socketChannel.socket()).thenReturn(socket);
     TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
     TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
     stream.write(ByteBuffer.wrap("foo".getBytes()));
     stream.write(ByteBuffer.wrap("bar".getBytes()));
     byte[] out = new byte[6];
     int n = stream.read(out);
     assertThat(n).isEqualTo(6);
     assertThat(new String(out)).isEqualTo("foobar");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testByteArrayReadMulti() throws Exception {
    SocketChannel socketChannel = mock(SocketChannel.class);
    Socket socket = mock(Socket.class);
    when(socketChannel.socket()).thenReturn(socket);
    TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
    TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
    stream.write(ByteBuffer.wrap("foo".getBytes()));
    stream.write(ByteBuffer.wrap("bar".getBytes()));
    byte[] out = new byte[6];
    int n = stream.read(out);
    assertThat(n).isEqualTo(6);
    assertThat(new String(out)).isEqualTo("foobar");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Socket socket;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    socket = mock(Socket.class);
}

// === Replace local variable in test with ===
socket;

```
</details>

---
#### Test Case ID #spring-integration_Test_35_3
#### Test Case Name: `testByteArrayReadWithOffset`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpNioConnectionTests.java`)
#### Mock Object Variable Name: `socket`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testByteArrayReadWithOffset() throws Exception {
     SocketChannel socketChannel = mock(SocketChannel.class);
-    Socket socket = mock(Socket.class);
+    // removed local mock; replaced with global field `socket`
     when(socketChannel.socket()).thenReturn(socket);
     TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
     TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
     stream.write(ByteBuffer.wrap("foo".getBytes()));
     byte[] out = new byte[5];
     int n = stream.read(out, 1, 4);
     assertThat(n).isEqualTo(3);
     assertThat(new String(out)).isEqualTo("\u0000foo\u0000");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testByteArrayReadWithOffset() throws Exception {
    SocketChannel socketChannel = mock(SocketChannel.class);
    Socket socket = mock(Socket.class);
    when(socketChannel.socket()).thenReturn(socket);
    TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
    TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
    stream.write(ByteBuffer.wrap("foo".getBytes()));
    byte[] out = new byte[5];
    int n = stream.read(out, 1, 4);
    assertThat(n).isEqualTo(3);
    assertThat(new String(out)).isEqualTo("\u0000foo\u0000");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Socket socket;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    socket = mock(Socket.class);
}

// === Replace local variable in test with ===
socket;

```
</details>

---
#### Test Case ID #spring-integration_Test_35_4
#### Test Case Name: `testByteArrayReadWithBadArgs`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpNioConnectionTests.java`)
#### Mock Object Variable Name: `socket`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testByteArrayReadWithBadArgs() throws Exception {
     SocketChannel socketChannel = mock(SocketChannel.class);
-    Socket socket = mock(Socket.class);
+    // removed local mock; replaced with global field `socket`
     when(socketChannel.socket()).thenReturn(socket);
     TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
     TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
     stream.write(ByteBuffer.wrap("foo".getBytes()));
     byte[] out = new byte[5];
     assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> stream.read(out, 1, 5));
     assertThatIllegalArgumentException().isThrownBy(() -> stream.read(null, 1, 5));
     assertThat(stream.read(out, 0, 0)).isEqualTo(0);
     assertThat(stream.read(out)).isEqualTo(3);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testByteArrayReadWithBadArgs() throws Exception {
    SocketChannel socketChannel = mock(SocketChannel.class);
    Socket socket = mock(Socket.class);
    when(socketChannel.socket()).thenReturn(socket);
    TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
    TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
    stream.write(ByteBuffer.wrap("foo".getBytes()));
    byte[] out = new byte[5];
    assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> stream.read(out, 1, 5));
    assertThatIllegalArgumentException().isThrownBy(() -> stream.read(null, 1, 5));
    assertThat(stream.read(out, 0, 0)).isEqualTo(0);
    assertThat(stream.read(out)).isEqualTo(3);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Socket socket;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    socket = mock(Socket.class);
}

// === Replace local variable in test with ===
socket;

```
</details>

---
#### Test Case ID #spring-integration_Test_35_5
#### Test Case Name: `testByteArrayBlocksForZeroRead`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpNioConnectionTests.java`)
#### Mock Object Variable Name: `socket`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testByteArrayBlocksForZeroRead() throws Exception {
     SocketChannel socketChannel = mock(SocketChannel.class);
-    Socket socket = mock(Socket.class);
+    // removed local mock; replaced with global field `socket`
     when(socketChannel.socket()).thenReturn(socket);
     TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
     final TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
     final CountDownLatch latch = new CountDownLatch(1);
     final byte[] out = new byte[4];
     this.executor.execute(() -> {
         try {
             stream.read(out);
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
         latch.countDown();
     });
     Thread.sleep(1000);
     assertThat(out[0]).isEqualTo((byte) 0x00);
     stream.write(ByteBuffer.wrap("foo".getBytes()));
     assertThat(latch.await(10, TimeUnit.SECONDS)).isTrue();
     assertThat(new String(out)).isEqualTo("foo\u0000");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testByteArrayBlocksForZeroRead() throws Exception {
    SocketChannel socketChannel = mock(SocketChannel.class);
    Socket socket = mock(Socket.class);
    when(socketChannel.socket()).thenReturn(socket);
    TcpNioConnection connection = new TcpNioConnection(socketChannel, false, false, null, null);
    final TcpNioConnection.ChannelInputStream stream = (ChannelInputStream) new DirectFieldAccessor(connection).getPropertyValue("channelInputStream");
    final CountDownLatch latch = new CountDownLatch(1);
    final byte[] out = new byte[4];
    this.executor.execute(() -> {
        try {
            stream.read(out);
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
        latch.countDown();
    });
    Thread.sleep(1000);
    assertThat(out[0]).isEqualTo((byte) 0x00);
    stream.write(ByteBuffer.wrap("foo".getBytes()));
    assertThat(latch.await(10, TimeUnit.SECONDS)).isTrue();
    assertThat(new String(out)).isEqualTo("foo\u0000");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Socket socket;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    socket = mock(Socket.class);
}

// === Replace local variable in test with ===
socket;

```
</details>

---
#### Test Case ID #spring-integration_Test_35_6
#### Test Case Name: `transferHeaders`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpNioConnectionTests.java`)
#### Mock Object Variable Name: `inSocket`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void transferHeaders() throws Exception {
-    Socket inSocket = mock(Socket.class);
+    // removed local mock; replaced with global field `socket`
     SocketChannel inChannel = mock(SocketChannel.class);
     when(inChannel.socket()).thenReturn(inSocket);
@@
-    when(inChannel.socket()).thenReturn(inSocket);
+    when(inChannel.socket()).thenReturn(socket);
     TcpNioConnection inboundConnection = new TcpNioConnection(inChannel, true, false, nullPublisher, null);
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void transferHeaders() throws Exception {
    Socket inSocket = mock(Socket.class);
    SocketChannel inChannel = mock(SocketChannel.class);
    when(inChannel.socket()).thenReturn(inSocket);
    TcpNioConnection inboundConnection = new TcpNioConnection(inChannel, true, false, nullPublisher, null);
    inboundConnection.setDeserializer(new MapJsonSerializer());
    MapMessageConverter inConverter = new MapMessageConverter();
    MessageConvertingTcpMessageMapper inMapper = new MessageConvertingTcpMessageMapper(inConverter);
    inboundConnection.setMapper(inMapper);
    final ByteArrayOutputStream written = new ByteArrayOutputStream();
    doAnswer(new Answer<Integer>() {

        @Override
        public Integer answer(InvocationOnMock invocation) {
            ByteBuffer buff = invocation.getArgument(0);
            byte[] bytes = written.toByteArray();
            buff.put(bytes);
            return bytes.length;
        }
    }).when(inChannel).read(any(ByteBuffer.class));
    Socket outSocket = mock(Socket.class);
    SocketChannel outChannel = mock(SocketChannel.class);
    when(outChannel.socket()).thenReturn(outSocket);
    TcpNioConnection outboundConnection = new TcpNioConnection(outChannel, true, false, nullPublisher, null);
    doAnswer(invocation -> {
        ByteBuffer buff = invocation.getArgument(0);
        byte[] bytes = new byte[buff.limit()];
        buff.get(bytes);
        written.write(bytes);
        return null;
    }).when(outChannel).write(any(ByteBuffer.class));
    MapMessageConverter outConverter = new MapMessageConverter();
    outConverter.setHeaderNames("bar");
    MessageConvertingTcpMessageMapper outMapper = new MessageConvertingTcpMessageMapper(outConverter);
    outboundConnection.setMapper(outMapper);
    outboundConnection.setSerializer(new MapJsonSerializer());
    Message<String> message = MessageBuilder.withPayload("foo").setHeader("bar", "baz").build();
    outboundConnection.send(message);
    final AtomicReference<Message<?>> inboundMessage = new AtomicReference<Message<?>>();
    final CountDownLatch latch = new CountDownLatch(1);
    TcpListener listener = message1 -> {
        inboundMessage.set(message1);
        latch.countDown();
        return false;
    };
    inboundConnection.registerListener(listener);
    inboundConnection.readPacket();
    assertThat(latch.await(10, TimeUnit.SECONDS)).isTrue();
    assertThat(inboundMessage.get()).isNotNull();
    assertThat(inboundMessage.get().getPayload()).isEqualTo("foo");
    assertThat(inboundMessage.get().getHeaders().get("bar")).isEqualTo("baz");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Socket socket;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    socket = mock(Socket.class);
}

// === Replace local variable in test with ===
socket;

```
</details>

---
## Mock Clone Instance #spring-integration_MCI_36
- **Scope**: method level
- **Mocked Class**: `org.springframework.kafka.core.ProducerFactory`
- **Test Case Count**: 4
- **MO Count**: 4

### Reusable Method
```java
private static ProducerFactory<?, ?> createMockProducerFactory(Producer<?, ?> producer) {
    ProducerFactory<?, ?> pf = mock(ProducerFactory.class);
    given(pf.createProducer()).willReturn(producer);
    return pf;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_36_1
#### Test Case Name: `immediateFailure`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `pf`
<summary>Suggested Diff</summary>

```diff
@@
    given(producer.send(any(), any())).willReturn(cf);
-    ProducerFactory pf = mock(ProducerFactory.class);
-    given(pf.createProducer()).willReturn(producer);
+    ProducerFactory pf = createMockProducerFactory(producer);
    KafkaTemplate template = new KafkaTemplate(pf);
    template.setDefaultTopic("foo");
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler<>(template);
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void immediateFailure() {
    Producer producer = mock(Producer.class);
    CompletableFuture cf = new CompletableFuture();
    RuntimeException rte = new RuntimeException("test.immediate");
    cf.completeExceptionally(rte);
    given(producer.send(any(), any())).willReturn(cf);
    ProducerFactory pf = mock(ProducerFactory.class);
    given(pf.createProducer()).willReturn(producer);
    KafkaTemplate template = new KafkaTemplate(pf);
    template.setDefaultTopic("foo");
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler<>(template);
    QueueChannel fails = new QueueChannel();
    handler.setSendFailureChannel(fails);
    assertThatExceptionOfType(MessageHandlingException.class).isThrownBy(() -> handler.handleMessage(new GenericMessage<>(""))).withCauseExactlyInstanceOf(KafkaException.class).withStackTraceContaining("test.immediate");
    Message<?> fail = fails.receive(0);
    assertThat(fail).isNotNull();
    assertThat(fail.getPayload()).asInstanceOf(throwable(KafkaSendFailureException.class)).cause().isInstanceOf(KafkaException.class).cause().isEqualTo(rte);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ProducerFactory<?, ?> createMockProducerFactory(Producer<?, ?> producer) {
    ProducerFactory<?, ?> pf = mock(ProducerFactory.class);
    given(pf.createProducer()).willReturn(producer);
    return pf;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_36_2
#### Test Case Name: `testFlush`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `pf`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testFlush() {
-    ProducerFactory pf = mock(ProducerFactory.class);
     Producer producer = mock(Producer.class);
-    given(pf.createProducer()).willReturn(producer);
+    ProducerFactory pf = createMockProducerFactory(producer);
     willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
     KafkaTemplate template = new KafkaTemplate(pf);
     KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testFlush() {
    ProducerFactory pf = mock(ProducerFactory.class);
    Producer producer = mock(Producer.class);
    given(pf.createProducer()).willReturn(producer);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    KafkaTemplate template = new KafkaTemplate(pf);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setTopicExpression(new LiteralExpression("bar"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.start();
    handler.handleMessage(new GenericMessage<>("foo", Collections.singletonMap(KafkaIntegrationHeaders.FLUSH, Boolean.TRUE)));
    InOrder inOrder = inOrder(producer);
    ArgumentCaptor<ProducerRecord> captor = ArgumentCaptor.forClass(ProducerRecord.class);
    inOrder.verify(producer).send(captor.capture(), any(Callback.class));
    inOrder.verify(producer).flush();
    handler.stop();
    assertThat(captor.getValue().headers().lastHeader(KafkaIntegrationHeaders.FLUSH)).isNull();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ProducerFactory<?, ?> createMockProducerFactory(Producer<?, ?> producer) {
    ProducerFactory<?, ?> pf = mock(ProducerFactory.class);
    given(pf.createProducer()).willReturn(producer);
    return pf;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_36_3
#### Test Case Name: `testNoFlush`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `pf`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @SuppressWarnings({ "rawtypes", "unchecked" })
 @Test
 void testNoFlush() {
-    ProducerFactory pf = mock(ProducerFactory.class);
     Producer producer = mock(Producer.class);
-    given(pf.createProducer()).willReturn(producer);
+    ProducerFactory pf = createMockProducerFactory(producer);
     willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
     KafkaTemplate template = new KafkaTemplate(pf);
     KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
     handler.setTopicExpression(new LiteralExpression("bar"));
     handler.setBeanFactory(mock(BeanFactory.class));
     handler.afterPropertiesSet();
     handler.start();
     handler.handleMessage(new GenericMessage<>("foo"));
     InOrder inOrder = inOrder(producer);
     inOrder.verify(producer).send(any(ProducerRecord.class), any(Callback.class));
     inOrder.verify(producer, never()).flush();
     handler.stop();
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testNoFlush() {
    ProducerFactory pf = mock(ProducerFactory.class);
    Producer producer = mock(Producer.class);
    given(pf.createProducer()).willReturn(producer);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    KafkaTemplate template = new KafkaTemplate(pf);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setTopicExpression(new LiteralExpression("bar"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.start();
    handler.handleMessage(new GenericMessage<>("foo"));
    InOrder inOrder = inOrder(producer);
    inOrder.verify(producer).send(any(ProducerRecord.class), any(Callback.class));
    inOrder.verify(producer, never()).flush();
    handler.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ProducerFactory<?, ?> createMockProducerFactory(Producer<?, ?> producer) {
    ProducerFactory<?, ?> pf = mock(ProducerFactory.class);
    given(pf.createProducer()).willReturn(producer);
    return pf;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_36_4
#### Test Case Name: `conversion`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `pf`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @SuppressWarnings({ "rawtypes", "unchecked" })
 @Test
 void conversion() {
-    ProducerFactory pf = mock(ProducerFactory.class);
     Producer producer = mock(Producer.class);
-    given(pf.createProducer()).willReturn(producer);
+    ProducerFactory pf = createMockProducerFactory(producer);
     willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
     KafkaTemplate template = new KafkaTemplate(pf);
     RecordMessageConverter converter = mock(RecordMessageConverter.class);
     ProducerRecord recordFromConverter = mock(ProducerRecord.class);
     given(converter.fromMessage(any(), any())).willReturn(recordFromConverter);
     template.setMessageConverter(converter);
     KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
     handler.setTopicExpression(new LiteralExpression("bar"));
     handler.setBeanFactory(mock(BeanFactory.class));
     ProducerRecordCreator creator = mock(ProducerRecordCreator.class);
     ProducerRecord recordFromCreator = mock(ProducerRecord.class);
     given(creator.create(any(), any(), any(), any(), any(), any(), any())).willReturn(recordFromCreator);
     handler.setProducerRecordCreator(creator);
     handler.afterPropertiesSet();
     handler.start();
     handler.handleMessage(new GenericMessage<>("foo"));
     ArgumentCaptor<ProducerRecord> captor = ArgumentCaptor.forClass(ProducerRecord.class);
     verify(producer).send(captor.capture(), any(Callback.class));
     assertThat(captor.getValue()).isSameAs(recordFromCreator);
     handler.setUseTemplateConverter(true);
     handler.handleMessage(new GenericMessage<>("foo"));
     verify(producer, times(2)).send(captor.capture(), any(Callback.class));
     assertThat(captor.getValue()).isSameAs(recordFromConverter);
     handler.stop();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void conversion() {
    ProducerFactory pf = mock(ProducerFactory.class);
    Producer producer = mock(Producer.class);
    given(pf.createProducer()).willReturn(producer);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    KafkaTemplate template = new KafkaTemplate(pf);
    RecordMessageConverter converter = mock(RecordMessageConverter.class);
    ProducerRecord recordFromConverter = mock(ProducerRecord.class);
    given(converter.fromMessage(any(), any())).willReturn(recordFromConverter);
    template.setMessageConverter(converter);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setTopicExpression(new LiteralExpression("bar"));
    handler.setBeanFactory(mock(BeanFactory.class));
    ProducerRecordCreator creator = mock(ProducerRecordCreator.class);
    ProducerRecord recordFromCreator = mock(ProducerRecord.class);
    given(creator.create(any(), any(), any(), any(), any(), any(), any())).willReturn(recordFromCreator);
    handler.setProducerRecordCreator(creator);
    handler.afterPropertiesSet();
    handler.start();
    handler.handleMessage(new GenericMessage<>("foo"));
    ArgumentCaptor<ProducerRecord> captor = ArgumentCaptor.forClass(ProducerRecord.class);
    verify(producer).send(captor.capture(), any(Callback.class));
    assertThat(captor.getValue()).isSameAs(recordFromCreator);
    handler.setUseTemplateConverter(true);
    handler.handleMessage(new GenericMessage<>("foo"));
    verify(producer, times(2)).send(captor.capture(), any(Callback.class));
    assertThat(captor.getValue()).isSameAs(recordFromConverter);
    handler.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ProducerFactory<?, ?> createMockProducerFactory(Producer<?, ?> producer) {
    ProducerFactory<?, ?> pf = mock(ProducerFactory.class);
    given(pf.createProducer()).willReturn(producer);
    return pf;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_37
- **Scope**: method level
- **Mocked Class**: `org.springframework.kafka.core.ProducerFactory`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static ProducerFactory<?, ?> createMockProducerFactory() {
    ProducerFactory<?, ?> pf = mock(ProducerFactory.class);
    given(pf.transactionCapable()).willReturn(true);
    return pf;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_37_1
#### Test Case Name: `testTransaction`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `pf`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testTransaction() {
-    ProducerFactory pf = mock(ProducerFactory.class);
-    given(pf.transactionCapable()).willReturn(true);
+    ProducerFactory pf = createMockProducerFactory();
    Producer producer = mock(Producer.class);
-    given(pf.createProducer(isNull())).willReturn(producer);
+    given(pf.createProducer(isNull())).willReturn(producer);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    KafkaTemplate template = new KafkaTemplate(pf);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setTopicExpression(new LiteralExpression("bar"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.start();
    handler.handleMessage(new GenericMessage<>("foo"));
    handler.stop();
    InOrder inOrder = inOrder(producer);
    inOrder.verify(producer).beginTransaction();
    inOrder.verify(producer).send(any(ProducerRecord.class), any(Callback.class));
    inOrder.verify(producer).commitTransaction();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testTransaction() {
    ProducerFactory pf = mock(ProducerFactory.class);
    given(pf.transactionCapable()).willReturn(true);
    Producer producer = mock(Producer.class);
    given(pf.createProducer(isNull())).willReturn(producer);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    KafkaTemplate template = new KafkaTemplate(pf);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setTopicExpression(new LiteralExpression("bar"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.start();
    handler.handleMessage(new GenericMessage<>("foo"));
    handler.stop();
    InOrder inOrder = inOrder(producer);
    inOrder.verify(producer).beginTransaction();
    inOrder.verify(producer).send(any(ProducerRecord.class), any(Callback.class));
    inOrder.verify(producer).commitTransaction();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ProducerFactory<?, ?> createMockProducerFactory() {
    ProducerFactory<?, ?> pf = mock(ProducerFactory.class);
    given(pf.transactionCapable()).willReturn(true);
    return pf;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_37_2
#### Test Case Name: `testConsumeAndProduceTransaction`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `pf`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    willAnswer(i -> {
        closeLatch.countDown();
        return null;
    }).given(producer).close(any());
-    ProducerFactory pf = mock(ProducerFactory.class);
-    given(pf.transactionCapable()).willReturn(true);
+    ProducerFactory pf = createMockProducerFactory();
    willReturn(producer).given(pf).createProducer(isNull());
    KafkaTransactionManager ptm = new KafkaTransactionManager(pf);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "unchecked", "rawtypes" })
@Test
void testConsumeAndProduceTransaction() throws Exception {
    Consumer mockConsumer = mock(Consumer.class);
    final TopicPartition topicPartition = new TopicPartition("foo", 0);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(mockConsumer).subscribe(any(Collection.class), any(ConsumerRebalanceListener.class));
    ConsumerRecords records = new ConsumerRecords(Collections.singletonMap(topicPartition, Collections.singletonList(new ConsumerRecord<>("foo", 0, 0, "key", "value"))));
    final AtomicBoolean done = new AtomicBoolean();
    willAnswer(i -> {
        if (done.compareAndSet(false, true)) {
            return records;
        } else {
            Thread.sleep(500);
            return null;
        }
    }).given(mockConsumer).poll(any(Duration.class));
    ConsumerGroupMetadata meta = new ConsumerGroupMetadata("group");
    given(mockConsumer.groupMetadata()).willReturn(meta);
    ConsumerFactory cf = mock(ConsumerFactory.class);
    willReturn(mockConsumer).given(cf).createConsumer("group", "", null, KafkaTestUtils.defaultPropertyOverrides());
    Producer producer = mock(Producer.class);
    given(producer.send(any(), any())).willReturn(mock(Future.class));
    final CountDownLatch closeLatch = new CountDownLatch(2);
    willAnswer(i -> {
        closeLatch.countDown();
        return null;
    }).given(producer).close(any());
    ProducerFactory pf = mock(ProducerFactory.class);
    given(pf.transactionCapable()).willReturn(true);
    willReturn(producer).given(pf).createProducer(isNull());
    KafkaTransactionManager ptm = new KafkaTransactionManager(pf);
    ContainerProperties props = new ContainerProperties("foo");
    props.setGroupId("group");
    props.setKafkaAwareTransactionManager(ptm);
    props.setAssignmentCommitOption(AssignmentCommitOption.ALWAYS);
    final KafkaTemplate template = new KafkaTemplate(pf);
    KafkaMessageListenerContainer container = new KafkaMessageListenerContainer<>(cf, props);
    container.setBeanName("commit");
    KafkaMessageDrivenChannelAdapter inbound = new KafkaMessageDrivenChannelAdapter<>(container);
    DirectChannel channel = new DirectChannel();
    inbound.setOutputChannel(channel);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setMessageKeyExpression(new LiteralExpression("bar"));
    handler.setTopicExpression(new LiteralExpression("topic"));
    channel.subscribe(handler);
    inbound.afterPropertiesSet();
    inbound.start();
    assertThat(closeLatch.await(10, TimeUnit.SECONDS)).isTrue();
    InOrder inOrder = inOrder(producer);
    inOrder.verify(producer).beginTransaction();
    inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(0)), meta);
    inOrder.verify(producer).commitTransaction();
    inOrder.verify(producer).close(any());
    inOrder.verify(producer).beginTransaction();
    ArgumentCaptor<ProducerRecord> captor = ArgumentCaptor.forClass(ProducerRecord.class);
    inOrder.verify(producer).send(captor.capture(), any(Callback.class));
    assertThat(captor.getValue()).isEqualTo(new ProducerRecord("topic", null, "bar", "value"));
    inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1)), meta);
    inOrder.verify(producer).commitTransaction();
    inOrder.verify(producer).close(any());
    container.stop();
    verify(pf, times(2)).createProducer(isNull());
    verifyNoMoreInteractions(producer);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ProducerFactory<?, ?> createMockProducerFactory() {
    ProducerFactory<?, ?> pf = mock(ProducerFactory.class);
    given(pf.transactionCapable()).willReturn(true);
    return pf;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_37_3
#### Test Case Name: `testTransactionSynch`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `pf`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Producer producer = mock(Producer.class);
-    ProducerFactory pf = mock(ProducerFactory.class);
-    given(pf.transactionCapable()).willReturn(true);
-    given(pf.createProducer(isNull())).willReturn(producer);
+    ProducerFactory pf = createMockProducerFactory();
+    given(pf.createProducer(isNull())).willReturn(producer);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    KafkaTemplate template = new KafkaTemplate(pf);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testTransactionSynch() {
    Producer producer = mock(Producer.class);
    ProducerFactory pf = mock(ProducerFactory.class);
    given(pf.transactionCapable()).willReturn(true);
    given(pf.createProducer(isNull())).willReturn(producer);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    KafkaTemplate template = new KafkaTemplate(pf);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setTopicExpression(new LiteralExpression("bar"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.start();
    try {
        new TransactionTemplate(new SomeOtherTransactionManager()).executeWithoutResult(status -> {
            handler.handleMessage(new GenericMessage<>("foo"));
            throw new IllegalStateException("test");
        });
    } catch (IllegalStateException ex) {
    }
    handler.stop();
    verify(producer).beginTransaction();
    verify(producer).send(any(ProducerRecord.class), any(Callback.class));
    verify(producer).abortTransaction();
    verify(producer).close(any());
    verifyNoMoreInteractions(producer);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ProducerFactory<?, ?> createMockProducerFactory() {
    ProducerFactory<?, ?> pf = mock(ProducerFactory.class);
    given(pf.transactionCapable()).willReturn(true);
    return pf;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_38
- **Scope**: method level
- **Mocked Class**: `org.springframework.amqp.rabbit.connection.ConnectionFactory`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static ConnectionFactory createMockConnectionFactory(Connection connection) {
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    when(connectionFactory.createConnection()).thenReturn(connection);
    return connectionFactory;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_38_1
#### Test Case Name: `testPtP`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\channel\DispatcherHasNoSubscribersTests.java`)
#### Mock Object Variable Name: `connectionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    doAnswer(invocation -> channel).when(connection).createChannel(anyBoolean());
-    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
-    when(connectionFactory.createConnection()).thenReturn(connection);
+    ConnectionFactory connectionFactory = createMockConnectionFactory(connection);
    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
    container.setConnectionFactory(connectionFactory);
    AmqpTemplate amqpTemplate = mock(AmqpTemplate.class);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testPtP() throws Exception {
    final Channel channel = mock(Channel.class);
    DeclareOk declareOk = mock(DeclareOk.class);
    when(declareOk.getQueue()).thenReturn("noSubscribersChannel");
    when(channel.queueDeclare(anyString(), anyBoolean(), anyBoolean(), anyBoolean(), isNull())).thenReturn(declareOk);
    Connection connection = mock(Connection.class);
    doAnswer(invocation -> channel).when(connection).createChannel(anyBoolean());
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    when(connectionFactory.createConnection()).thenReturn(connection);
    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
    container.setConnectionFactory(connectionFactory);
    AmqpTemplate amqpTemplate = mock(AmqpTemplate.class);
    PointToPointSubscribableAmqpChannel amqpChannel = new PointToPointSubscribableAmqpChannel("noSubscribersChannel", container, amqpTemplate);
    amqpChannel.setBeanName("noSubscribersChannel");
    amqpChannel.setBeanFactory(mock(BeanFactory.class));
    amqpChannel.afterPropertiesSet();
    MessageListener listener = container.getMessageListener();
    assertThatExceptionOfType(MessageDeliveryException.class).isThrownBy(() -> listener.onMessage(new Message("Hello world!".getBytes()))).withMessageContaining("Dispatcher has no subscribers for amqp-channel 'noSubscribersChannel'.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConnectionFactory createMockConnectionFactory(Connection connection) {
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    when(connectionFactory.createConnection()).thenReturn(connection);
    return connectionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_38_2
#### Test Case Name: `testPubSub`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\channel\DispatcherHasNoSubscribersTests.java`)
#### Mock Object Variable Name: `connectionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    doAnswer(invocation -> channel).when(connection).createChannel(anyBoolean());
-    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
-    when(connectionFactory.createConnection()).thenReturn(connection);
+    ConnectionFactory connectionFactory = createMockConnectionFactory(connection);
    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
    container.setConnectionFactory(connectionFactory);
    AmqpTemplate amqpTemplate = mock(AmqpTemplate.class);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testPubSub() {
    final Channel channel = mock(Channel.class);
    Connection connection = mock(Connection.class);
    doAnswer(invocation -> channel).when(connection).createChannel(anyBoolean());
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    when(connectionFactory.createConnection()).thenReturn(connection);
    SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();
    container.setConnectionFactory(connectionFactory);
    AmqpTemplate amqpTemplate = mock(AmqpTemplate.class);
    PublishSubscribeAmqpChannel amqpChannel = new PublishSubscribeAmqpChannel("noSubscribersChannel", container, amqpTemplate);
    amqpChannel.setBeanName("noSubscribersChannel");
    amqpChannel.setBeanFactory(mock(BeanFactory.class));
    amqpChannel.afterPropertiesSet();
    List<String> logList = insertMockLoggerInListener(amqpChannel);
    MessageListener listener = container.getMessageListener();
    listener.onMessage(new Message("Hello world!".getBytes()));
    verifyLogReceived(logList);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConnectionFactory createMockConnectionFactory(Connection connection) {
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    when(connectionFactory.createConnection()).thenReturn(connection);
    return connectionFactory;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_39
- **Scope**: method level
- **Mocked Class**: `org.springframework.amqp.rabbit.connection.ConnectionFactory`
- **Test Case Count**: 5
- **MO Count**: 5

### Reusable Method
```java
// === Declare in class scope ===
private ConnectionFactory connectionFactory;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    connectionFactory = mock(ConnectionFactory.class);
}

// === Replace local variable in test with ===
connectionFactory

```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_39_1
#### Test Case Name: `testDelayExpression`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\outbound\OutboundEndpointTests.java`)
#### Mock Object Variable Name: `connectionFactory`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testDelayExpression() {
-    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+    // removed local mock; replaced with global field `connectionFactory`
     RabbitTemplate amqpTemplate = spy(new RabbitTemplate(connectionFactory));
     AmqpOutboundEndpoint endpoint = new AmqpOutboundEndpoint(amqpTemplate);
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testDelayExpression() {
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    RabbitTemplate amqpTemplate = spy(new RabbitTemplate(connectionFactory));
    AmqpOutboundEndpoint endpoint = new AmqpOutboundEndpoint(amqpTemplate);
    willDoNothing().given(amqpTemplate).send(anyString(), anyString(), any(Message.class), isNull());
    willAnswer(invocation -> invocation.getArgument(2)).given(amqpTemplate).sendAndReceive(anyString(), anyString(), any(Message.class), isNull());
    endpoint.setExchangeName("foo");
    endpoint.setRoutingKey("bar");
    endpoint.setDelayExpressionString("42");
    endpoint.setBeanFactory(mock(BeanFactory.class));
    endpoint.afterPropertiesSet();
    endpoint.handleMessage(new GenericMessage<>("foo"));
    ArgumentCaptor<Message> captor = ArgumentCaptor.forClass(Message.class);
    verify(amqpTemplate).send(eq("foo"), eq("bar"), captor.capture(), isNull());
    assertThat(captor.getValue().getMessageProperties().getDelayLong()).isEqualTo(42);
    endpoint.setExpectReply(true);
    endpoint.setOutputChannel(new NullChannel());
    endpoint.handleMessage(new GenericMessage<>("foo"));
    verify(amqpTemplate).sendAndReceive(eq("foo"), eq("bar"), captor.capture(), isNull());
    assertThat(captor.getValue().getMessageProperties().getDelayLong()).isEqualTo(42);
    endpoint.setDelay(23);
    endpoint.setRoutingKey("baz");
    endpoint.afterPropertiesSet();
    endpoint.handleMessage(new GenericMessage<>("foo"));
    verify(amqpTemplate).sendAndReceive(eq("foo"), eq("baz"), captor.capture(), isNull());
    assertThat(captor.getValue().getMessageProperties().getDelayLong()).isEqualTo(23);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private ConnectionFactory connectionFactory;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    connectionFactory = mock(ConnectionFactory.class);
}

// === Replace local variable in test with ===
connectionFactory

```
</details>

---
#### Test Case ID #spring-integration_Test_39_2
#### Test Case Name: `testAsyncDelayExpression`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\outbound\OutboundEndpointTests.java`)
#### Mock Object Variable Name: `connectionFactory`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testAsyncDelayExpression() {
-    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+    // removed local mock; replaced with global field `connectionFactory`
     AsyncRabbitTemplate amqpTemplate = spy(new AsyncRabbitTemplate(new RabbitTemplate(connectionFactory), new SimpleMessageListenerContainer(connectionFactory), "replyTo"));
     amqpTemplate.setTaskScheduler(mock(TaskScheduler.class));
     AsyncAmqpOutboundGateway gateway = new AsyncAmqpOutboundGateway(amqpTemplate);
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testAsyncDelayExpression() {
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    AsyncRabbitTemplate amqpTemplate = spy(new AsyncRabbitTemplate(new RabbitTemplate(connectionFactory), new SimpleMessageListenerContainer(connectionFactory), "replyTo"));
    amqpTemplate.setTaskScheduler(mock(TaskScheduler.class));
    AsyncAmqpOutboundGateway gateway = new AsyncAmqpOutboundGateway(amqpTemplate);
    willReturn(mock(RabbitMessageFuture.class)).given(amqpTemplate).sendAndReceive(anyString(), anyString(), any(Message.class));
    gateway.setExchangeName("foo");
    gateway.setRoutingKey("bar");
    gateway.setDelayExpressionString("42");
    gateway.setBeanFactory(mock(BeanFactory.class));
    gateway.setOutputChannel(new NullChannel());
    gateway.afterPropertiesSet();
    gateway.start();
    ArgumentCaptor<Message> captor = ArgumentCaptor.forClass(Message.class);
    gateway.handleMessage(new GenericMessage<>("foo"));
    verify(amqpTemplate).sendAndReceive(eq("foo"), eq("bar"), captor.capture());
    assertThat(captor.getValue().getMessageProperties().getDelayLong()).isEqualTo(42);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private ConnectionFactory connectionFactory;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    connectionFactory = mock(ConnectionFactory.class);
}

// === Replace local variable in test with ===
connectionFactory

```
</details>

---
#### Test Case ID #spring-integration_Test_39_3
#### Test Case Name: `testHeaderMapperWinsAdapter`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\outbound\OutboundEndpointTests.java`)
#### Mock Object Variable Name: `connectionFactory`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testHeaderMapperWinsAdapter() {
-    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+    // removed local mock; replaced with global field `connectionFactory`
     RabbitTemplate amqpTemplate = spy(new RabbitTemplate(connectionFactory));
     AmqpOutboundEndpoint endpoint = new AmqpOutboundEndpoint(amqpTemplate);
     endpoint.setHeadersMappedLast(true);
     final AtomicReference<Message> amqpMessage = new AtomicReference<>();
     willAnswer(invocation -> {
         amqpMessage.set(invocation.getArgument(2));
         return null;
     }).given(amqpTemplate).send(isNull(), isNull(), any(Message.class), isNull());
     org.springframework.messaging.Message<?> message = MessageBuilder.withPayload("foo").setHeader(MessageHeaders.CONTENT_TYPE, "bar").build();
     endpoint.handleMessage(message);
     assertThat(amqpMessage.get()).isNotNull();
     assertThat(amqpMessage.get().getMessageProperties().getContentType()).isEqualTo("bar");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testHeaderMapperWinsAdapter() {
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    RabbitTemplate amqpTemplate = spy(new RabbitTemplate(connectionFactory));
    AmqpOutboundEndpoint endpoint = new AmqpOutboundEndpoint(amqpTemplate);
    endpoint.setHeadersMappedLast(true);
    final AtomicReference<Message> amqpMessage = new AtomicReference<>();
    willAnswer(invocation -> {
        amqpMessage.set(invocation.getArgument(2));
        return null;
    }).given(amqpTemplate).send(isNull(), isNull(), any(Message.class), isNull());
    org.springframework.messaging.Message<?> message = MessageBuilder.withPayload("foo").setHeader(MessageHeaders.CONTENT_TYPE, "bar").build();
    endpoint.handleMessage(message);
    assertThat(amqpMessage.get()).isNotNull();
    assertThat(amqpMessage.get().getMessageProperties().getContentType()).isEqualTo("bar");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private ConnectionFactory connectionFactory;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    connectionFactory = mock(ConnectionFactory.class);
}

// === Replace local variable in test with ===
connectionFactory

```
</details>

---
#### Test Case ID #spring-integration_Test_39_4
#### Test Case Name: `testHeaderMapperWinsGateway`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\outbound\OutboundEndpointTests.java`)
#### Mock Object Variable Name: `connectionFactory`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testHeaderMapperWinsGateway() {
-    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+    // removed local mock; replaced with global field `connectionFactory`
     TestRabbitTemplate amqpTemplate = spy(new TestRabbitTemplate(connectionFactory));
     amqpTemplate.setUseTemporaryReplyQueues(true);
     AmqpOutboundEndpoint endpoint = new AmqpOutboundEndpoint(amqpTemplate);
     endpoint.setHeadersMappedLast(true);
     endpoint.setExpectReply(true);
     DefaultAmqpHeaderMapper mapper = DefaultAmqpHeaderMapper.inboundMapper();
     mapper.setRequestHeaderNames("*");
     endpoint.setHeaderMapper(mapper);
     final AtomicReference<Message> amqpMessage = new AtomicReference<>();
     willAnswer(invocation -> {
         amqpMessage.set(invocation.getArgument(2));
         return null;
     }).given(amqpTemplate).doSendAndReceiveWithTemporary(isNull(), isNull(), any(Message.class), isNull());
     org.springframework.messaging.Message<?> message = MessageBuilder.withPayload("foo").setHeader(MessageHeaders.CONTENT_TYPE, "bar").setReplyChannel(new QueueChannel()).build();
     endpoint.handleMessage(message);
     assertThat(amqpMessage.get()).isNotNull();
     assertThat(amqpMessage.get().getMessageProperties().getContentType()).isEqualTo("bar");
     assertThat(amqpMessage.get().getMessageProperties().getHeaders().get(MessageHeaders.REPLY_CHANNEL)).isNull();
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testHeaderMapperWinsGateway() {
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    TestRabbitTemplate amqpTemplate = spy(new TestRabbitTemplate(connectionFactory));
    amqpTemplate.setUseTemporaryReplyQueues(true);
    AmqpOutboundEndpoint endpoint = new AmqpOutboundEndpoint(amqpTemplate);
    endpoint.setHeadersMappedLast(true);
    endpoint.setExpectReply(true);
    DefaultAmqpHeaderMapper mapper = DefaultAmqpHeaderMapper.inboundMapper();
    mapper.setRequestHeaderNames("*");
    endpoint.setHeaderMapper(mapper);
    final AtomicReference<Message> amqpMessage = new AtomicReference<>();
    willAnswer(invocation -> {
        amqpMessage.set(invocation.getArgument(2));
        return null;
    }).given(amqpTemplate).doSendAndReceiveWithTemporary(isNull(), isNull(), any(Message.class), isNull());
    org.springframework.messaging.Message<?> message = MessageBuilder.withPayload("foo").setHeader(MessageHeaders.CONTENT_TYPE, "bar").setReplyChannel(new QueueChannel()).build();
    endpoint.handleMessage(message);
    assertThat(amqpMessage.get()).isNotNull();
    assertThat(amqpMessage.get().getMessageProperties().getContentType()).isEqualTo("bar");
    assertThat(amqpMessage.get().getMessageProperties().getHeaders().get(MessageHeaders.REPLY_CHANNEL)).isNull();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private ConnectionFactory connectionFactory;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    connectionFactory = mock(ConnectionFactory.class);
}

// === Replace local variable in test with ===
connectionFactory

```
</details>

---
#### Test Case ID #spring-integration_Test_39_5
#### Test Case Name: `testReplyHeadersWin`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\outbound\OutboundEndpointTests.java`)
#### Mock Object Variable Name: `connectionFactory`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testReplyHeadersWin() {
-    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
+    // removed local mock; replaced with global field `connectionFactory`
     TestRabbitTemplate amqpTemplate = spy(new TestRabbitTemplate(connectionFactory));
     amqpTemplate.setUseTemporaryReplyQueues(true);
     AmqpOutboundEndpoint endpoint = new AmqpOutboundEndpoint(amqpTemplate);
     endpoint.setExpectReply(true);
     willAnswer(invocation -> org.springframework.amqp.core.MessageBuilder.withBody(new byte[0]).setHeader(AbstractJavaTypeMapper.DEFAULT_CLASSID_FIELD_NAME, String.class.getName()).build()).given(amqpTemplate).doSendAndReceiveWithTemporary(isNull(), isNull(), any(Message.class), isNull());
     QueueChannel replyChannel = new QueueChannel();
     org.springframework.messaging.Message<?> message = MessageBuilder.withPayload("foo").setHeader(JsonHeaders.RESOLVABLE_TYPE, ResolvableType.forClass(Date.class)).setReplyChannel(replyChannel).build();
     endpoint.handleMessage(message);
     org.springframework.messaging.Message<?> receive = replyChannel.receive(10_000);
     assertThat(receive).isNotNull();
     assertThat(receive.getHeaders()).containsEntry(AbstractJavaTypeMapper.DEFAULT_CLASSID_FIELD_NAME, String.class.getName()).containsEntry(JsonHeaders.TYPE_ID, String.class.getName()).containsEntry(JsonHeaders.RESOLVABLE_TYPE, ResolvableType.forClass(String.class));
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testReplyHeadersWin() {
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    TestRabbitTemplate amqpTemplate = spy(new TestRabbitTemplate(connectionFactory));
    amqpTemplate.setUseTemporaryReplyQueues(true);
    AmqpOutboundEndpoint endpoint = new AmqpOutboundEndpoint(amqpTemplate);
    endpoint.setExpectReply(true);
    willAnswer(invocation -> org.springframework.amqp.core.MessageBuilder.withBody(new byte[0]).setHeader(AbstractJavaTypeMapper.DEFAULT_CLASSID_FIELD_NAME, String.class.getName()).build()).given(amqpTemplate).doSendAndReceiveWithTemporary(isNull(), isNull(), any(Message.class), isNull());
    QueueChannel replyChannel = new QueueChannel();
    org.springframework.messaging.Message<?> message = MessageBuilder.withPayload("foo").setHeader(JsonHeaders.RESOLVABLE_TYPE, ResolvableType.forClass(Date.class)).setReplyChannel(replyChannel).build();
    endpoint.handleMessage(message);
    org.springframework.messaging.Message<?> receive = replyChannel.receive(10_000);
    assertThat(receive).isNotNull();
    assertThat(receive.getHeaders()).containsEntry(AbstractJavaTypeMapper.DEFAULT_CLASSID_FIELD_NAME, String.class.getName()).containsEntry(JsonHeaders.TYPE_ID, String.class.getName()).containsEntry(JsonHeaders.RESOLVABLE_TYPE, ResolvableType.forClass(String.class));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private ConnectionFactory connectionFactory;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    connectionFactory = mock(ConnectionFactory.class);
}

// === Replace local variable in test with ===
connectionFactory

```
</details>

---
## Mock Clone Instance #spring-integration_MCI_40
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.ip.tcp.connection.TcpSocketSupport`
- **Test Case Count**: 4
- **MO Count**: 4

### Reusable Method
```java
// === Declare in class scope ===
private TcpSocketSupport sockSupp;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    sockSupp = mock(TcpSocketSupport.class);
}

// === Replace local variable in test with ===
sockSupp

```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_40_1
#### Test Case Name: `netCustomServer`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\dsl\ConnectionFactoryTests.java`)
#### Mock Object Variable Name: `sockSupp`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void netCustomServer() {
-    TcpSocketSupport sockSupp = mock(TcpSocketSupport.class);
+    // removed local mock; replaced with global field `sockSupp`
     TcpNetConnectionSupport conSupp = mock(TcpNetConnectionSupport.class);
     TcpSocketFactorySupport factSupp = mock(TcpSocketFactorySupport.class);
     TcpNetServerConnectionFactory server = Tcp.netServer(0).socketSupport(sockSupp).connectionSupport(conSupp).socketFactorySupport(factSupp).getObject();
     assertThat(TestUtils.getPropertyValue(server, "tcpSocketSupport")).isSameAs(sockSupp);
     assertThat(TestUtils.getPropertyValue(server, "tcpNetConnectionSupport")).isSameAs(conSupp);
     assertThat(TestUtils.getPropertyValue(server, "tcpSocketFactorySupport")).isSameAs(factSupp);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void netCustomServer() {
    TcpSocketSupport sockSupp = mock(TcpSocketSupport.class);
    TcpNetConnectionSupport conSupp = mock(TcpNetConnectionSupport.class);
    TcpSocketFactorySupport factSupp = mock(TcpSocketFactorySupport.class);
    TcpNetServerConnectionFactory server = Tcp.netServer(0).socketSupport(sockSupp).connectionSupport(conSupp).socketFactorySupport(factSupp).getObject();
    assertThat(TestUtils.getPropertyValue(server, "tcpSocketSupport")).isSameAs(sockSupp);
    assertThat(TestUtils.getPropertyValue(server, "tcpNetConnectionSupport")).isSameAs(conSupp);
    assertThat(TestUtils.getPropertyValue(server, "tcpSocketFactorySupport")).isSameAs(factSupp);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private TcpSocketSupport sockSupp;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    sockSupp = mock(TcpSocketSupport.class);
}

// === Replace local variable in test with ===
sockSupp

```
</details>

---
#### Test Case ID #spring-integration_Test_40_2
#### Test Case Name: `nioCustomServer`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\dsl\ConnectionFactoryTests.java`)
#### Mock Object Variable Name: `sockSupp`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void nioCustomServer() {
-    TcpSocketSupport sockSupp = mock(TcpSocketSupport.class);
+    // removed local mock; replaced with global field `sockSupp`
     TcpNioConnectionSupport conSupp = mock(TcpNioConnectionSupport.class);
     TcpNioServerConnectionFactory server = Tcp.nioServer(0).socketSupport(sockSupp).directBuffers(true).connectionSupport(conSupp).getObject();
     assertThat(TestUtils.getPropertyValue(server, "tcpSocketSupport")).isSameAs(sockSupp);
     assertThat(TestUtils.getPropertyValue(server, "usingDirectBuffers", Boolean.class)).isTrue();
     assertThat(TestUtils.getPropertyValue(server, "tcpNioConnectionSupport")).isSameAs(conSupp);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void nioCustomServer() {
    TcpSocketSupport sockSupp = mock(TcpSocketSupport.class);
    TcpNioConnectionSupport conSupp = mock(TcpNioConnectionSupport.class);
    TcpNioServerConnectionFactory server = Tcp.nioServer(0).socketSupport(sockSupp).directBuffers(true).connectionSupport(conSupp).getObject();
    assertThat(TestUtils.getPropertyValue(server, "tcpSocketSupport")).isSameAs(sockSupp);
    assertThat(TestUtils.getPropertyValue(server, "usingDirectBuffers", Boolean.class)).isTrue();
    assertThat(TestUtils.getPropertyValue(server, "tcpNioConnectionSupport")).isSameAs(conSupp);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private TcpSocketSupport sockSupp;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    sockSupp = mock(TcpSocketSupport.class);
}

// === Replace local variable in test with ===
sockSupp

```
</details>

---
#### Test Case ID #spring-integration_Test_40_3
#### Test Case Name: `netCustomClient`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\dsl\ConnectionFactoryTests.java`)
#### Mock Object Variable Name: `sockSupp`
<summary>Suggested Diff</summary>

```diff
@@
@Test
void netCustomClient() {
-    TcpSocketSupport sockSupp = mock(TcpSocketSupport.class);
+    // removed local mock; replaced with global field `sockSupp`
    TcpNetConnectionSupport conSupp = mock(TcpNetConnectionSupport.class);
    TcpSocketFactorySupport factSupp = mock(TcpSocketFactorySupport.class);
    TcpNetClientConnectionFactory client = Tcp.netClient("localhost", 0).socketSupport(sockSupp).connectionSupport(conSupp).socketFactorySupport(factSupp).getObject();
    assertThat(TestUtils.getPropertyValue(client, "tcpSocketSupport")).isSameAs(sockSupp);
    assertThat(TestUtils.getPropertyValue(client, "tcpNetConnectionSupport")).isSameAs(conSupp);
    assertThat(TestUtils.getPropertyValue(client, "tcpSocketFactorySupport")).isSameAs(factSupp);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void netCustomClient() {
    TcpSocketSupport sockSupp = mock(TcpSocketSupport.class);
    TcpNetConnectionSupport conSupp = mock(TcpNetConnectionSupport.class);
    TcpSocketFactorySupport factSupp = mock(TcpSocketFactorySupport.class);
    TcpNetClientConnectionFactory client = Tcp.netClient("localhost", 0).socketSupport(sockSupp).connectionSupport(conSupp).socketFactorySupport(factSupp).getObject();
    assertThat(TestUtils.getPropertyValue(client, "tcpSocketSupport")).isSameAs(sockSupp);
    assertThat(TestUtils.getPropertyValue(client, "tcpNetConnectionSupport")).isSameAs(conSupp);
    assertThat(TestUtils.getPropertyValue(client, "tcpSocketFactorySupport")).isSameAs(factSupp);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private TcpSocketSupport sockSupp;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    sockSupp = mock(TcpSocketSupport.class);
}

// === Replace local variable in test with ===
sockSupp

```
</details>

---
#### Test Case ID #spring-integration_Test_40_4
#### Test Case Name: `nioCustomClient`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\dsl\ConnectionFactoryTests.java`)
#### Mock Object Variable Name: `sockSupp`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void nioCustomClient() {
-    TcpSocketSupport sockSupp = mock(TcpSocketSupport.class);
+    // removed local mock; replaced with global field `sockSupp`
     TcpNioConnectionSupport conSupp = mock(TcpNioConnectionSupport.class);
     TcpNioClientConnectionFactory client = Tcp.nioClient("localhost", 0).socketSupport(sockSupp).directBuffers(true).connectionSupport(conSupp).getObject();
-    assertThat(TestUtils.getPropertyValue(client, "tcpSocketSupport")).isSameAs(sockSupp);
+    assertThat(TestUtils.getPropertyValue(client, "tcpSocketSupport")).isSameAs(sockSupp);
     assertThat(TestUtils.getPropertyValue(client, "usingDirectBuffers", Boolean.class)).isTrue();
     assertThat(TestUtils.getPropertyValue(client, "tcpNioConnectionSupport")).isSameAs(conSupp);
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void nioCustomClient() {
    TcpSocketSupport sockSupp = mock(TcpSocketSupport.class);
    TcpNioConnectionSupport conSupp = mock(TcpNioConnectionSupport.class);
    TcpNioClientConnectionFactory client = Tcp.nioClient("localhost", 0).socketSupport(sockSupp).directBuffers(true).connectionSupport(conSupp).getObject();
    assertThat(TestUtils.getPropertyValue(client, "tcpSocketSupport")).isSameAs(sockSupp);
    assertThat(TestUtils.getPropertyValue(client, "usingDirectBuffers", Boolean.class)).isTrue();
    assertThat(TestUtils.getPropertyValue(client, "tcpNioConnectionSupport")).isSameAs(conSupp);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private TcpSocketSupport sockSupp;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    sockSupp = mock(TcpSocketSupport.class);
}

// === Replace local variable in test with ===
sockSupp

```
</details>

---
## Mock Clone Instance #spring-integration_MCI_41
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.ip.tcp.connection.TcpSocketSupport`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
// === Declare in class scope ===
private TcpSocketSupport socketSupport;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    socketSupport = Mockito.mock(TcpSocketSupport.class);
}

// === Replace local variable in test with ===
socketSupport

```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_41_1
#### Test Case Name: `testNetClient`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\SocketSupportTests.java`)
#### Mock Object Variable Name: `socketSupport`
<summary>Suggested Diff</summary>

```diff
@@
     when(factory.createSocket()).thenReturn(socket);
-    TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);
+    // removed local mock; replaced with global field `socketSupport`
     TcpNetClientConnectionFactory connectionFactory = new TcpNetClientConnectionFactory("x", 0);
     connectionFactory.setTcpSocketFactorySupport(factorySupport);
     connectionFactory.setTcpSocketSupport(socketSupport);
     connectionFactory.start();
     connectionFactory.getConnection();
-    verify(socketSupport).postProcessSocket(socket);
+    verify(socketSupport).postProcessSocket(socket);
     connectionFactory.stop();
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testNetClient() throws Exception {
    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
    SocketFactory factory = Mockito.mock(SocketFactory.class);
    when(factorySupport.getSocketFactory()).thenReturn(factory);
    Socket socket = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
    when(socket.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
    when(socket.getInetAddress()).thenReturn(inetAddress);
    when(factory.createSocket()).thenReturn(socket);
    TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);
    TcpNetClientConnectionFactory connectionFactory = new TcpNetClientConnectionFactory("x", 0);
    connectionFactory.setTcpSocketFactorySupport(factorySupport);
    connectionFactory.setTcpSocketSupport(socketSupport);
    connectionFactory.start();
    connectionFactory.getConnection();
    verify(socketSupport).postProcessSocket(socket);
    connectionFactory.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private TcpSocketSupport socketSupport;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    socketSupport = Mockito.mock(TcpSocketSupport.class);
}

// === Replace local variable in test with ===
socketSupport

```
</details>

---
#### Test Case ID #spring-integration_Test_41_2
#### Test Case Name: `testNetClientSocketTimeout`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\SocketSupportTests.java`)
#### Mock Object Variable Name: `socketSupport`
<summary>Suggested Diff</summary>

```diff
@@
     doThrow(new SocketTimeoutException()).when(socket).connect(any(), eq(1000));
-    TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);
+    // removed local mock; replaced with global field `socketSupport`
     TcpNetClientConnectionFactory connectionFactory = new TcpNetClientConnectionFactory("x", 0);
     connectionFactory.setConnectTimeout(1);
     connectionFactory.setTcpSocketFactorySupport(factorySupport);
     connectionFactory.setTcpSocketSupport(socketSupport);
     connectionFactory.start();
     assertThatThrownBy(connectionFactory::getConnection).isInstanceOf(UncheckedIOException.class).hasCauseInstanceOf(SocketTimeoutException.class);
     connectionFactory.stop();
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testNetClientSocketTimeout() throws Exception {
    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
    SocketFactory factory = Mockito.mock(SocketFactory.class);
    when(factorySupport.getSocketFactory()).thenReturn(factory);
    Socket socket = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
    when(socket.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
    when(socket.getInetAddress()).thenReturn(inetAddress);
    when(factory.createSocket()).thenReturn(socket);
    doThrow(new SocketTimeoutException()).when(socket).connect(any(), eq(1000));
    TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);
    TcpNetClientConnectionFactory connectionFactory = new TcpNetClientConnectionFactory("x", 0);
    connectionFactory.setConnectTimeout(1);
    connectionFactory.setTcpSocketFactorySupport(factorySupport);
    connectionFactory.setTcpSocketSupport(socketSupport);
    connectionFactory.start();
    assertThatThrownBy(connectionFactory::getConnection).isInstanceOf(UncheckedIOException.class).hasCauseInstanceOf(SocketTimeoutException.class);
    connectionFactory.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private TcpSocketSupport socketSupport;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    socketSupport = Mockito.mock(TcpSocketSupport.class);
}

// === Replace local variable in test with ===
socketSupport

```
</details>

---
#### Test Case ID #spring-integration_Test_41_3
#### Test Case Name: `testNetServer`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\SocketSupportTests.java`)
#### Mock Object Variable Name: `socketSupport`
<summary>Suggested Diff</summary>

```diff
@@
     when(serverSocket.accept()).thenReturn(socket).then(invocation -> {
         if (closed.get()) {
             throw new SocketException();
         }
         latch1.countDown();
         latch2.await(10, TimeUnit.SECONDS);
         Thread.sleep(50);
         return socket1;
     });
-    TcpSocketSupport socketSupport = mock(TcpSocketSupport.class);
+    // removed local mock; replaced with global field `socketSupport`
     TcpNetServerConnectionFactory connectionFactory = new TcpNetServerConnectionFactory(0);
     connectionFactory.setTcpSocketFactorySupport(factorySupport);
     connectionFactory.setTcpSocketSupport(socketSupport);
     connectionFactory.registerListener(mock(TcpListener.class));
     connectionFactory.start();
     assertThat(latch1.await(10, TimeUnit.SECONDS)).isTrue();
-    verify(socketSupport).postProcessServerSocket(serverSocket);
+    verify(socketSupport).postProcessServerSocket(serverSocket);
-    verify(socketSupport).postProcessSocket(socket);
+    verify(socketSupport).postProcessSocket(socket);
     latch2.countDown();
     connectionFactory.stop();
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testNetServer() throws Exception {
    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
    ServerSocketFactory factory = mock(ServerSocketFactory.class);
    when(factorySupport.getServerSocketFactory()).thenReturn(factory);
    Socket socket = mock(Socket.class);
    Socket socket1 = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
    when(socket.getInputStream()).thenReturn(is);
    when(socket1.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
    when(socket.getInetAddress()).thenReturn(inetAddress);
    when(socket1.getInetAddress()).thenReturn(inetAddress);
    ServerSocket serverSocket = mock(ServerSocket.class);
    AtomicBoolean closed = new AtomicBoolean();
    doAnswer(invoc -> {
        closed.set(true);
        return null;
    }).when(serverSocket).close();
    when(serverSocket.getInetAddress()).thenReturn(inetAddress);
    when(factory.createServerSocket(0, 5)).thenReturn(serverSocket);
    final CountDownLatch latch1 = new CountDownLatch(1);
    final CountDownLatch latch2 = new CountDownLatch(1);
    when(serverSocket.accept()).thenReturn(socket).then(invocation -> {
        if (closed.get()) {
            throw new SocketException();
        }
        latch1.countDown();
        latch2.await(10, TimeUnit.SECONDS);
        Thread.sleep(50);
        return socket1;
    });
    TcpSocketSupport socketSupport = mock(TcpSocketSupport.class);
    TcpNetServerConnectionFactory connectionFactory = new TcpNetServerConnectionFactory(0);
    connectionFactory.setTcpSocketFactorySupport(factorySupport);
    connectionFactory.setTcpSocketSupport(socketSupport);
    connectionFactory.registerListener(mock(TcpListener.class));
    connectionFactory.start();
    assertThat(latch1.await(10, TimeUnit.SECONDS)).isTrue();
    verify(socketSupport).postProcessServerSocket(serverSocket);
    verify(socketSupport).postProcessSocket(socket);
    latch2.countDown();
    connectionFactory.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private TcpSocketSupport socketSupport;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    socketSupport = Mockito.mock(TcpSocketSupport.class);
}

// === Replace local variable in test with ===
socketSupport

```
</details>

---
## Mock Clone Instance #spring-integration_MCI_42
- **Scope**: method level
- **Mocked Class**: `org.springframework.messaging.support.ChannelInterceptor`
- **Test Case Count**: 4
- **MO Count**: 4

### Reusable Method
```java
// === Declare in class scope ===
private ChannelInterceptor channelInterceptor;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    channelInterceptor = mock(ChannelInterceptor.class);
}

// === Replace local variable in test with ===
channelInterceptor;

```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_42_1
#### Test Case Name: `testProcessorWithInterceptorDefaultPattern`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\config\GlobalChannelInterceptorProcessorTests.java`)
#### Mock Object Variable Name: `channelInterceptor`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testProcessorWithInterceptorDefaultPattern() {
     Map<String, GlobalChannelInterceptorWrapper> interceptors = new HashMap<>();
     Map<String, InterceptableChannel> channels = new HashMap<>();
-    ChannelInterceptor channelInterceptor = mock();
+    // removed local mock; replaced with global field `channelInterceptor`
     GlobalChannelInterceptorWrapper globalChannelInterceptorWrapper = new GlobalChannelInterceptorWrapper(channelInterceptor);
     InterceptableChannel channel = mock();
     interceptors.put("Test-1", globalChannelInterceptorWrapper);
     channels.put("Test-1", channel);
     when(this.beanFactory.getBeansOfType(GlobalChannelInterceptorWrapper.class)).thenReturn(interceptors);
     when(this.beanFactory.getBeansOfType(InterceptableChannel.class)).thenReturn(channels);
     this.globalChannelInterceptorProcessor.afterSingletonsInstantiated();
     verify(channel).addInterceptor(channelInterceptor);
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testProcessorWithInterceptorDefaultPattern() {
    Map<String, GlobalChannelInterceptorWrapper> interceptors = new HashMap<>();
    Map<String, InterceptableChannel> channels = new HashMap<>();
    ChannelInterceptor channelInterceptor = mock();
    GlobalChannelInterceptorWrapper globalChannelInterceptorWrapper = new GlobalChannelInterceptorWrapper(channelInterceptor);
    InterceptableChannel channel = mock();
    interceptors.put("Test-1", globalChannelInterceptorWrapper);
    channels.put("Test-1", channel);
    when(this.beanFactory.getBeansOfType(GlobalChannelInterceptorWrapper.class)).thenReturn(interceptors);
    when(this.beanFactory.getBeansOfType(InterceptableChannel.class)).thenReturn(channels);
    this.globalChannelInterceptorProcessor.afterSingletonsInstantiated();
    verify(channel).addInterceptor(channelInterceptor);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private ChannelInterceptor channelInterceptor;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    channelInterceptor = mock(ChannelInterceptor.class);
}

// === Replace local variable in test with ===
channelInterceptor;

```
</details>

---
#### Test Case ID #spring-integration_Test_42_2
#### Test Case Name: `testProcessorWithInterceptorMatchingPattern`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\config\GlobalChannelInterceptorProcessorTests.java`)
#### Mock Object Variable Name: `channelInterceptor`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testProcessorWithInterceptorMatchingPattern() {
     Map<String, GlobalChannelInterceptorWrapper> interceptors = new HashMap<>();
     Map<String, InterceptableChannel> channels = new HashMap<>();
-    ChannelInterceptor channelInterceptor = mock();
+    // removed local mock; replaced with global field `channelInterceptor`
     GlobalChannelInterceptorWrapper globalChannelInterceptorWrapper = new GlobalChannelInterceptorWrapper(channelInterceptor);
     InterceptableChannel channel = mock();
     globalChannelInterceptorWrapper.setPatterns(new String[] { "Te*" });
     interceptors.put("Test-1", globalChannelInterceptorWrapper);
     channels.put("Test-1", channel);
     when(this.beanFactory.getBeansOfType(GlobalChannelInterceptorWrapper.class)).thenReturn(interceptors);
     when(this.beanFactory.getBeansOfType(InterceptableChannel.class)).thenReturn(channels);
     this.globalChannelInterceptorProcessor.afterSingletonsInstantiated();
     verify(channel).addInterceptor(channelInterceptor);
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testProcessorWithInterceptorMatchingPattern() {
    Map<String, GlobalChannelInterceptorWrapper> interceptors = new HashMap<>();
    Map<String, InterceptableChannel> channels = new HashMap<>();
    ChannelInterceptor channelInterceptor = mock();
    GlobalChannelInterceptorWrapper globalChannelInterceptorWrapper = new GlobalChannelInterceptorWrapper(channelInterceptor);
    InterceptableChannel channel = mock();
    globalChannelInterceptorWrapper.setPatterns(new String[] { "Te*" });
    interceptors.put("Test-1", globalChannelInterceptorWrapper);
    channels.put("Test-1", channel);
    when(this.beanFactory.getBeansOfType(GlobalChannelInterceptorWrapper.class)).thenReturn(interceptors);
    when(this.beanFactory.getBeansOfType(InterceptableChannel.class)).thenReturn(channels);
    this.globalChannelInterceptorProcessor.afterSingletonsInstantiated();
    verify(channel).addInterceptor(channelInterceptor);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private ChannelInterceptor channelInterceptor;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    channelInterceptor = mock(ChannelInterceptor.class);
}

// === Replace local variable in test with ===
channelInterceptor;

```
</details>

---
#### Test Case ID #spring-integration_Test_42_3
#### Test Case Name: `testProcessorWithInterceptorNotMatchingPattern`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\config\GlobalChannelInterceptorProcessorTests.java`)
#### Mock Object Variable Name: `channelInterceptor`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testProcessorWithInterceptorNotMatchingPattern() {
     Map<String, GlobalChannelInterceptorWrapper> interceptors = new HashMap<>();
     Map<String, InterceptableChannel> channels = new HashMap<>();
-    ChannelInterceptor channelInterceptor = mock();
+    // removed local mock; replaced with global field `channelInterceptor`
     GlobalChannelInterceptorWrapper globalChannelInterceptorWrapper = new GlobalChannelInterceptorWrapper(channelInterceptor);
     InterceptableChannel channel = mock();
     globalChannelInterceptorWrapper.setPatterns(new String[] { "te*" });
     interceptors.put("Test-1", globalChannelInterceptorWrapper);
     channels.put("Test-1", channel);
     when(this.beanFactory.getBeansOfType(GlobalChannelInterceptorWrapper.class)).thenReturn(interceptors);
     when(this.beanFactory.getBeansOfType(InterceptableChannel.class)).thenReturn(channels);
     this.globalChannelInterceptorProcessor.afterSingletonsInstantiated();
-    verify(channel, never()).addInterceptor(channelInterceptor);
+    verify(channel, never()).addInterceptor(channelInterceptor);
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testProcessorWithInterceptorNotMatchingPattern() {
    Map<String, GlobalChannelInterceptorWrapper> interceptors = new HashMap<>();
    Map<String, InterceptableChannel> channels = new HashMap<>();
    ChannelInterceptor channelInterceptor = mock();
    GlobalChannelInterceptorWrapper globalChannelInterceptorWrapper = new GlobalChannelInterceptorWrapper(channelInterceptor);
    InterceptableChannel channel = mock();
    globalChannelInterceptorWrapper.setPatterns(new String[] { "te*" });
    interceptors.put("Test-1", globalChannelInterceptorWrapper);
    channels.put("Test-1", channel);
    when(this.beanFactory.getBeansOfType(GlobalChannelInterceptorWrapper.class)).thenReturn(interceptors);
    when(this.beanFactory.getBeansOfType(InterceptableChannel.class)).thenReturn(channels);
    this.globalChannelInterceptorProcessor.afterSingletonsInstantiated();
    verify(channel, never()).addInterceptor(channelInterceptor);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private ChannelInterceptor channelInterceptor;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    channelInterceptor = mock(ChannelInterceptor.class);
}

// === Replace local variable in test with ===
channelInterceptor;

```
</details>

---
#### Test Case ID #spring-integration_Test_42_4
#### Test Case Name: `testProcessorWithInterceptorMatchingNegativePattern`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\config\GlobalChannelInterceptorProcessorTests.java`)
#### Mock Object Variable Name: `channelInterceptor`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testProcessorWithInterceptorMatchingNegativePattern() {
     Map<String, GlobalChannelInterceptorWrapper> interceptors = new HashMap<>();
     Map<String, InterceptableChannel> channels = new HashMap<>();
-    ChannelInterceptor channelInterceptor = mock();
+    // removed local mock; replaced with global field `channelInterceptor`
     GlobalChannelInterceptorWrapper globalChannelInterceptorWrapper = new GlobalChannelInterceptorWrapper(channelInterceptor);
     InterceptableChannel channel = mock();
     globalChannelInterceptorWrapper.setPatterns(new String[] { "!te*", "!Te*" });
     interceptors.put("Test-1", globalChannelInterceptorWrapper);
     channels.put("Test-1", channel);
     when(this.beanFactory.getBeansOfType(GlobalChannelInterceptorWrapper.class)).thenReturn(interceptors);
     when(this.beanFactory.getBeansOfType(InterceptableChannel.class)).thenReturn(channels);
     this.globalChannelInterceptorProcessor.afterSingletonsInstantiated();
     verify(channel, never()).addInterceptor(channelInterceptor);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testProcessorWithInterceptorMatchingNegativePattern() {
    Map<String, GlobalChannelInterceptorWrapper> interceptors = new HashMap<>();
    Map<String, InterceptableChannel> channels = new HashMap<>();
    ChannelInterceptor channelInterceptor = mock();
    GlobalChannelInterceptorWrapper globalChannelInterceptorWrapper = new GlobalChannelInterceptorWrapper(channelInterceptor);
    InterceptableChannel channel = mock();
    globalChannelInterceptorWrapper.setPatterns(new String[] { "!te*", "!Te*" });
    interceptors.put("Test-1", globalChannelInterceptorWrapper);
    channels.put("Test-1", channel);
    when(this.beanFactory.getBeansOfType(GlobalChannelInterceptorWrapper.class)).thenReturn(interceptors);
    when(this.beanFactory.getBeansOfType(InterceptableChannel.class)).thenReturn(channels);
    this.globalChannelInterceptorProcessor.afterSingletonsInstantiated();
    verify(channel, never()).addInterceptor(channelInterceptor);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private ChannelInterceptor channelInterceptor;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    channelInterceptor = mock(ChannelInterceptor.class);
}

// === Replace local variable in test with ===
channelInterceptor;

```
</details>

---
## Mock Clone Instance #spring-integration_MCI_43
- **Scope**: method level
- **Mocked Class**: `org.springframework.web.socket.WebSocketSession`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static WebSocketSession createMockWebSocketSession(String protocol, String secondReturn) {
    WebSocketSession session = mock(WebSocketSession.class);
    when(session.getAcceptedProtocol()).thenReturn(protocol, secondReturn);
    return session;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_43_1
#### Test Case Name: `testProtocolHandlers`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-websocket\src\test\java\org\springframework\integration\websocket\support\SubProtocolHandlerRegistryTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SubProtocolHandler defaultProtocolHandler = mock(SubProtocolHandler.class);
    SubProtocolHandlerRegistry subProtocolHandlerRegistry = new SubProtocolHandlerRegistry(Collections.singletonList(new StompSubProtocolHandler()), defaultProtocolHandler);
-    WebSocketSession session = mock(WebSocketSession.class);
-    when(session.getAcceptedProtocol()).thenReturn("v10.stomp", (String) null);
+    WebSocketSession session = createMockWebSocketSession("v10.stomp", (String) null);
    SubProtocolHandler protocolHandler = subProtocolHandlerRegistry.findProtocolHandler(session);
    assertThat(protocolHandler).isNotNull();
    assertThat(protocolHandler).isInstanceOf(StompSubProtocolHandler.class);
    protocolHandler = subProtocolHandlerRegistry.findProtocolHandler(session);
    assertThat(protocolHandler).isNotNull();
    assertThat(defaultProtocolHandler).isSameAs(protocolHandler);
    assertThat(new StompSubProtocolHandler().getSupportedProtocols()).isEqualTo(subProtocolHandlerRegistry.getSubProtocols());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testProtocolHandlers() {
    SubProtocolHandler defaultProtocolHandler = mock(SubProtocolHandler.class);
    SubProtocolHandlerRegistry subProtocolHandlerRegistry = new SubProtocolHandlerRegistry(Collections.singletonList(new StompSubProtocolHandler()), defaultProtocolHandler);
    WebSocketSession session = mock(WebSocketSession.class);
    when(session.getAcceptedProtocol()).thenReturn("v10.stomp", (String) null);
    SubProtocolHandler protocolHandler = subProtocolHandlerRegistry.findProtocolHandler(session);
    assertThat(protocolHandler).isNotNull();
    assertThat(protocolHandler).isInstanceOf(StompSubProtocolHandler.class);
    protocolHandler = subProtocolHandlerRegistry.findProtocolHandler(session);
    assertThat(protocolHandler).isNotNull();
    assertThat(defaultProtocolHandler).isSameAs(protocolHandler);
    assertThat(new StompSubProtocolHandler().getSupportedProtocols()).isEqualTo(subProtocolHandlerRegistry.getSubProtocols());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static WebSocketSession createMockWebSocketSession(String protocol, String secondReturn) {
    WebSocketSession session = mock(WebSocketSession.class);
    when(session.getAcceptedProtocol()).thenReturn(protocol, secondReturn);
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_43_2
#### Test Case Name: `testSingleHandler`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-websocket\src\test\java\org\springframework\integration\websocket\support\SubProtocolHandlerRegistryTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SubProtocolHandlerRegistry subProtocolHandlerRegistry = new SubProtocolHandlerRegistry(Collections.singletonList(testProtocolHandler));
-    WebSocketSession session = mock(WebSocketSession.class);
-    when(session.getAcceptedProtocol()).thenReturn("foo", (String) null);
+    WebSocketSession session = createMockWebSocketSession("foo", (String) null);
    SubProtocolHandler protocolHandler = subProtocolHandlerRegistry.findProtocolHandler(session);
    assertThat(protocolHandler).isNotNull();
    assertThat(testProtocolHandler).isSameAs(protocolHandler);
    protocolHandler = subProtocolHandlerRegistry.findProtocolHandler(session);
    assertThat(protocolHandler).isNotNull();
    assertThat(testProtocolHandler).isSameAs(protocolHandler);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testSingleHandler() {
    SubProtocolHandler testProtocolHandler = spy(new StompSubProtocolHandler());
    when(testProtocolHandler.getSupportedProtocols()).thenReturn(Collections.singletonList("foo"));
    SubProtocolHandlerRegistry subProtocolHandlerRegistry = new SubProtocolHandlerRegistry(Collections.singletonList(testProtocolHandler));
    WebSocketSession session = mock(WebSocketSession.class);
    when(session.getAcceptedProtocol()).thenReturn("foo", (String) null);
    SubProtocolHandler protocolHandler = subProtocolHandlerRegistry.findProtocolHandler(session);
    assertThat(protocolHandler).isNotNull();
    assertThat(testProtocolHandler).isSameAs(protocolHandler);
    protocolHandler = subProtocolHandlerRegistry.findProtocolHandler(session);
    assertThat(protocolHandler).isNotNull();
    assertThat(testProtocolHandler).isSameAs(protocolHandler);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static WebSocketSession createMockWebSocketSession(String protocol, String secondReturn) {
    WebSocketSession session = mock(WebSocketSession.class);
    when(session.getAcceptedProtocol()).thenReturn(protocol, secondReturn);
    return session;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_44
- **Scope**: method level
- **Mocked Class**: `org.springframework.kafka.core.ConsumerFactory`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static ConsumerFactory<String, String> createMockConsumerFactory(Consumer<String, String> mockConsumer) {
    ConsumerFactory<String, String> cf = mock(ConsumerFactory.class);
    willReturn(mockConsumer).given(cf).createConsumer("group", "", null, KafkaTestUtils.defaultPropertyOverrides());
    return cf;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_44_1
#### Test Case Name: `testConsumeAndProduceTransaction`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `cf`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    given(mockConsumer.groupMetadata()).willReturn(meta);
-    ConsumerFactory cf = mock(ConsumerFactory.class);
-    willReturn(mockConsumer).given(cf).createConsumer("group", "", null, KafkaTestUtils.defaultPropertyOverrides());
+    ConsumerFactory cf = createMockConsumerFactory(mockConsumer);
    Producer producer = mock(Producer.class);
    given(producer.send(any(), any())).willReturn(mock(Future.class));
    final CountDownLatch closeLatch = new CountDownLatch(2);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "unchecked", "rawtypes" })
@Test
void testConsumeAndProduceTransaction() throws Exception {
    Consumer mockConsumer = mock(Consumer.class);
    final TopicPartition topicPartition = new TopicPartition("foo", 0);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(mockConsumer).subscribe(any(Collection.class), any(ConsumerRebalanceListener.class));
    ConsumerRecords records = new ConsumerRecords(Collections.singletonMap(topicPartition, Collections.singletonList(new ConsumerRecord<>("foo", 0, 0, "key", "value"))));
    final AtomicBoolean done = new AtomicBoolean();
    willAnswer(i -> {
        if (done.compareAndSet(false, true)) {
            return records;
        } else {
            Thread.sleep(500);
            return null;
        }
    }).given(mockConsumer).poll(any(Duration.class));
    ConsumerGroupMetadata meta = new ConsumerGroupMetadata("group");
    given(mockConsumer.groupMetadata()).willReturn(meta);
    ConsumerFactory cf = mock(ConsumerFactory.class);
    willReturn(mockConsumer).given(cf).createConsumer("group", "", null, KafkaTestUtils.defaultPropertyOverrides());
    Producer producer = mock(Producer.class);
    given(producer.send(any(), any())).willReturn(mock(Future.class));
    final CountDownLatch closeLatch = new CountDownLatch(2);
    willAnswer(i -> {
        closeLatch.countDown();
        return null;
    }).given(producer).close(any());
    ProducerFactory pf = mock(ProducerFactory.class);
    given(pf.transactionCapable()).willReturn(true);
    willReturn(producer).given(pf).createProducer(isNull());
    KafkaTransactionManager ptm = new KafkaTransactionManager(pf);
    ContainerProperties props = new ContainerProperties("foo");
    props.setGroupId("group");
    props.setKafkaAwareTransactionManager(ptm);
    props.setAssignmentCommitOption(AssignmentCommitOption.ALWAYS);
    final KafkaTemplate template = new KafkaTemplate(pf);
    KafkaMessageListenerContainer container = new KafkaMessageListenerContainer<>(cf, props);
    container.setBeanName("commit");
    KafkaMessageDrivenChannelAdapter inbound = new KafkaMessageDrivenChannelAdapter<>(container);
    DirectChannel channel = new DirectChannel();
    inbound.setOutputChannel(channel);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setMessageKeyExpression(new LiteralExpression("bar"));
    handler.setTopicExpression(new LiteralExpression("topic"));
    channel.subscribe(handler);
    inbound.afterPropertiesSet();
    inbound.start();
    assertThat(closeLatch.await(10, TimeUnit.SECONDS)).isTrue();
    InOrder inOrder = inOrder(producer);
    inOrder.verify(producer).beginTransaction();
    inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(0)), meta);
    inOrder.verify(producer).commitTransaction();
    inOrder.verify(producer).close(any());
    inOrder.verify(producer).beginTransaction();
    ArgumentCaptor<ProducerRecord> captor = ArgumentCaptor.forClass(ProducerRecord.class);
    inOrder.verify(producer).send(captor.capture(), any(Callback.class));
    assertThat(captor.getValue()).isEqualTo(new ProducerRecord("topic", null, "bar", "value"));
    inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1)), meta);
    inOrder.verify(producer).commitTransaction();
    inOrder.verify(producer).close(any());
    container.stop();
    verify(pf, times(2)).createProducer(isNull());
    verifyNoMoreInteractions(producer);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConsumerFactory<String, String> createMockConsumerFactory(Consumer<String, String> mockConsumer) {
    ConsumerFactory<String, String> cf = mock(ConsumerFactory.class);
    willReturn(mockConsumer).given(cf).createConsumer("group", "", null, KafkaTestUtils.defaultPropertyOverrides());
    return cf;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_44_2
#### Test Case Name: `testConsumeAndProduceTransactionTxIdOverride`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `cf`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    given(mockConsumer.groupMetadata()).willReturn(meta);
-    ConsumerFactory cf = mock(ConsumerFactory.class);
-    willReturn(mockConsumer).given(cf).createConsumer("group", "", null, KafkaTestUtils.defaultPropertyOverrides());
+    ConsumerFactory cf = createMockConsumerFactory(mockConsumer);
    Producer producer = mock(Producer.class);
    given(producer.send(any(), any())).willReturn(mock(Future.class));
    final CountDownLatch closeLatch = new CountDownLatch(2);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "unchecked", "rawtypes" })
@Test
void testConsumeAndProduceTransactionTxIdOverride() throws Exception {
    Consumer mockConsumer = mock(Consumer.class);
    final TopicPartition topicPartition = new TopicPartition("foo", 0);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(mockConsumer).subscribe(any(Collection.class), any(ConsumerRebalanceListener.class));
    ConsumerRecords records = new ConsumerRecords(Collections.singletonMap(topicPartition, Collections.singletonList(new ConsumerRecord<>("foo", 0, 0, "key", "value"))));
    final AtomicBoolean done = new AtomicBoolean();
    willAnswer(i -> {
        if (done.compareAndSet(false, true)) {
            return records;
        } else {
            Thread.sleep(500);
            return null;
        }
    }).given(mockConsumer).poll(any(Duration.class));
    ConsumerGroupMetadata meta = new ConsumerGroupMetadata("group");
    given(mockConsumer.groupMetadata()).willReturn(meta);
    ConsumerFactory cf = mock(ConsumerFactory.class);
    willReturn(mockConsumer).given(cf).createConsumer("group", "", null, KafkaTestUtils.defaultPropertyOverrides());
    Producer producer = mock(Producer.class);
    given(producer.send(any(), any())).willReturn(mock(Future.class));
    final CountDownLatch closeLatch = new CountDownLatch(2);
    willAnswer(i -> {
        closeLatch.countDown();
        return null;
    }).given(producer).close(any());
    AtomicReference<String> txId = new AtomicReference<>();
    DefaultKafkaProducerFactory pf = new DefaultKafkaProducerFactory(Collections.emptyMap()) {

        @Override
        protected Producer createTransactionalProducer(String txIdPrefix) {
            txId.set(txIdPrefix);
            return producer;
        }
    };
    pf.setTransactionIdPrefix("default.tx.id.");
    KafkaTransactionManager tm = new KafkaTransactionManager(pf);
    tm.setTransactionIdPrefix("tm.tx.id.");
    ContainerProperties props = new ContainerProperties("foo");
    props.setGroupId("group");
    props.setKafkaAwareTransactionManager(tm);
    props.setAssignmentCommitOption(AssignmentCommitOption.ALWAYS);
    final KafkaTemplate template = new KafkaTemplate(pf);
    template.setTransactionIdPrefix("template.tx.id.");
    KafkaMessageListenerContainer container = new KafkaMessageListenerContainer<>(cf, props);
    container.setBeanName("commit");
    KafkaMessageDrivenChannelAdapter inbound = new KafkaMessageDrivenChannelAdapter<>(container);
    DirectChannel channel = new DirectChannel();
    inbound.setOutputChannel(channel);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setMessageKeyExpression(new LiteralExpression("bar"));
    handler.setTopicExpression(new LiteralExpression("topic"));
    channel.subscribe(handler);
    inbound.afterPropertiesSet();
    inbound.start();
    assertThat(closeLatch.await(10, TimeUnit.SECONDS)).isTrue();
    InOrder inOrder = inOrder(producer);
    inOrder.verify(producer).beginTransaction();
    inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(0)), meta);
    inOrder.verify(producer).commitTransaction();
    inOrder.verify(producer).close(any());
    inOrder.verify(producer).beginTransaction();
    ArgumentCaptor<ProducerRecord> captor = ArgumentCaptor.forClass(ProducerRecord.class);
    inOrder.verify(producer).send(captor.capture(), any(Callback.class));
    assertThat(captor.getValue()).isEqualTo(new ProducerRecord("topic", null, "bar", "value"));
    inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1)), meta);
    inOrder.verify(producer).commitTransaction();
    inOrder.verify(producer).close(any());
    container.stop();
    verifyNoMoreInteractions(producer);
    assertThat(txId.get()).isEqualTo("tm.tx.id.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConsumerFactory<String, String> createMockConsumerFactory(Consumer<String, String> mockConsumer) {
    ConsumerFactory<String, String> cf = mock(ConsumerFactory.class);
    willReturn(mockConsumer).given(cf).createConsumer("group", "", null, KafkaTestUtils.defaultPropertyOverrides());
    return cf;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_45
- **Scope**: method level
- **Mocked Class**: `org.springframework.kafka.core.ConsumerFactory`
- **Test Case Count**: 8
- **MO Count**: 8

### Reusable Method
```java
private static ConsumerFactory<?, ?> createMockConsumerFactory(Consumer<?, ?> consumer, int maxPollRecords) {
    ConsumerFactory<?, ?> consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, maxPollRecords))
        .given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any()))
        .willReturn(consumer);
    return consumerFactory;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_45_1
#### Test Case Name: `testConsumerAwareRebalanceListener`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\inbound\MessageSourceTests.java`)
#### Mock Object Variable Name: `consumerFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    willAnswer(i -> {
        listener.set(i.getArgument(1));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
-    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
-    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
-    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
+    ConsumerFactory consumerFactory = createMockConsumerFactory(consumer, 1);
    ConsumerProperties consumerProperties = new ConsumerProperties("foo");
    AtomicBoolean partitionsAssignedCalled = new AtomicBoolean();
    AtomicReference<Consumer> partitionsAssignedConsumer = new AtomicReference<>();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "unchecked", "rawtypes" })
@Test
void testConsumerAwareRebalanceListener() {
    Consumer consumer = mock(Consumer.class);
    TopicPartition topicPartition = new TopicPartition("foo", 0);
    List<TopicPartition> assigned = Collections.singletonList(topicPartition);
    AtomicReference<ConsumerRebalanceListener> listener = new AtomicReference<>();
    willAnswer(i -> {
        listener.set(i.getArgument(1));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
    ConsumerProperties consumerProperties = new ConsumerProperties("foo");
    AtomicBoolean partitionsAssignedCalled = new AtomicBoolean();
    AtomicReference<Consumer> partitionsAssignedConsumer = new AtomicReference<>();
    AtomicBoolean partitionsRevokedCalled = new AtomicBoolean();
    AtomicReference<Consumer> partitionsRevokedConsumer = new AtomicReference<>();
    consumerProperties.setConsumerRebalanceListener(new ConsumerAwareRebalanceListener() {

        @Override
        public void onPartitionsRevokedAfterCommit(Consumer<?, ?> cons, Collection<TopicPartition> partitions) {
            partitionsRevokedCalled.getAndSet(true);
            partitionsRevokedConsumer.set(cons);
        }

        @Override
        public void onPartitionsAssigned(Consumer<?, ?> cons, Collection<TopicPartition> partitions) {
            partitionsAssignedCalled.getAndSet(true);
            partitionsAssignedConsumer.set(cons);
        }
    });
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, consumerProperties);
    source.setRawMessageHeader(true);
    source.receive();
    listener.get().onPartitionsAssigned(assigned);
    assertThat(partitionsAssignedCalled.get()).isTrue();
    assertThat(partitionsAssignedConsumer.get()).isEqualTo(consumer);
    listener.get().onPartitionsRevoked(assigned);
    assertThat(partitionsRevokedCalled.get()).isTrue();
    assertThat(partitionsRevokedConsumer.get()).isEqualTo(consumer);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConsumerFactory<?, ?> createMockConsumerFactory(Consumer<?, ?> consumer, int maxPollRecords) {
    ConsumerFactory<?, ?> consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, maxPollRecords))
        .given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any()))
        .willReturn(consumer);
    return consumerFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_45_2
#### Test Case Name: `testRebalanceListener`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\inbound\MessageSourceTests.java`)
#### Mock Object Variable Name: `consumerFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    willAnswer(i -> {
        listener.set(i.getArgument(1));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
-    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
-    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
-    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
+    ConsumerFactory consumerFactory = createMockConsumerFactory(consumer, 1);
    ConsumerProperties consumerProperties = new ConsumerProperties("foo");
    AtomicBoolean partitionsAssignedCalled = new AtomicBoolean();
    AtomicBoolean partitionsRevokedCalled = new AtomicBoolean();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "unchecked", "rawtypes" })
@Test
void testRebalanceListener() {
    Consumer consumer = mock(Consumer.class);
    TopicPartition topicPartition1 = new TopicPartition("foo", 0);
    List<TopicPartition> assigned1 = new ArrayList<>(Collections.singletonList(topicPartition1));
    TopicPartition topicPartition2 = new TopicPartition("foo", 1);
    List<TopicPartition> assigned2 = new ArrayList<>(Collections.singletonList(topicPartition2));
    AtomicReference<ConsumerRebalanceListener> listener = new AtomicReference<>();
    willAnswer(i -> {
        listener.set(i.getArgument(1));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
    ConsumerProperties consumerProperties = new ConsumerProperties("foo");
    AtomicBoolean partitionsAssignedCalled = new AtomicBoolean();
    AtomicBoolean partitionsRevokedCalled = new AtomicBoolean();
    consumerProperties.setConsumerRebalanceListener(new ConsumerRebalanceListener() {

        @Override
        public void onPartitionsRevoked(Collection<TopicPartition> partitions) {
            partitionsRevokedCalled.getAndSet(true);
        }

        @Override
        public void onPartitionsAssigned(Collection<TopicPartition> partitions) {
            partitionsAssignedCalled.getAndSet(true);
        }
    });
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, consumerProperties);
    source.setRawMessageHeader(true);
    source.receive();
    listener.get().onPartitionsAssigned(assigned1);
    assertThat(partitionsAssignedCalled.get()).isTrue();
    assertThat(new ArrayList<>(source.getAssignedPartitions())).isEqualTo(assigned1);
    listener.get().onPartitionsAssigned(assigned2);
    List<TopicPartition> temp = new ArrayList<>(assigned1);
    temp.addAll(assigned2);
    assertThat(new ArrayList<>(source.getAssignedPartitions())).isEqualTo(temp);
    listener.get().onPartitionsRevoked(assigned1);
    assertThat(partitionsRevokedCalled.get()).isTrue();
    assertThat(new ArrayList<>(source.getAssignedPartitions())).isEqualTo(assigned2);
    source.pause();
    assertThat(source.isPaused()).isFalse();
    InOrder inOrder = inOrder(consumer);
    source.receive();
    assertThat(source.isPaused()).isTrue();
    inOrder.verify(consumer).pause(new LinkedHashSet<>(assigned2));
    inOrder.verify(consumer).poll(any());
    listener.get().onPartitionsAssigned(assigned1);
    inOrder.verify(consumer).pause(new LinkedHashSet<>(temp));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConsumerFactory<?, ?> createMockConsumerFactory(Consumer<?, ?> consumer, int maxPollRecords) {
    ConsumerFactory<?, ?> consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, maxPollRecords))
        .given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any()))
        .willReturn(consumer);
    return consumerFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_45_3
#### Test Case Name: `testAckCommon`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\inbound\MessageSourceTests.java`)
#### Mock Object Variable Name: `consumerFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2, cr3, cr4, cr5);
-    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
-    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
-    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
+    ConsumerFactory consumerFactory = createMockConsumerFactory(consumer, 1);
    ConsumerProperties consumerProperties = new ConsumerProperties("foo");
    AtomicInteger callbackCount = new AtomicInteger();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
private void testAckCommon(boolean sync, boolean timeout) {
    Consumer consumer = mock(Consumer.class);
    TopicPartition topicPartition = new TopicPartition("foo", 0);
    List<TopicPartition> assigned = Collections.singletonList(topicPartition);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(assigned);
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    ArgumentCaptor<Collection<TopicPartition>> partitions = ArgumentCaptor.forClass(Collection.class);
    willDoNothing().given(consumer).pause(partitions.capture());
    willDoNothing().given(consumer).resume(partitions.capture());
    willAnswer(invoc -> {
        OffsetCommitCallback callback = invoc.getArgument(1);
        callback.onComplete(null, null);
        return null;
    }).given(consumer).commitAsync(any(), any());
    Map<TopicPartition, List<ConsumerRecord>> records1 = new LinkedHashMap<>();
    records1.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty())));
    Map<TopicPartition, List<ConsumerRecord>> records2 = new LinkedHashMap<>();
    records2.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "bar", new RecordHeaders(), Optional.empty())));
    Map<TopicPartition, List<ConsumerRecord>> records3 = new LinkedHashMap<>();
    records3.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 2L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "baz", new RecordHeaders(), Optional.empty())));
    Map<TopicPartition, List<ConsumerRecord>> records4 = new LinkedHashMap<>();
    records4.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 3L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "qux", new RecordHeaders(), Optional.empty())));
    ConsumerRecords cr1 = new ConsumerRecords(records1);
    ConsumerRecords cr2 = new ConsumerRecords(records2);
    ConsumerRecords cr3 = new ConsumerRecords(records3);
    ConsumerRecords cr4 = new ConsumerRecords(records4);
    ConsumerRecords cr5 = new ConsumerRecords(Collections.emptyMap());
    given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2, cr3, cr4, cr5);
    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
    ConsumerProperties consumerProperties = new ConsumerProperties("foo");
    AtomicInteger callbackCount = new AtomicInteger();
    OffsetCommitCallback commitCallback = (offsets, ex) -> {
        callbackCount.incrementAndGet();
    };
    if (!sync) {
        consumerProperties.setSyncCommits(false);
        consumerProperties.setCommitCallback(commitCallback);
    }
    if (timeout) {
        consumerProperties.setSyncCommitTimeout(Duration.ofSeconds(5));
    }
    consumerProperties.setCommitLogLevel(Level.INFO);
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, consumerProperties);
    source.setRawMessageHeader(true);
    Message<?> received = source.receive();
    assertThat(received).isNotNull();
    assertThat(received.getHeaders().get(KafkaHeaders.RAW_DATA)).isInstanceOf(ConsumerRecord.class);
    assertThat(received.getHeaders().get(IntegrationMessageHeaderAccessor.SOURCE_DATA)).isSameAs(received.getHeaders().get(KafkaHeaders.RAW_DATA));
    assertThat(received.getHeaders()).containsKeys(MessageHeaders.TIMESTAMP, MessageHeaders.ID);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    assertThat(received).isNotNull();
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    assertThat(received).isNotNull();
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    assertThat(received).isNotNull();
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    assertThat(received).isNull();
    source.pause();
    source.receive();
    source.resume();
    source.receive();
    source.destroy();
    InOrder inOrder = inOrder(consumer);
    inOrder.verify(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    inOrder.verify(consumer).poll(any(Duration.class));
    checkCommit(sync, timeout, consumer, topicPartition, commitCallback, inOrder, 1L);
    inOrder.verify(consumer).poll(any(Duration.class));
    checkCommit(sync, timeout, consumer, topicPartition, commitCallback, inOrder, 2L);
    inOrder.verify(consumer).poll(any(Duration.class));
    checkCommit(sync, timeout, consumer, topicPartition, commitCallback, inOrder, 3L);
    inOrder.verify(consumer).poll(any(Duration.class));
    checkCommit(sync, timeout, consumer, topicPartition, commitCallback, inOrder, 4L);
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).pause(partitions.getAllValues().get(0));
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).resume(partitions.getAllValues().get(1));
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).close(any());
    inOrder.verifyNoMoreInteractions();
    if (!sync) {
        assertThat(callbackCount.get()).isEqualTo(4);
    }
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConsumerFactory<?, ?> createMockConsumerFactory(Consumer<?, ?> consumer, int maxPollRecords) {
    ConsumerFactory<?, ?> consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, maxPollRecords))
        .given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any()))
        .willReturn(consumer);
    return consumerFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_45_4
#### Test Case Name: `testAckOutOfOrder`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\inbound\MessageSourceTests.java`)
#### Mock Object Variable Name: `consumerFactory`
<summary>Suggested Diff</summary>

```diff
@@
     given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2, cr3, cr4, cr5, cr6, cr7);
-    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
-    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
-    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
+    ConsumerFactory consumerFactory = createMockConsumerFactory(consumer, 1);
     KafkaMessageSource source = new KafkaMessageSource(consumerFactory, new ConsumerProperties("foo"));
     Message<?> received1 = source.receive();
     // need some other interaction with mock between polls for InOrder
     consumer.paused();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testAckOutOfOrder() {
    Consumer consumer = mock(Consumer.class);
    TopicPartition topicPartition = new TopicPartition("foo", 0);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    AtomicReference<Set<TopicPartition>> paused = new AtomicReference<>(new HashSet<>());
    willAnswer(i -> {
        paused.set(new HashSet<>(i.getArgument(0)));
        return null;
    }).given(consumer).pause(anyCollection());
    willAnswer(i -> paused.get()).given(consumer).paused();
    Map<TopicPartition, List<ConsumerRecord>> records1 = new LinkedHashMap<>();
    records1.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty())));
    Map<TopicPartition, List<ConsumerRecord>> records2 = new LinkedHashMap<>();
    records2.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "bar", new RecordHeaders(), Optional.empty())));
    Map<TopicPartition, List<ConsumerRecord>> records3 = new LinkedHashMap<>();
    records3.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 2L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "baz", new RecordHeaders(), Optional.empty())));
    Map<TopicPartition, List<ConsumerRecord>> records4 = new LinkedHashMap<>();
    records4.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 3L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "qux", new RecordHeaders(), Optional.empty())));
    Map<TopicPartition, List<ConsumerRecord>> records5 = new LinkedHashMap<>();
    records5.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 4L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "fiz", new RecordHeaders(), Optional.empty())));
    Map<TopicPartition, List<ConsumerRecord>> records6 = new LinkedHashMap<>();
    records6.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 5L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "buz", new RecordHeaders(), Optional.empty())));
    ConsumerRecords cr1 = new ConsumerRecords(records1);
    ConsumerRecords cr2 = new ConsumerRecords(records2);
    ConsumerRecords cr3 = new ConsumerRecords(records3);
    ConsumerRecords cr4 = new ConsumerRecords(records4);
    ConsumerRecords cr5 = new ConsumerRecords(records5);
    ConsumerRecords cr6 = new ConsumerRecords(records6);
    ConsumerRecords cr7 = new ConsumerRecords(Collections.emptyMap());
    given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2, cr3, cr4, cr5, cr6, cr7);
    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, new ConsumerProperties("foo"));
    Message<?> received1 = source.receive();
    // need some other interaction with mock between polls for InOrder
    consumer.paused();
    Message<?> received2 = source.receive();
    // need some other interaction with mock between polls for InOrder
    consumer.paused();
    Message<?> received3 = source.receive();
    // need some other interaction with mock between polls for InOrder
    consumer.paused();
    Message<?> received4 = source.receive();
    // need some other interaction with mock between polls for InOrder
    consumer.paused();
    Message<?> received5 = source.receive();
    // need some other interaction with mock between polls for InOrder
    consumer.paused();
    Message<?> received6 = source.receive();
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received3).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received2).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received5).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received1).acknowledge(// should commit offset 3 (received 3)
    AcknowledgmentCallback.Status.ACCEPT);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received6).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received4).acknowledge(// should commit offset 6 (received 6).
    AcknowledgmentCallback.Status.ACCEPT);
    assertThat(source.receive()).isNull();
    source.destroy();
    InOrder inOrder = inOrder(consumer);
    inOrder.verify(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).paused();
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).paused();
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).paused();
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).paused();
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(3L)));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(6L)));
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).close(any());
    inOrder.verifyNoMoreInteractions();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConsumerFactory<?, ?> createMockConsumerFactory(Consumer<?, ?> consumer, int maxPollRecords) {
    ConsumerFactory<?, ?> consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, maxPollRecords))
        .given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any()))
        .willReturn(consumer);
    return consumerFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_45_5
#### Test Case Name: `testNack`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\inbound\MessageSourceTests.java`)
#### Mock Object Variable Name: `consumerFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    given(consumer.poll(any(Duration.class))).willReturn(cr1, cr1, cr2, cr2, cr3);
-    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
-    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
-    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
+    ConsumerFactory consumerFactory = createMockConsumerFactory(consumer, 1);
    ConsumerProperties consumerProperties = new ConsumerProperties("foo");
    consumerProperties.setSyncCommitTimeout(Duration.ofSeconds(30));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testNack() {
    Consumer consumer = mock(Consumer.class);
    TopicPartition topicPartition = new TopicPartition("foo", 0);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    AtomicReference<Set<TopicPartition>> paused = new AtomicReference<>(new HashSet<>());
    willAnswer(i -> {
        paused.set(new HashSet<>(i.getArgument(0)));
        return null;
    }).given(consumer).pause(anyCollection());
    willAnswer(i -> paused.get()).given(consumer).paused();
    Map<TopicPartition, List<ConsumerRecord>> records1 = new LinkedHashMap<>();
    records1.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty())));
    ConsumerRecords cr1 = new ConsumerRecords(records1);
    Map<TopicPartition, List<ConsumerRecord>> records2 = new LinkedHashMap<>();
    records2.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "bar", new RecordHeaders(), Optional.empty())));
    ConsumerRecords cr2 = new ConsumerRecords(records2);
    ConsumerRecords cr3 = new ConsumerRecords(Collections.emptyMap());
    given(consumer.poll(any(Duration.class))).willReturn(cr1, cr1, cr2, cr2, cr3);
    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
    ConsumerProperties consumerProperties = new ConsumerProperties("foo");
    consumerProperties.setSyncCommitTimeout(Duration.ofSeconds(30));
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, consumerProperties);
    Message<?> received = source.receive();
    assertThat(received.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(0L);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.REQUEUE);
    received = source.receive();
    assertThat(received.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(0L);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    assertThat(received.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(1L);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.REQUEUE);
    received = source.receive();
    assertThat(received.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(1L);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    source.destroy();
    assertThat(received).isNull();
    InOrder inOrder = inOrder(consumer);
    inOrder.verify(consumer).poll(any(Duration.class));
    // rollback
    inOrder.verify(consumer).seek(topicPartition, 0L);
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1L)), Duration.ofSeconds(30));
    inOrder.verify(consumer).poll(any(Duration.class));
    // rollback
    inOrder.verify(consumer).seek(topicPartition, 1L);
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(2L)), Duration.ofSeconds(30));
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).close(any());
    inOrder.verifyNoMoreInteractions();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConsumerFactory<?, ?> createMockConsumerFactory(Consumer<?, ?> consumer, int maxPollRecords) {
    ConsumerFactory<?, ?> consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, maxPollRecords))
        .given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any()))
        .willReturn(consumer);
    return consumerFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_45_6
#### Test Case Name: `testNackWithLaterInflight`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\inbound\MessageSourceTests.java`)
#### Mock Object Variable Name: `consumerFactory`
<summary>Suggested Diff</summary>

```diff
@@
    given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2, cr1, cr2, cr3);
-    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
-    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
-    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
+    ConsumerFactory consumerFactory = createMockConsumerFactory(consumer, 1);
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, new ConsumerProperties("foo"));
    Message<?> received1 = source.receive();
    // need some other interaction with mock between polls for InOrder
    consumer.paused();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testNackWithLaterInflight() {
    Consumer consumer = mock(Consumer.class);
    TopicPartition topicPartition = new TopicPartition("foo", 0);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    AtomicReference<Set<TopicPartition>> paused = new AtomicReference<>(new HashSet<>());
    willAnswer(i -> {
        paused.set(new HashSet<>(i.getArgument(0)));
        return null;
    }).given(consumer).pause(anyCollection());
    willAnswer(i -> paused.get()).given(consumer).paused();
    Map<TopicPartition, List<ConsumerRecord>> records1 = new LinkedHashMap<>();
    records1.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty())));
    ConsumerRecords cr1 = new ConsumerRecords(records1);
    Map<TopicPartition, List<ConsumerRecord>> records2 = new LinkedHashMap<>();
    records2.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "bar", new RecordHeaders(), Optional.empty())));
    ConsumerRecords cr2 = new ConsumerRecords(records2);
    ConsumerRecords cr3 = new ConsumerRecords(Collections.emptyMap());
    given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2, cr1, cr2, cr3);
    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, new ConsumerProperties("foo"));
    Message<?> received1 = source.receive();
    // need some other interaction with mock between polls for InOrder
    consumer.paused();
    // inflight
    Message<?> received2 = source.receive();
    assertThat(received1.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(0L);
    AcknowledgmentCallback ack1 = StaticMessageHeaderAccessor.getAcknowledgmentCallback(received1);
    Log log1 = spy(KafkaTestUtils.getPropertyValue(ack1, "logger.log", Log.class));
    new DirectFieldAccessor(ack1).setPropertyValue("logger.log", log1);
    given(log1.isWarnEnabled()).willReturn(true);
    willDoNothing().given(log1).warn(any());
    ack1.acknowledge(AcknowledgmentCallback.Status.REQUEUE);
    assertThat(received2.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(1L);
    AcknowledgmentCallback ack2 = StaticMessageHeaderAccessor.getAcknowledgmentCallback(received2);
    Log log2 = spy(KafkaTestUtils.getPropertyValue(ack2, "logger.log", Log.class));
    new DirectFieldAccessor(ack2).setPropertyValue("logger.log", log2);
    given(log2.isWarnEnabled()).willReturn(true);
    willDoNothing().given(log2).warn(any());
    ack2.acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received1 = source.receive();
    assertThat(received1.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(0L);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received1).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received2 = source.receive();
    assertThat(received2.getHeaders().get(KafkaHeaders.OFFSET)).isEqualTo(1L);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received2).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received1 = source.receive();
    source.destroy();
    assertThat(received1).isNull();
    InOrder inOrder = inOrder(consumer, log1, log2);
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).paused();
    inOrder.verify(consumer).poll(any(Duration.class));
    // rollback
    inOrder.verify(consumer).seek(topicPartition, 0L);
    inOrder.verify(log1).isWarnEnabled();
    ArgumentCaptor<LogMessage> captor = ArgumentCaptor.forClass(LogMessage.class);
    inOrder.verify(log1).warn(captor.capture());
    assertThat(captor.getValue().toString()).contains("Rolled back").contains("later in-flight offsets [1] will also be re-fetched");
    inOrder.verify(log2).isWarnEnabled();
    captor = ArgumentCaptor.forClass(LogMessage.class);
    inOrder.verify(log2).warn(captor.capture());
    assertThat(captor.getValue().toString()).contains("Cannot commit offset for").contains("; an earlier offset was rolled back");
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1L)));
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(2L)));
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).close(any());
    inOrder.verifyNoMoreInteractions();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConsumerFactory<?, ?> createMockConsumerFactory(Consumer<?, ?> consumer, int maxPollRecords) {
    ConsumerFactory<?, ?> consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, maxPollRecords))
        .given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any()))
        .willReturn(consumer);
    return consumerFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_45_7
#### Test Case Name: `testPollTimeouts`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\inbound\MessageSourceTests.java`)
#### Mock Object Variable Name: `consumerFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    given(consumer.poll(Duration.of(5000, ChronoUnit.MILLIS))).willReturn(cr2, ConsumerRecords.EMPTY);
-    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
-    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
-    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
+    ConsumerFactory consumerFactory = createMockConsumerFactory(consumer, 1);
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, new ConsumerProperties("foo"));
    source.setRawMessageHeader(true);
    Message<?> received = source.receive();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testPollTimeouts() {
    Consumer consumer = mock(Consumer.class);
    TopicPartition topicPartition = new TopicPartition("foo", 0);
    List<TopicPartition> assigned = Collections.singletonList(topicPartition);
    AtomicReference<ConsumerRebalanceListener> listener = new AtomicReference<>();
    willAnswer(i -> {
        listener.set(i.getArgument(1));
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    Map<TopicPartition, List<ConsumerRecord>> records1 = new LinkedHashMap<>();
    records1.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty())));
    ConsumerRecords cr1 = new ConsumerRecords(records1);
    given(consumer.poll(Duration.of(20 * 5000, ChronoUnit.MILLIS))).willReturn(cr1, ConsumerRecords.EMPTY);
    Map<TopicPartition, List<ConsumerRecord>> records2 = new LinkedHashMap<>();
    records2.put(topicPartition, Collections.singletonList(new ConsumerRecord("foo", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty())));
    ConsumerRecords cr2 = new ConsumerRecords(records2);
    given(consumer.poll(Duration.of(5000, ChronoUnit.MILLIS))).willReturn(cr2, ConsumerRecords.EMPTY);
    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1)).given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, new ConsumerProperties("foo"));
    source.setRawMessageHeader(true);
    Message<?> received = source.receive();
    assertThat(received).isNotNull();
    assertThat(received).isNotNull();
    assertThat(received.getHeaders().get(KafkaHeaders.RAW_DATA)).isInstanceOf(ConsumerRecord.class);
    assertThat(received.getHeaders().get(KafkaHeaders.RAW_DATA)).isEqualTo(cr1.records(topicPartition).get(0));
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    listener.get().onPartitionsAssigned(assigned);
    received = source.receive();
    assertThat(received).isNotNull();
    assertThat(received.getHeaders().get(KafkaHeaders.RAW_DATA)).isInstanceOf(ConsumerRecord.class);
    assertThat(received.getHeaders().get(KafkaHeaders.RAW_DATA)).isEqualTo(cr2.records(topicPartition).get(0));
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    listener.get().onPartitionsRevoked(assigned);
    received = source.receive();
    assertThat(received).isNull();
    InOrder inOrder = inOrder(consumer);
    inOrder.verify(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    // assignTimeout used on initial poll (before partition assigned)
    inOrder.verify(consumer).poll(Duration.of(20 * 5000, ChronoUnit.MILLIS));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1L)));
    // pollTimeout used on subsequent polls
    inOrder.verify(consumer).poll(Duration.of(5000, ChronoUnit.MILLIS));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(2L)));
    // assignTimeout used after partitions revoked
    inOrder.verify(consumer).poll(Duration.of(20 * 5000, ChronoUnit.MILLIS));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConsumerFactory<?, ?> createMockConsumerFactory(Consumer<?, ?> consumer, int maxPollRecords) {
    ConsumerFactory<?, ?> consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, maxPollRecords))
        .given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any()))
        .willReturn(consumer);
    return consumerFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_45_8
#### Test Case Name: `testAllowMulti`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\inbound\MessageSourceTests.java`)
#### Mock Object Variable Name: `consumerFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2);
-    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
-    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 4)).given(consumerFactory).getConfigurationProperties();
-    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
+    ConsumerFactory consumerFactory = createMockConsumerFactory(consumer, 4);
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, new ConsumerProperties("foo"), true);
    source.setRawMessageHeader(true);
    Message<?> received = source.receive();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testAllowMulti() {
    Consumer consumer = mock(Consumer.class);
    TopicPartition topicPartition = new TopicPartition("foo", 0);
    List<TopicPartition> assigned = Collections.singletonList(topicPartition);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(assigned);
        return null;
    }).given(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    ArgumentCaptor<Collection<TopicPartition>> partitions = ArgumentCaptor.forClass(Collection.class);
    willDoNothing().given(consumer).pause(partitions.capture());
    willDoNothing().given(consumer).resume(partitions.capture());
    Map<TopicPartition, List<ConsumerRecord>> records = new LinkedHashMap<>();
    records.put(topicPartition, Arrays.asList(new ConsumerRecord("foo", 0, 0L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "foo", new RecordHeaders(), Optional.empty()), new ConsumerRecord("foo", 0, 1L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "bar", new RecordHeaders(), Optional.empty()), new ConsumerRecord("foo", 0, 2L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "baz", new RecordHeaders(), Optional.empty()), new ConsumerRecord("foo", 0, 3L, 0L, TimestampType.NO_TIMESTAMP_TYPE, 0, 0, null, "qux", new RecordHeaders(), Optional.empty())));
    ConsumerRecords cr1 = new ConsumerRecords(records);
    ConsumerRecords cr2 = new ConsumerRecords(Collections.emptyMap());
    given(consumer.poll(any(Duration.class))).willReturn(cr1, cr2);
    ConsumerFactory consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 4)).given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any())).willReturn(consumer);
    KafkaMessageSource source = new KafkaMessageSource(consumerFactory, new ConsumerProperties("foo"), true);
    source.setRawMessageHeader(true);
    Message<?> received = source.receive();
    assertThat(received).isNotNull();
    assertThat(received.getHeaders().get(KafkaMessageSource.REMAINING_RECORDS, Integer.class)).isEqualTo(3);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    assertThat(received).isNotNull();
    assertThat(received.getHeaders().get(KafkaMessageSource.REMAINING_RECORDS, Integer.class)).isEqualTo(2);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    assertThat(received).isNotNull();
    assertThat(received.getHeaders().get(KafkaMessageSource.REMAINING_RECORDS, Integer.class)).isEqualTo(1);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    assertThat(received).isNotNull();
    assertThat(received.getHeaders().get(KafkaMessageSource.REMAINING_RECORDS, Integer.class)).isEqualTo(0);
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(AcknowledgmentCallback.Status.ACCEPT);
    received = source.receive();
    assertThat(received).isNull();
    source.destroy();
    InOrder inOrder = inOrder(consumer);
    inOrder.verify(consumer).subscribe(anyCollection(), any(ConsumerRebalanceListener.class));
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1L)));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(2L)));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(3L)));
    inOrder.verify(consumer).commitSync(Collections.singletonMap(topicPartition, new OffsetAndMetadata(4L)));
    inOrder.verify(consumer).poll(any(Duration.class));
    inOrder.verify(consumer).close(any());
    inOrder.verifyNoMoreInteractions();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConsumerFactory<?, ?> createMockConsumerFactory(Consumer<?, ?> consumer, int maxPollRecords) {
    ConsumerFactory<?, ?> consumerFactory = mock(ConsumerFactory.class);
    willReturn(Collections.singletonMap(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, maxPollRecords))
        .given(consumerFactory).getConfigurationProperties();
    given(consumerFactory.createConsumer(isNull(), anyString(), isNull(), any()))
        .willReturn(consumer);
    return consumerFactory;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_46
- **Scope**: method level
- **Mocked Class**: `javax.sql.DataSource`
- **Test Case Count**: 15
- **MO Count**: 15

### Reusable Method
```java
// === Declare in class scope ===
private DataSource datasource;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    datasource = mock(DataSource.class);
}

// === Replace local variable in test with ===
datasource;

```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_46_1
#### Test Case Name: `testStoredProcExecutorWithNullProcedureName`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-jdbc\src\test\java\org\springframework\integration\jdbc\StoredProcExecutorTests.java`)
#### Mock Object Variable Name: `datasource`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testStoredProcExecutorWithNullProcedureName() {
-    DataSource datasource = mock(DataSource.class);
+    // removed local mock; replaced with global field `datasource`
     StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
     storedProcExecutor.setBeanFactory(mock(BeanFactory.class));
     assertThatIllegalArgumentException().isThrownBy(storedProcExecutor::afterPropertiesSet).withMessage("You must either provide a " + "Stored Procedure Name or a Stored Procedure Name Expression.");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testStoredProcExecutorWithNullProcedureName() {
    DataSource datasource = mock(DataSource.class);
    StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
    storedProcExecutor.setBeanFactory(mock(BeanFactory.class));
    assertThatIllegalArgumentException().isThrownBy(storedProcExecutor::afterPropertiesSet).withMessage("You must either provide a " + "Stored Procedure Name or a Stored Procedure Name Expression.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private DataSource datasource;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    datasource = mock(DataSource.class);
}

// === Replace local variable in test with ===
datasource;

```
</details>

---
#### Test Case ID #spring-integration_Test_46_2
#### Test Case Name: `testStoredProcExecutorWithEmptyProcedureName`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-jdbc\src\test\java\org\springframework\integration\jdbc\StoredProcExecutorTests.java`)
#### Mock Object Variable Name: `datasource`
<summary>Suggested Diff</summary>

```diff
@@
@Test
public void testStoredProcExecutorWithEmptyProcedureName() {
-    DataSource datasource = mock(DataSource.class);
+    // removed local mock; replaced with global field `datasource`
    StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
    assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.setStoredProcedureName("      ")).withMessage("storedProcedureName must not be null and cannot be empty.");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testStoredProcExecutorWithEmptyProcedureName() {
    DataSource datasource = mock(DataSource.class);
    StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
    assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.setStoredProcedureName("      ")).withMessage("storedProcedureName must not be null and cannot be empty.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private DataSource datasource;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    datasource = mock(DataSource.class);
}

// === Replace local variable in test with ===
datasource;

```
</details>

---
#### Test Case ID #spring-integration_Test_46_3
#### Test Case Name: `testGetStoredProcedureNameExpressionAsString`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-jdbc\src\test\java\org\springframework\integration\jdbc\StoredProcExecutorTests.java`)
#### Mock Object Variable Name: `datasource`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testGetStoredProcedureNameExpressionAsString() throws Exception {
-    DataSource datasource = mock(DataSource.class);
+    // removed local mock; replaced with global field `datasource`
     StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
     final ExpressionFactoryBean efb = new ExpressionFactoryBean("headers['stored_procedure_name']");
     efb.afterPropertiesSet();
     final Expression expression = efb.getObject();
     storedProcExecutor.setStoredProcedureNameExpression(expression);
     storedProcExecutor.setBeanFactory(mock(BeanFactory.class));
     storedProcExecutor.afterPropertiesSet();
     assertThat(storedProcExecutor.getStoredProcedureNameExpressionAsString()).isEqualTo("headers['stored_procedure_name']");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testGetStoredProcedureNameExpressionAsString() throws Exception {
    DataSource datasource = mock(DataSource.class);
    StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
    final ExpressionFactoryBean efb = new ExpressionFactoryBean("headers['stored_procedure_name']");
    efb.afterPropertiesSet();
    final Expression expression = efb.getObject();
    storedProcExecutor.setStoredProcedureNameExpression(expression);
    storedProcExecutor.setBeanFactory(mock(BeanFactory.class));
    storedProcExecutor.afterPropertiesSet();
    assertThat(storedProcExecutor.getStoredProcedureNameExpressionAsString()).isEqualTo("headers['stored_procedure_name']");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private DataSource datasource;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    datasource = mock(DataSource.class);
}

// === Replace local variable in test with ===
datasource;

```
</details>

---
#### Test Case ID #spring-integration_Test_46_4
#### Test Case Name: `testGetStoredProcedureNameExpressionAsString2`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-jdbc\src\test\java\org\springframework\integration\jdbc\StoredProcExecutorTests.java`)
#### Mock Object Variable Name: `datasource`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testGetStoredProcedureNameExpressionAsString2() {
-    DataSource datasource = mock(DataSource.class);
+    // removed local mock; replaced with global field `datasource`
     StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
     storedProcExecutor.setStoredProcedureName("123");
     storedProcExecutor.setBeanFactory(mock(BeanFactory.class));
     storedProcExecutor.afterPropertiesSet();
     assertThat(storedProcExecutor.getStoredProcedureName()).isEqualTo("123");
     assertThat(storedProcExecutor.getStoredProcedureNameExpressionAsString()).isEqualTo("123");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testGetStoredProcedureNameExpressionAsString2() {
    DataSource datasource = mock(DataSource.class);
    StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
    storedProcExecutor.setStoredProcedureName("123");
    storedProcExecutor.setBeanFactory(mock(BeanFactory.class));
    storedProcExecutor.afterPropertiesSet();
    assertThat(storedProcExecutor.getStoredProcedureName()).isEqualTo("123");
    assertThat(storedProcExecutor.getStoredProcedureNameExpressionAsString()).isEqualTo("123");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private DataSource datasource;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    datasource = mock(DataSource.class);
}

// === Replace local variable in test with ===
datasource;

```
</details>

---
#### Test Case ID #spring-integration_Test_46_5
#### Test Case Name: `testSetReturningResultSetRowMappersWithNullMap`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-jdbc\src\test\java\org\springframework\integration\jdbc\StoredProcExecutorTests.java`)
#### Mock Object Variable Name: `datasource`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testSetReturningResultSetRowMappersWithNullMap() {
-    DataSource datasource = mock(DataSource.class);
+    // removed local mock; replaced with global field `datasource`
     StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
     assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.setReturningResultSetRowMappers(null)).withMessage("'returningResultSetRowMappers' must not be null.");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testSetReturningResultSetRowMappersWithNullMap() {
    DataSource datasource = mock(DataSource.class);
    StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
    assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.setReturningResultSetRowMappers(null)).withMessage("'returningResultSetRowMappers' must not be null.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private DataSource datasource;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    datasource = mock(DataSource.class);
}

// === Replace local variable in test with ===
datasource;

```
</details>

---
#### Test Case ID #spring-integration_Test_46_6
#### Test Case Name: `testSetReturningResultSetRowMappersWithMapContainingNullValues`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-jdbc\src\test\java\org\springframework\integration\jdbc\StoredProcExecutorTests.java`)
#### Mock Object Variable Name: `datasource`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testSetReturningResultSetRowMappersWithMapContainingNullValues() {
-    DataSource datasource = mock(DataSource.class);
+    // removed local mock; replaced with global field `datasource`
     StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
     Map<String, RowMapper<?>> rowMappers = new HashMap<>();
     rowMappers.put("results", null);
     assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.setReturningResultSetRowMappers(rowMappers)).withMessage("'returningResultSetRowMappers' cannot contain null values.");
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testSetReturningResultSetRowMappersWithMapContainingNullValues() {
    DataSource datasource = mock(DataSource.class);
    StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
    Map<String, RowMapper<?>> rowMappers = new HashMap<>();
    rowMappers.put("results", null);
    assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.setReturningResultSetRowMappers(rowMappers)).withMessage("'returningResultSetRowMappers' cannot contain null values.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private DataSource datasource;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    datasource = mock(DataSource.class);
}

// === Replace local variable in test with ===
datasource;

```
</details>

---
#### Test Case ID #spring-integration_Test_46_7
#### Test Case Name: `testSetReturningResultSetRowMappersWithEmptyMap`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-jdbc\src\test\java\org\springframework\integration\jdbc\StoredProcExecutorTests.java`)
#### Mock Object Variable Name: `datasource`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testSetReturningResultSetRowMappersWithEmptyMap() {
-    DataSource datasource = mock(DataSource.class);
+    // removed local mock; replaced with global field `datasource`
     StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
     Map<String, RowMapper<?>> rowmappers = new HashMap<String, RowMapper<?>>();
     storedProcExecutor.setReturningResultSetRowMappers(rowmappers);
     //Should Successfully finish
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testSetReturningResultSetRowMappersWithEmptyMap() {
    DataSource datasource = mock(DataSource.class);
    StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
    Map<String, RowMapper<?>> rowmappers = new HashMap<String, RowMapper<?>>();
    storedProcExecutor.setReturningResultSetRowMappers(rowmappers);
    //Should Successfully finish
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private DataSource datasource;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    datasource = mock(DataSource.class);
}

// === Replace local variable in test with ===
datasource;

```
</details>

---
#### Test Case ID #spring-integration_Test_46_8
#### Test Case Name: `testSetSqlParameterSourceFactoryWithNullParameter`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-jdbc\src\test\java\org\springframework\integration\jdbc\StoredProcExecutorTests.java`)
#### Mock Object Variable Name: `datasource`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testSetSqlParameterSourceFactoryWithNullParameter() {
-    DataSource datasource = mock(DataSource.class);
+    // removed local mock; replaced with global field `datasource`
     StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
     try {
         storedProcExecutor.setSqlParameterSourceFactory(null);
     } catch (IllegalArgumentException e) {
         assertThat(e.getMessage()).isEqualTo("sqlParameterSourceFactory must not be null.");
         return;
     }
     fail("Exception expected.");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testSetSqlParameterSourceFactoryWithNullParameter() {
    DataSource datasource = mock(DataSource.class);
    StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
    try {
        storedProcExecutor.setSqlParameterSourceFactory(null);
    } catch (IllegalArgumentException e) {
        assertThat(e.getMessage()).isEqualTo("sqlParameterSourceFactory must not be null.");
        return;
    }
    fail("Exception expected.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private DataSource datasource;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    datasource = mock(DataSource.class);
}

// === Replace local variable in test with ===
datasource;

```
</details>

---
#### Test Case ID #spring-integration_Test_46_9
#### Test Case Name: `testSetSqlParametersWithNullValueInList`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-jdbc\src\test\java\org\springframework\integration\jdbc\StoredProcExecutorTests.java`)
#### Mock Object Variable Name: `datasource`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testSetSqlParametersWithNullValueInList() {
-    DataSource datasource = mock(DataSource.class);
+    // removed local mock; replaced with global field `datasource`
     StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
     List<SqlParameter> sqlParameters = new ArrayList<>();
     sqlParameters.add(null);
     assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.setSqlParameters(sqlParameters)).withMessage("'sqlParameters' cannot contain null values.");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testSetSqlParametersWithNullValueInList() {
    DataSource datasource = mock(DataSource.class);
    StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
    List<SqlParameter> sqlParameters = new ArrayList<>();
    sqlParameters.add(null);
    assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.setSqlParameters(sqlParameters)).withMessage("'sqlParameters' cannot contain null values.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private DataSource datasource;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    datasource = mock(DataSource.class);
}

// === Replace local variable in test with ===
datasource;

```
</details>

---
#### Test Case ID #spring-integration_Test_46_10
#### Test Case Name: `testSetSqlParametersWithEmptyList`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-jdbc\src\test\java\org\springframework\integration\jdbc\StoredProcExecutorTests.java`)
#### Mock Object Variable Name: `datasource`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testSetSqlParametersWithEmptyList() {
-    DataSource datasource = mock(DataSource.class);
+    // removed local mock; replaced with global field `datasource`
     StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
     List<SqlParameter> sqlParameters = new ArrayList<>();
     assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.setSqlParameters(sqlParameters)).withMessage("'sqlParameters' must not be null or empty.");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testSetSqlParametersWithEmptyList() {
    DataSource datasource = mock(DataSource.class);
    StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
    List<SqlParameter> sqlParameters = new ArrayList<>();
    assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.setSqlParameters(sqlParameters)).withMessage("'sqlParameters' must not be null or empty.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private DataSource datasource;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    datasource = mock(DataSource.class);
}

// === Replace local variable in test with ===
datasource;

```
</details>

---
#### Test Case ID #spring-integration_Test_46_11
#### Test Case Name: `testSetSqlParametersWithNullList`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-jdbc\src\test\java\org\springframework\integration\jdbc\StoredProcExecutorTests.java`)
#### Mock Object Variable Name: `datasource`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testSetSqlParametersWithNullList() {
-    DataSource datasource = mock(DataSource.class);
+    // removed local mock; replaced with global field `datasource`
     StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
     assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.setSqlParameters(null)).withMessage("'sqlParameters' must not be null or empty.");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testSetSqlParametersWithNullList() {
    DataSource datasource = mock(DataSource.class);
    StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
    assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.setSqlParameters(null)).withMessage("'sqlParameters' must not be null or empty.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private DataSource datasource;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    datasource = mock(DataSource.class);
}

// === Replace local variable in test with ===
datasource;

```
</details>

---
#### Test Case ID #spring-integration_Test_46_12
#### Test Case Name: `testSetProcedureParametersWithNullValueInList`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-jdbc\src\test\java\org\springframework\integration\jdbc\StoredProcExecutorTests.java`)
#### Mock Object Variable Name: `datasource`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testSetProcedureParametersWithNullValueInList() {
-    DataSource datasource = mock(DataSource.class);
+    // removed local mock; replaced with global field `datasource`
     StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
     List<ProcedureParameter> procedureParameters = new ArrayList<>();
     procedureParameters.add(null);
     assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.setProcedureParameters(procedureParameters)).withMessage("'procedureParameters' cannot contain null values.");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testSetProcedureParametersWithNullValueInList() {
    DataSource datasource = mock(DataSource.class);
    StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
    List<ProcedureParameter> procedureParameters = new ArrayList<>();
    procedureParameters.add(null);
    assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.setProcedureParameters(procedureParameters)).withMessage("'procedureParameters' cannot contain null values.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private DataSource datasource;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    datasource = mock(DataSource.class);
}

// === Replace local variable in test with ===
datasource;

```
</details>

---
#### Test Case ID #spring-integration_Test_46_13
#### Test Case Name: `testSetProcedureParametersWithEmptyList`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-jdbc\src\test\java\org\springframework\integration\jdbc\StoredProcExecutorTests.java`)
#### Mock Object Variable Name: `datasource`
<summary>Suggested Diff</summary>

```diff
@@
@Test
public void testSetProcedureParametersWithEmptyList() {
-    DataSource datasource = mock(DataSource.class);
+    // removed local mock; replaced with global field `datasource`
    StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
    List<ProcedureParameter> procedureParameters = new ArrayList<>();
    assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.setProcedureParameters(procedureParameters)).withMessage("'procedureParameters' must not be null or empty.");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testSetProcedureParametersWithEmptyList() {
    DataSource datasource = mock(DataSource.class);
    StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
    List<ProcedureParameter> procedureParameters = new ArrayList<>();
    assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.setProcedureParameters(procedureParameters)).withMessage("'procedureParameters' must not be null or empty.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private DataSource datasource;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    datasource = mock(DataSource.class);
}

// === Replace local variable in test with ===
datasource;

```
</details>

---
#### Test Case ID #spring-integration_Test_46_14
#### Test Case Name: `testSetProcedureParametersWithNullList`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-jdbc\src\test\java\org\springframework\integration\jdbc\StoredProcExecutorTests.java`)
#### Mock Object Variable Name: `datasource`
<summary>Suggested Diff</summary>

```diff
@@
@Test
public void testSetProcedureParametersWithNullList() {
-    DataSource datasource = mock(DataSource.class);
+    // removed local mock; replaced with global field `datasource`
    StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
    assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.setProcedureParameters(null)).withMessage("'procedureParameters' must not be null or empty.");
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testSetProcedureParametersWithNullList() {
    DataSource datasource = mock(DataSource.class);
    StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
    assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.setProcedureParameters(null)).withMessage("'procedureParameters' must not be null or empty.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private DataSource datasource;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    datasource = mock(DataSource.class);
}

// === Replace local variable in test with ===
datasource;

```
</details>

---
#### Test Case ID #spring-integration_Test_46_15
#### Test Case Name: `testStoredProcExecutorWithNonResolvingExpression`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-jdbc\src\test\java\org\springframework\integration\jdbc\StoredProcExecutorTests.java`)
#### Mock Object Variable Name: `datasource`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testStoredProcExecutorWithNonResolvingExpression() throws Exception {
-    final DataSource datasource = mock(DataSource.class);
+    // removed local mock; replaced with global field `datasource`
     final StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
     final ExpressionFactoryBean efb = new ExpressionFactoryBean("headers['stored_procedure_name']");
     efb.afterPropertiesSet();
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testStoredProcExecutorWithNonResolvingExpression() throws Exception {
    final DataSource datasource = mock(DataSource.class);
    final StoredProcExecutor storedProcExecutor = new StoredProcExecutor(datasource);
    final ExpressionFactoryBean efb = new ExpressionFactoryBean("headers['stored_procedure_name']");
    efb.afterPropertiesSet();
    final Expression expression = efb.getObject();
    storedProcExecutor.setStoredProcedureNameExpression(expression);
    storedProcExecutor.setBeanFactory(mock(BeanFactory.class));
    storedProcExecutor.afterPropertiesSet();
    Map<String, SimpleJdbcCallOperations> jdbcCallOperationsMap = new HashMap<>();
    jdbcCallOperationsMap.put("123", mock(SimpleJdbcCallOperations.class));
    new DirectFieldAccessor(storedProcExecutor).setPropertyValue("jdbcCallOperationsMap", jdbcCallOperationsMap);
    //This should work
    storedProcExecutor.executeStoredProcedure(MessageBuilder.withPayload("test").setHeader("stored_procedure_name", "123").build());
    //This should cause an exception
    assertThatIllegalArgumentException().isThrownBy(() -> storedProcExecutor.executeStoredProcedure(MessageBuilder.withPayload("test").setHeader("some_other_header", "123").build())).withMessage("Unable to resolve Stored Procedure/Function name for the provided Expression " + "'headers['stored_procedure_name']'.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private DataSource datasource;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    datasource = mock(DataSource.class);
}

// === Replace local variable in test with ===
datasource;

```
</details>

---
## Mock Clone Instance #spring-integration_MCI_47
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.file.remote.session.SessionFactory<org.springframework.integration.file.remote.gateway.RemoteFileOutboundGatewayTests.TestLsEntry>`
- **Test Case Count**: 6
- **MO Count**: 6

### Reusable Method
```java
private static SessionFactory<RemoteFileOutboundGatewayTests.TestLsEntry> createMockSessionFactory(Session<RemoteFileOutboundGatewayTests.TestLsEntry> session) {
    @SuppressWarnings("unchecked")
    SessionFactory<RemoteFileOutboundGatewayTests.TestLsEntry> sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_47_1
#### Test Case Name: `testPut`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    @SuppressWarnings("unchecked")
-    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
    @SuppressWarnings("unchecked")
    Session<TestLsEntry> session = mock(Session.class);
    RemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<TestLsEntry>(sessionFactory) {

        @Override
        public boolean exists(String path) {
            return false;
        }
    };
    template.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    template.setBeanFactory(mock(BeanFactory.class));
    template.afterPropertiesSet();
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(template, "put", "payload");
    FileTransferringMessageHandler<TestLsEntry> handler = new FileTransferringMessageHandler<>(sessionFactory);
    handler.setRemoteDirectoryExpressionString("'foo/'");
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    gw.afterPropertiesSet();
+    SessionFactory<TestLsEntry> sessionFactory = createMockSessionFactory(session);
    Message<String> requestMessage = MessageBuilder.withPayload("hello").setHeader(FileHeaders.FILENAME, "bar.txt").build();
    String path = (String) gw.handleRequestMessage(requestMessage);
    assertThat(path).isEqualTo("foo/bar.txt");
    ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
    verify(session).write(any(InputStream.class), captor.capture());
    assertThat(captor.getValue()).isEqualTo("foo/bar.txt.writing");
    verify(session).rename("foo/bar.txt.writing", "foo/bar.txt");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testPut() throws Exception {
    @SuppressWarnings("unchecked")
    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
    @SuppressWarnings("unchecked")
    Session<TestLsEntry> session = mock(Session.class);
    RemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<TestLsEntry>(sessionFactory) {

        @Override
        public boolean exists(String path) {
            return false;
        }
    };
    template.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    template.setBeanFactory(mock(BeanFactory.class));
    template.afterPropertiesSet();
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(template, "put", "payload");
    FileTransferringMessageHandler<TestLsEntry> handler = new FileTransferringMessageHandler<>(sessionFactory);
    handler.setRemoteDirectoryExpressionString("'foo/'");
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    Message<String> requestMessage = MessageBuilder.withPayload("hello").setHeader(FileHeaders.FILENAME, "bar.txt").build();
    String path = (String) gw.handleRequestMessage(requestMessage);
    assertThat(path).isEqualTo("foo/bar.txt");
    ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
    verify(session).write(any(InputStream.class), captor.capture());
    assertThat(captor.getValue()).isEqualTo("foo/bar.txt.writing");
    verify(session).rename("foo/bar.txt.writing", "foo/bar.txt");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory<RemoteFileOutboundGatewayTests.TestLsEntry> createMockSessionFactory(Session<RemoteFileOutboundGatewayTests.TestLsEntry> session) {
    @SuppressWarnings("unchecked")
    SessionFactory<RemoteFileOutboundGatewayTests.TestLsEntry> sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_47_2
#### Test Case Name: `testPutExists`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testPutExists() throws Exception {
     @SuppressWarnings("unchecked")
-    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
     @SuppressWarnings("unchecked")
     Session<TestLsEntry> session = mock(Session.class);
     willReturn(Boolean.TRUE).given(session).exists(anyString());
     RemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<>(sessionFactory);
     template.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
     template.setBeanFactory(mock(BeanFactory.class));
     template.afterPropertiesSet();
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(template, "put", "payload");
     FileTransferringMessageHandler<TestLsEntry> handler = new FileTransferringMessageHandler<>(sessionFactory);
     handler.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
     handler.setBeanFactory(mock(BeanFactory.class));
     handler.afterPropertiesSet();
     gw.afterPropertiesSet();
-    when(sessionFactory.getSession()).thenReturn(session);
+    SessionFactory<TestLsEntry> sessionFactory = createMockSessionFactory(session);
     Message<String> requestMessage = MessageBuilder.withPayload("hello").setHeader(FileHeaders.FILENAME, "bar.txt").build();
     // default (null) == REPLACE
     String path = (String) gw.handleRequestMessage(requestMessage);
     assertThat(path).isEqualTo("foo/bar.txt");
     ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
     verify(session).write(any(InputStream.class), captor.capture());
     assertThat(captor.getValue()).isEqualTo("foo/bar.txt.writing");
     verify(session).rename("foo/bar.txt.writing", "foo/bar.txt");
     gw.setFileExistsMode(FileExistsMode.FAIL);
     assertThatExceptionOfType(MessageDeliveryException.class).isThrownBy(() -> gw.handleRequestMessage(requestMessage)).withStackTraceContaining("The destination file already exists");
     gw.setFileExistsMode(FileExistsMode.REPLACE);
     path = (String) gw.handleRequestMessage(requestMessage);
     assertThat(path).isEqualTo("foo/bar.txt");
     captor = ArgumentCaptor.forClass(String.class);
     verify(session, times(2)).write(any(InputStream.class), captor.capture());
     assertThat(captor.getValue()).isEqualTo("foo/bar.txt.writing");
     verify(session, times(2)).rename("foo/bar.txt.writing", "foo/bar.txt");
     gw.setFileExistsMode(FileExistsMode.APPEND);
     path = (String) gw.handleRequestMessage(requestMessage);
     assertThat(path).isEqualTo("foo/bar.txt");
     captor = ArgumentCaptor.forClass(String.class);
     verify(session).append(any(InputStream.class), captor.capture());
     assertThat(captor.getValue()).isEqualTo("foo/bar.txt");
     gw.setFileExistsMode(FileExistsMode.IGNORE);
     path = (String) gw.handleRequestMessage(requestMessage);
     assertThat(path).isEqualTo("foo/bar.txt");
     // no more writes/appends
     verify(session, times(2)).write(any(InputStream.class), anyString());
     verify(session, times(1)).append(any(InputStream.class), anyString());
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testPutExists() throws Exception {
    @SuppressWarnings("unchecked")
    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
    @SuppressWarnings("unchecked")
    Session<TestLsEntry> session = mock(Session.class);
    willReturn(Boolean.TRUE).given(session).exists(anyString());
    RemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<>(sessionFactory);
    template.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    template.setBeanFactory(mock(BeanFactory.class));
    template.afterPropertiesSet();
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(template, "put", "payload");
    FileTransferringMessageHandler<TestLsEntry> handler = new FileTransferringMessageHandler<>(sessionFactory);
    handler.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    Message<String> requestMessage = MessageBuilder.withPayload("hello").setHeader(FileHeaders.FILENAME, "bar.txt").build();
    // default (null) == REPLACE
    String path = (String) gw.handleRequestMessage(requestMessage);
    assertThat(path).isEqualTo("foo/bar.txt");
    ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
    verify(session).write(any(InputStream.class), captor.capture());
    assertThat(captor.getValue()).isEqualTo("foo/bar.txt.writing");
    verify(session).rename("foo/bar.txt.writing", "foo/bar.txt");
    gw.setFileExistsMode(FileExistsMode.FAIL);
    assertThatExceptionOfType(MessageDeliveryException.class).isThrownBy(() -> gw.handleRequestMessage(requestMessage)).withStackTraceContaining("The destination file already exists");
    gw.setFileExistsMode(FileExistsMode.REPLACE);
    path = (String) gw.handleRequestMessage(requestMessage);
    assertThat(path).isEqualTo("foo/bar.txt");
    captor = ArgumentCaptor.forClass(String.class);
    verify(session, times(2)).write(any(InputStream.class), captor.capture());
    assertThat(captor.getValue()).isEqualTo("foo/bar.txt.writing");
    verify(session, times(2)).rename("foo/bar.txt.writing", "foo/bar.txt");
    gw.setFileExistsMode(FileExistsMode.APPEND);
    path = (String) gw.handleRequestMessage(requestMessage);
    assertThat(path).isEqualTo("foo/bar.txt");
    captor = ArgumentCaptor.forClass(String.class);
    verify(session).append(any(InputStream.class), captor.capture());
    assertThat(captor.getValue()).isEqualTo("foo/bar.txt");
    gw.setFileExistsMode(FileExistsMode.IGNORE);
    path = (String) gw.handleRequestMessage(requestMessage);
    assertThat(path).isEqualTo("foo/bar.txt");
    // no more writes/appends
    verify(session, times(2)).write(any(InputStream.class), anyString());
    verify(session, times(1)).append(any(InputStream.class), anyString());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory<RemoteFileOutboundGatewayTests.TestLsEntry> createMockSessionFactory(Session<RemoteFileOutboundGatewayTests.TestLsEntry> session) {
    @SuppressWarnings("unchecked")
    SessionFactory<RemoteFileOutboundGatewayTests.TestLsEntry> sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_47_3
#### Test Case Name: `testPutExistsExpression`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 @SuppressWarnings("unchecked")
 public void testPutExistsExpression() throws Exception {
-    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
     Session<TestLsEntry> session = mock(Session.class);
     willReturn(Boolean.TRUE).given(session).exists(anyString());
     RemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<>(sessionFactory);
     template.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
     template.setBeanFactory(mock(BeanFactory.class));
     template.afterPropertiesSet();
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(template, "put", "payload");
     FileTransferringMessageHandler<TestLsEntry> handler = new FileTransferringMessageHandler<>(sessionFactory);
     handler.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
     handler.setBeanFactory(mock(BeanFactory.class));
     handler.afterPropertiesSet();
     gw.afterPropertiesSet();
     gw.setFileExistsModeExpressionString("headers[\"file.exists.mode\"]");
-    when(sessionFactory.getSession()).thenReturn(session);
+    SessionFactory<TestLsEntry> sessionFactory = createMockSessionFactory(session);
     MessageBuilder<String> requestMessageBuilder = MessageBuilder.withPayload("hello").setHeader(FileHeaders.FILENAME, "bar.txt");
     Message<String> defaultMessage = requestMessageBuilder.build();
     String path = (String) gw.handleRequestMessage(defaultMessage);
     assertThat(path).isEqualTo("foo/bar.txt");
     ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
     verify(session).write(any(InputStream.class), captor.capture());
     assertThat(captor.getValue()).isEqualTo("foo/bar.txt.writing");
     verify(session).rename("foo/bar.txt.writing", "foo/bar.txt");
     Message<String> failMessage = requestMessageBuilder.setHeader("file.exists.mode", FileExistsMode.FAIL).build();
     assertThatExceptionOfType(MessageDeliveryException.class).isThrownBy(() -> gw.handleRequestMessage(failMessage)).withStackTraceContaining("The destination file already exists");
     Message<String> replaceMessage = requestMessageBuilder.setHeader("file.exists.mode", "replace").build();
     path = (String) gw.handleRequestMessage(replaceMessage);
     assertThat(path).isEqualTo("foo/bar.txt");
     captor = ArgumentCaptor.forClass(String.class);
     verify(session, times(2)).write(any(InputStream.class), captor.capture());
     assertThat(captor.getValue()).isEqualTo("foo/bar.txt.writing");
     verify(session, times(2)).rename("foo/bar.txt.writing", "foo/bar.txt");
     Message<String> appendMessage = requestMessageBuilder.setHeader("file.exists.mode", "APPEND").build();
     path = (String) gw.handleRequestMessage(appendMessage);
     assertThat(path).isEqualTo("foo/bar.txt");
     captor = ArgumentCaptor.forClass(String.class);
     verify(session).append(any(InputStream.class), captor.capture());
     assertThat(captor.getValue()).isEqualTo("foo/bar.txt");
     Message<String> ignoreMessage = requestMessageBuilder.setHeader("file.exists.mode", FileExistsMode.IGNORE).build();
     path = (String) gw.handleRequestMessage(ignoreMessage);
     assertThat(path).isEqualTo("foo/bar.txt");
     // no more writes/appends
     verify(session, times(2)).write(any(InputStream.class), anyString());
     verify(session, times(1)).append(any(InputStream.class), anyString());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@SuppressWarnings("unchecked")
public void testPutExistsExpression() throws Exception {
    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
    Session<TestLsEntry> session = mock(Session.class);
    willReturn(Boolean.TRUE).given(session).exists(anyString());
    RemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<>(sessionFactory);
    template.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    template.setBeanFactory(mock(BeanFactory.class));
    template.afterPropertiesSet();
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(template, "put", "payload");
    FileTransferringMessageHandler<TestLsEntry> handler = new FileTransferringMessageHandler<>(sessionFactory);
    handler.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    gw.afterPropertiesSet();
    gw.setFileExistsModeExpressionString("headers[\"file.exists.mode\"]");
    when(sessionFactory.getSession()).thenReturn(session);
    MessageBuilder<String> requestMessageBuilder = MessageBuilder.withPayload("hello").setHeader(FileHeaders.FILENAME, "bar.txt");
    Message<String> defaultMessage = requestMessageBuilder.build();
    String path = (String) gw.handleRequestMessage(defaultMessage);
    assertThat(path).isEqualTo("foo/bar.txt");
    ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
    verify(session).write(any(InputStream.class), captor.capture());
    assertThat(captor.getValue()).isEqualTo("foo/bar.txt.writing");
    verify(session).rename("foo/bar.txt.writing", "foo/bar.txt");
    Message<String> failMessage = requestMessageBuilder.setHeader("file.exists.mode", FileExistsMode.FAIL).build();
    assertThatExceptionOfType(MessageDeliveryException.class).isThrownBy(() -> gw.handleRequestMessage(failMessage)).withStackTraceContaining("The destination file already exists");
    Message<String> replaceMessage = requestMessageBuilder.setHeader("file.exists.mode", "replace").build();
    path = (String) gw.handleRequestMessage(replaceMessage);
    assertThat(path).isEqualTo("foo/bar.txt");
    captor = ArgumentCaptor.forClass(String.class);
    verify(session, times(2)).write(any(InputStream.class), captor.capture());
    assertThat(captor.getValue()).isEqualTo("foo/bar.txt.writing");
    verify(session, times(2)).rename("foo/bar.txt.writing", "foo/bar.txt");
    Message<String> appendMessage = requestMessageBuilder.setHeader("file.exists.mode", "APPEND").build();
    path = (String) gw.handleRequestMessage(appendMessage);
    assertThat(path).isEqualTo("foo/bar.txt");
    captor = ArgumentCaptor.forClass(String.class);
    verify(session).append(any(InputStream.class), captor.capture());
    assertThat(captor.getValue()).isEqualTo("foo/bar.txt");
    Message<String> ignoreMessage = requestMessageBuilder.setHeader("file.exists.mode", FileExistsMode.IGNORE).build();
    path = (String) gw.handleRequestMessage(ignoreMessage);
    assertThat(path).isEqualTo("foo/bar.txt");
    // no more writes/appends
    verify(session, times(2)).write(any(InputStream.class), anyString());
    verify(session, times(1)).append(any(InputStream.class), anyString());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory<RemoteFileOutboundGatewayTests.TestLsEntry> createMockSessionFactory(Session<RemoteFileOutboundGatewayTests.TestLsEntry> session) {
    @SuppressWarnings("unchecked")
    SessionFactory<RemoteFileOutboundGatewayTests.TestLsEntry> sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_47_4
#### Test Case Name: `testMput`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 @SuppressWarnings("unchecked")
 public void testMput() throws Exception {
-    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
     Session<TestLsEntry> session = mock(Session.class);
+    SessionFactory<TestLsEntry> sessionFactory = createMockSessionFactory(session);
     RemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<>(sessionFactory);
     template.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
     template.setBeanFactory(mock(BeanFactory.class));
     template.afterPropertiesSet();
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(template, "mput", "payload");
     gw.afterPropertiesSet();
-    when(sessionFactory.getSession()).thenReturn(session);
     final AtomicReference<String> written = new AtomicReference<>();
     doAnswer(invocation -> {
         written.set(invocation.getArgument(1));
         return null;
     }).when(session).write(any(InputStream.class), anyString());
     assertThat(new File(tempFolder, "baz.txt").createNewFile()).isTrue();
     assertThat(new File(tempFolder, "qux.txt").createNewFile()).isTrue();
     Message<File> requestMessage = MessageBuilder.withPayload(tempFolder).build();
     List<String> out = (List<String>) gw.handleRequestMessage(requestMessage);
     assertThat(out).hasSize(2);
     assertThat(out.get(0)).isNotEqualTo(out.get(1));
     assertThat(out.get(0)).isIn("foo/baz.txt", "foo/qux.txt");
     assertThat(out.get(1)).isIn("foo/baz.txt", "foo/qux.txt");
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@SuppressWarnings("unchecked")
public void testMput() throws Exception {
    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
    Session<TestLsEntry> session = mock(Session.class);
    RemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<>(sessionFactory);
    template.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    template.setBeanFactory(mock(BeanFactory.class));
    template.afterPropertiesSet();
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(template, "mput", "payload");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    final AtomicReference<String> written = new AtomicReference<>();
    doAnswer(invocation -> {
        written.set(invocation.getArgument(1));
        return null;
    }).when(session).write(any(InputStream.class), anyString());
    assertThat(new File(tempFolder, "baz.txt").createNewFile()).isTrue();
    assertThat(new File(tempFolder, "qux.txt").createNewFile()).isTrue();
    Message<File> requestMessage = MessageBuilder.withPayload(tempFolder).build();
    List<String> out = (List<String>) gw.handleRequestMessage(requestMessage);
    assertThat(out).hasSize(2);
    assertThat(out.get(0)).isNotEqualTo(out.get(1));
    assertThat(out.get(0)).isIn("foo/baz.txt", "foo/qux.txt");
    assertThat(out.get(1)).isIn("foo/baz.txt", "foo/qux.txt");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory<RemoteFileOutboundGatewayTests.TestLsEntry> createMockSessionFactory(Session<RemoteFileOutboundGatewayTests.TestLsEntry> session) {
    @SuppressWarnings("unchecked")
    SessionFactory<RemoteFileOutboundGatewayTests.TestLsEntry> sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_47_5
#### Test Case Name: `testMputRecursive`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 @SuppressWarnings("unchecked")
 public void testMputRecursive() throws Exception {
-    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
     Session<TestLsEntry> session = mock(Session.class);
+    SessionFactory<TestLsEntry> sessionFactory = createMockSessionFactory(session);
     RemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<>(sessionFactory);
     template.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
     template.setBeanFactory(mock(BeanFactory.class));
     template.afterPropertiesSet();
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(template, "mput", null);
     gw.setOptions("-R");
     gw.afterPropertiesSet();
-    when(sessionFactory.getSession()).thenReturn(session);
     final AtomicReference<String> written = new AtomicReference<>();
     doAnswer(invocation -> {
         written.set(invocation.getArgument(1));
         return null;
     }).when(session).write(any(InputStream.class), anyString());
     new File(tempFolder, "baz.txt").createNewFile();
     new File(tempFolder, "qux.txt").createNewFile();
     File dir1 = Files.createTempDirectory(tempFolder.toPath(), "junit").toFile();
     File file3 = File.createTempFile("foo", ".txt", dir1);
     Message<File> requestMessage = MessageBuilder.withPayload(tempFolder).build();
     List<String> out = (List<String>) gw.handleRequestMessage(requestMessage);
     assertThat(out).hasSize(3);
     assertThat(out.get(0)).isNotEqualTo(out.get(1));
     assertThat(out.get(0)).isIn("foo/baz.txt", "foo/qux.txt", "foo/" + dir1.getName() + "/" + file3.getName());
     assertThat(out.get(1)).isIn("foo/baz.txt", "foo/qux.txt", "foo/" + dir1.getName() + "/" + file3.getName());
     assertThat(out.get(2)).isIn("foo/baz.txt", "foo/qux.txt", "foo/" + dir1.getName() + "/" + file3.getName());
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@SuppressWarnings("unchecked")
public void testMputRecursive() throws Exception {
    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
    Session<TestLsEntry> session = mock(Session.class);
    RemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<>(sessionFactory);
    template.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    template.setBeanFactory(mock(BeanFactory.class));
    template.afterPropertiesSet();
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(template, "mput", null);
    gw.setOptions("-R");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    final AtomicReference<String> written = new AtomicReference<>();
    doAnswer(invocation -> {
        written.set(invocation.getArgument(1));
        return null;
    }).when(session).write(any(InputStream.class), anyString());
    new File(tempFolder, "baz.txt").createNewFile();
    new File(tempFolder, "qux.txt").createNewFile();
    File dir1 = Files.createTempDirectory(tempFolder.toPath(), "junit").toFile();
    File file3 = File.createTempFile("foo", ".txt", dir1);
    Message<File> requestMessage = MessageBuilder.withPayload(tempFolder).build();
    List<String> out = (List<String>) gw.handleRequestMessage(requestMessage);
    assertThat(out).hasSize(3);
    assertThat(out.get(0)).isNotEqualTo(out.get(1));
    assertThat(out.get(0)).isIn("foo/baz.txt", "foo/qux.txt", "foo/" + dir1.getName() + "/" + file3.getName());
    assertThat(out.get(1)).isIn("foo/baz.txt", "foo/qux.txt", "foo/" + dir1.getName() + "/" + file3.getName());
    assertThat(out.get(2)).isIn("foo/baz.txt", "foo/qux.txt", "foo/" + dir1.getName() + "/" + file3.getName());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory<RemoteFileOutboundGatewayTests.TestLsEntry> createMockSessionFactory(Session<RemoteFileOutboundGatewayTests.TestLsEntry> session) {
    @SuppressWarnings("unchecked")
    SessionFactory<RemoteFileOutboundGatewayTests.TestLsEntry> sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_47_6
#### Test Case Name: `testMputCollection`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `sessionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 @SuppressWarnings("unchecked")
 public void testMputCollection() throws Exception {
-    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
     Session<TestLsEntry> session = mock(Session.class);
     TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mput", "payload");
     gw.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
     gw.afterPropertiesSet();
-    when(sessionFactory.getSession()).thenReturn(session);
+    SessionFactory<TestLsEntry> sessionFactory = createMockSessionFactory(session);
     final AtomicReference<String> written = new AtomicReference<>();
     doAnswer(invocation -> {
         written.set(invocation.getArgument(1));
         return null;
     }).when(session).write(any(InputStream.class), anyString());
     List<File> files = new ArrayList<>();
     File file1 = new File(tempFolder, "fiz.txt");
     file1.createNewFile();
     files.add(file1);
     File file2 = new File(tempFolder, "buz.txt");
     file2.createNewFile();
     files.add(file2);
     Message<List<File>> requestMessage = MessageBuilder.withPayload(files).build();
     List<String> out = (List<String>) gw.handleRequestMessage(requestMessage);
     assertThat(out).isNotNull().hasSize(2);
     assertThat(out.get(0)).isNotEqualTo(out.get(1));
     assertThat(out.get(0)).isEqualTo("foo/fiz.txt");
     assertThat(out.get(1)).isEqualTo("foo/buz.txt");
     assertThat(written.get()).isEqualTo("foo/buz.txt.writing");
     verify(session).rename("foo/buz.txt.writing", "foo/buz.txt");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@SuppressWarnings("unchecked")
public void testMputCollection() throws Exception {
    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
    Session<TestLsEntry> session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mput", "payload");
    gw.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    final AtomicReference<String> written = new AtomicReference<>();
    doAnswer(invocation -> {
        written.set(invocation.getArgument(1));
        return null;
    }).when(session).write(any(InputStream.class), anyString());
    List<File> files = new ArrayList<>();
    File file1 = new File(tempFolder, "fiz.txt");
    file1.createNewFile();
    files.add(file1);
    File file2 = new File(tempFolder, "buz.txt");
    file2.createNewFile();
    files.add(file2);
    Message<List<File>> requestMessage = MessageBuilder.withPayload(files).build();
    List<String> out = (List<String>) gw.handleRequestMessage(requestMessage);
    assertThat(out).isNotNull().hasSize(2);
    assertThat(out.get(0)).isNotEqualTo(out.get(1));
    assertThat(out.get(0)).isEqualTo("foo/fiz.txt");
    assertThat(out.get(1)).isEqualTo("foo/buz.txt");
    assertThat(written.get()).isEqualTo("foo/buz.txt.writing");
    verify(session).rename("foo/buz.txt.writing", "foo/buz.txt");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SessionFactory<RemoteFileOutboundGatewayTests.TestLsEntry> createMockSessionFactory(Session<RemoteFileOutboundGatewayTests.TestLsEntry> session) {
    @SuppressWarnings("unchecked")
    SessionFactory<RemoteFileOutboundGatewayTests.TestLsEntry> sessionFactory = mock(SessionFactory.class);
    when(sessionFactory.getSession()).thenReturn(session);
    return sessionFactory;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_48
- **Scope**: method level
- **Mocked Class**: `org.springframework.ws.soap.SoapMessage`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static SoapMessage createMockSoapMessage(String soapActionReturn) {
    SoapMessage soapMessage = mock(SoapMessage.class);
    when(soapMessage.getSoapAction()).thenReturn(soapActionReturn);
    return soapMessage;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_48_1
#### Test Case Name: `testExtractStandardHeadersEmptySoapAction`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ws\src\test\java\org\springframework\integration\ws\DefaultSoapHeaderMapperTests.java`)
#### Mock Object Variable Name: `soapMessage`
<summary>Suggested Diff</summary>

```diff
@@
     DefaultSoapHeaderMapper mapper = new DefaultSoapHeaderMapper();
-    SoapMessage soapMessage = mock(SoapMessage.class);
-    when(soapMessage.getSoapAction()).thenReturn("");
+    SoapMessage soapMessage = createMockSoapMessage("");
     assertThat(mapper.extractStandardHeaders(soapMessage).isEmpty()).isTrue();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testExtractStandardHeadersEmptySoapAction() {
    DefaultSoapHeaderMapper mapper = new DefaultSoapHeaderMapper();
    SoapMessage soapMessage = mock(SoapMessage.class);
    when(soapMessage.getSoapAction()).thenReturn("");
    assertThat(mapper.extractStandardHeaders(soapMessage).isEmpty()).isTrue();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SoapMessage createMockSoapMessage(String soapActionReturn) {
    SoapMessage soapMessage = mock(SoapMessage.class);
    when(soapMessage.getSoapAction()).thenReturn(soapActionReturn);
    return soapMessage;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_48_2
#### Test Case Name: `testExtractStandardHeadersNonEmptySoapAction`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ws\src\test\java\org\springframework\integration\ws\DefaultSoapHeaderMapperTests.java`)
#### Mock Object Variable Name: `soapMessage`
<summary>Suggested Diff</summary>

```diff
@@
    DefaultSoapHeaderMapper mapper = new DefaultSoapHeaderMapper();
-    SoapMessage soapMessage = mock(SoapMessage.class);
-    when(soapMessage.getSoapAction()).thenReturn("foo");
+    SoapMessage soapMessage = createMockSoapMessage("foo");
    Map<String, Object> standardHeaders = mapper.toHeadersFromRequest(soapMessage);
    assertThat(standardHeaders.size()).isEqualTo(1);
    assertThat(standardHeaders.containsKey(WebServiceHeaders.SOAP_ACTION)).isTrue();
    assertThat(standardHeaders.get(WebServiceHeaders.SOAP_ACTION)).isEqualTo("foo");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testExtractStandardHeadersNonEmptySoapAction() {
    DefaultSoapHeaderMapper mapper = new DefaultSoapHeaderMapper();
    SoapMessage soapMessage = mock(SoapMessage.class);
    when(soapMessage.getSoapAction()).thenReturn("foo");
    Map<String, Object> standardHeaders = mapper.toHeadersFromRequest(soapMessage);
    assertThat(standardHeaders.size()).isEqualTo(1);
    assertThat(standardHeaders.containsKey(WebServiceHeaders.SOAP_ACTION)).isTrue();
    assertThat(standardHeaders.get(WebServiceHeaders.SOAP_ACTION)).isEqualTo("foo");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SoapMessage createMockSoapMessage(String soapActionReturn) {
    SoapMessage soapMessage = mock(SoapMessage.class);
    when(soapMessage.getSoapAction()).thenReturn(soapActionReturn);
    return soapMessage;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_49
- **Scope**: method level
- **Mocked Class**: `com.rabbitmq.client.ConnectionFactory`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static ConnectionFactory createMockConnectionFactory(Connection connection) {
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
    return connectionFactory;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_49_1
#### Test Case Name: `testAck`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\inbound\AmqpMessageSourceTests.java`)
#### Mock Object Variable Name: `connectionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    willReturn(channel).given(connection).createChannel();
-    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
-    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
+    ConnectionFactory connectionFactory = createMockConnectionFactory(connection);
    CachingConnectionFactory ccf = new CachingConnectionFactory(connectionFactory);
    AmqpMessageSource source = new AmqpMessageSource(ccf, "foo");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testAck() throws Exception {
    Channel channel = mock(Channel.class);
    willReturn(true).given(channel).isOpen();
    Envelope envelope = new Envelope(123L, false, "ex", "rk");
    BasicProperties props = new BasicProperties.Builder().contentType(MessageProperties.DEFAULT_CONTENT_TYPE).build();
    GetResponse getResponse = new GetResponse(envelope, props, "bar".getBytes(), 0);
    willReturn(getResponse).given(channel).basicGet("foo", false);
    Connection connection = mock(Connection.class);
    willReturn(true).given(connection).isOpen();
    willReturn(channel).given(connection).createChannel();
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
    CachingConnectionFactory ccf = new CachingConnectionFactory(connectionFactory);
    AmqpMessageSource source = new AmqpMessageSource(ccf, "foo");
    source.setRawMessageHeader(true);
    Message<?> received = source.receive();
    assertThat(received.getHeaders().get(AmqpMessageHeaderErrorMessageStrategy.AMQP_RAW_MESSAGE)).isInstanceOf(org.springframework.amqp.core.Message.class);
    assertThat(received.getHeaders().get(IntegrationMessageHeaderAccessor.SOURCE_DATA)).isSameAs(received.getHeaders().get(AmqpMessageHeaderErrorMessageStrategy.AMQP_RAW_MESSAGE));
    assertThat(received.getHeaders().get(AmqpHeaders.CONSUMER_QUEUE)).isEqualTo("foo");
    // make sure channel is not cached
    org.springframework.amqp.rabbit.connection.Connection conn = ccf.createConnection();
    // should not have been "closed"
    Channel notCached = conn.createChannel(false);
    verify(connection, times(2)).createChannel();
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(Status.ACCEPT);
    verify(channel).basicAck(123L, false);
    // should have been "closed"
    Channel cached = conn.createChannel(false);
    verify(connection, times(2)).createChannel();
    notCached.close();
    cached.close();
    ccf.destroy();
    verify(channel, times(2)).close();
    verify(connection).close(30000);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConnectionFactory createMockConnectionFactory(Connection connection) {
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
    return connectionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_49_2
#### Test Case Name: `testNackOrRequeue`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\inbound\AmqpMessageSourceTests.java`)
#### Mock Object Variable Name: `connectionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    willReturn(true).given(connection).isOpen();
    willReturn(channel).given(connection).createChannel();
-    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
-    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
+    ConnectionFactory connectionFactory = createMockConnectionFactory(connection);
    CachingConnectionFactory ccf = new CachingConnectionFactory(connectionFactory);
    AmqpMessageSource source = new AmqpMessageSource(ccf, "foo");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
private void testNackOrRequeue(boolean requeue) throws Exception {
    Channel channel = mock(Channel.class);
    willReturn(true).given(channel).isOpen();
    Envelope envelope = new Envelope(123L, false, "ex", "rk");
    BasicProperties props = new BasicProperties.Builder().contentType(MessageProperties.DEFAULT_CONTENT_TYPE).build();
    GetResponse getResponse = new GetResponse(envelope, props, "bar".getBytes(), 0);
    willReturn(getResponse).given(channel).basicGet("foo", false);
    Connection connection = mock(Connection.class);
    willReturn(true).given(connection).isOpen();
    willReturn(channel).given(connection).createChannel();
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
    CachingConnectionFactory ccf = new CachingConnectionFactory(connectionFactory);
    AmqpMessageSource source = new AmqpMessageSource(ccf, "foo");
    Message<?> received = source.receive();
    verify(connection).createChannel();
    StaticMessageHeaderAccessor.getAcknowledgmentCallback(received).acknowledge(requeue ? Status.REQUEUE : Status.REJECT);
    verify(channel).basicReject(123L, requeue);
    verify(connection).createChannel();
    ccf.destroy();
    verify(channel).close();
    verify(connection).close(30000);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConnectionFactory createMockConnectionFactory(Connection connection) {
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
    return connectionFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_49_3
#### Test Case Name: `testBatch`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-amqp\src\test\java\org\springframework\integration\amqp\inbound\AmqpMessageSourceTests.java`)
#### Mock Object Variable Name: `connectionFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    willReturn(true).given(connection).isOpen();
    willReturn(channel).given(connection).createChannel();
-    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
-    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
+    ConnectionFactory connectionFactory = createMockConnectionFactory(connection);
    CachingConnectionFactory ccf = new CachingConnectionFactory(connectionFactory);
    AmqpMessageSource source = new AmqpMessageSource(ccf, "foo");
    Message<?> received = source.receive();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "unchecked" })
@Test
public void testBatch() throws Exception {
    SimpleBatchingStrategy bs = new SimpleBatchingStrategy(2, 10_000, 10_000L);
    MessageProperties messageProperties = new MessageProperties();
    messageProperties.setContentType("text/plain");
    org.springframework.amqp.core.Message message = new org.springframework.amqp.core.Message("test1".getBytes(), messageProperties);
    bs.addToBatch("foo", "bar", message);
    message = new org.springframework.amqp.core.Message("test2".getBytes(), messageProperties);
    MessageBatch batched = bs.addToBatch("foo", "bar", message);
    Channel channel = mock(Channel.class);
    willReturn(true).given(channel).isOpen();
    Envelope envelope = new Envelope(123L, false, "ex", "rk");
    BasicProperties props = new BasicProperties.Builder().headers(batched.message().getMessageProperties().getHeaders()).contentType("text/plain").build();
    GetResponse getResponse = new GetResponse(envelope, props, batched.message().getBody(), 0);
    willReturn(getResponse).given(channel).basicGet("foo", false);
    Connection connection = mock(Connection.class);
    willReturn(true).given(connection).isOpen();
    willReturn(channel).given(connection).createChannel();
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
    CachingConnectionFactory ccf = new CachingConnectionFactory(connectionFactory);
    AmqpMessageSource source = new AmqpMessageSource(ccf, "foo");
    Message<?> received = source.receive();
    assertThat(received).isNotNull();
    assertThat(((List<String>) received.getPayload())).contains("test1", "test2");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConnectionFactory createMockConnectionFactory(Connection connection) {
    ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
    willReturn(connection).given(connectionFactory).newConnection((ExecutorService) isNull(), anyString());
    return connectionFactory;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_50
- **Scope**: method level
- **Mocked Class**: `org.apache.kafka.clients.producer.Producer`
- **Test Case Count**: 6
- **MO Count**: 6

### Reusable Method
```java
private static Producer createMockProducer() {
    Producer producer = mock(Producer.class);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    return producer;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_50_1
#### Test Case Name: `testTransaction`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `producer`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ProducerFactory pf = mock(ProducerFactory.class);
    given(pf.transactionCapable()).willReturn(true);
-    Producer producer = mock(Producer.class);
-    given(pf.createProducer(isNull())).willReturn(producer);
-    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
+    Producer producer = createMockProducer();
+    given(pf.createProducer(isNull())).willReturn(producer);
    KafkaTemplate template = new KafkaTemplate(pf);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setTopicExpression(new LiteralExpression("bar"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.start();
    handler.handleMessage(new GenericMessage<>("foo"));
    handler.stop();
    InOrder inOrder = inOrder(producer);
    inOrder.verify(producer).beginTransaction();
    inOrder.verify(producer).send(any(ProducerRecord.class), any(Callback.class));
    inOrder.verify(producer).commitTransaction();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testTransaction() {
    ProducerFactory pf = mock(ProducerFactory.class);
    given(pf.transactionCapable()).willReturn(true);
    Producer producer = mock(Producer.class);
    given(pf.createProducer(isNull())).willReturn(producer);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    KafkaTemplate template = new KafkaTemplate(pf);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setTopicExpression(new LiteralExpression("bar"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.start();
    handler.handleMessage(new GenericMessage<>("foo"));
    handler.stop();
    InOrder inOrder = inOrder(producer);
    inOrder.verify(producer).beginTransaction();
    inOrder.verify(producer).send(any(ProducerRecord.class), any(Callback.class));
    inOrder.verify(producer).commitTransaction();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Producer createMockProducer() {
    Producer producer = mock(Producer.class);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    return producer;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_50_2
#### Test Case Name: `testTransactionTxIdOverride`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `producer`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testTransactionTxIdOverride() {
-    Producer producer = mock(Producer.class);
+    Producer producer = createMockProducer();
    AtomicReference<String> txId = new AtomicReference<>();
    DefaultKafkaProducerFactory pf = new DefaultKafkaProducerFactory(Collections.emptyMap()) {

        @Override
        protected Producer createTransactionalProducer(String txIdPrefix) {
            txId.set(txIdPrefix);
            return producer;
        }
    };
-    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    KafkaTemplate template = new KafkaTemplate(pf);
    template.setTransactionIdPrefix("overridden.tx.id.");
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setTopicExpression(new LiteralExpression("bar"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.start();
    handler.handleMessage(new GenericMessage<>("foo"));
    handler.stop();
    InOrder inOrder = inOrder(producer);
    inOrder.verify(producer).beginTransaction();
    inOrder.verify(producer).send(any(ProducerRecord.class), any(Callback.class));
    inOrder.verify(producer).commitTransaction();
    assertThat(txId.get()).isEqualTo("overridden.tx.id.");
+
+
+    // static import or qualification may be needed for createMockProducer()
}
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testTransactionTxIdOverride() {
    Producer producer = mock(Producer.class);
    AtomicReference<String> txId = new AtomicReference<>();
    DefaultKafkaProducerFactory pf = new DefaultKafkaProducerFactory(Collections.emptyMap()) {

        @Override
        protected Producer createTransactionalProducer(String txIdPrefix) {
            txId.set(txIdPrefix);
            return producer;
        }
    };
    pf.setTransactionIdPrefix("default.tx.id.");
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    KafkaTemplate template = new KafkaTemplate(pf);
    template.setTransactionIdPrefix("overridden.tx.id.");
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setTopicExpression(new LiteralExpression("bar"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.start();
    handler.handleMessage(new GenericMessage<>("foo"));
    handler.stop();
    InOrder inOrder = inOrder(producer);
    inOrder.verify(producer).beginTransaction();
    inOrder.verify(producer).send(any(ProducerRecord.class), any(Callback.class));
    inOrder.verify(producer).commitTransaction();
    assertThat(txId.get()).isEqualTo("overridden.tx.id.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Producer createMockProducer() {
    Producer producer = mock(Producer.class);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    return producer;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_50_3
#### Test Case Name: `testTransactionSynch`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `producer`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testTransactionSynch() {
-    Producer producer = mock(Producer.class);
+    Producer producer = createMockProducer();
    ProducerFactory pf = mock(ProducerFactory.class);
    given(pf.transactionCapable()).willReturn(true);
    given(pf.createProducer(isNull())).willReturn(producer);
-    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    KafkaTemplate template = new KafkaTemplate(pf);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testTransactionSynch() {
    Producer producer = mock(Producer.class);
    ProducerFactory pf = mock(ProducerFactory.class);
    given(pf.transactionCapable()).willReturn(true);
    given(pf.createProducer(isNull())).willReturn(producer);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    KafkaTemplate template = new KafkaTemplate(pf);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setTopicExpression(new LiteralExpression("bar"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.start();
    try {
        new TransactionTemplate(new SomeOtherTransactionManager()).executeWithoutResult(status -> {
            handler.handleMessage(new GenericMessage<>("foo"));
            throw new IllegalStateException("test");
        });
    } catch (IllegalStateException ex) {
    }
    handler.stop();
    verify(producer).beginTransaction();
    verify(producer).send(any(ProducerRecord.class), any(Callback.class));
    verify(producer).abortTransaction();
    verify(producer).close(any());
    verifyNoMoreInteractions(producer);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Producer createMockProducer() {
    Producer producer = mock(Producer.class);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    return producer;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_50_4
#### Test Case Name: `testFlush`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `producer`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ProducerFactory pf = mock(ProducerFactory.class);
-    Producer producer = mock(Producer.class);
+    Producer producer = createMockProducer();
    given(pf.createProducer()).willReturn(producer);
-    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    KafkaTemplate template = new KafkaTemplate(pf);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setTopicExpression(new LiteralExpression("bar"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.start();
    handler.handleMessage(new GenericMessage<>("foo", Collections.singletonMap(KafkaIntegrationHeaders.FLUSH, Boolean.TRUE)));
    InOrder inOrder = inOrder(producer);
    ArgumentCaptor<ProducerRecord> captor = ArgumentCaptor.forClass(ProducerRecord.class);
    inOrder.verify(producer).send(captor.capture(), any(Callback.class));
    inOrder.verify(producer).flush();
    handler.stop();
    assertThat(captor.getValue().headers().lastHeader(KafkaIntegrationHeaders.FLUSH)).isNull();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testFlush() {
    ProducerFactory pf = mock(ProducerFactory.class);
    Producer producer = mock(Producer.class);
    given(pf.createProducer()).willReturn(producer);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    KafkaTemplate template = new KafkaTemplate(pf);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setTopicExpression(new LiteralExpression("bar"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.start();
    handler.handleMessage(new GenericMessage<>("foo", Collections.singletonMap(KafkaIntegrationHeaders.FLUSH, Boolean.TRUE)));
    InOrder inOrder = inOrder(producer);
    ArgumentCaptor<ProducerRecord> captor = ArgumentCaptor.forClass(ProducerRecord.class);
    inOrder.verify(producer).send(captor.capture(), any(Callback.class));
    inOrder.verify(producer).flush();
    handler.stop();
    assertThat(captor.getValue().headers().lastHeader(KafkaIntegrationHeaders.FLUSH)).isNull();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Producer createMockProducer() {
    Producer producer = mock(Producer.class);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    return producer;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_50_5
#### Test Case Name: `testNoFlush`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `producer`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ProducerFactory pf = mock(ProducerFactory.class);
-    Producer producer = mock(Producer.class);
+    Producer producer = createMockProducer();
    given(pf.createProducer()).willReturn(producer);
-    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    KafkaTemplate template = new KafkaTemplate(pf);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setTopicExpression(new LiteralExpression("bar"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.start();
    handler.handleMessage(new GenericMessage<>("foo"));
    InOrder inOrder = inOrder(producer);
    inOrder.verify(producer).send(any(ProducerRecord.class), any(Callback.class));
    inOrder.verify(producer, never()).flush();
    handler.stop();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void testNoFlush() {
    ProducerFactory pf = mock(ProducerFactory.class);
    Producer producer = mock(Producer.class);
    given(pf.createProducer()).willReturn(producer);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    KafkaTemplate template = new KafkaTemplate(pf);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setTopicExpression(new LiteralExpression("bar"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.start();
    handler.handleMessage(new GenericMessage<>("foo"));
    InOrder inOrder = inOrder(producer);
    inOrder.verify(producer).send(any(ProducerRecord.class), any(Callback.class));
    inOrder.verify(producer, never()).flush();
    handler.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Producer createMockProducer() {
    Producer producer = mock(Producer.class);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    return producer;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_50_6
#### Test Case Name: `conversion`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `producer`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ProducerFactory pf = mock(ProducerFactory.class);
-    Producer producer = mock(Producer.class);
+    Producer producer = createMockProducer();
    given(pf.createProducer()).willReturn(producer);
-    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    KafkaTemplate template = new KafkaTemplate(pf);
    RecordMessageConverter converter = mock(RecordMessageConverter.class);
    ProducerRecord recordFromConverter = mock(ProducerRecord.class);
    given(converter.fromMessage(any(), any())).willReturn(recordFromConverter);
    template.setMessageConverter(converter);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setTopicExpression(new LiteralExpression("bar"));
    handler.setBeanFactory(mock(BeanFactory.class));
    ProducerRecordCreator creator = mock(ProducerRecordCreator.class);
    ProducerRecord recordFromCreator = mock(ProducerRecord.class);
    given(creator.create(any(), any(), any(), any(), any(), any(), any())).willReturn(recordFromCreator);
    handler.setProducerRecordCreator(creator);
    handler.afterPropertiesSet();
    handler.start();
    handler.handleMessage(new GenericMessage<>("foo"));
    ArgumentCaptor<ProducerRecord> captor = ArgumentCaptor.forClass(ProducerRecord.class);
    verify(producer).send(captor.capture(), any(Callback.class));
    assertThat(captor.getValue()).isSameAs(recordFromCreator);
    handler.setUseTemplateConverter(true);
    handler.handleMessage(new GenericMessage<>("foo"));
    verify(producer, times(2)).send(captor.capture(), any(Callback.class));
    assertThat(captor.getValue()).isSameAs(recordFromConverter);
    handler.stop();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "rawtypes", "unchecked" })
@Test
void conversion() {
    ProducerFactory pf = mock(ProducerFactory.class);
    Producer producer = mock(Producer.class);
    given(pf.createProducer()).willReturn(producer);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    KafkaTemplate template = new KafkaTemplate(pf);
    RecordMessageConverter converter = mock(RecordMessageConverter.class);
    ProducerRecord recordFromConverter = mock(ProducerRecord.class);
    given(converter.fromMessage(any(), any())).willReturn(recordFromConverter);
    template.setMessageConverter(converter);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setTopicExpression(new LiteralExpression("bar"));
    handler.setBeanFactory(mock(BeanFactory.class));
    ProducerRecordCreator creator = mock(ProducerRecordCreator.class);
    ProducerRecord recordFromCreator = mock(ProducerRecord.class);
    given(creator.create(any(), any(), any(), any(), any(), any(), any())).willReturn(recordFromCreator);
    handler.setProducerRecordCreator(creator);
    handler.afterPropertiesSet();
    handler.start();
    handler.handleMessage(new GenericMessage<>("foo"));
    ArgumentCaptor<ProducerRecord> captor = ArgumentCaptor.forClass(ProducerRecord.class);
    verify(producer).send(captor.capture(), any(Callback.class));
    assertThat(captor.getValue()).isSameAs(recordFromCreator);
    handler.setUseTemplateConverter(true);
    handler.handleMessage(new GenericMessage<>("foo"));
    verify(producer, times(2)).send(captor.capture(), any(Callback.class));
    assertThat(captor.getValue()).isSameAs(recordFromConverter);
    handler.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Producer createMockProducer() {
    Producer producer = mock(Producer.class);
    willReturn(mock(Future.class)).given(producer).send(any(ProducerRecord.class), any(Callback.class));
    return producer;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_51
- **Scope**: method level
- **Mocked Class**: `org.apache.kafka.clients.producer.Producer`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static Producer createMockProducer(CountDownLatch closeLatch) {
    Producer producer = mock(Producer.class);
    given(producer.send(any(), any())).willReturn(mock(Future.class));
    willAnswer(i -> {
        closeLatch.countDown();
        return null;
    }).given(producer).close(any());
    return producer;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_51_1
#### Test Case Name: `testConsumeAndProduceTransaction`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `producer`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    willReturn(mockConsumer).given(cf).createConsumer("group", "", null, KafkaTestUtils.defaultPropertyOverrides());
-    Producer producer = mock(Producer.class);
-    given(producer.send(any(), any())).willReturn(mock(Future.class));
-    final CountDownLatch closeLatch = new CountDownLatch(2);
-    willAnswer(i -> {
-        closeLatch.countDown();
-        return null;
-    }).given(producer).close(any());
+    final CountDownLatch closeLatch = new CountDownLatch(2);
+    Producer producer = createMockProducer(closeLatch);
     ProducerFactory pf = mock(ProducerFactory.class);
     given(pf.transactionCapable()).willReturn(true);
     willReturn(producer).given(pf).createProducer(isNull());
     KafkaTransactionManager ptm = new KafkaTransactionManager(pf);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "unchecked", "rawtypes" })
@Test
void testConsumeAndProduceTransaction() throws Exception {
    Consumer mockConsumer = mock(Consumer.class);
    final TopicPartition topicPartition = new TopicPartition("foo", 0);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(mockConsumer).subscribe(any(Collection.class), any(ConsumerRebalanceListener.class));
    ConsumerRecords records = new ConsumerRecords(Collections.singletonMap(topicPartition, Collections.singletonList(new ConsumerRecord<>("foo", 0, 0, "key", "value"))));
    final AtomicBoolean done = new AtomicBoolean();
    willAnswer(i -> {
        if (done.compareAndSet(false, true)) {
            return records;
        } else {
            Thread.sleep(500);
            return null;
        }
    }).given(mockConsumer).poll(any(Duration.class));
    ConsumerGroupMetadata meta = new ConsumerGroupMetadata("group");
    given(mockConsumer.groupMetadata()).willReturn(meta);
    ConsumerFactory cf = mock(ConsumerFactory.class);
    willReturn(mockConsumer).given(cf).createConsumer("group", "", null, KafkaTestUtils.defaultPropertyOverrides());
    Producer producer = mock(Producer.class);
    given(producer.send(any(), any())).willReturn(mock(Future.class));
    final CountDownLatch closeLatch = new CountDownLatch(2);
    willAnswer(i -> {
        closeLatch.countDown();
        return null;
    }).given(producer).close(any());
    ProducerFactory pf = mock(ProducerFactory.class);
    given(pf.transactionCapable()).willReturn(true);
    willReturn(producer).given(pf).createProducer(isNull());
    KafkaTransactionManager ptm = new KafkaTransactionManager(pf);
    ContainerProperties props = new ContainerProperties("foo");
    props.setGroupId("group");
    props.setKafkaAwareTransactionManager(ptm);
    props.setAssignmentCommitOption(AssignmentCommitOption.ALWAYS);
    final KafkaTemplate template = new KafkaTemplate(pf);
    KafkaMessageListenerContainer container = new KafkaMessageListenerContainer<>(cf, props);
    container.setBeanName("commit");
    KafkaMessageDrivenChannelAdapter inbound = new KafkaMessageDrivenChannelAdapter<>(container);
    DirectChannel channel = new DirectChannel();
    inbound.setOutputChannel(channel);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setMessageKeyExpression(new LiteralExpression("bar"));
    handler.setTopicExpression(new LiteralExpression("topic"));
    channel.subscribe(handler);
    inbound.afterPropertiesSet();
    inbound.start();
    assertThat(closeLatch.await(10, TimeUnit.SECONDS)).isTrue();
    InOrder inOrder = inOrder(producer);
    inOrder.verify(producer).beginTransaction();
    inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(0)), meta);
    inOrder.verify(producer).commitTransaction();
    inOrder.verify(producer).close(any());
    inOrder.verify(producer).beginTransaction();
    ArgumentCaptor<ProducerRecord> captor = ArgumentCaptor.forClass(ProducerRecord.class);
    inOrder.verify(producer).send(captor.capture(), any(Callback.class));
    assertThat(captor.getValue()).isEqualTo(new ProducerRecord("topic", null, "bar", "value"));
    inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1)), meta);
    inOrder.verify(producer).commitTransaction();
    inOrder.verify(producer).close(any());
    container.stop();
    verify(pf, times(2)).createProducer(isNull());
    verifyNoMoreInteractions(producer);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Producer createMockProducer(CountDownLatch closeLatch) {
    Producer producer = mock(Producer.class);
    given(producer.send(any(), any())).willReturn(mock(Future.class));
    willAnswer(i -> {
        closeLatch.countDown();
        return null;
    }).given(producer).close(any());
    return producer;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_51_2
#### Test Case Name: `testConsumeAndProduceTransactionTxIdOverride`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-kafka\src\test\java\org\springframework\integration\kafka\outbound\KafkaProducerMessageHandlerTests.java`)
#### Mock Object Variable Name: `producer`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    willReturn(mockConsumer).given(cf).createConsumer("group", "", null, KafkaTestUtils.defaultPropertyOverrides());
-    Producer producer = mock(Producer.class);
-    given(producer.send(any(), any())).willReturn(mock(Future.class));
-    final CountDownLatch closeLatch = new CountDownLatch(2);
-    willAnswer(i -> {
-        closeLatch.countDown();
-        return null;
-    }).given(producer).close(any());
+    final CountDownLatch closeLatch = new CountDownLatch(2);
+    Producer producer = createMockProducer(closeLatch);
    AtomicReference<String> txId = new AtomicReference<>();
    DefaultKafkaProducerFactory pf = new DefaultKafkaProducerFactory(Collections.emptyMap()) {
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings({ "unchecked", "rawtypes" })
@Test
void testConsumeAndProduceTransactionTxIdOverride() throws Exception {
    Consumer mockConsumer = mock(Consumer.class);
    final TopicPartition topicPartition = new TopicPartition("foo", 0);
    willAnswer(i -> {
        ((ConsumerRebalanceListener) i.getArgument(1)).onPartitionsAssigned(Collections.singletonList(topicPartition));
        return null;
    }).given(mockConsumer).subscribe(any(Collection.class), any(ConsumerRebalanceListener.class));
    ConsumerRecords records = new ConsumerRecords(Collections.singletonMap(topicPartition, Collections.singletonList(new ConsumerRecord<>("foo", 0, 0, "key", "value"))));
    final AtomicBoolean done = new AtomicBoolean();
    willAnswer(i -> {
        if (done.compareAndSet(false, true)) {
            return records;
        } else {
            Thread.sleep(500);
            return null;
        }
    }).given(mockConsumer).poll(any(Duration.class));
    ConsumerGroupMetadata meta = new ConsumerGroupMetadata("group");
    given(mockConsumer.groupMetadata()).willReturn(meta);
    ConsumerFactory cf = mock(ConsumerFactory.class);
    willReturn(mockConsumer).given(cf).createConsumer("group", "", null, KafkaTestUtils.defaultPropertyOverrides());
    Producer producer = mock(Producer.class);
    given(producer.send(any(), any())).willReturn(mock(Future.class));
    final CountDownLatch closeLatch = new CountDownLatch(2);
    willAnswer(i -> {
        closeLatch.countDown();
        return null;
    }).given(producer).close(any());
    AtomicReference<String> txId = new AtomicReference<>();
    DefaultKafkaProducerFactory pf = new DefaultKafkaProducerFactory(Collections.emptyMap()) {

        @Override
        protected Producer createTransactionalProducer(String txIdPrefix) {
            txId.set(txIdPrefix);
            return producer;
        }
    };
    pf.setTransactionIdPrefix("default.tx.id.");
    KafkaTransactionManager tm = new KafkaTransactionManager(pf);
    tm.setTransactionIdPrefix("tm.tx.id.");
    ContainerProperties props = new ContainerProperties("foo");
    props.setGroupId("group");
    props.setKafkaAwareTransactionManager(tm);
    props.setAssignmentCommitOption(AssignmentCommitOption.ALWAYS);
    final KafkaTemplate template = new KafkaTemplate(pf);
    template.setTransactionIdPrefix("template.tx.id.");
    KafkaMessageListenerContainer container = new KafkaMessageListenerContainer<>(cf, props);
    container.setBeanName("commit");
    KafkaMessageDrivenChannelAdapter inbound = new KafkaMessageDrivenChannelAdapter<>(container);
    DirectChannel channel = new DirectChannel();
    inbound.setOutputChannel(channel);
    KafkaProducerMessageHandler handler = new KafkaProducerMessageHandler(template);
    handler.setMessageKeyExpression(new LiteralExpression("bar"));
    handler.setTopicExpression(new LiteralExpression("topic"));
    channel.subscribe(handler);
    inbound.afterPropertiesSet();
    inbound.start();
    assertThat(closeLatch.await(10, TimeUnit.SECONDS)).isTrue();
    InOrder inOrder = inOrder(producer);
    inOrder.verify(producer).beginTransaction();
    inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(0)), meta);
    inOrder.verify(producer).commitTransaction();
    inOrder.verify(producer).close(any());
    inOrder.verify(producer).beginTransaction();
    ArgumentCaptor<ProducerRecord> captor = ArgumentCaptor.forClass(ProducerRecord.class);
    inOrder.verify(producer).send(captor.capture(), any(Callback.class));
    assertThat(captor.getValue()).isEqualTo(new ProducerRecord("topic", null, "bar", "value"));
    inOrder.verify(producer).sendOffsetsToTransaction(Collections.singletonMap(topicPartition, new OffsetAndMetadata(1)), meta);
    inOrder.verify(producer).commitTransaction();
    inOrder.verify(producer).close(any());
    container.stop();
    verifyNoMoreInteractions(producer);
    assertThat(txId.get()).isEqualTo("tm.tx.id.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Producer createMockProducer(CountDownLatch closeLatch) {
    Producer producer = mock(Producer.class);
    given(producer.send(any(), any())).willReturn(mock(Future.class));
    willAnswer(i -> {
        closeLatch.countDown();
        return null;
    }).given(producer).close(any());
    return producer;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_52
- **Scope**: method level
- **Mocked Class**: `org.springframework.messaging.Message<?>`
- **Test Case Count**: 1
- **MO Count**: 2

### Reusable Method
```java
private static Message<?> createMockMessageWithHeaders() {
    Message<?> message = mock(Message.class);
    willReturn(new MessageHeaders(mock(Map.class))).given(message).getHeaders();
    return message;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_52_1
#### Test Case Name: `shouldIgnoreNullValuesWhenInitializedWithCollectionContainingNulls`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\store\SimpleMessageGroupTests.java`)
#### Mock Object Variable Name: `m1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @SuppressWarnings("unchecked")
 @Test
 public void shouldIgnoreNullValuesWhenInitializedWithCollectionContainingNulls() {
-    Message<?> m1 = mock(Message.class);
-    willReturn(new MessageHeaders(mock(Map.class))).given(m1).getHeaders();
+    Message<?> m1 = createMockMessageWithHeaders();
     Message<?> m2 = mock(Message.class);
     willReturn(new MessageHeaders(mock(Map.class))).given(m2).getHeaders();
     final List<Message<?>> messages = new ArrayList<>();
     messages.add(m1);
     messages.add(null);
     messages.add(m2);
     SimpleMessageGroup grp = new SimpleMessageGroup(messages, 1);
     assertThat(grp.getMessages().size()).isEqualTo(2);
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("unchecked")
@Test
public void shouldIgnoreNullValuesWhenInitializedWithCollectionContainingNulls() {
    Message<?> m1 = mock(Message.class);
    willReturn(new MessageHeaders(mock(Map.class))).given(m1).getHeaders();
    Message<?> m2 = mock(Message.class);
    willReturn(new MessageHeaders(mock(Map.class))).given(m2).getHeaders();
    final List<Message<?>> messages = new ArrayList<>();
    messages.add(m1);
    messages.add(null);
    messages.add(m2);
    SimpleMessageGroup grp = new SimpleMessageGroup(messages, 1);
    assertThat(grp.getMessages().size()).isEqualTo(2);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Message<?> createMockMessageWithHeaders() {
    Message<?> message = mock(Message.class);
    willReturn(new MessageHeaders(mock(Map.class))).given(message).getHeaders();
    return message;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_52_2
#### Test Case Name: `shouldIgnoreNullValuesWhenInitializedWithCollectionContainingNulls`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\store\SimpleMessageGroupTests.java`)
#### Mock Object Variable Name: `m2`
<summary>Suggested Diff</summary>

```diff
@@
     Message<?> m1 = mock(Message.class);
     willReturn(new MessageHeaders(mock(Map.class))).given(m1).getHeaders();
-    Message<?> m2 = mock(Message.class);
-    willReturn(new MessageHeaders(mock(Map.class))).given(m2).getHeaders();
+    Message<?> m2 = createMockMessageWithHeaders();
     final List<Message<?>> messages = new ArrayList<>();
     messages.add(m1);
     messages.add(null);
     messages.add(m2);
     SimpleMessageGroup grp = new SimpleMessageGroup(messages, 1);
     assertThat(grp.getMessages().size()).isEqualTo(2);
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("unchecked")
@Test
public void shouldIgnoreNullValuesWhenInitializedWithCollectionContainingNulls() {
    Message<?> m1 = mock(Message.class);
    willReturn(new MessageHeaders(mock(Map.class))).given(m1).getHeaders();
    Message<?> m2 = mock(Message.class);
    willReturn(new MessageHeaders(mock(Map.class))).given(m2).getHeaders();
    final List<Message<?>> messages = new ArrayList<>();
    messages.add(m1);
    messages.add(null);
    messages.add(m2);
    SimpleMessageGroup grp = new SimpleMessageGroup(messages, 1);
    assertThat(grp.getMessages().size()).isEqualTo(2);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Message<?> createMockMessageWithHeaders() {
    Message<?> message = mock(Message.class);
    willReturn(new MessageHeaders(mock(Map.class))).given(message).getHeaders();
    return message;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_53
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.acks.AcknowledgmentCallback`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static AcknowledgmentCallback createMockAcknowledgmentCallback(boolean isAutoAck) {
    AcknowledgmentCallback callback = mock(AcknowledgmentCallback.class);
    given(callback.isAutoAck()).willReturn(isAutoAck);
    return callback;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_53_1
#### Test Case Name: `testAckNack`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\endpoint\MessageSourcePollingTemplateTests.java`)
#### Mock Object Variable Name: `callback`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testAckNack() {
-    AcknowledgmentCallback callback = mock(AcknowledgmentCallback.class);
-    given(callback.isAutoAck()).willReturn(true);
+    AcknowledgmentCallback callback = createMockAcknowledgmentCallback(true);
     MessageSource<?> source = () -> new GenericMessage<>("foo", Collections.singletonMap(IntegrationMessageHeaderAccessor.ACKNOWLEDGMENT_CALLBACK, callback));
     MessageSourcePollingTemplate template = new MessageSourcePollingTemplate(source);
     template.poll(h -> {
     });
     verify(callback).acknowledge(Status.ACCEPT);
     try {
         template.poll(h -> {
             throw new RuntimeException("expected");
         });
         fail("expected exception");
     } catch (MessageHandlingException e) {
         assertThat(e.getCause().getMessage()).isEqualTo("expected");
     }
     verify(callback).acknowledge(Status.REJECT);
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testAckNack() {
    AcknowledgmentCallback callback = mock(AcknowledgmentCallback.class);
    given(callback.isAutoAck()).willReturn(true);
    MessageSource<?> source = () -> new GenericMessage<>("foo", Collections.singletonMap(IntegrationMessageHeaderAccessor.ACKNOWLEDGMENT_CALLBACK, callback));
    MessageSourcePollingTemplate template = new MessageSourcePollingTemplate(source);
    template.poll(h -> {
    });
    verify(callback).acknowledge(Status.ACCEPT);
    try {
        template.poll(h -> {
            throw new RuntimeException("expected");
        });
        fail("expected exception");
    } catch (MessageHandlingException e) {
        assertThat(e.getCause().getMessage()).isEqualTo("expected");
    }
    verify(callback).acknowledge(Status.REJECT);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AcknowledgmentCallback createMockAcknowledgmentCallback(boolean isAutoAck) {
    AcknowledgmentCallback callback = mock(AcknowledgmentCallback.class);
    given(callback.isAutoAck()).willReturn(isAutoAck);
    return callback;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_53_2
#### Test Case Name: `testNoAutoAck`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\endpoint\MessageSourcePollingTemplateTests.java`)
#### Mock Object Variable Name: `callback`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testNoAutoAck() {
-    AcknowledgmentCallback callback = mock(AcknowledgmentCallback.class);
-    given(callback.isAutoAck()).willReturn(false);
+    AcknowledgmentCallback callback = createMockAcknowledgmentCallback(false);
     MessageSource<?> source = () -> new GenericMessage<>("foo", Collections.singletonMap(IntegrationMessageHeaderAccessor.ACKNOWLEDGMENT_CALLBACK, callback));
     MessageSourcePollingTemplate template = new MessageSourcePollingTemplate(source);
     template.poll(h -> {
     });
     verify(callback, never()).acknowledge(Status.ACCEPT);
     verify(callback, never()).acknowledge(Status.REJECT);
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testNoAutoAck() {
    AcknowledgmentCallback callback = mock(AcknowledgmentCallback.class);
    given(callback.isAutoAck()).willReturn(false);
    MessageSource<?> source = () -> new GenericMessage<>("foo", Collections.singletonMap(IntegrationMessageHeaderAccessor.ACKNOWLEDGMENT_CALLBACK, callback));
    MessageSourcePollingTemplate template = new MessageSourcePollingTemplate(source);
    template.poll(h -> {
    });
    verify(callback, never()).acknowledge(Status.ACCEPT);
    verify(callback, never()).acknowledge(Status.REJECT);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AcknowledgmentCallback createMockAcknowledgmentCallback(boolean isAutoAck) {
    AcknowledgmentCallback callback = mock(AcknowledgmentCallback.class);
    given(callback.isAutoAck()).willReturn(isAutoAck);
    return callback;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_54
- **Scope**: method level
- **Mocked Class**: `org.springframework.messaging.support.InterceptableChannel`
- **Test Case Count**: 4
- **MO Count**: 4

### Reusable Method
```java
// === Declare in class scope ===
private InterceptableChannel channel;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    channel = mock(InterceptableChannel.class);
}

// === Replace local variable in test with ===
channel;

```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_54_1
#### Test Case Name: `testProcessorWithInterceptorDefaultPattern`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\config\GlobalChannelInterceptorProcessorTests.java`)
#### Mock Object Variable Name: `channel`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testProcessorWithInterceptorDefaultPattern() {
     Map<String, GlobalChannelInterceptorWrapper> interceptors = new HashMap<>();
     Map<String, InterceptableChannel> channels = new HashMap<>();
     ChannelInterceptor channelInterceptor = mock();
     GlobalChannelInterceptorWrapper globalChannelInterceptorWrapper = new GlobalChannelInterceptorWrapper(channelInterceptor);
-    InterceptableChannel channel = mock();
+    // removed local mock; replaced with global field `channel`
     interceptors.put("Test-1", globalChannelInterceptorWrapper);
     channels.put("Test-1", channel);
     when(this.beanFactory.getBeansOfType(GlobalChannelInterceptorWrapper.class)).thenReturn(interceptors);
     when(this.beanFactory.getBeansOfType(InterceptableChannel.class)).thenReturn(channels);
     this.globalChannelInterceptorProcessor.afterSingletonsInstantiated();
-    verify(channel).addInterceptor(channelInterceptor);
+    verify(channel).addInterceptor(channelInterceptor);
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testProcessorWithInterceptorDefaultPattern() {
    Map<String, GlobalChannelInterceptorWrapper> interceptors = new HashMap<>();
    Map<String, InterceptableChannel> channels = new HashMap<>();
    ChannelInterceptor channelInterceptor = mock();
    GlobalChannelInterceptorWrapper globalChannelInterceptorWrapper = new GlobalChannelInterceptorWrapper(channelInterceptor);
    InterceptableChannel channel = mock();
    interceptors.put("Test-1", globalChannelInterceptorWrapper);
    channels.put("Test-1", channel);
    when(this.beanFactory.getBeansOfType(GlobalChannelInterceptorWrapper.class)).thenReturn(interceptors);
    when(this.beanFactory.getBeansOfType(InterceptableChannel.class)).thenReturn(channels);
    this.globalChannelInterceptorProcessor.afterSingletonsInstantiated();
    verify(channel).addInterceptor(channelInterceptor);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private InterceptableChannel channel;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    channel = mock(InterceptableChannel.class);
}

// === Replace local variable in test with ===
channel;

```
</details>

---
#### Test Case ID #spring-integration_Test_54_2
#### Test Case Name: `testProcessorWithInterceptorMatchingPattern`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\config\GlobalChannelInterceptorProcessorTests.java`)
#### Mock Object Variable Name: `channel`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testProcessorWithInterceptorMatchingPattern() {
     Map<String, GlobalChannelInterceptorWrapper> interceptors = new HashMap<>();
     Map<String, InterceptableChannel> channels = new HashMap<>();
     ChannelInterceptor channelInterceptor = mock();
     GlobalChannelInterceptorWrapper globalChannelInterceptorWrapper = new GlobalChannelInterceptorWrapper(channelInterceptor);
-    InterceptableChannel channel = mock();
+    // removed local mock; replaced with global field `channel`
     globalChannelInterceptorWrapper.setPatterns(new String[] { "Te*" });
     interceptors.put("Test-1", globalChannelInterceptorWrapper);
-    channels.put("Test-1", channel);
+    channels.put("Test-1", channel);
     when(this.beanFactory.getBeansOfType(GlobalChannelInterceptorWrapper.class)).thenReturn(interceptors);
     when(this.beanFactory.getBeansOfType(InterceptableChannel.class)).thenReturn(channels);
     this.globalChannelInterceptorProcessor.afterSingletonsInstantiated();
-    verify(channel).addInterceptor(channelInterceptor);
+    verify(channel).addInterceptor(channelInterceptor);
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testProcessorWithInterceptorMatchingPattern() {
    Map<String, GlobalChannelInterceptorWrapper> interceptors = new HashMap<>();
    Map<String, InterceptableChannel> channels = new HashMap<>();
    ChannelInterceptor channelInterceptor = mock();
    GlobalChannelInterceptorWrapper globalChannelInterceptorWrapper = new GlobalChannelInterceptorWrapper(channelInterceptor);
    InterceptableChannel channel = mock();
    globalChannelInterceptorWrapper.setPatterns(new String[] { "Te*" });
    interceptors.put("Test-1", globalChannelInterceptorWrapper);
    channels.put("Test-1", channel);
    when(this.beanFactory.getBeansOfType(GlobalChannelInterceptorWrapper.class)).thenReturn(interceptors);
    when(this.beanFactory.getBeansOfType(InterceptableChannel.class)).thenReturn(channels);
    this.globalChannelInterceptorProcessor.afterSingletonsInstantiated();
    verify(channel).addInterceptor(channelInterceptor);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private InterceptableChannel channel;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    channel = mock(InterceptableChannel.class);
}

// === Replace local variable in test with ===
channel;

```
</details>

---
#### Test Case ID #spring-integration_Test_54_3
#### Test Case Name: `testProcessorWithInterceptorNotMatchingPattern`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\config\GlobalChannelInterceptorProcessorTests.java`)
#### Mock Object Variable Name: `channel`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testProcessorWithInterceptorNotMatchingPattern() {
     Map<String, GlobalChannelInterceptorWrapper> interceptors = new HashMap<>();
     Map<String, InterceptableChannel> channels = new HashMap<>();
     ChannelInterceptor channelInterceptor = mock();
     GlobalChannelInterceptorWrapper globalChannelInterceptorWrapper = new GlobalChannelInterceptorWrapper(channelInterceptor);
-    InterceptableChannel channel = mock();
+    // removed local mock; replaced with global field `channel`
     globalChannelInterceptorWrapper.setPatterns(new String[] { "te*" });
     interceptors.put("Test-1", globalChannelInterceptorWrapper);
     channels.put("Test-1", channel);
     when(this.beanFactory.getBeansOfType(GlobalChannelInterceptorWrapper.class)).thenReturn(interceptors);
     when(this.beanFactory.getBeansOfType(InterceptableChannel.class)).thenReturn(channels);
     this.globalChannelInterceptorProcessor.afterSingletonsInstantiated();
-    verify(channel, never()).addInterceptor(channelInterceptor);
+    verify(channel, never()).addInterceptor(channelInterceptor);
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testProcessorWithInterceptorNotMatchingPattern() {
    Map<String, GlobalChannelInterceptorWrapper> interceptors = new HashMap<>();
    Map<String, InterceptableChannel> channels = new HashMap<>();
    ChannelInterceptor channelInterceptor = mock();
    GlobalChannelInterceptorWrapper globalChannelInterceptorWrapper = new GlobalChannelInterceptorWrapper(channelInterceptor);
    InterceptableChannel channel = mock();
    globalChannelInterceptorWrapper.setPatterns(new String[] { "te*" });
    interceptors.put("Test-1", globalChannelInterceptorWrapper);
    channels.put("Test-1", channel);
    when(this.beanFactory.getBeansOfType(GlobalChannelInterceptorWrapper.class)).thenReturn(interceptors);
    when(this.beanFactory.getBeansOfType(InterceptableChannel.class)).thenReturn(channels);
    this.globalChannelInterceptorProcessor.afterSingletonsInstantiated();
    verify(channel, never()).addInterceptor(channelInterceptor);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private InterceptableChannel channel;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    channel = mock(InterceptableChannel.class);
}

// === Replace local variable in test with ===
channel;

```
</details>

---
#### Test Case ID #spring-integration_Test_54_4
#### Test Case Name: `testProcessorWithInterceptorMatchingNegativePattern`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\config\GlobalChannelInterceptorProcessorTests.java`)
#### Mock Object Variable Name: `channel`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 public void testProcessorWithInterceptorMatchingNegativePattern() {
     Map<String, GlobalChannelInterceptorWrapper> interceptors = new HashMap<>();
     Map<String, InterceptableChannel> channels = new HashMap<>();
     ChannelInterceptor channelInterceptor = mock();
     GlobalChannelInterceptorWrapper globalChannelInterceptorWrapper = new GlobalChannelInterceptorWrapper(channelInterceptor);
-    InterceptableChannel channel = mock();
+    // removed local mock; replaced with global field `channel`
     globalChannelInterceptorWrapper.setPatterns(new String[] { "!te*", "!Te*" });
     interceptors.put("Test-1", globalChannelInterceptorWrapper);
     channels.put("Test-1", channel);
     when(this.beanFactory.getBeansOfType(GlobalChannelInterceptorWrapper.class)).thenReturn(interceptors);
     when(this.beanFactory.getBeansOfType(InterceptableChannel.class)).thenReturn(channels);
     this.globalChannelInterceptorProcessor.afterSingletonsInstantiated();
-    verify(channel, never()).addInterceptor(channelInterceptor);
+    verify(channel, never()).addInterceptor(channelInterceptor);
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testProcessorWithInterceptorMatchingNegativePattern() {
    Map<String, GlobalChannelInterceptorWrapper> interceptors = new HashMap<>();
    Map<String, InterceptableChannel> channels = new HashMap<>();
    ChannelInterceptor channelInterceptor = mock();
    GlobalChannelInterceptorWrapper globalChannelInterceptorWrapper = new GlobalChannelInterceptorWrapper(channelInterceptor);
    InterceptableChannel channel = mock();
    globalChannelInterceptorWrapper.setPatterns(new String[] { "!te*", "!Te*" });
    interceptors.put("Test-1", globalChannelInterceptorWrapper);
    channels.put("Test-1", channel);
    when(this.beanFactory.getBeansOfType(GlobalChannelInterceptorWrapper.class)).thenReturn(interceptors);
    when(this.beanFactory.getBeansOfType(InterceptableChannel.class)).thenReturn(channels);
    this.globalChannelInterceptorProcessor.afterSingletonsInstantiated();
    verify(channel, never()).addInterceptor(channelInterceptor);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private InterceptableChannel channel;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    channel = mock(InterceptableChannel.class);
}

// === Replace local variable in test with ===
channel;

```
</details>

---
## Mock Clone Instance #spring-integration_MCI_55
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.file.remote.session.Session<F>`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static <F> Session<F> createMockSession() {
    Session<F> session = mock(Session.class);
    doAnswer(invocation -> {
        String path = invocation.getArgument(1);
        assertThat(path.startsWith("/")).isFalse();
        return null;
    }).when(session).rename(Mockito.anyString(), Mockito.anyString());
    return session;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_55_1
#### Test Case Name: `testRemoteDirWithEmptyString`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\handler\FileTransferringMessageHandlerTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory<F> sf = mock(SessionFactory.class);
-    Session<F> session = mock(Session.class);
+    Session<F> session = createMockSession();
    when(sf.getSession()).thenReturn(session);
-    doAnswer(invocation -> {
-        String path = invocation.getArgument(1);
-        assertThat(path.startsWith("/")).isFalse();
-        return null;
-    }).when(session).rename(Mockito.anyString(), Mockito.anyString());
    ExpressionParser parser = new SpelExpressionParser();
    FileTransferringMessageHandler<F> handler = new FileTransferringMessageHandler<F>(sf);
    handler.setRemoteDirectoryExpression(parser.parseExpression("''"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.handleMessage(new GenericMessage<String>("hello"));
    verify(session, times(1)).write(Mockito.any(InputStream.class), Mockito.anyString());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("unchecked")
@Test
public <F> void testRemoteDirWithEmptyString() throws Exception {
    SessionFactory<F> sf = mock(SessionFactory.class);
    Session<F> session = mock(Session.class);
    when(sf.getSession()).thenReturn(session);
    doAnswer(invocation -> {
        String path = invocation.getArgument(1);
        assertThat(path.startsWith("/")).isFalse();
        return null;
    }).when(session).rename(Mockito.anyString(), Mockito.anyString());
    ExpressionParser parser = new SpelExpressionParser();
    FileTransferringMessageHandler<F> handler = new FileTransferringMessageHandler<F>(sf);
    handler.setRemoteDirectoryExpression(parser.parseExpression("''"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    handler.handleMessage(new GenericMessage<String>("hello"));
    verify(session, times(1)).write(Mockito.any(InputStream.class), Mockito.anyString());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static <F> Session<F> createMockSession() {
    Session<F> session = mock(Session.class);
    doAnswer(invocation -> {
        String path = invocation.getArgument(1);
        assertThat(path.startsWith("/")).isFalse();
        return null;
    }).when(session).rename(Mockito.anyString(), Mockito.anyString());
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_55_2
#### Test Case Name: `testRemoteDirWithNull`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\handler\FileTransferringMessageHandlerTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory<F> sf = mock(SessionFactory.class);
-    Session<F> session = mock(Session.class);
+    Session<F> session = createMockSession();
    when(sf.getSession()).thenReturn(session);
-    doAnswer(invocation -> {
-        String path = invocation.getArgument(1);
-        assertThat(path.startsWith("/")).isFalse();
-        return null;
-    }).when(session).rename(Mockito.anyString(), Mockito.anyString());
    ExpressionParser parser = new SpelExpressionParser();
    FileTransferringMessageHandler<F> handler = new FileTransferringMessageHandler<F>(sf);
    handler.setRemoteDirectoryExpression(parser.parseExpression("headers['path']"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    Message<?> message = MessageBuilder.withPayload("hello").setHeader("path", null).build();
    handler.handleMessage(message);
    verify(session, times(1)).write(Mockito.any(InputStream.class), Mockito.anyString());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("unchecked")
@Test
public <F> void testRemoteDirWithNull() throws Exception {
    SessionFactory<F> sf = mock(SessionFactory.class);
    Session<F> session = mock(Session.class);
    when(sf.getSession()).thenReturn(session);
    doAnswer(invocation -> {
        String path = invocation.getArgument(1);
        assertThat(path.startsWith("/")).isFalse();
        return null;
    }).when(session).rename(Mockito.anyString(), Mockito.anyString());
    ExpressionParser parser = new SpelExpressionParser();
    FileTransferringMessageHandler<F> handler = new FileTransferringMessageHandler<F>(sf);
    handler.setRemoteDirectoryExpression(parser.parseExpression("headers['path']"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    Message<?> message = MessageBuilder.withPayload("hello").setHeader("path", null).build();
    handler.handleMessage(message);
    verify(session, times(1)).write(Mockito.any(InputStream.class), Mockito.anyString());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static <F> Session<F> createMockSession() {
    Session<F> session = mock(Session.class);
    doAnswer(invocation -> {
        String path = invocation.getArgument(1);
        assertThat(path.startsWith("/")).isFalse();
        return null;
    }).when(session).rename(Mockito.anyString(), Mockito.anyString());
    return session;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_56
- **Scope**: method level
- **Mocked Class**: `jakarta.mail.Folder`
- **Test Case Count**: 5
- **MO Count**: 5

### Reusable Method
```java
private static Folder createMockFolder(Message[] messages) {
    Folder folder = mock(Folder.class);
    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
    given(folder.isOpen()).willReturn(true);
    willAnswer(invocation -> messages).given(folder).search(any(SearchTerm.class));
    return folder;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_56_1
#### Test Case Name: `receiveMarkAsReadAndDelete`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\ImapMailReceiverTests.java`)
#### Mock Object Variable Name: `folder`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
-    Folder folder = mock(Folder.class);
-    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
-    given(folder.isOpen()).willReturn(true);
+    Message msg1 = GreenMailUtil.newMimeMessage("test1");
+    Message msg2 = GreenMailUtil.newMimeMessage("test2");
+    final Message[] messages = new Message[] { msg1, msg2 };
+    Folder folder = createMockFolder(messages);
    folderField.set(receiver, folder);
-    Message msg1 = GreenMailUtil.newMimeMessage("test1");
-    Message msg2 = GreenMailUtil.newMimeMessage("test2");
-    final Message[] messages = new Message[] { msg1, msg2 };
    willAnswer(invocation -> {
        DirectFieldAccessor accessor = new DirectFieldAccessor(invocation.getMock());
        int folderOpenMode = (int) accessor.getPropertyValue("folderOpenMode");
        if (folderOpenMode != Folder.READ_WRITE) {
            throw new IllegalArgumentException("Folder had to be open in READ_WRITE mode");
        }
        return null;
    }).given(receiver).openFolder();
-    willAnswer(invocation -> messages).given(folder).search(any(SearchTerm.class));
    willAnswer(invocation -> null).given(receiver).fetchMessages(messages);
    receiver.receive();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void receiveMarkAsReadAndDelete() throws Exception {
    AbstractMailReceiver receiver = new ImapMailReceiver();
    ((ImapMailReceiver) receiver).setShouldMarkMessagesAsRead(true);
    receiver.setShouldDeleteMessages(true);
    receiver = spy(receiver);
    receiver.setBeanFactory(mock(BeanFactory.class));
    receiver.afterPropertiesSet();
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
    Folder folder = mock(Folder.class);
    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
    given(folder.isOpen()).willReturn(true);
    folderField.set(receiver, folder);
    Message msg1 = GreenMailUtil.newMimeMessage("test1");
    Message msg2 = GreenMailUtil.newMimeMessage("test2");
    final Message[] messages = new Message[] { msg1, msg2 };
    willAnswer(invocation -> {
        DirectFieldAccessor accessor = new DirectFieldAccessor(invocation.getMock());
        int folderOpenMode = (int) accessor.getPropertyValue("folderOpenMode");
        if (folderOpenMode != Folder.READ_WRITE) {
            throw new IllegalArgumentException("Folder had to be open in READ_WRITE mode");
        }
        return null;
    }).given(receiver).openFolder();
    willAnswer(invocation -> messages).given(folder).search(any(SearchTerm.class));
    willAnswer(invocation -> null).given(receiver).fetchMessages(messages);
    receiver.receive();
    assertThat(msg1.getFlags().contains(Flag.SEEN)).isTrue();
    assertThat(msg2.getFlags().contains(Flag.SEEN)).isTrue();
    verify(receiver, times(2)).deleteMessages(Mockito.any());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Folder createMockFolder(Message[] messages) {
    Folder folder = mock(Folder.class);
    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
    given(folder.isOpen()).willReturn(true);
    willAnswer(invocation -> messages).given(folder).search(any(SearchTerm.class));
    return folder;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_56_2
#### Test Case Name: `receiveAndDontMarkAsRead`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\ImapMailReceiverTests.java`)
#### Mock Object Variable Name: `folder`
<summary>Suggested Diff</summary>

```diff
@@
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
-    Folder folder = mock(Folder.class);
-    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
-    given(folder.isOpen()).willReturn(true);
+    Folder folder = createMockFolder(messages);
    folderField.set(receiver, folder);
    Message msg1 = GreenMailUtil.newMimeMessage("test1");
    Message msg2 = GreenMailUtil.newMimeMessage("test2");
    final Message[] messages = new Message[] { msg1, msg2 };
    willAnswer(invocation -> null).given(receiver).openFolder();
-    willAnswer(invocation -> messages).given(folder).search(any(SearchTerm.class));
    willAnswer(invocation -> null).given(receiver).fetchMessages(messages);
    receiver.afterPropertiesSet();
    receiver.receive();
    assertThat(msg1.getFlags().contains(Flag.SEEN)).isFalse();
    assertThat(msg2.getFlags().contains(Flag.SEEN)).isFalse();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void receiveAndDontMarkAsRead() throws Exception {
    AbstractMailReceiver receiver = new ImapMailReceiver();
    ((ImapMailReceiver) receiver).setShouldMarkMessagesAsRead(false);
    receiver = spy(receiver);
    receiver.setBeanFactory(mock(BeanFactory.class));
    receiver.afterPropertiesSet();
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
    Folder folder = mock(Folder.class);
    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
    given(folder.isOpen()).willReturn(true);
    folderField.set(receiver, folder);
    Message msg1 = GreenMailUtil.newMimeMessage("test1");
    Message msg2 = GreenMailUtil.newMimeMessage("test2");
    final Message[] messages = new Message[] { msg1, msg2 };
    willAnswer(invocation -> null).given(receiver).openFolder();
    willAnswer(invocation -> messages).given(folder).search(any(SearchTerm.class));
    willAnswer(invocation -> null).given(receiver).fetchMessages(messages);
    receiver.afterPropertiesSet();
    receiver.receive();
    assertThat(msg1.getFlags().contains(Flag.SEEN)).isFalse();
    assertThat(msg2.getFlags().contains(Flag.SEEN)).isFalse();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Folder createMockFolder(Message[] messages) {
    Folder folder = mock(Folder.class);
    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
    given(folder.isOpen()).willReturn(true);
    willAnswer(invocation -> messages).given(folder).search(any(SearchTerm.class));
    return folder;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_56_3
#### Test Case Name: `receiveAndDontMarkAsReadButDelete`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\ImapMailReceiverTests.java`)
#### Mock Object Variable Name: `folder`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
-    Folder folder = mock(Folder.class);
-    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
-    given(folder.isOpen()).willReturn(true);
+    Message msg1 = GreenMailUtil.newMimeMessage("test1");
+    Message msg2 = GreenMailUtil.newMimeMessage("test2");
+    final Message[] messages = new Message[] { msg1, msg2 };
+    Folder folder = createMockFolder(messages);
    folderField.set(receiver, folder);
-    Message msg1 = GreenMailUtil.newMimeMessage("test1");
-    Message msg2 = GreenMailUtil.newMimeMessage("test2");
-    final Message[] messages = new Message[] { msg1, msg2 };
    willAnswer(invocation -> {
        DirectFieldAccessor accessor = new DirectFieldAccessor(invocation.getMock());
        int folderOpenMode = (int) accessor.getPropertyValue("folderOpenMode");
        if (folderOpenMode != Folder.READ_WRITE) {
            throw new IllegalArgumentException("Folder had to be open in READ_WRITE mode");
        }
        return null;
    }).given(receiver).openFolder();
-    willAnswer(invocation -> messages).given(folder).search(any(SearchTerm.class));
    willAnswer(invocation -> null).given(receiver).fetchMessages(messages);
    receiver.afterPropertiesSet();
    receiver.receive();
    assertThat(msg1.getFlags().contains(Flag.SEEN)).isFalse();
    assertThat(msg2.getFlags().contains(Flag.SEEN)).isFalse();
    assertThat(msg1.getFlags().contains(Flag.DELETED)).isTrue();
    assertThat(msg2.getFlags().contains(Flag.DELETED)).isTrue();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void receiveAndDontMarkAsReadButDelete() throws Exception {
    AbstractMailReceiver receiver = new ImapMailReceiver();
    receiver.setShouldDeleteMessages(true);
    ((ImapMailReceiver) receiver).setShouldMarkMessagesAsRead(false);
    receiver = spy(receiver);
    receiver.setBeanFactory(mock(BeanFactory.class));
    receiver.afterPropertiesSet();
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
    Folder folder = mock(Folder.class);
    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
    given(folder.isOpen()).willReturn(true);
    folderField.set(receiver, folder);
    Message msg1 = GreenMailUtil.newMimeMessage("test1");
    Message msg2 = GreenMailUtil.newMimeMessage("test2");
    final Message[] messages = new Message[] { msg1, msg2 };
    willAnswer(invocation -> {
        DirectFieldAccessor accessor = new DirectFieldAccessor(invocation.getMock());
        int folderOpenMode = (int) accessor.getPropertyValue("folderOpenMode");
        if (folderOpenMode != Folder.READ_WRITE) {
            throw new IllegalArgumentException("Folder had to be open in READ_WRITE mode");
        }
        return null;
    }).given(receiver).openFolder();
    willAnswer(invocation -> messages).given(folder).search(any(SearchTerm.class));
    willAnswer(invocation -> null).given(receiver).fetchMessages(messages);
    receiver.afterPropertiesSet();
    receiver.receive();
    assertThat(msg1.getFlags().contains(Flag.SEEN)).isFalse();
    assertThat(msg2.getFlags().contains(Flag.SEEN)).isFalse();
    assertThat(msg1.getFlags().contains(Flag.DELETED)).isTrue();
    assertThat(msg2.getFlags().contains(Flag.DELETED)).isTrue();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Folder createMockFolder(Message[] messages) {
    Folder folder = mock(Folder.class);
    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
    given(folder.isOpen()).willReturn(true);
    willAnswer(invocation -> messages).given(folder).search(any(SearchTerm.class));
    return folder;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_56_4
#### Test Case Name: `receiveAndIgnoreMarkAsReadDontDelete`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\ImapMailReceiverTests.java`)
#### Mock Object Variable Name: `folder`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
-    Folder folder = mock(Folder.class);
-    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
-    given(folder.isOpen()).willReturn(true);
    Message msg1 = GreenMailUtil.newMimeMessage("test1");
    Message msg2 = GreenMailUtil.newMimeMessage("test2");
    final Message[] messages = new Message[] { msg1, msg2 };
+    Folder folder = createMockFolder(messages);
    folderField.set(receiver, folder);
    willAnswer(invocation -> null).given(receiver).fetchMessages(messages);
    receiver.receive();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void receiveAndIgnoreMarkAsReadDontDelete() throws Exception {
    AbstractMailReceiver receiver = new ImapMailReceiver();
    receiver = spy(receiver);
    receiver.setBeanFactory(mock(BeanFactory.class));
    receiver.afterPropertiesSet();
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
    Folder folder = mock(Folder.class);
    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
    given(folder.isOpen()).willReturn(true);
    folderField.set(receiver, folder);
    Message msg1 = GreenMailUtil.newMimeMessage("test1");
    Message msg2 = GreenMailUtil.newMimeMessage("test2");
    final Message[] messages = new Message[] { msg1, msg2 };
    willAnswer(invocation -> {
        DirectFieldAccessor accessor = new DirectFieldAccessor(invocation.getMock());
        int folderOpenMode = (int) accessor.getPropertyValue("folderOpenMode");
        if (folderOpenMode != Folder.READ_WRITE) {
            throw new IllegalArgumentException("Folder had to be open in READ_WRITE mode");
        }
        return null;
    }).given(receiver).openFolder();
    willAnswer(invocation -> messages).given(folder).search(any(SearchTerm.class));
    willAnswer(invocation -> null).given(receiver).fetchMessages(messages);
    receiver.receive();
    assertThat(msg1.getFlags().contains(Flag.SEEN)).isTrue();
    assertThat(msg2.getFlags().contains(Flag.SEEN)).isTrue();
    verify(receiver, times(0)).deleteMessages(Mockito.any());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Folder createMockFolder(Message[] messages) {
    Folder folder = mock(Folder.class);
    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
    given(folder.isOpen()).willReturn(true);
    willAnswer(invocation -> messages).given(folder).search(any(SearchTerm.class));
    return folder;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_56_5
#### Test Case Name: `testIdleChannelAdapterException`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\ImapMailReceiverTests.java`)
#### Mock Object Variable Name: `folder`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
-    Folder folder = mock(IMAPFolder.class);
-    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
-    given(folder.isOpen()).willReturn(true);
-    given(folder.exists()).willReturn(true);
+    Message mailMessage = GreenMailUtil.newMimeMessage("test1");
+    Message[] messages = new Message[] { mailMessage };
+    Folder folder = createMockFolder(messages);
+    given(folder.exists()).willReturn(true);
    folderField.set(receiver, folder);
    Field storeField = AbstractMailReceiver.class.getDeclaredField("store");
    storeField.setAccessible(true);
    Store store = mock(Store.class);
    given(store.isConnected()).willReturn(true);
    storeField.set(receiver, store);
    DirectFieldAccessor adapterAccessor = new DirectFieldAccessor(adapter);
    adapterAccessor.setPropertyValue("mailReceiver", receiver);
-    Message mailMessage = GreenMailUtil.newMimeMessage("test1");
-    Message[] messages = new Message[] { mailMessage };
-    willAnswer(invocation -> messages).given(folder).search(any(SearchTerm.class));
    adapter.start();
    org.springframework.messaging.Message<?> replMessage = errorChannel.receive(10000);
    assertThat(replMessage).isNotNull();
    assertThat(((Exception) replMessage.getPayload()).getCause().getMessage()).isEqualTo("Failed");
    adapter.stop();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testIdleChannelAdapterException() throws Exception {
    ImapIdleChannelAdapter adapter = this.context.getBean("simpleAdapter", ImapIdleChannelAdapter.class);
    //ImapMailReceiver receiver = (ImapMailReceiver) TestUtils.getPropertyValue(adapter, "mailReceiver");
    DirectChannel channel = new DirectChannel();
    channel.subscribe(new AbstractReplyProducingMessageHandler() {

        @Override
        protected Object handleRequestMessage(org.springframework.messaging.Message<?> requestMessage) {
            throw new RuntimeException("Failed");
        }
    });
    adapter.setOutputChannel(channel);
    QueueChannel errorChannel = new QueueChannel();
    adapter.setErrorChannel(errorChannel);
    adapter.setReconnectDelay(10);
    AbstractMailReceiver receiver = new ImapMailReceiver();
    receiver.setBeanFactory(mock(BeanFactory.class));
    receiver.afterPropertiesSet();
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
    Folder folder = mock(IMAPFolder.class);
    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
    given(folder.isOpen()).willReturn(true);
    given(folder.exists()).willReturn(true);
    folderField.set(receiver, folder);
    Field storeField = AbstractMailReceiver.class.getDeclaredField("store");
    storeField.setAccessible(true);
    Store store = mock(Store.class);
    given(store.isConnected()).willReturn(true);
    storeField.set(receiver, store);
    DirectFieldAccessor adapterAccessor = new DirectFieldAccessor(adapter);
    adapterAccessor.setPropertyValue("mailReceiver", receiver);
    Message mailMessage = GreenMailUtil.newMimeMessage("test1");
    Message[] messages = new Message[] { mailMessage };
    willAnswer(invocation -> messages).given(folder).search(any(SearchTerm.class));
    adapter.start();
    org.springframework.messaging.Message<?> replMessage = errorChannel.receive(10000);
    assertThat(replMessage).isNotNull();
    assertThat(((Exception) replMessage.getPayload()).getCause().getMessage()).isEqualTo("Failed");
    adapter.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Folder createMockFolder(Message[] messages) {
    Folder folder = mock(Folder.class);
    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
    given(folder.isOpen()).willReturn(true);
    willAnswer(invocation -> messages).given(folder).search(any(SearchTerm.class));
    return folder;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_57
- **Scope**: class level
- **Mocked Class**: `jakarta.mail.Folder`
- **Test Case Count**: 7
- **MO Count**: 7

### Reusable Method
```java
public class MockFolder {
    public static Folder createMockFolderWithPermanentFlags(Flags permanentFlags) {
        Folder folder = mock(Folder.class);
        when(folder.getPermanentFlags()).thenReturn(permanentFlags);
        return folder;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_57_1
#### Test Case Name: `testAttachmentsGuts`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\ImapMailReceiverTests.java`)
#### Mock Object Variable Name: `folder`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
private Folder testAttachmentsGuts(final ImapMailReceiver receiver) throws MessagingException, IOException {
    Store store = mock(Store.class);
-    Folder folder = mock(Folder.class);
-    given(folder.exists()).willReturn(true);
-    given(folder.isOpen()).willReturn(true);
+    Folder folder = MockFolder.createMockFolderWithPermanentFlags(new Flags(Flags.Flag.USER));
+    given(folder.exists()).willReturn(true);
+    given(folder.isOpen()).willReturn(true);
    Message message = GreenMailUtil.newMimeMessage(new ClassPathResource("test.mail").getInputStream());
    given(folder.search(Mockito.any())).willReturn(new Message[] { message });
    given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);
-    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
    DirectFieldAccessor df = new DirectFieldAccessor(receiver);
    df.setPropertyValue("store", store);
    receiver.setBeanFactory(mock(BeanFactory.class));
    receiver.afterPropertiesSet();
    return folder;
}
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
private Folder testAttachmentsGuts(final ImapMailReceiver receiver) throws MessagingException, IOException {
    Store store = mock(Store.class);
    Folder folder = mock(Folder.class);
    given(folder.exists()).willReturn(true);
    given(folder.isOpen()).willReturn(true);
    Message message = GreenMailUtil.newMimeMessage(new ClassPathResource("test.mail").getInputStream());
    given(folder.search(Mockito.any())).willReturn(new Message[] { message });
    given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);
    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
    DirectFieldAccessor df = new DirectFieldAccessor(receiver);
    df.setPropertyValue("store", store);
    receiver.setBeanFactory(mock(BeanFactory.class));
    receiver.afterPropertiesSet();
    return folder;
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockFolder {
    public static Folder createMockFolderWithPermanentFlags(Flags permanentFlags) {
        Folder folder = mock(Folder.class);
        when(folder.getPermanentFlags()).thenReturn(permanentFlags);
        return folder;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_57_2
#### Test Case Name: `validateSearchTermsWhenShouldMarkAsReadWithExistingFlags`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\ImapMailSearchTermsTests.java`)
#### Mock Object Variable Name: `folder`
<summary>Suggested Diff</summary>

```diff
@@
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
-    Folder folder = mock(Folder.class);
-    when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));
+    Folder folder = MockFolder.createMockFolderWithPermanentFlags(new Flags(Flags.Flag.USER));
    folderField.set(receiver, folder);
    Method compileSearchTerms = ReflectionUtils.findMethod(receiver.getClass(), "compileSearchTerms", Flags.class);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void validateSearchTermsWhenShouldMarkAsReadWithExistingFlags() throws Exception {
    ImapMailReceiver receiver = new ImapMailReceiver();
    receiver.setShouldMarkMessagesAsRead(true);
    receiver.setBeanFactory(mock(BeanFactory.class));
    receiver.afterPropertiesSet();
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
    Folder folder = mock(Folder.class);
    when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));
    folderField.set(receiver, folder);
    Method compileSearchTerms = ReflectionUtils.findMethod(receiver.getClass(), "compileSearchTerms", Flags.class);
    compileSearchTerms.setAccessible(true);
    Flags flags = new Flags();
    flags.add(Flag.ANSWERED);
    SearchTerm searchTerms = (SearchTerm) compileSearchTerms.invoke(receiver, flags);
    assertThat(searchTerms instanceof AndTerm).isTrue();
    AndTerm andTerm = (AndTerm) searchTerms;
    SearchTerm[] terms = andTerm.getTerms();
    assertThat(terms.length).isEqualTo(2);
    NotTerm notTerm = (NotTerm) terms[0];
    assertThat(((FlagTerm) notTerm.getTerm()).getFlags().contains(Flag.ANSWERED)).isTrue();
    notTerm = (NotTerm) terms[1];
    Flags siFlags = new Flags();
    siFlags.add(AbstractMailReceiver.DEFAULT_SI_USER_FLAG);
    assertThat(((FlagTerm) notTerm.getTerm()).getFlags().contains(siFlags)).isTrue();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockFolder {
    public static Folder createMockFolderWithPermanentFlags(Flags permanentFlags) {
        Folder folder = mock(Folder.class);
        when(folder.getPermanentFlags()).thenReturn(permanentFlags);
        return folder;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_57_3
#### Test Case Name: `validateSearchTermsWhenShouldNotMarkAsReadNoExistingFlags`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\ImapMailSearchTermsTests.java`)
#### Mock Object Variable Name: `folder`
<summary>Suggested Diff</summary>

```diff
@@
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
-    Folder folder = mock(Folder.class);
-    when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));
+    Folder folder = MockFolder.createMockFolderWithPermanentFlags(new Flags(Flags.Flag.USER));
    folderField.set(receiver, folder);
    Method compileSearchTerms = ReflectionUtils.findMethod(receiver.getClass(), "compileSearchTerms", Flags.class);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void validateSearchTermsWhenShouldNotMarkAsReadNoExistingFlags() throws Exception {
    ImapMailReceiver receiver = new ImapMailReceiver();
    receiver.setShouldMarkMessagesAsRead(false);
    receiver.setBeanFactory(mock(BeanFactory.class));
    receiver.afterPropertiesSet();
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
    Folder folder = mock(Folder.class);
    when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));
    folderField.set(receiver, folder);
    Method compileSearchTerms = ReflectionUtils.findMethod(receiver.getClass(), "compileSearchTerms", Flags.class);
    compileSearchTerms.setAccessible(true);
    Flags flags = new Flags();
    SearchTerm searchTerms = (SearchTerm) compileSearchTerms.invoke(receiver, flags);
    assertThat(searchTerms instanceof NotTerm).isTrue();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockFolder {
    public static Folder createMockFolderWithPermanentFlags(Flags permanentFlags) {
        Folder folder = mock(Folder.class);
        when(folder.getPermanentFlags()).thenReturn(permanentFlags);
        return folder;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_57_4
#### Test Case Name: `receiveAndDelete`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\Pop3MailReceiverTests.java`)
#### Mock Object Variable Name: `folder`
<summary>Suggested Diff</summary>

```diff
@@
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
-    Folder folder = mock(Folder.class);
-    when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));
+    Folder folder = MockFolder.createMockFolderWithPermanentFlags(new Flags(Flags.Flag.USER));
    folderField.set(receiver, folder);
    Message msg1 = GreenMailUtil.newMimeMessage("test1");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void receiveAndDelete() throws Exception {
    AbstractMailReceiver receiver = new Pop3MailReceiver();
    receiver.setShouldDeleteMessages(true);
    receiver = spy(receiver);
    receiver.setBeanFactory(mock(BeanFactory.class));
    receiver.afterPropertiesSet();
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
    Folder folder = mock(Folder.class);
    when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));
    folderField.set(receiver, folder);
    Message msg1 = GreenMailUtil.newMimeMessage("test1");
    Message msg2 = GreenMailUtil.newMimeMessage("test2");
    final Message[] messages = new Message[] { msg1, msg2 };
    doAnswer(invocation -> {
        DirectFieldAccessor accessor = new DirectFieldAccessor(invocation.getMock());
        int folderOpenMode = (Integer) accessor.getPropertyValue("folderOpenMode");
        if (folderOpenMode != Folder.READ_WRITE) {
            throw new IllegalArgumentException("Folder had to be open in READ_WRITE mode");
        }
        return null;
    }).when(receiver).openFolder();
    doAnswer(invocation -> messages).when(receiver).searchForNewMessages();
    doAnswer(invocation -> null).when(receiver).fetchMessages(messages);
    receiver.afterPropertiesSet();
    receiver.receive();
    assertThat(msg1.getFlags().contains(Flag.DELETED)).isTrue();
    assertThat(msg2.getFlags().contains(Flag.DELETED)).isTrue();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockFolder {
    public static Folder createMockFolderWithPermanentFlags(Flags permanentFlags) {
        Folder folder = mock(Folder.class);
        when(folder.getPermanentFlags()).thenReturn(permanentFlags);
        return folder;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_57_5
#### Test Case Name: `receiveAndDontDelete`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\Pop3MailReceiverTests.java`)
#### Mock Object Variable Name: `folder`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
-    Folder folder = mock(Folder.class);
-    when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));
+    Folder folder = MockFolder.createMockFolderWithPermanentFlags(new Flags(Flags.Flag.USER));
    folderField.set(receiver, folder);
    Message msg1 = GreenMailUtil.newMimeMessage("test1");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void receiveAndDontDelete() throws Exception {
    AbstractMailReceiver receiver = new Pop3MailReceiver();
    receiver.setShouldDeleteMessages(false);
    receiver = spy(receiver);
    receiver.setBeanFactory(mock(BeanFactory.class));
    receiver.afterPropertiesSet();
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
    Folder folder = mock(Folder.class);
    when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));
    folderField.set(receiver, folder);
    Message msg1 = GreenMailUtil.newMimeMessage("test1");
    Message msg2 = GreenMailUtil.newMimeMessage("test2");
    final Message[] messages = new Message[] { msg1, msg2 };
    doAnswer(invocation -> null).when(receiver).openFolder();
    doAnswer(invocation -> messages).when(receiver).searchForNewMessages();
    doAnswer(invocation -> null).when(receiver).fetchMessages(messages);
    receiver.afterPropertiesSet();
    receiver.receive();
    assertThat(msg1.getFlags().contains(Flag.DELETED)).isFalse();
    assertThat(msg2.getFlags().contains(Flag.DELETED)).isFalse();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockFolder {
    public static Folder createMockFolderWithPermanentFlags(Flags permanentFlags) {
        Folder folder = mock(Folder.class);
        when(folder.getPermanentFlags()).thenReturn(permanentFlags);
        return folder;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_57_6
#### Test Case Name: `receiveAndDontSetDeleteWithUrl`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\Pop3MailReceiverTests.java`)
#### Mock Object Variable Name: `folder`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
-    Folder folder = mock(Folder.class);
-    when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));
+    Folder folder = MockFolder.createMockFolderWithPermanentFlags(new Flags(Flags.Flag.USER));
    folderField.set(receiver, folder);
    Message msg1 = GreenMailUtil.newMimeMessage("test1");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void receiveAndDontSetDeleteWithUrl() throws Exception {
    AbstractMailReceiver receiver = new Pop3MailReceiver("pop3://some.host");
    receiver = spy(receiver);
    receiver.setBeanFactory(mock(BeanFactory.class));
    receiver.afterPropertiesSet();
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
    Folder folder = mock(Folder.class);
    when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));
    folderField.set(receiver, folder);
    Message msg1 = GreenMailUtil.newMimeMessage("test1");
    Message msg2 = GreenMailUtil.newMimeMessage("test2");
    final Message[] messages = new Message[] { msg1, msg2 };
    doAnswer(invocation -> null).when(receiver).openFolder();
    doAnswer(invocation -> messages).when(receiver).searchForNewMessages();
    doAnswer(invocation -> null).when(receiver).fetchMessages(messages);
    receiver.afterPropertiesSet();
    receiver.receive();
    assertThat(msg1.getFlags().contains(Flag.DELETED)).isFalse();
    assertThat(msg2.getFlags().contains(Flag.DELETED)).isFalse();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockFolder {
    public static Folder createMockFolderWithPermanentFlags(Flags permanentFlags) {
        Folder folder = mock(Folder.class);
        when(folder.getPermanentFlags()).thenReturn(permanentFlags);
        return folder;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_57_7
#### Test Case Name: `receiveAndDontSetDeleteWithoutUrl`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\Pop3MailReceiverTests.java`)
#### Mock Object Variable Name: `folder`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
-    Folder folder = mock(Folder.class);
-    when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));
+    Folder folder = MockFolder.createMockFolderWithPermanentFlags(new Flags(Flags.Flag.USER));
    folderField.set(receiver, folder);
    Message msg1 = GreenMailUtil.newMimeMessage("test1");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void receiveAndDontSetDeleteWithoutUrl() throws Exception {
    AbstractMailReceiver receiver = new Pop3MailReceiver();
    receiver = spy(receiver);
    receiver.setBeanFactory(mock(BeanFactory.class));
    receiver.afterPropertiesSet();
    Field folderField = AbstractMailReceiver.class.getDeclaredField("folder");
    folderField.setAccessible(true);
    Folder folder = mock(Folder.class);
    when(folder.getPermanentFlags()).thenReturn(new Flags(Flags.Flag.USER));
    folderField.set(receiver, folder);
    Message msg1 = GreenMailUtil.newMimeMessage("test1");
    Message msg2 = GreenMailUtil.newMimeMessage("test2");
    final Message[] messages = new Message[] { msg1, msg2 };
    doAnswer(invocation -> null).when(receiver).openFolder();
    doAnswer(invocation -> messages).when(receiver).searchForNewMessages();
    doAnswer(invocation -> null).when(receiver).fetchMessages(messages);
    receiver.afterPropertiesSet();
    receiver.receive();
    assertThat(msg1.getFlags().contains(Flag.DELETED)).isFalse();
    assertThat(msg2.getFlags().contains(Flag.DELETED)).isFalse();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockFolder {
    public static Folder createMockFolderWithPermanentFlags(Flags permanentFlags) {
        Folder folder = mock(Folder.class);
        when(folder.getPermanentFlags()).thenReturn(permanentFlags);
        return folder;
    }
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_58
- **Scope**: method level
- **Mocked Class**: `jakarta.mail.Message`
- **Test Case Count**: 1
- **MO Count**: 2

### Reusable Method
```java
private static Message createMockMessageWithSubject(String subject) {
    Message message = mock(MimeMessage.class);
    given(message.getSubject()).willReturn(subject);
    return message;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_58_1
#### Test Case Name: `receiveExpungedAndNotExpungedLogFiltered`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\ImapMailReceiverTests.java`)
#### Mock Object Variable Name: `msg1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(logger.isDebugEnabled()).thenReturn(true);
-    Message msg1 = mock(MimeMessage.class);
+    Message msg1 = createMockMessageWithSubject("msg1");
    Message msg2 = mock(MimeMessage.class);
-    given(msg1.isExpunged()).willReturn(true);
+    given(msg1.isExpunged()).willReturn(true);
-    given(msg1.getSubject()).willReturn("msg1");
    given(msg2.getSubject()).willReturn("msg2");
    Expression selectorExpression = new SpelExpressionParser().parseExpression("false");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void receiveExpungedAndNotExpungedLogFiltered() throws Exception {
    AbstractMailReceiver receiver = new ImapMailReceiver();
    LogAccessor logger = spy(TestUtils.getPropertyValue(receiver, "logger", LogAccessor.class));
    new DirectFieldAccessor(receiver).setPropertyValue("logger", logger);
    when(logger.isDebugEnabled()).thenReturn(true);
    Message msg1 = mock(MimeMessage.class);
    Message msg2 = mock(MimeMessage.class);
    given(msg1.isExpunged()).willReturn(true);
    given(msg1.getSubject()).willReturn("msg1");
    given(msg2.getSubject()).willReturn("msg2");
    Expression selectorExpression = new SpelExpressionParser().parseExpression("false");
    receiver.setSelectorExpression(selectorExpression);
    receiveAndMarkAsReadDontDeleteGuts(receiver, msg1, msg2);
    verify(msg1).isExpunged();
    verify(msg2).isExpunged();
    verify(msg1, never()).getSubject();
    verify(msg2).getSubject();
    verify(logger).debug(Mockito.startsWith("Expunged message discarded"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Message createMockMessageWithSubject(String subject) {
    Message message = mock(MimeMessage.class);
    given(message.getSubject()).willReturn(subject);
    return message;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_58_2
#### Test Case Name: `receiveExpungedAndNotExpungedLogFiltered`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\ImapMailReceiverTests.java`)
#### Mock Object Variable Name: `msg2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Message msg1 = mock(MimeMessage.class);
-    Message msg2 = mock(MimeMessage.class);
     given(msg1.isExpunged()).willReturn(true);
     given(msg1.getSubject()).willReturn("msg1");
-    given(msg2.getSubject()).willReturn("msg2");
+    Message msg2 = createMockMessageWithSubject("msg2");
     Expression selectorExpression = new SpelExpressionParser().parseExpression("false");
     receiver.setSelectorExpression(selectorExpression);
     receiveAndMarkAsReadDontDeleteGuts(receiver, msg1, msg2);
     verify(msg1).isExpunged();
     verify(msg2).isExpunged();
     verify(msg1, never()).getSubject();
     verify(msg2).getSubject();
     verify(logger).debug(Mockito.startsWith("Expunged message discarded"));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void receiveExpungedAndNotExpungedLogFiltered() throws Exception {
    AbstractMailReceiver receiver = new ImapMailReceiver();
    LogAccessor logger = spy(TestUtils.getPropertyValue(receiver, "logger", LogAccessor.class));
    new DirectFieldAccessor(receiver).setPropertyValue("logger", logger);
    when(logger.isDebugEnabled()).thenReturn(true);
    Message msg1 = mock(MimeMessage.class);
    Message msg2 = mock(MimeMessage.class);
    given(msg1.isExpunged()).willReturn(true);
    given(msg1.getSubject()).willReturn("msg1");
    given(msg2.getSubject()).willReturn("msg2");
    Expression selectorExpression = new SpelExpressionParser().parseExpression("false");
    receiver.setSelectorExpression(selectorExpression);
    receiveAndMarkAsReadDontDeleteGuts(receiver, msg1, msg2);
    verify(msg1).isExpunged();
    verify(msg2).isExpunged();
    verify(msg1, never()).getSubject();
    verify(msg2).getSubject();
    verify(logger).debug(Mockito.startsWith("Expunged message discarded"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Message createMockMessageWithSubject(String subject) {
    Message message = mock(MimeMessage.class);
    given(message.getSubject()).willReturn(subject);
    return message;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_59
- **Scope**: method level
- **Mocked Class**: `java.io.File`
- **Test Case Count**: 2
- **MO Count**: 4

### Reusable Method
```java
private static File createMockFile(Path toPathReturn) {
    File fileMock = mock();
    when(fileMock.toPath()).thenReturn(toPathReturn);
    return fileMock;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_59_1
#### Test Case Name: `scanEachPoll`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\FileReadingMessageSourceTests.java`)
#### Mock Object Variable Name: `anotherFileMock`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void scanEachPoll() {
-    File anotherFileMock = mock();
-    when(anotherFileMock.toPath()).thenReturn(Path.of("[dir]/anotherFileMock"));
+    File anotherFileMock = createMockFile(Path.of("[dir]/anotherFileMock"));
    when(inputDirectoryMock.listFiles()).thenReturn(new File[] { fileMock, anotherFileMock });
    source.setScanEachPoll(true);
    assertThat(source.receive()).isNotNull();
    assertThat(source.receive()).isNotNull();
    assertThat(source.receive()).isNull();
    verify(inputDirectoryMock, times(3)).listFiles();
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void scanEachPoll() {
    File anotherFileMock = mock();
    when(anotherFileMock.toPath()).thenReturn(Path.of("[dir]/anotherFileMock"));
    when(inputDirectoryMock.listFiles()).thenReturn(new File[] { fileMock, anotherFileMock });
    source.setScanEachPoll(true);
    assertThat(source.receive()).isNotNull();
    assertThat(source.receive()).isNotNull();
    assertThat(source.receive()).isNull();
    verify(inputDirectoryMock, times(3)).listFiles();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static File createMockFile(Path toPathReturn) {
    File fileMock = mock();
    when(fileMock.toPath()).thenReturn(toPathReturn);
    return fileMock;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_59_2
#### Test Case Name: `orderedReception`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\FileReadingMessageSourceTests.java`)
#### Mock Object Variable Name: `file1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void orderedReception() {
-    File file1 = mock();
-    when(file1.toPath()).thenReturn(Path.of("[dir]/file1"));
+    File file1 = createMockFile(Path.of("[dir]/file1"));
    File file2 = mock();
    when(file2.toPath()).thenReturn(Path.of("[dir]/file2"));
    File file3 = mock();
    when(file3.toPath()).thenReturn(Path.of("[dir]/file3"));
    // record the comparator to reverse order the files
    when(comparator.compare(file1, file2)).thenReturn(1);
    when(comparator.compare(file1, file3)).thenReturn(1);
    when(comparator.compare(file3, file2)).thenReturn(-1);
    when(inputDirectoryMock.listFiles()).thenReturn(new File[] { file2, file3, file1 });
    assertThat(source.receive().getPayload()).isSameAs(file3);
    assertThat(source.receive().getPayload()).isSameAs(file2);
    assertThat(source.receive().getPayload()).isSameAs(file1);
    assertThat(source.receive()).isNull();
    verify(inputDirectoryMock, times(2)).listFiles();
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void orderedReception() {
    File file1 = mock();
    when(file1.toPath()).thenReturn(Path.of("[dir]/file1"));
    File file2 = mock();
    when(file2.toPath()).thenReturn(Path.of("[dir]/file2"));
    File file3 = mock();
    when(file3.toPath()).thenReturn(Path.of("[dir]/file3"));
    // record the comparator to reverse order the files
    when(comparator.compare(file1, file2)).thenReturn(1);
    when(comparator.compare(file1, file3)).thenReturn(1);
    when(comparator.compare(file3, file2)).thenReturn(-1);
    when(inputDirectoryMock.listFiles()).thenReturn(new File[] { file2, file3, file1 });
    assertThat(source.receive().getPayload()).isSameAs(file3);
    assertThat(source.receive().getPayload()).isSameAs(file2);
    assertThat(source.receive().getPayload()).isSameAs(file1);
    assertThat(source.receive()).isNull();
    verify(inputDirectoryMock, times(2)).listFiles();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static File createMockFile(Path toPathReturn) {
    File fileMock = mock();
    when(fileMock.toPath()).thenReturn(toPathReturn);
    return fileMock;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_59_3
#### Test Case Name: `orderedReception`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\FileReadingMessageSourceTests.java`)
#### Mock Object Variable Name: `file2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    File file1 = mock();
    when(file1.toPath()).thenReturn(Path.of("[dir]/file1"));
-    File file2 = mock();
-    when(file2.toPath()).thenReturn(Path.of("[dir]/file2"));
+    File file2 = createMockFile(Path.of("[dir]/file2"));
    File file3 = mock();
    when(file3.toPath()).thenReturn(Path.of("[dir]/file3"));
    // record the comparator to reverse order the files
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void orderedReception() {
    File file1 = mock();
    when(file1.toPath()).thenReturn(Path.of("[dir]/file1"));
    File file2 = mock();
    when(file2.toPath()).thenReturn(Path.of("[dir]/file2"));
    File file3 = mock();
    when(file3.toPath()).thenReturn(Path.of("[dir]/file3"));
    // record the comparator to reverse order the files
    when(comparator.compare(file1, file2)).thenReturn(1);
    when(comparator.compare(file1, file3)).thenReturn(1);
    when(comparator.compare(file3, file2)).thenReturn(-1);
    when(inputDirectoryMock.listFiles()).thenReturn(new File[] { file2, file3, file1 });
    assertThat(source.receive().getPayload()).isSameAs(file3);
    assertThat(source.receive().getPayload()).isSameAs(file2);
    assertThat(source.receive().getPayload()).isSameAs(file1);
    assertThat(source.receive()).isNull();
    verify(inputDirectoryMock, times(2)).listFiles();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static File createMockFile(Path toPathReturn) {
    File fileMock = mock();
    when(fileMock.toPath()).thenReturn(toPathReturn);
    return fileMock;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_59_4
#### Test Case Name: `orderedReception`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\FileReadingMessageSourceTests.java`)
#### Mock Object Variable Name: `file3`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    File file2 = mock();
    when(file2.toPath()).thenReturn(Path.of("[dir]/file2"));
-    File file3 = mock();
-    when(file3.toPath()).thenReturn(Path.of("[dir]/file3"));
+    File file3 = createMockFile(Path.of("[dir]/file3"));
    // record the comparator to reverse order the files
    when(comparator.compare(file1, file2)).thenReturn(1);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void orderedReception() {
    File file1 = mock();
    when(file1.toPath()).thenReturn(Path.of("[dir]/file1"));
    File file2 = mock();
    when(file2.toPath()).thenReturn(Path.of("[dir]/file2"));
    File file3 = mock();
    when(file3.toPath()).thenReturn(Path.of("[dir]/file3"));
    // record the comparator to reverse order the files
    when(comparator.compare(file1, file2)).thenReturn(1);
    when(comparator.compare(file1, file3)).thenReturn(1);
    when(comparator.compare(file3, file2)).thenReturn(-1);
    when(inputDirectoryMock.listFiles()).thenReturn(new File[] { file2, file3, file1 });
    assertThat(source.receive().getPayload()).isSameAs(file3);
    assertThat(source.receive().getPayload()).isSameAs(file2);
    assertThat(source.receive().getPayload()).isSameAs(file1);
    assertThat(source.receive()).isNull();
    verify(inputDirectoryMock, times(2)).listFiles();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static File createMockFile(Path toPathReturn) {
    File fileMock = mock();
    when(fileMock.toPath()).thenReturn(toPathReturn);
    return fileMock;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_60
- **Scope**: method level
- **Mocked Class**: `org.springframework.context.SmartLifecycle`
- **Test Case Count**: 1
- **MO Count**: 2

### Reusable Method
```java
private static SmartLifecycle createMockSmartLifecycle(int phase) {
    SmartLifecycle mock = mock(SmartLifecycle.class);
    when(mock.getPhase()).thenReturn(phase);
    return mock;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_60_1
#### Test Case Name: `testOrder`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\support\SmartLifecycleRoleControllerTests.java`)
#### Mock Object Variable Name: `lc1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testOrder() {
-    SmartLifecycle lc1 = mock(SmartLifecycle.class);
-    when(lc1.getPhase()).thenReturn(2);
+    SmartLifecycle lc1 = createMockSmartLifecycle(2);
     SmartLifecycle lc2 = mock(SmartLifecycle.class);
     when(lc2.getPhase()).thenReturn(1);
     MultiValueMap<String, SmartLifecycle> map = new LinkedMultiValueMap<>();
     map.add("foo", lc1);
     map.add("foo", lc2);
     SmartLifecycleRoleController controller = new SmartLifecycleRoleController(map);
     controller.startLifecyclesInRole("foo");
     controller.stopLifecyclesInRole("foo");
     InOrder inOrder = inOrder(lc1, lc2);
     inOrder.verify(lc2).start();
     inOrder.verify(lc1).start();
     inOrder.verify(lc1).stop();
     inOrder.verify(lc2).stop();
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testOrder() {
    SmartLifecycle lc1 = mock(SmartLifecycle.class);
    when(lc1.getPhase()).thenReturn(2);
    SmartLifecycle lc2 = mock(SmartLifecycle.class);
    when(lc2.getPhase()).thenReturn(1);
    MultiValueMap<String, SmartLifecycle> map = new LinkedMultiValueMap<>();
    map.add("foo", lc1);
    map.add("foo", lc2);
    SmartLifecycleRoleController controller = new SmartLifecycleRoleController(map);
    controller.startLifecyclesInRole("foo");
    controller.stopLifecyclesInRole("foo");
    InOrder inOrder = inOrder(lc1, lc2);
    inOrder.verify(lc2).start();
    inOrder.verify(lc1).start();
    inOrder.verify(lc1).stop();
    inOrder.verify(lc2).stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SmartLifecycle createMockSmartLifecycle(int phase) {
    SmartLifecycle mock = mock(SmartLifecycle.class);
    when(mock.getPhase()).thenReturn(phase);
    return mock;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_60_2
#### Test Case Name: `testOrder`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\support\SmartLifecycleRoleControllerTests.java`)
#### Mock Object Variable Name: `lc2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SmartLifecycle lc1 = mock(SmartLifecycle.class);
    when(lc1.getPhase()).thenReturn(2);
-    SmartLifecycle lc2 = mock(SmartLifecycle.class);
-    when(lc2.getPhase()).thenReturn(1);
+    SmartLifecycle lc2 = createMockSmartLifecycle(1);
    MultiValueMap<String, SmartLifecycle> map = new LinkedMultiValueMap<>();
    map.add("foo", lc1);
    map.add("foo", lc2);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testOrder() {
    SmartLifecycle lc1 = mock(SmartLifecycle.class);
    when(lc1.getPhase()).thenReturn(2);
    SmartLifecycle lc2 = mock(SmartLifecycle.class);
    when(lc2.getPhase()).thenReturn(1);
    MultiValueMap<String, SmartLifecycle> map = new LinkedMultiValueMap<>();
    map.add("foo", lc1);
    map.add("foo", lc2);
    SmartLifecycleRoleController controller = new SmartLifecycleRoleController(map);
    controller.startLifecyclesInRole("foo");
    controller.stopLifecyclesInRole("foo");
    InOrder inOrder = inOrder(lc1, lc2);
    inOrder.verify(lc2).start();
    inOrder.verify(lc1).start();
    inOrder.verify(lc1).stop();
    inOrder.verify(lc2).stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static SmartLifecycle createMockSmartLifecycle(int phase) {
    SmartLifecycle mock = mock(SmartLifecycle.class);
    when(mock.getPhase()).thenReturn(phase);
    return mock;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_61
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.file.remote.session.Session<java.lang.String>`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static Session<String> createMockSessionWithReadRaw() {
    Session<String> session = mock();
    when(session.readRaw(anyString())).thenReturn(mock());
    return session;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_61_1
#### Test Case Name: `fetchFilesFromRemoteAfterClearingFetchedCache`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\RemoteFileStreamingMessageSourceTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    RemoteFileTemplate<String> remoteFileTemplate = mock();
    when(remoteFileTemplate.list("remoteDirectory")).thenReturn(new String[] { "file1", "file2" });
-    Session<String> session = mock();
-    when(session.readRaw(anyString())).thenReturn(mock());
+    Session<String> session = createMockSessionWithReadRaw();
    when(remoteFileTemplate.getSession()).thenReturn(session);
    Comparator<String> comparator = mock();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void fetchFilesFromRemoteAfterClearingFetchedCache() throws IOException {
    RemoteFileTemplate<String> remoteFileTemplate = mock();
    when(remoteFileTemplate.list("remoteDirectory")).thenReturn(new String[] { "file1", "file2" });
    Session<String> session = mock();
    when(session.readRaw(anyString())).thenReturn(mock());
    when(remoteFileTemplate.getSession()).thenReturn(session);
    Comparator<String> comparator = mock();
    TestRemoteFileStreamingMessageSource testRemoteFileStreamingMessageSource = new TestRemoteFileStreamingMessageSource(remoteFileTemplate, comparator);
    testRemoteFileStreamingMessageSource.setRemoteDirectory("remoteDirectory");
    testRemoteFileStreamingMessageSource.setBeanFactory(mock());
    testRemoteFileStreamingMessageSource.start();
    assertThat(testRemoteFileStreamingMessageSource.doReceive(2)).isNotNull();
    testRemoteFileStreamingMessageSource.clearFetchedCache();
    assertThat(testRemoteFileStreamingMessageSource.doReceive(2)).isNotNull();
    verify(remoteFileTemplate, times(2)).list("remoteDirectory");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session<String> createMockSessionWithReadRaw() {
    Session<String> session = mock();
    when(session.readRaw(anyString())).thenReturn(mock());
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_61_2
#### Test Case Name: `filterOutFilesNotAcceptedByFilter`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\RemoteFileStreamingMessageSourceTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    RemoteFileTemplate<String> remoteFileTemplate = mock();
    when(remoteFileTemplate.list("remoteDirectory")).thenReturn(new String[] { "file1", "file2" });
-    Session<String> session = mock();
-    when(session.readRaw(anyString())).thenReturn(mock());
+    Session<String> session = createMockSessionWithReadRaw();
    when(remoteFileTemplate.getSession()).thenReturn(session);
    FileListFilter<String> fileListFilter = mock();
    when(fileListFilter.supportsSingleFileFiltering()).thenReturn(true);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void filterOutFilesNotAcceptedByFilter() throws IOException {
    RemoteFileTemplate<String> remoteFileTemplate = mock();
    when(remoteFileTemplate.list("remoteDirectory")).thenReturn(new String[] { "file1", "file2" });
    Session<String> session = mock();
    when(session.readRaw(anyString())).thenReturn(mock());
    when(remoteFileTemplate.getSession()).thenReturn(session);
    FileListFilter<String> fileListFilter = mock();
    when(fileListFilter.supportsSingleFileFiltering()).thenReturn(true);
    when(fileListFilter.accept("file1")).thenReturn(false);
    when(fileListFilter.accept("file2")).thenReturn(false);
    Comparator<String> comparator = mock();
    TestRemoteFileStreamingMessageSource testRemoteFileStreamingMessageSource = new TestRemoteFileStreamingMessageSource(remoteFileTemplate, comparator);
    testRemoteFileStreamingMessageSource.setFilter(fileListFilter);
    testRemoteFileStreamingMessageSource.setRemoteDirectory("remoteDirectory");
    testRemoteFileStreamingMessageSource.setBeanFactory(mock());
    testRemoteFileStreamingMessageSource.start();
    assertThat(testRemoteFileStreamingMessageSource.doReceive(-1)).isNull();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session<String> createMockSessionWithReadRaw() {
    Session<String> session = mock();
    when(session.readRaw(anyString())).thenReturn(mock());
    return session;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_62
- **Scope**: method level
- **Mocked Class**: `org.eclipse.angus.mail.imap.IMAPFolder`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static IMAPFolder createMockImapFolder(Flags permanentFlags, boolean existsReturn, boolean isOpenFirstReturn, boolean isOpenSecondReturn) {
    IMAPFolder folder = mock(IMAPFolder.class);
    given(folder.getPermanentFlags()).willReturn(permanentFlags);
    given(folder.exists()).willReturn(existsReturn);
    given(folder.isOpen()).willReturn(isOpenFirstReturn).willReturn(isOpenSecondReturn);
    return folder;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_62_1
#### Test Case Name: `testNoInitialIdleDelayWhenRecentNotSupported`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\ImapMailReceiverTests.java`)
#### Mock Object Variable Name: `folder`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();
    setUpScheduler(receiver, taskScheduler);
-    final IMAPFolder folder = mock(IMAPFolder.class);
-    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
-    given(folder.isOpen()).willReturn(false).willReturn(true);
-    given(folder.exists()).willReturn(true);
+    final IMAPFolder folder = createMockImapFolder(new Flags(Flags.Flag.USER), true, false, true);
    Field storeField = AbstractMailReceiver.class.getDeclaredField("store");
    storeField.setAccessible(true);
    Store store = mock(Store.class);
@@
    willAnswer(invocation -> {
        /*
 			 * Return the message from first invocation of waitForMessages()
 			 * and in receive(); then return false in the next call to
 			 * waitForMessages() so we enter idle(); counter will be reset
 			 * to 1 in the mocked idle().
 			 */
        if (shouldFindMessagesCounter.decrementAndGet() >= 0) {
            return messages;
        } else {
            return new Message[0];
        }
    }).given(folder).search(any(SearchTerm.class));
    willAnswer(invocation -> {
        Thread.sleep(300);
        shouldFindMessagesCounter.set(1);
        return null;
    }).given(folder).idle(true);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("resource")
@Test
public void testNoInitialIdleDelayWhenRecentNotSupported() throws Exception {
    ImapIdleChannelAdapter adapter = this.context.getBean("simpleAdapter", ImapIdleChannelAdapter.class);
    QueueChannel channel = new QueueChannel();
    adapter.setOutputChannel(channel);
    adapter.setReconnectDelay(10);
    ImapMailReceiver receiver = new ImapMailReceiver("imap:foo");
    ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();
    setUpScheduler(receiver, taskScheduler);
    final IMAPFolder folder = mock(IMAPFolder.class);
    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
    given(folder.isOpen()).willReturn(false).willReturn(true);
    given(folder.exists()).willReturn(true);
    Field storeField = AbstractMailReceiver.class.getDeclaredField("store");
    storeField.setAccessible(true);
    Store store = mock(Store.class);
    given(store.isConnected()).willReturn(true);
    given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);
    storeField.set(receiver, store);
    receiver.afterPropertiesSet();
    DirectFieldAccessor adapterAccessor = new DirectFieldAccessor(adapter);
    adapterAccessor.setPropertyValue("mailReceiver", receiver);
    Message mailMessage = GreenMailUtil.newMimeMessage("test1");
    final Message[] messages = new Message[] { mailMessage };
    final AtomicInteger shouldFindMessagesCounter = new AtomicInteger(2);
    willAnswer(invocation -> {
        /*
			 * Return the message from first invocation of waitForMessages()
			 * and in receive(); then return false in the next call to
			 * waitForMessages() so we enter idle(); counter will be reset
			 * to 1 in the mocked idle().
			 */
        if (shouldFindMessagesCounter.decrementAndGet() >= 0) {
            return messages;
        } else {
            return new Message[0];
        }
    }).given(folder).search(any(SearchTerm.class));
    willAnswer(invocation -> {
        Thread.sleep(300);
        shouldFindMessagesCounter.set(1);
        return null;
    }).given(folder).idle(true);
    adapter.start();
    /*
		 * Idle takes 5 seconds; if all is well, we should receive the first message
		 * before then.
		 */
    assertThat(channel.receive(20000)).isNotNull();
    // We should not receive any more until the next idle elapses
    assertThat(channel.receive(100)).isNull();
    assertThat(channel.receive(10000)).isNotNull();
    adapter.stop();
    taskScheduler.shutdown();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static IMAPFolder createMockImapFolder(Flags permanentFlags, boolean existsReturn, boolean isOpenFirstReturn, boolean isOpenSecondReturn) {
    IMAPFolder folder = mock(IMAPFolder.class);
    given(folder.getPermanentFlags()).willReturn(permanentFlags);
    given(folder.exists()).willReturn(existsReturn);
    given(folder.isOpen()).willReturn(isOpenFirstReturn).willReturn(isOpenSecondReturn);
    return folder;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_62_2
#### Test Case Name: `testInitialIdleDelayWhenRecentIsSupported`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\ImapMailReceiverTests.java`)
#### Mock Object Variable Name: `folder`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();
    setUpScheduler(receiver, taskScheduler);
-    IMAPFolder folder = mock(IMAPFolder.class);
-    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.RECENT));
-    given(folder.isOpen()).willReturn(false).willReturn(true);
-    given(folder.exists()).willReturn(true);
+    IMAPFolder folder = createMockImapFolder(new Flags(Flags.Flag.RECENT), true, false, true);
    Field storeField = AbstractMailReceiver.class.getDeclaredField("store");
    storeField.setAccessible(true);
    Store store = mock(Store.class);
@@
    Message[] messages = new Message[] { mailMessage };
    willAnswer(invocation -> messages).given(folder).search(any(SearchTerm.class));
    CountDownLatch idles = new CountDownLatch(2);
    willAnswer(invocation -> {
        idles.countDown();
        Thread.sleep(500);
        return null;
    }).given(folder).idle(true);
    adapter.start();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testInitialIdleDelayWhenRecentIsSupported() throws Exception {
    ImapIdleChannelAdapter adapter = this.context.getBean("simpleAdapter", ImapIdleChannelAdapter.class);
    QueueChannel channel = new QueueChannel();
    adapter.setOutputChannel(channel);
    adapter.setReconnectDelay(100);
    adapter.afterPropertiesSet();
    ImapMailReceiver receiver = new ImapMailReceiver("imap:foo");
    receiver.setCancelIdleInterval(10);
    ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();
    setUpScheduler(receiver, taskScheduler);
    IMAPFolder folder = mock(IMAPFolder.class);
    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.RECENT));
    given(folder.isOpen()).willReturn(false).willReturn(true);
    given(folder.exists()).willReturn(true);
    Field storeField = AbstractMailReceiver.class.getDeclaredField("store");
    storeField.setAccessible(true);
    Store store = mock(Store.class);
    given(store.isConnected()).willReturn(true);
    given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);
    storeField.set(receiver, store);
    receiver.afterPropertiesSet();
    DirectFieldAccessor adapterAccessor = new DirectFieldAccessor(adapter);
    adapterAccessor.setPropertyValue("mailReceiver", receiver);
    Message mailMessage = GreenMailUtil.newMimeMessage("test1");
    Message[] messages = new Message[] { mailMessage };
    willAnswer(invocation -> messages).given(folder).search(any(SearchTerm.class));
    CountDownLatch idles = new CountDownLatch(2);
    willAnswer(invocation -> {
        idles.countDown();
        Thread.sleep(500);
        return null;
    }).given(folder).idle(true);
    adapter.start();
    /*
		 * Idle takes 5 seconds; since this server supports RECENT, we should
		 * not receive any early messages.
		 */
    assertThat(channel.receive(100)).isNull();
    assertThat(channel.receive(20000)).isNotNull();
    assertThat(idles.await(10, TimeUnit.SECONDS)).isTrue();
    adapter.stop();
    taskScheduler.shutdown();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static IMAPFolder createMockImapFolder(Flags permanentFlags, boolean existsReturn, boolean isOpenFirstReturn, boolean isOpenSecondReturn) {
    IMAPFolder folder = mock(IMAPFolder.class);
    given(folder.getPermanentFlags()).willReturn(permanentFlags);
    given(folder.exists()).willReturn(existsReturn);
    given(folder.isOpen()).willReturn(isOpenFirstReturn).willReturn(isOpenSecondReturn);
    return folder;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_62_3
#### Test Case Name: `testIdleReconnects`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-mail\src\test\java\org\springframework\integration\mail\ImapMailReceiverTests.java`)
#### Mock Object Variable Name: `folder`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    receiver.afterPropertiesSet();
-    IMAPFolder folder = mock(IMAPFolder.class);
-    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
-    given(folder.isOpen()).willReturn(false).willReturn(true);
-    given(folder.exists()).willReturn(true);
-    given(folder.hasNewMessages()).willReturn(true);
+    IMAPFolder folder = createMockImapFolder(new Flags(Flags.Flag.USER), true, false, true);
+    given(folder.hasNewMessages()).willReturn(true);
    Field storeField = AbstractMailReceiver.class.getDeclaredField("store");
    storeField.setAccessible(true);
    Store store = mock(Store.class);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testIdleReconnects() throws Exception {
    ImapMailReceiver receiver = spy(new ImapMailReceiver("imap:foo"));
    receiver.setBeanFactory(mock(BeanFactory.class));
    receiver.afterPropertiesSet();
    IMAPFolder folder = mock(IMAPFolder.class);
    given(folder.getPermanentFlags()).willReturn(new Flags(Flags.Flag.USER));
    given(folder.isOpen()).willReturn(false).willReturn(true);
    given(folder.exists()).willReturn(true);
    given(folder.hasNewMessages()).willReturn(true);
    Field storeField = AbstractMailReceiver.class.getDeclaredField("store");
    storeField.setAccessible(true);
    Store store = mock(Store.class);
    given(store.isConnected()).willReturn(false);
    given(store.getFolder(Mockito.any(URLName.class))).willReturn(folder);
    storeField.set(receiver, store);
    ImapIdleChannelAdapter adapter = new ImapIdleChannelAdapter(receiver);
    LogAccessor logger = spy(TestUtils.getPropertyValue(adapter, "logger", LogAccessor.class));
    new DirectFieldAccessor(adapter).setPropertyValue("logger", logger);
    willDoNothing().given(logger).warn(any(Throwable.class), anyString());
    willAnswer(i -> {
        i.callRealMethod();
        throw new FolderClosedException(folder, "test");
    }).given(receiver).waitForNewMessages();
    adapter.setReconnectDelay(10);
    CountDownLatch latch = new CountDownLatch(3);
    adapter.setApplicationEventPublisher(e -> latch.countDown());
    adapter.afterPropertiesSet();
    adapter.start();
    assertThat(latch.await(60, TimeUnit.SECONDS)).isTrue();
    verify(store, atLeast(3)).connect();
    adapter.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static IMAPFolder createMockImapFolder(Flags permanentFlags, boolean existsReturn, boolean isOpenFirstReturn, boolean isOpenSecondReturn) {
    IMAPFolder folder = mock(IMAPFolder.class);
    given(folder.getPermanentFlags()).willReturn(permanentFlags);
    given(folder.exists()).willReturn(existsReturn);
    given(folder.isOpen()).willReturn(isOpenFirstReturn).willReturn(isOpenSecondReturn);
    return folder;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_63
- **Scope**: method level
- **Mocked Class**: `java.util.concurrent.locks.Lock`
- **Test Case Count**: 1
- **MO Count**: 2

### Reusable Method
```java
private static Lock createMockLock(java.util.function.Supplier<Boolean> tryLockSupplier) {
    Lock lock = mock(Lock.class);
    given(lock.tryLock(anyLong(), any(TimeUnit.class))).willAnswer(i -> tryLockSupplier.get());
    return lock;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_63_1
#### Test Case Name: `competingWithLock`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\support\leader\LockRegistryLeaderInitiatorTests.java`)
#### Mock Object Variable Name: `firstLock`
<summary>Suggested Diff</summary>

```diff
@@
    // set up first registry instance - this one will be able to obtain lock initially
    LockRegistry firstRegistry = mock(LockRegistry.class);
-    Lock firstLock = mock(Lock.class);
-    given(firstRegistry.obtain(anyString())).willReturn(firstLock);
-    given(firstLock.tryLock(anyLong(), any(TimeUnit.class))).willAnswer(i -> firstLocked.get());
+    Lock firstLock = createMockLock(() -> firstLocked.get());
+    given(firstRegistry.obtain(anyString())).willReturn(firstLock);
    // set up first initiator instance using first LockRegistry
    LockRegistryLeaderInitiator first = new LockRegistryLeaderInitiator(firstRegistry, new DefaultCandidate());
    CountDownLatch firstGranted = new CountDownLatch(1);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void competingWithLock() throws Exception {
    // switch used to toggle which registry obtains lock
    AtomicBoolean firstLocked = new AtomicBoolean(true);
    // set up first registry instance - this one will be able to obtain lock initially
    LockRegistry firstRegistry = mock(LockRegistry.class);
    Lock firstLock = mock(Lock.class);
    given(firstRegistry.obtain(anyString())).willReturn(firstLock);
    given(firstLock.tryLock(anyLong(), any(TimeUnit.class))).willAnswer(i -> firstLocked.get());
    // set up first initiator instance using first LockRegistry
    LockRegistryLeaderInitiator first = new LockRegistryLeaderInitiator(firstRegistry, new DefaultCandidate());
    CountDownLatch firstGranted = new CountDownLatch(1);
    CountDownLatch firstRevoked = new CountDownLatch(1);
    CountDownLatch firstAquireLockFailed = new CountDownLatch(1);
    first.setHeartBeatMillis(10);
    first.setBusyWaitMillis(1);
    first.setLeaderEventPublisher(new CountingPublisher(firstGranted, firstRevoked, firstAquireLockFailed));
    // set up second registry instance - this one will NOT be able to obtain lock initially
    LockRegistry secondRegistry = mock(LockRegistry.class);
    Lock secondLock = mock(Lock.class);
    given(secondRegistry.obtain(anyString())).willReturn(secondLock);
    given(secondLock.tryLock(anyLong(), any(TimeUnit.class))).willAnswer(i -> !firstLocked.get());
    // set up second initiator instance using second LockRegistry
    LockRegistryLeaderInitiator second = new LockRegistryLeaderInitiator(secondRegistry, new DefaultCandidate());
    CountDownLatch secondGranted = new CountDownLatch(1);
    CountDownLatch secondRevoked = new CountDownLatch(1);
    CountDownLatch secondAquireLockFailed = new CountDownLatch(1);
    second.setHeartBeatMillis(10);
    second.setBusyWaitMillis(1);
    second.setLeaderEventPublisher(new CountingPublisher(secondGranted, secondRevoked, secondAquireLockFailed));
    // start initiators
    first.start();
    second.start();
    // first initiator should lead and publish granted event
    assertThat(firstGranted.await(10, TimeUnit.SECONDS)).isTrue();
    assertThat(first.getContext().isLeader()).isTrue();
    assertThat(second.getContext().isLeader()).isFalse();
    // simulate first registry instance unable to obtain lock, for example due to lock timeout
    firstLocked.set(false);
    // second initiator should take lead and publish granted event, first initiator should publish revoked event
    assertThat(secondGranted.await(10, TimeUnit.SECONDS)).isTrue();
    assertThat(firstRevoked.await(10, TimeUnit.SECONDS)).isTrue();
    assertThat(second.getContext().isLeader()).isTrue();
    assertThat(first.getContext().isLeader()).isFalse();
    first.stop();
    second.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Lock createMockLock(java.util.function.Supplier<Boolean> tryLockSupplier) {
    Lock lock = mock(Lock.class);
    given(lock.tryLock(anyLong(), any(TimeUnit.class))).willAnswer(i -> tryLockSupplier.get());
    return lock;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_63_2
#### Test Case Name: `competingWithLock`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\support\leader\LockRegistryLeaderInitiatorTests.java`)
#### Mock Object Variable Name: `secondLock`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    LockRegistry secondRegistry = mock(LockRegistry.class);
-    Lock secondLock = mock(Lock.class);
-    given(secondRegistry.obtain(anyString())).willReturn(secondLock);
-    given(secondLock.tryLock(anyLong(), any(TimeUnit.class))).willAnswer(i -> !firstLocked.get());
+    Lock secondLock = createMockLock(() -> !firstLocked.get());
+    given(secondRegistry.obtain(anyString())).willReturn(secondLock);
    // set up second initiator instance using second LockRegistry
    LockRegistryLeaderInitiator second = new LockRegistryLeaderInitiator(secondRegistry, new DefaultCandidate());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void competingWithLock() throws Exception {
    // switch used to toggle which registry obtains lock
    AtomicBoolean firstLocked = new AtomicBoolean(true);
    // set up first registry instance - this one will be able to obtain lock initially
    LockRegistry firstRegistry = mock(LockRegistry.class);
    Lock firstLock = mock(Lock.class);
    given(firstRegistry.obtain(anyString())).willReturn(firstLock);
    given(firstLock.tryLock(anyLong(), any(TimeUnit.class))).willAnswer(i -> firstLocked.get());
    // set up first initiator instance using first LockRegistry
    LockRegistryLeaderInitiator first = new LockRegistryLeaderInitiator(firstRegistry, new DefaultCandidate());
    CountDownLatch firstGranted = new CountDownLatch(1);
    CountDownLatch firstRevoked = new CountDownLatch(1);
    CountDownLatch firstAquireLockFailed = new CountDownLatch(1);
    first.setHeartBeatMillis(10);
    first.setBusyWaitMillis(1);
    first.setLeaderEventPublisher(new CountingPublisher(firstGranted, firstRevoked, firstAquireLockFailed));
    // set up second registry instance - this one will NOT be able to obtain lock initially
    LockRegistry secondRegistry = mock(LockRegistry.class);
    Lock secondLock = mock(Lock.class);
    given(secondRegistry.obtain(anyString())).willReturn(secondLock);
    given(secondLock.tryLock(anyLong(), any(TimeUnit.class))).willAnswer(i -> !firstLocked.get());
    // set up second initiator instance using second LockRegistry
    LockRegistryLeaderInitiator second = new LockRegistryLeaderInitiator(secondRegistry, new DefaultCandidate());
    CountDownLatch secondGranted = new CountDownLatch(1);
    CountDownLatch secondRevoked = new CountDownLatch(1);
    CountDownLatch secondAquireLockFailed = new CountDownLatch(1);
    second.setHeartBeatMillis(10);
    second.setBusyWaitMillis(1);
    second.setLeaderEventPublisher(new CountingPublisher(secondGranted, secondRevoked, secondAquireLockFailed));
    // start initiators
    first.start();
    second.start();
    // first initiator should lead and publish granted event
    assertThat(firstGranted.await(10, TimeUnit.SECONDS)).isTrue();
    assertThat(first.getContext().isLeader()).isTrue();
    assertThat(second.getContext().isLeader()).isFalse();
    // simulate first registry instance unable to obtain lock, for example due to lock timeout
    firstLocked.set(false);
    // second initiator should take lead and publish granted event, first initiator should publish revoked event
    assertThat(secondGranted.await(10, TimeUnit.SECONDS)).isTrue();
    assertThat(firstRevoked.await(10, TimeUnit.SECONDS)).isTrue();
    assertThat(second.getContext().isLeader()).isTrue();
    assertThat(first.getContext().isLeader()).isFalse();
    first.stop();
    second.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Lock createMockLock(java.util.function.Supplier<Boolean> tryLockSupplier) {
    Lock lock = mock(Lock.class);
    given(lock.tryLock(anyLong(), any(TimeUnit.class))).willAnswer(i -> tryLockSupplier.get());
    return lock;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_64
- **Scope**: class level
- **Mocked Class**: `jcifs.smb.SmbFile`
- **Test Case Count**: 1
- **MO Count**: 6

### Reusable Method
```java
public class MockSmbFile {
    public static SmbFile createMockSmbFile(long lastModified) {
        SmbFile smbFile = mock(SmbFile.class);
        when(smbFile.getLastModified()).thenReturn(lastModified);
        return smbFile;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_64_1
#### Test Case Name: `testAge`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-smb\src\test\java\org\springframework\integration\smb\filters\SmbLastModifiedFileListFilterTests.java`)
#### Mock Object Variable Name: `smbFile1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SmbLastModifiedFileListFilter filter = new SmbLastModifiedFileListFilter();
    filter.setAge(80);
-    SmbFile smbFile1 = mock(SmbFile.class);
-    when(smbFile1.getLastModified()).thenReturn(System.currentTimeMillis());
+    SmbFile smbFile1 = MockSmbFile.createMockSmbFile(System.currentTimeMillis());
    SmbFile smbFile2 = mock(SmbFile.class);
    when(smbFile2.getLastModified()).thenReturn(System.currentTimeMillis());
    SmbFile smbFile3 = mock(SmbFile.class);
    when(smbFile3.getLastModified()).thenReturn(Instant.now().minus(Duration.ofDays(1)).toEpochMilli());
    SmbFile[] files = new SmbFile[] { smbFile1, smbFile2, smbFile3 };
    assertThat(filter.filterFiles(files)).hasSize(1);
    assertThat(filter.accept(smbFile1)).isFalse();
    assertThat(filter.accept(smbFile3)).isTrue();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testAge() {
    SmbLastModifiedFileListFilter filter = new SmbLastModifiedFileListFilter();
    filter.setAge(80);
    SmbFile smbFile1 = mock(SmbFile.class);
    when(smbFile1.getLastModified()).thenReturn(System.currentTimeMillis());
    SmbFile smbFile2 = mock(SmbFile.class);
    when(smbFile2.getLastModified()).thenReturn(System.currentTimeMillis());
    SmbFile smbFile3 = mock(SmbFile.class);
    when(smbFile3.getLastModified()).thenReturn(Instant.now().minus(Duration.ofDays(1)).toEpochMilli());
    SmbFile[] files = new SmbFile[] { smbFile1, smbFile2, smbFile3 };
    assertThat(filter.filterFiles(files)).hasSize(1);
    assertThat(filter.accept(smbFile1)).isFalse();
    assertThat(filter.accept(smbFile3)).isTrue();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockSmbFile {
    public static SmbFile createMockSmbFile(long lastModified) {
        SmbFile smbFile = mock(SmbFile.class);
        when(smbFile.getLastModified()).thenReturn(lastModified);
        return smbFile;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_64_2
#### Test Case Name: `testAge`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-smb\src\test\java\org\springframework\integration\smb\filters\SmbLastModifiedFileListFilterTests.java`)
#### Mock Object Variable Name: `smbFile2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SmbFile smbFile1 = mock(SmbFile.class);
    when(smbFile1.getLastModified()).thenReturn(System.currentTimeMillis());
-    SmbFile smbFile2 = mock(SmbFile.class);
-    when(smbFile2.getLastModified()).thenReturn(System.currentTimeMillis());
+    SmbFile smbFile2 = MockSmbFile.createMockSmbFile(System.currentTimeMillis());
    SmbFile smbFile3 = mock(SmbFile.class);
    when(smbFile3.getLastModified()).thenReturn(Instant.now().minus(Duration.ofDays(1)).toEpochMilli());
    SmbFile[] files = new SmbFile[] { smbFile1, smbFile2, smbFile3 };
    assertThat(filter.filterFiles(files)).hasSize(1);
    assertThat(filter.accept(smbFile1)).isFalse();
    assertThat(filter.accept(smbFile3)).isTrue();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testAge() {
    SmbLastModifiedFileListFilter filter = new SmbLastModifiedFileListFilter();
    filter.setAge(80);
    SmbFile smbFile1 = mock(SmbFile.class);
    when(smbFile1.getLastModified()).thenReturn(System.currentTimeMillis());
    SmbFile smbFile2 = mock(SmbFile.class);
    when(smbFile2.getLastModified()).thenReturn(System.currentTimeMillis());
    SmbFile smbFile3 = mock(SmbFile.class);
    when(smbFile3.getLastModified()).thenReturn(Instant.now().minus(Duration.ofDays(1)).toEpochMilli());
    SmbFile[] files = new SmbFile[] { smbFile1, smbFile2, smbFile3 };
    assertThat(filter.filterFiles(files)).hasSize(1);
    assertThat(filter.accept(smbFile1)).isFalse();
    assertThat(filter.accept(smbFile3)).isTrue();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockSmbFile {
    public static SmbFile createMockSmbFile(long lastModified) {
        SmbFile smbFile = mock(SmbFile.class);
        when(smbFile.getLastModified()).thenReturn(lastModified);
        return smbFile;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_64_3
#### Test Case Name: `testAge`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-smb\src\test\java\org\springframework\integration\smb\filters\SmbLastModifiedFileListFilterTests.java`)
#### Mock Object Variable Name: `smbFile3`
<summary>Suggested Diff</summary>

```diff
@@
     SmbFile smbFile2 = mock(SmbFile.class);
     when(smbFile2.getLastModified()).thenReturn(System.currentTimeMillis());
-    SmbFile smbFile3 = mock(SmbFile.class);
-    when(smbFile3.getLastModified()).thenReturn(Instant.now().minus(Duration.ofDays(1)).toEpochMilli());
+    SmbFile smbFile3 = MockSmbFile.createMockSmbFile(Instant.now().minus(Duration.ofDays(1)).toEpochMilli());
     SmbFile[] files = new SmbFile[] { smbFile1, smbFile2, smbFile3 };
     assertThat(filter.filterFiles(files)).hasSize(1);
     assertThat(filter.accept(smbFile1)).isFalse();
     assertThat(filter.accept(smbFile3)).isTrue();
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testAge() {
    SmbLastModifiedFileListFilter filter = new SmbLastModifiedFileListFilter();
    filter.setAge(80);
    SmbFile smbFile1 = mock(SmbFile.class);
    when(smbFile1.getLastModified()).thenReturn(System.currentTimeMillis());
    SmbFile smbFile2 = mock(SmbFile.class);
    when(smbFile2.getLastModified()).thenReturn(System.currentTimeMillis());
    SmbFile smbFile3 = mock(SmbFile.class);
    when(smbFile3.getLastModified()).thenReturn(Instant.now().minus(Duration.ofDays(1)).toEpochMilli());
    SmbFile[] files = new SmbFile[] { smbFile1, smbFile2, smbFile3 };
    assertThat(filter.filterFiles(files)).hasSize(1);
    assertThat(filter.accept(smbFile1)).isFalse();
    assertThat(filter.accept(smbFile3)).isTrue();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockSmbFile {
    public static SmbFile createMockSmbFile(long lastModified) {
        SmbFile smbFile = mock(SmbFile.class);
        when(smbFile.getLastModified()).thenReturn(lastModified);
        return smbFile;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_64_4
#### Test Case Name: `testAge`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-smb\src\test\java\org\springframework\integration\smb\filters\SmbRecentFileListFilterTests.java`)
#### Mock Object Variable Name: `smbFile1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SmbRecentFileListFilter filter = new SmbRecentFileListFilter(Duration.ofHours(20));
-    SmbFile smbFile1 = mock();
-    when(smbFile1.getLastModified()).thenReturn(System.currentTimeMillis());
+    SmbFile smbFile1 = MockSmbFile.createMockSmbFile(System.currentTimeMillis());
    SmbFile smbFile2 = mock();
    when(smbFile2.getLastModified()).thenReturn(System.currentTimeMillis());
    SmbFile smbFile3 = mock();
    when(smbFile3.getLastModified()).thenReturn(Instant.now().minus(Duration.ofDays(1)).toEpochMilli());
    SmbFile[] files = new SmbFile[] { smbFile1, smbFile2, smbFile3 };
    assertThat(filter.filterFiles(files)).hasSize(2);
    assertThat(filter.accept(smbFile1)).isTrue();
    assertThat(filter.accept(smbFile2)).isTrue();
    assertThat(filter.accept(smbFile3)).isFalse();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testAge() {
    SmbRecentFileListFilter filter = new SmbRecentFileListFilter(Duration.ofHours(20));
    SmbFile smbFile1 = mock();
    when(smbFile1.getLastModified()).thenReturn(System.currentTimeMillis());
    SmbFile smbFile2 = mock();
    when(smbFile2.getLastModified()).thenReturn(System.currentTimeMillis());
    SmbFile smbFile3 = mock();
    when(smbFile3.getLastModified()).thenReturn(Instant.now().minus(Duration.ofDays(1)).toEpochMilli());
    SmbFile[] files = new SmbFile[] { smbFile1, smbFile2, smbFile3 };
    assertThat(filter.filterFiles(files)).hasSize(2);
    assertThat(filter.accept(smbFile1)).isTrue();
    assertThat(filter.accept(smbFile2)).isTrue();
    assertThat(filter.accept(smbFile3)).isFalse();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockSmbFile {
    public static SmbFile createMockSmbFile(long lastModified) {
        SmbFile smbFile = mock(SmbFile.class);
        when(smbFile.getLastModified()).thenReturn(lastModified);
        return smbFile;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_64_5
#### Test Case Name: `testAge`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-smb\src\test\java\org\springframework\integration\smb\filters\SmbRecentFileListFilterTests.java`)
#### Mock Object Variable Name: `smbFile2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SmbFile smbFile1 = mock();
    when(smbFile1.getLastModified()).thenReturn(System.currentTimeMillis());
-    SmbFile smbFile2 = mock();
-    when(smbFile2.getLastModified()).thenReturn(System.currentTimeMillis());
+    SmbFile smbFile2 = MockSmbFile.createMockSmbFile(System.currentTimeMillis());
    SmbFile smbFile3 = mock();
    when(smbFile3.getLastModified()).thenReturn(Instant.now().minus(Duration.ofDays(1)).toEpochMilli());
    SmbFile[] files = new SmbFile[] { smbFile1, smbFile2, smbFile3 };
    assertThat(filter.filterFiles(files)).hasSize(2);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testAge() {
    SmbRecentFileListFilter filter = new SmbRecentFileListFilter(Duration.ofHours(20));
    SmbFile smbFile1 = mock();
    when(smbFile1.getLastModified()).thenReturn(System.currentTimeMillis());
    SmbFile smbFile2 = mock();
    when(smbFile2.getLastModified()).thenReturn(System.currentTimeMillis());
    SmbFile smbFile3 = mock();
    when(smbFile3.getLastModified()).thenReturn(Instant.now().minus(Duration.ofDays(1)).toEpochMilli());
    SmbFile[] files = new SmbFile[] { smbFile1, smbFile2, smbFile3 };
    assertThat(filter.filterFiles(files)).hasSize(2);
    assertThat(filter.accept(smbFile1)).isTrue();
    assertThat(filter.accept(smbFile2)).isTrue();
    assertThat(filter.accept(smbFile3)).isFalse();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockSmbFile {
    public static SmbFile createMockSmbFile(long lastModified) {
        SmbFile smbFile = mock(SmbFile.class);
        when(smbFile.getLastModified()).thenReturn(lastModified);
        return smbFile;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_64_6
#### Test Case Name: `testAge`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-smb\src\test\java\org\springframework\integration\smb\filters\SmbRecentFileListFilterTests.java`)
#### Mock Object Variable Name: `smbFile3`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SmbFile smbFile1 = mock();
    when(smbFile1.getLastModified()).thenReturn(System.currentTimeMillis());
    SmbFile smbFile2 = mock();
    when(smbFile2.getLastModified()).thenReturn(System.currentTimeMillis());
-    SmbFile smbFile3 = mock();
-    when(smbFile3.getLastModified()).thenReturn(Instant.now().minus(Duration.ofDays(1)).toEpochMilli());
+    SmbFile smbFile3 = MockSmbFile.createMockSmbFile(Instant.now().minus(Duration.ofDays(1)).toEpochMilli());
    SmbFile[] files = new SmbFile[] { smbFile1, smbFile2, smbFile3 };
    assertThat(filter.filterFiles(files)).hasSize(2);
    assertThat(filter.accept(smbFile1)).isTrue();
    assertThat(filter.accept(smbFile2)).isTrue();
    assertThat(filter.accept(smbFile3)).isFalse();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testAge() {
    SmbRecentFileListFilter filter = new SmbRecentFileListFilter(Duration.ofHours(20));
    SmbFile smbFile1 = mock();
    when(smbFile1.getLastModified()).thenReturn(System.currentTimeMillis());
    SmbFile smbFile2 = mock();
    when(smbFile2.getLastModified()).thenReturn(System.currentTimeMillis());
    SmbFile smbFile3 = mock();
    when(smbFile3.getLastModified()).thenReturn(Instant.now().minus(Duration.ofDays(1)).toEpochMilli());
    SmbFile[] files = new SmbFile[] { smbFile1, smbFile2, smbFile3 };
    assertThat(filter.filterFiles(files)).hasSize(2);
    assertThat(filter.accept(smbFile1)).isTrue();
    assertThat(filter.accept(smbFile2)).isTrue();
    assertThat(filter.accept(smbFile3)).isFalse();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockSmbFile {
    public static SmbFile createMockSmbFile(long lastModified) {
        SmbFile smbFile = mock(SmbFile.class);
        when(smbFile.getLastModified()).thenReturn(lastModified);
        return smbFile;
    }
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_65
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.file.remote.session.Session<org.springframework.integration.file.remote.gateway.RemoteFileOutboundGatewayTests.TestLsEntry>`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static Session<RemoteFileOutboundGatewayTests.TestLsEntry> createMockSession(AtomicReference<String> written) {
    Session<RemoteFileOutboundGatewayTests.TestLsEntry> session = mock(Session.class);
    doAnswer(invocation -> {
        written.set(invocation.getArgument(1));
        return null;
    }).when(session).write(any(InputStream.class), anyString());
    return session;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_65_1
#### Test Case Name: `testMput`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
-    Session<TestLsEntry> session = mock(Session.class);
    RemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<>(sessionFactory);
    template.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    template.setBeanFactory(mock(BeanFactory.class));
    template.afterPropertiesSet();
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(template, "mput", "payload");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    final AtomicReference<String> written = new AtomicReference<>();
+    Session<TestLsEntry> session = createMockSession(written);
-    doAnswer(invocation -> {
-        written.set(invocation.getArgument(1));
-        return null;
-    }).when(session).write(any(InputStream.class), anyString());
    assertThat(new File(tempFolder, "baz.txt").createNewFile()).isTrue();
    assertThat(new File(tempFolder, "qux.txt").createNewFile()).isTrue();
    Message<File> requestMessage = MessageBuilder.withPayload(tempFolder).build();
    List<String> out = (List<String>) gw.handleRequestMessage(requestMessage);
    assertThat(out).hasSize(2);
    assertThat(out.get(0)).isNotEqualTo(out.get(1));
    assertThat(out.get(0)).isIn("foo/baz.txt", "foo/qux.txt");
    assertThat(out.get(1)).isIn("foo/baz.txt", "foo/qux.txt");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@SuppressWarnings("unchecked")
public void testMput() throws Exception {
    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
    Session<TestLsEntry> session = mock(Session.class);
    RemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<>(sessionFactory);
    template.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    template.setBeanFactory(mock(BeanFactory.class));
    template.afterPropertiesSet();
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(template, "mput", "payload");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    final AtomicReference<String> written = new AtomicReference<>();
    doAnswer(invocation -> {
        written.set(invocation.getArgument(1));
        return null;
    }).when(session).write(any(InputStream.class), anyString());
    assertThat(new File(tempFolder, "baz.txt").createNewFile()).isTrue();
    assertThat(new File(tempFolder, "qux.txt").createNewFile()).isTrue();
    Message<File> requestMessage = MessageBuilder.withPayload(tempFolder).build();
    List<String> out = (List<String>) gw.handleRequestMessage(requestMessage);
    assertThat(out).hasSize(2);
    assertThat(out.get(0)).isNotEqualTo(out.get(1));
    assertThat(out.get(0)).isIn("foo/baz.txt", "foo/qux.txt");
    assertThat(out.get(1)).isIn("foo/baz.txt", "foo/qux.txt");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session<RemoteFileOutboundGatewayTests.TestLsEntry> createMockSession(AtomicReference<String> written) {
    Session<RemoteFileOutboundGatewayTests.TestLsEntry> session = mock(Session.class);
    doAnswer(invocation -> {
        written.set(invocation.getArgument(1));
        return null;
    }).when(session).write(any(InputStream.class), anyString());
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_65_2
#### Test Case Name: `testMputRecursive`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
-    Session<TestLsEntry> session = mock(Session.class);
    RemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<>(sessionFactory);
    template.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    template.setBeanFactory(mock(BeanFactory.class));
    template.afterPropertiesSet();
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(template, "mput", null);
    gw.setOptions("-R");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    final AtomicReference<String> written = new AtomicReference<>();
+    Session<TestLsEntry> session = createMockSession(written);
    new File(tempFolder, "baz.txt").createNewFile();
    new File(tempFolder, "qux.txt").createNewFile();
    File dir1 = Files.createTempDirectory(tempFolder.toPath(), "junit").toFile();
    File file3 = File.createTempFile("foo", ".txt", dir1);
    Message<File> requestMessage = MessageBuilder.withPayload(tempFolder).build();
    List<String> out = (List<String>) gw.handleRequestMessage(requestMessage);
    assertThat(out).hasSize(3);
    assertThat(out.get(0)).isNotEqualTo(out.get(1));
    assertThat(out.get(0)).isIn("foo/baz.txt", "foo/qux.txt", "foo/" + dir1.getName() + "/" + file3.getName());
    assertThat(out.get(1)).isIn("foo/baz.txt", "foo/qux.txt", "foo/" + dir1.getName() + "/" + file3.getName());
    assertThat(out.get(2)).isIn("foo/baz.txt", "foo/qux.txt", "foo/" + dir1.getName() + "/" + file3.getName());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@SuppressWarnings("unchecked")
public void testMputRecursive() throws Exception {
    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
    Session<TestLsEntry> session = mock(Session.class);
    RemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<>(sessionFactory);
    template.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    template.setBeanFactory(mock(BeanFactory.class));
    template.afterPropertiesSet();
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(template, "mput", null);
    gw.setOptions("-R");
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    final AtomicReference<String> written = new AtomicReference<>();
    doAnswer(invocation -> {
        written.set(invocation.getArgument(1));
        return null;
    }).when(session).write(any(InputStream.class), anyString());
    new File(tempFolder, "baz.txt").createNewFile();
    new File(tempFolder, "qux.txt").createNewFile();
    File dir1 = Files.createTempDirectory(tempFolder.toPath(), "junit").toFile();
    File file3 = File.createTempFile("foo", ".txt", dir1);
    Message<File> requestMessage = MessageBuilder.withPayload(tempFolder).build();
    List<String> out = (List<String>) gw.handleRequestMessage(requestMessage);
    assertThat(out).hasSize(3);
    assertThat(out.get(0)).isNotEqualTo(out.get(1));
    assertThat(out.get(0)).isIn("foo/baz.txt", "foo/qux.txt", "foo/" + dir1.getName() + "/" + file3.getName());
    assertThat(out.get(1)).isIn("foo/baz.txt", "foo/qux.txt", "foo/" + dir1.getName() + "/" + file3.getName());
    assertThat(out.get(2)).isIn("foo/baz.txt", "foo/qux.txt", "foo/" + dir1.getName() + "/" + file3.getName());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session<RemoteFileOutboundGatewayTests.TestLsEntry> createMockSession(AtomicReference<String> written) {
    Session<RemoteFileOutboundGatewayTests.TestLsEntry> session = mock(Session.class);
    doAnswer(invocation -> {
        written.set(invocation.getArgument(1));
        return null;
    }).when(session).write(any(InputStream.class), anyString());
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_65_3
#### Test Case Name: `testMputCollection`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
-    Session<TestLsEntry> session = mock(Session.class);
+    final AtomicReference<String> written = new AtomicReference<>();
+    Session<TestLsEntry> session = createMockSession(written);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mput", "payload");
    gw.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
-    final AtomicReference<String> written = new AtomicReference<>();
-    doAnswer(invocation -> {
-        written.set(invocation.getArgument(1));
-        return null;
-    }).when(session).write(any(InputStream.class), anyString());
    List<File> files = new ArrayList<>();
    File file1 = new File(tempFolder, "fiz.txt");
    file1.createNewFile();
    files.add(file1);
    File file2 = new File(tempFolder, "buz.txt");
    file2.createNewFile();
    files.add(file2);
    Message<List<File>> requestMessage = MessageBuilder.withPayload(files).build();
    List<String> out = (List<String>) gw.handleRequestMessage(requestMessage);
    assertThat(out).isNotNull().hasSize(2);
    assertThat(out.get(0)).isNotEqualTo(out.get(1));
    assertThat(out.get(0)).isEqualTo("foo/fiz.txt");
    assertThat(out.get(1)).isEqualTo("foo/buz.txt");
    assertThat(written.get()).isEqualTo("foo/buz.txt.writing");
    verify(session).rename("foo/buz.txt.writing", "foo/buz.txt");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@SuppressWarnings("unchecked")
public void testMputCollection() throws Exception {
    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
    Session<TestLsEntry> session = mock(Session.class);
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(sessionFactory, "mput", "payload");
    gw.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    final AtomicReference<String> written = new AtomicReference<>();
    doAnswer(invocation -> {
        written.set(invocation.getArgument(1));
        return null;
    }).when(session).write(any(InputStream.class), anyString());
    List<File> files = new ArrayList<>();
    File file1 = new File(tempFolder, "fiz.txt");
    file1.createNewFile();
    files.add(file1);
    File file2 = new File(tempFolder, "buz.txt");
    file2.createNewFile();
    files.add(file2);
    Message<List<File>> requestMessage = MessageBuilder.withPayload(files).build();
    List<String> out = (List<String>) gw.handleRequestMessage(requestMessage);
    assertThat(out).isNotNull().hasSize(2);
    assertThat(out.get(0)).isNotEqualTo(out.get(1));
    assertThat(out.get(0)).isEqualTo("foo/fiz.txt");
    assertThat(out.get(1)).isEqualTo("foo/buz.txt");
    assertThat(written.get()).isEqualTo("foo/buz.txt.writing");
    verify(session).rename("foo/buz.txt.writing", "foo/buz.txt");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session<RemoteFileOutboundGatewayTests.TestLsEntry> createMockSession(AtomicReference<String> written) {
    Session<RemoteFileOutboundGatewayTests.TestLsEntry> session = mock(Session.class);
    doAnswer(invocation -> {
        written.set(invocation.getArgument(1));
        return null;
    }).when(session).write(any(InputStream.class), anyString());
    return session;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_66
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.file.remote.session.Session<org.springframework.integration.file.remote.gateway.RemoteFileOutboundGatewayTests.TestLsEntry>`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static Session<RemoteFileOutboundGatewayTests.TestLsEntry> createMockSessionExistsTrue() {
    @SuppressWarnings("unchecked")
    Session<RemoteFileOutboundGatewayTests.TestLsEntry> session = mock(Session.class);
    willReturn(Boolean.TRUE).given(session).exists(anyString());
    return session;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_66_1
#### Test Case Name: `testPutExists`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    @SuppressWarnings("unchecked")
    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
-    @SuppressWarnings("unchecked")
-    Session<TestLsEntry> session = mock(Session.class);
-    willReturn(Boolean.TRUE).given(session).exists(anyString());
+    Session<TestLsEntry> session = createMockSessionExistsTrue();
    RemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<>(sessionFactory);
    template.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    template.setBeanFactory(mock(BeanFactory.class));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testPutExists() throws Exception {
    @SuppressWarnings("unchecked")
    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
    @SuppressWarnings("unchecked")
    Session<TestLsEntry> session = mock(Session.class);
    willReturn(Boolean.TRUE).given(session).exists(anyString());
    RemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<>(sessionFactory);
    template.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    template.setBeanFactory(mock(BeanFactory.class));
    template.afterPropertiesSet();
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(template, "put", "payload");
    FileTransferringMessageHandler<TestLsEntry> handler = new FileTransferringMessageHandler<>(sessionFactory);
    handler.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    gw.afterPropertiesSet();
    when(sessionFactory.getSession()).thenReturn(session);
    Message<String> requestMessage = MessageBuilder.withPayload("hello").setHeader(FileHeaders.FILENAME, "bar.txt").build();
    // default (null) == REPLACE
    String path = (String) gw.handleRequestMessage(requestMessage);
    assertThat(path).isEqualTo("foo/bar.txt");
    ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
    verify(session).write(any(InputStream.class), captor.capture());
    assertThat(captor.getValue()).isEqualTo("foo/bar.txt.writing");
    verify(session).rename("foo/bar.txt.writing", "foo/bar.txt");
    gw.setFileExistsMode(FileExistsMode.FAIL);
    assertThatExceptionOfType(MessageDeliveryException.class).isThrownBy(() -> gw.handleRequestMessage(requestMessage)).withStackTraceContaining("The destination file already exists");
    gw.setFileExistsMode(FileExistsMode.REPLACE);
    path = (String) gw.handleRequestMessage(requestMessage);
    assertThat(path).isEqualTo("foo/bar.txt");
    captor = ArgumentCaptor.forClass(String.class);
    verify(session, times(2)).write(any(InputStream.class), captor.capture());
    assertThat(captor.getValue()).isEqualTo("foo/bar.txt.writing");
    verify(session, times(2)).rename("foo/bar.txt.writing", "foo/bar.txt");
    gw.setFileExistsMode(FileExistsMode.APPEND);
    path = (String) gw.handleRequestMessage(requestMessage);
    assertThat(path).isEqualTo("foo/bar.txt");
    captor = ArgumentCaptor.forClass(String.class);
    verify(session).append(any(InputStream.class), captor.capture());
    assertThat(captor.getValue()).isEqualTo("foo/bar.txt");
    gw.setFileExistsMode(FileExistsMode.IGNORE);
    path = (String) gw.handleRequestMessage(requestMessage);
    assertThat(path).isEqualTo("foo/bar.txt");
    // no more writes/appends
    verify(session, times(2)).write(any(InputStream.class), anyString());
    verify(session, times(1)).append(any(InputStream.class), anyString());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session<RemoteFileOutboundGatewayTests.TestLsEntry> createMockSessionExistsTrue() {
    @SuppressWarnings("unchecked")
    Session<RemoteFileOutboundGatewayTests.TestLsEntry> session = mock(Session.class);
    willReturn(Boolean.TRUE).given(session).exists(anyString());
    return session;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_66_2
#### Test Case Name: `testPutExistsExpression`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-file\src\test\java\org\springframework\integration\file\remote\gateway\RemoteFileOutboundGatewayTests.java`)
#### Mock Object Variable Name: `session`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
-    Session<TestLsEntry> session = mock(Session.class);
-    willReturn(Boolean.TRUE).given(session).exists(anyString());
+    Session<TestLsEntry> session = createMockSessionExistsTrue();
    RemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<>(sessionFactory);
    template.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    template.setBeanFactory(mock(BeanFactory.class));
    template.afterPropertiesSet();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@SuppressWarnings("unchecked")
public void testPutExistsExpression() throws Exception {
    SessionFactory<TestLsEntry> sessionFactory = mock(SessionFactory.class);
    Session<TestLsEntry> session = mock(Session.class);
    willReturn(Boolean.TRUE).given(session).exists(anyString());
    RemoteFileTemplate<TestLsEntry> template = new RemoteFileTemplate<>(sessionFactory);
    template.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    template.setBeanFactory(mock(BeanFactory.class));
    template.afterPropertiesSet();
    TestRemoteFileOutboundGateway gw = new TestRemoteFileOutboundGateway(template, "put", "payload");
    FileTransferringMessageHandler<TestLsEntry> handler = new FileTransferringMessageHandler<>(sessionFactory);
    handler.setRemoteDirectoryExpression(new LiteralExpression("foo/"));
    handler.setBeanFactory(mock(BeanFactory.class));
    handler.afterPropertiesSet();
    gw.afterPropertiesSet();
    gw.setFileExistsModeExpressionString("headers[\"file.exists.mode\"]");
    when(sessionFactory.getSession()).thenReturn(session);
    MessageBuilder<String> requestMessageBuilder = MessageBuilder.withPayload("hello").setHeader(FileHeaders.FILENAME, "bar.txt");
    Message<String> defaultMessage = requestMessageBuilder.build();
    String path = (String) gw.handleRequestMessage(defaultMessage);
    assertThat(path).isEqualTo("foo/bar.txt");
    ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
    verify(session).write(any(InputStream.class), captor.capture());
    assertThat(captor.getValue()).isEqualTo("foo/bar.txt.writing");
    verify(session).rename("foo/bar.txt.writing", "foo/bar.txt");
    Message<String> failMessage = requestMessageBuilder.setHeader("file.exists.mode", FileExistsMode.FAIL).build();
    assertThatExceptionOfType(MessageDeliveryException.class).isThrownBy(() -> gw.handleRequestMessage(failMessage)).withStackTraceContaining("The destination file already exists");
    Message<String> replaceMessage = requestMessageBuilder.setHeader("file.exists.mode", "replace").build();
    path = (String) gw.handleRequestMessage(replaceMessage);
    assertThat(path).isEqualTo("foo/bar.txt");
    captor = ArgumentCaptor.forClass(String.class);
    verify(session, times(2)).write(any(InputStream.class), captor.capture());
    assertThat(captor.getValue()).isEqualTo("foo/bar.txt.writing");
    verify(session, times(2)).rename("foo/bar.txt.writing", "foo/bar.txt");
    Message<String> appendMessage = requestMessageBuilder.setHeader("file.exists.mode", "APPEND").build();
    path = (String) gw.handleRequestMessage(appendMessage);
    assertThat(path).isEqualTo("foo/bar.txt");
    captor = ArgumentCaptor.forClass(String.class);
    verify(session).append(any(InputStream.class), captor.capture());
    assertThat(captor.getValue()).isEqualTo("foo/bar.txt");
    Message<String> ignoreMessage = requestMessageBuilder.setHeader("file.exists.mode", FileExistsMode.IGNORE).build();
    path = (String) gw.handleRequestMessage(ignoreMessage);
    assertThat(path).isEqualTo("foo/bar.txt");
    // no more writes/appends
    verify(session, times(2)).write(any(InputStream.class), anyString());
    verify(session, times(1)).append(any(InputStream.class), anyString());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Session<RemoteFileOutboundGatewayTests.TestLsEntry> createMockSessionExistsTrue() {
    @SuppressWarnings("unchecked")
    Session<RemoteFileOutboundGatewayTests.TestLsEntry> session = mock(Session.class);
    willReturn(Boolean.TRUE).given(session).exists(anyString());
    return session;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_67
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.ip.tcp.connection.AbstractClientConnectionFactory`
- **Test Case Count**: 7
- **MO Count**: 7

### Reusable Method
```java
private static AbstractClientConnectionFactory createMockAbstractClientConnectionFactory(boolean isRunningReturn) {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isRunning()).thenReturn(isRunningReturn);
    return factory;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_67_1
#### Test Case Name: `testReuse`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\CachingClientConnectionFactoryTests.java`)
#### Mock Object Variable Name: `factory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testReuse() throws Exception {
-    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
-    when(factory.isRunning()).thenReturn(true);
+    AbstractClientConnectionFactory factory = createMockAbstractClientConnectionFactory(true);
     TcpConnectionSupport mockConn1 = makeMockConnection("conn1");
     TcpConnectionSupport mockConn2 = makeMockConnection("conn2");
     when(factory.getConnection()).thenReturn(mockConn1).thenReturn(mockConn2);
     CachingClientConnectionFactory cachingFactory = new CachingClientConnectionFactory(factory, 2);
     cachingFactory.start();
     TcpConnection conn1 = cachingFactory.getConnection();
     // INT-3652
     TcpConnectionInterceptorSupport cachedConn1 = (TcpConnectionInterceptorSupport) conn1;
     Log logger = spy(TestUtils.getPropertyValue(cachedConn1, "logger", Log.class));
     when(logger.isDebugEnabled()).thenReturn(true);
     new DirectFieldAccessor(cachedConn1).setPropertyValue("logger", logger);
     cachedConn1.onMessage(new ErrorMessage(new RuntimeException()));
     ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
     verify(logger).debug(captor.capture());
     assertThat(captor.getValue()).startsWith("Message discarded; no listener:");
     // end INT-3652
     assertThat(conn1.toString()).isEqualTo("Cached:" + mockConn1.toString());
     conn1.close();
     conn1 = cachingFactory.getConnection();
     assertThat(conn1.toString()).isEqualTo("Cached:" + mockConn1.toString());
     TcpConnection conn2 = cachingFactory.getConnection();
     assertThat(conn2.toString()).isEqualTo("Cached:" + mockConn2.toString());
     conn1.close();
     conn2.close();
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testReuse() throws Exception {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isRunning()).thenReturn(true);
    TcpConnectionSupport mockConn1 = makeMockConnection("conn1");
    TcpConnectionSupport mockConn2 = makeMockConnection("conn2");
    when(factory.getConnection()).thenReturn(mockConn1).thenReturn(mockConn2);
    CachingClientConnectionFactory cachingFactory = new CachingClientConnectionFactory(factory, 2);
    cachingFactory.start();
    TcpConnection conn1 = cachingFactory.getConnection();
    // INT-3652
    TcpConnectionInterceptorSupport cachedConn1 = (TcpConnectionInterceptorSupport) conn1;
    Log logger = spy(TestUtils.getPropertyValue(cachedConn1, "logger", Log.class));
    when(logger.isDebugEnabled()).thenReturn(true);
    new DirectFieldAccessor(cachedConn1).setPropertyValue("logger", logger);
    cachedConn1.onMessage(new ErrorMessage(new RuntimeException()));
    ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);
    verify(logger).debug(captor.capture());
    assertThat(captor.getValue()).startsWith("Message discarded; no listener:");
    // end INT-3652
    assertThat(conn1.toString()).isEqualTo("Cached:" + mockConn1.toString());
    conn1.close();
    conn1 = cachingFactory.getConnection();
    assertThat(conn1.toString()).isEqualTo("Cached:" + mockConn1.toString());
    TcpConnection conn2 = cachingFactory.getConnection();
    assertThat(conn2.toString()).isEqualTo("Cached:" + mockConn2.toString());
    conn1.close();
    conn2.close();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AbstractClientConnectionFactory createMockAbstractClientConnectionFactory(boolean isRunningReturn) {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isRunning()).thenReturn(isRunningReturn);
    return factory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_67_2
#### Test Case Name: `testReuseNoLimit`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\CachingClientConnectionFactoryTests.java`)
#### Mock Object Variable Name: `factory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void testReuseNoLimit() throws Exception {
-    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
-    when(factory.isRunning()).thenReturn(true);
+    AbstractClientConnectionFactory factory = createMockAbstractClientConnectionFactory(true);
    TcpConnectionSupport mockConn1 = makeMockConnection("conn1");
    TcpConnectionSupport mockConn2 = makeMockConnection("conn2");
    when(factory.getConnection()).thenReturn(mockConn1).thenReturn(mockConn2);
    CachingClientConnectionFactory cachingFactory = new CachingClientConnectionFactory(factory, 0);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testReuseNoLimit() throws Exception {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isRunning()).thenReturn(true);
    TcpConnectionSupport mockConn1 = makeMockConnection("conn1");
    TcpConnectionSupport mockConn2 = makeMockConnection("conn2");
    when(factory.getConnection()).thenReturn(mockConn1).thenReturn(mockConn2);
    CachingClientConnectionFactory cachingFactory = new CachingClientConnectionFactory(factory, 0);
    cachingFactory.start();
    TcpConnection conn1 = cachingFactory.getConnection();
    assertThat(conn1.toString()).isEqualTo("Cached:" + mockConn1.toString());
    conn1.close();
    conn1 = cachingFactory.getConnection();
    assertThat(conn1.toString()).isEqualTo("Cached:" + mockConn1.toString());
    TcpConnection conn2 = cachingFactory.getConnection();
    assertThat(conn2.toString()).isEqualTo("Cached:" + mockConn2.toString());
    conn1.close();
    conn2.close();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AbstractClientConnectionFactory createMockAbstractClientConnectionFactory(boolean isRunningReturn) {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isRunning()).thenReturn(isRunningReturn);
    return factory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_67_3
#### Test Case Name: `testReuseClosed`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\CachingClientConnectionFactoryTests.java`)
#### Mock Object Variable Name: `factory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void testReuseClosed() throws Exception {
-    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
-    when(factory.isRunning()).thenReturn(true);
+    AbstractClientConnectionFactory factory = createMockAbstractClientConnectionFactory(true);
    TcpConnectionSupport mockConn1 = makeMockConnection("conn1");
    TcpConnectionSupport mockConn2 = makeMockConnection("conn2");
    doAnswer(invocation -> null).when(mockConn1).close();
    when(factory.getConnection()).thenReturn(mockConn1).thenReturn(mockConn2).thenReturn(mockConn1).thenReturn(mockConn2);
    CachingClientConnectionFactory cachingFactory = new CachingClientConnectionFactory(factory, 2);
    cachingFactory.start();
    TcpConnection conn1 = cachingFactory.getConnection();
    assertThat(conn1.toString()).isEqualTo("Cached:" + mockConn1.toString());
    conn1.close();
    conn1 = cachingFactory.getConnection();
    assertThat(conn1.toString()).isEqualTo("Cached:" + mockConn1.toString());
    TcpConnection conn2 = cachingFactory.getConnection();
    assertThat(conn2.toString()).isEqualTo("Cached:" + mockConn2.toString());
    conn1.close();
    conn2.close();
    when(mockConn1.isOpen()).thenReturn(false);
    TcpConnection conn2a = cachingFactory.getConnection();
    assertThat(conn2a.toString()).isEqualTo("Cached:" + mockConn2.toString());
    assertThat(TestUtils.getPropertyValue(conn2a, "theConnection")).isSameAs(TestUtils.getPropertyValue(conn2, "theConnection"));
    conn2a.close();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testReuseClosed() throws Exception {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isRunning()).thenReturn(true);
    TcpConnectionSupport mockConn1 = makeMockConnection("conn1");
    TcpConnectionSupport mockConn2 = makeMockConnection("conn2");
    doAnswer(invocation -> null).when(mockConn1).close();
    when(factory.getConnection()).thenReturn(mockConn1).thenReturn(mockConn2).thenReturn(mockConn1).thenReturn(mockConn2);
    CachingClientConnectionFactory cachingFactory = new CachingClientConnectionFactory(factory, 2);
    cachingFactory.start();
    TcpConnection conn1 = cachingFactory.getConnection();
    assertThat(conn1.toString()).isEqualTo("Cached:" + mockConn1.toString());
    conn1.close();
    conn1 = cachingFactory.getConnection();
    assertThat(conn1.toString()).isEqualTo("Cached:" + mockConn1.toString());
    TcpConnection conn2 = cachingFactory.getConnection();
    assertThat(conn2.toString()).isEqualTo("Cached:" + mockConn2.toString());
    conn1.close();
    conn2.close();
    when(mockConn1.isOpen()).thenReturn(false);
    TcpConnection conn2a = cachingFactory.getConnection();
    assertThat(conn2a.toString()).isEqualTo("Cached:" + mockConn2.toString());
    assertThat(TestUtils.getPropertyValue(conn2a, "theConnection")).isSameAs(TestUtils.getPropertyValue(conn2, "theConnection"));
    conn2a.close();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AbstractClientConnectionFactory createMockAbstractClientConnectionFactory(boolean isRunningReturn) {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isRunning()).thenReturn(isRunningReturn);
    return factory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_67_4
#### Test Case Name: `testLimit`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\CachingClientConnectionFactoryTests.java`)
#### Mock Object Variable Name: `factory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testLimit() throws Exception {
-    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
-    when(factory.isRunning()).thenReturn(true);
+    AbstractClientConnectionFactory factory = createMockAbstractClientConnectionFactory(true);
     TcpConnectionSupport mockConn1 = makeMockConnection("conn1");
     TcpConnectionSupport mockConn2 = makeMockConnection("conn2");
     when(factory.getConnection()).thenReturn(mockConn1).thenReturn(mockConn2);
     CachingClientConnectionFactory cachingFactory = new CachingClientConnectionFactory(factory, 2);
     cachingFactory.setConnectionWaitTimeout(10);
     cachingFactory.start();
     TcpConnection conn1 = cachingFactory.getConnection();
     assertThat(conn1.toString()).isEqualTo("Cached:" + mockConn1.toString());
     conn1.close();
     conn1 = cachingFactory.getConnection();
     assertThat(conn1.toString()).isEqualTo("Cached:" + mockConn1.toString());
     TcpConnection conn2 = cachingFactory.getConnection();
     assertThat(conn2.toString()).isEqualTo("Cached:" + mockConn2.toString());
     assertThatExceptionOfType(PoolItemNotAvailableException.class).isThrownBy(cachingFactory::getConnection);
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testLimit() throws Exception {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isRunning()).thenReturn(true);
    TcpConnectionSupport mockConn1 = makeMockConnection("conn1");
    TcpConnectionSupport mockConn2 = makeMockConnection("conn2");
    when(factory.getConnection()).thenReturn(mockConn1).thenReturn(mockConn2);
    CachingClientConnectionFactory cachingFactory = new CachingClientConnectionFactory(factory, 2);
    cachingFactory.setConnectionWaitTimeout(10);
    cachingFactory.start();
    TcpConnection conn1 = cachingFactory.getConnection();
    assertThat(conn1.toString()).isEqualTo("Cached:" + mockConn1.toString());
    conn1.close();
    conn1 = cachingFactory.getConnection();
    assertThat(conn1.toString()).isEqualTo("Cached:" + mockConn1.toString());
    TcpConnection conn2 = cachingFactory.getConnection();
    assertThat(conn2.toString()).isEqualTo("Cached:" + mockConn2.toString());
    assertThatExceptionOfType(PoolItemNotAvailableException.class).isThrownBy(cachingFactory::getConnection);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AbstractClientConnectionFactory createMockAbstractClientConnectionFactory(boolean isRunningReturn) {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isRunning()).thenReturn(isRunningReturn);
    return factory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_67_5
#### Test Case Name: `testStop`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\CachingClientConnectionFactoryTests.java`)
#### Mock Object Variable Name: `factory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testStop() throws Exception {
-    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
-    when(factory.isRunning()).thenReturn(true);
+    AbstractClientConnectionFactory factory = createMockAbstractClientConnectionFactory(true);
     TcpConnectionSupport mockConn1 = makeMockConnection("conn1");
     TcpConnectionSupport mockConn2 = makeMockConnection("conn2");
     int i = 3;
     when(factory.getConnection()).thenReturn(mockConn1).thenReturn(mockConn2).thenReturn(makeMockConnection("conn" + (i++)));
     CachingClientConnectionFactory cachingFactory = new CachingClientConnectionFactory(factory, 2);
     cachingFactory.start();
     TcpConnection conn1 = cachingFactory.getConnection();
     assertThat(conn1.toString()).isEqualTo("Cached:" + mockConn1.toString());
     conn1.close();
     conn1 = cachingFactory.getConnection();
     assertThat(conn1.toString()).isEqualTo("Cached:" + mockConn1.toString());
     TcpConnection conn2 = cachingFactory.getConnection();
     assertThat(conn2.toString()).isEqualTo("Cached:" + mockConn2.toString());
     cachingFactory.stop();
     Answer<Object> answer = invocation -> null;
     doAnswer(answer).when(mockConn1).close();
     doAnswer(answer).when(mockConn2).close();
     when(factory.isRunning()).thenReturn(false);
     conn1.close();
     conn2.close();
     verify(mockConn1).close();
     verify(mockConn2).close();
     when(mockConn1.isOpen()).thenReturn(false);
     when(mockConn2.isOpen()).thenReturn(false);
     when(factory.isRunning()).thenReturn(true);
     TcpConnection conn3 = cachingFactory.getConnection();
     assertThat(TestUtils.getPropertyValue(conn3, "theConnection")).isNotSameAs(TestUtils.getPropertyValue(conn1, "theConnection"));
     assertThat(TestUtils.getPropertyValue(conn3, "theConnection")).isNotSameAs(TestUtils.getPropertyValue(conn2, "theConnection"));
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testStop() throws Exception {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isRunning()).thenReturn(true);
    TcpConnectionSupport mockConn1 = makeMockConnection("conn1");
    TcpConnectionSupport mockConn2 = makeMockConnection("conn2");
    int i = 3;
    when(factory.getConnection()).thenReturn(mockConn1).thenReturn(mockConn2).thenReturn(makeMockConnection("conn" + (i++)));
    CachingClientConnectionFactory cachingFactory = new CachingClientConnectionFactory(factory, 2);
    cachingFactory.start();
    TcpConnection conn1 = cachingFactory.getConnection();
    assertThat(conn1.toString()).isEqualTo("Cached:" + mockConn1.toString());
    conn1.close();
    conn1 = cachingFactory.getConnection();
    assertThat(conn1.toString()).isEqualTo("Cached:" + mockConn1.toString());
    TcpConnection conn2 = cachingFactory.getConnection();
    assertThat(conn2.toString()).isEqualTo("Cached:" + mockConn2.toString());
    cachingFactory.stop();
    Answer<Object> answer = invocation -> null;
    doAnswer(answer).when(mockConn1).close();
    doAnswer(answer).when(mockConn2).close();
    when(factory.isRunning()).thenReturn(false);
    conn1.close();
    conn2.close();
    verify(mockConn1).close();
    verify(mockConn2).close();
    when(mockConn1.isOpen()).thenReturn(false);
    when(mockConn2.isOpen()).thenReturn(false);
    when(factory.isRunning()).thenReturn(true);
    TcpConnection conn3 = cachingFactory.getConnection();
    assertThat(TestUtils.getPropertyValue(conn3, "theConnection")).isNotSameAs(TestUtils.getPropertyValue(conn1, "theConnection"));
    assertThat(TestUtils.getPropertyValue(conn3, "theConnection")).isNotSameAs(TestUtils.getPropertyValue(conn2, "theConnection"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AbstractClientConnectionFactory createMockAbstractClientConnectionFactory(boolean isRunningReturn) {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isRunning()).thenReturn(isRunningReturn);
    return factory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_67_6
#### Test Case Name: `testEnlargePool`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\CachingClientConnectionFactoryTests.java`)
#### Mock Object Variable Name: `factory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testEnlargePool() throws Exception {
-    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
-    when(factory.isRunning()).thenReturn(true);
+    AbstractClientConnectionFactory factory = createMockAbstractClientConnectionFactory(true);
     TcpConnectionSupport mockConn1 = makeMockConnection("conn1");
     TcpConnectionSupport mockConn2 = makeMockConnection("conn2");
     TcpConnectionSupport mockConn3 = makeMockConnection("conn3");
     TcpConnectionSupport mockConn4 = makeMockConnection("conn4");
     when(factory.getConnection()).thenReturn(mockConn1, mockConn2, mockConn3, mockConn4);
     CachingClientConnectionFactory cachingFactory = new CachingClientConnectionFactory(factory, 2);
     cachingFactory.start();
     TcpConnection conn1 = cachingFactory.getConnection();
     TcpConnection conn2 = cachingFactory.getConnection();
     assertThat(conn2).isNotSameAs(conn1);
     Semaphore semaphore = TestUtils.getPropertyValue(TestUtils.getPropertyValue(cachingFactory, "pool"), "permits", Semaphore.class);
     assertThat(semaphore.availablePermits()).isEqualTo(0);
     cachingFactory.setPoolSize(4);
     TcpConnection conn3 = cachingFactory.getConnection();
     TcpConnection conn4 = cachingFactory.getConnection();
     assertThat(semaphore.availablePermits()).isEqualTo(0);
     conn1.close();
     conn1.close();
     conn2.close();
     conn3.close();
     conn4.close();
     assertThat(semaphore.availablePermits()).isEqualTo(4);
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testEnlargePool() throws Exception {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isRunning()).thenReturn(true);
    TcpConnectionSupport mockConn1 = makeMockConnection("conn1");
    TcpConnectionSupport mockConn2 = makeMockConnection("conn2");
    TcpConnectionSupport mockConn3 = makeMockConnection("conn3");
    TcpConnectionSupport mockConn4 = makeMockConnection("conn4");
    when(factory.getConnection()).thenReturn(mockConn1, mockConn2, mockConn3, mockConn4);
    CachingClientConnectionFactory cachingFactory = new CachingClientConnectionFactory(factory, 2);
    cachingFactory.start();
    TcpConnection conn1 = cachingFactory.getConnection();
    TcpConnection conn2 = cachingFactory.getConnection();
    assertThat(conn2).isNotSameAs(conn1);
    Semaphore semaphore = TestUtils.getPropertyValue(TestUtils.getPropertyValue(cachingFactory, "pool"), "permits", Semaphore.class);
    assertThat(semaphore.availablePermits()).isEqualTo(0);
    cachingFactory.setPoolSize(4);
    TcpConnection conn3 = cachingFactory.getConnection();
    TcpConnection conn4 = cachingFactory.getConnection();
    assertThat(semaphore.availablePermits()).isEqualTo(0);
    conn1.close();
    conn1.close();
    conn2.close();
    conn3.close();
    conn4.close();
    assertThat(semaphore.availablePermits()).isEqualTo(4);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AbstractClientConnectionFactory createMockAbstractClientConnectionFactory(boolean isRunningReturn) {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isRunning()).thenReturn(isRunningReturn);
    return factory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_67_7
#### Test Case Name: `testReducePool`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\CachingClientConnectionFactoryTests.java`)
#### Mock Object Variable Name: `factory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testReducePool() throws Exception {
-    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
-    when(factory.isRunning()).thenReturn(true);
+    AbstractClientConnectionFactory factory = createMockAbstractClientConnectionFactory(true);
     TcpConnectionSupport mockConn1 = makeMockConnection("conn1", true);
     TcpConnectionSupport mockConn2 = makeMockConnection("conn2", true);
     TcpConnectionSupport mockConn3 = makeMockConnection("conn3", true);
     TcpConnectionSupport mockConn4 = makeMockConnection("conn4", true);
     when(factory.getConnection()).thenReturn(mockConn1).thenReturn(mockConn2).thenReturn(mockConn3).thenReturn(mockConn4);
     CachingClientConnectionFactory cachingFactory = new CachingClientConnectionFactory(factory, 4);
     cachingFactory.start();
     TcpConnection conn1 = cachingFactory.getConnection();
     TcpConnection conn2 = cachingFactory.getConnection();
     TcpConnection conn3 = cachingFactory.getConnection();
     TcpConnection conn4 = cachingFactory.getConnection();
     Semaphore semaphore = TestUtils.getPropertyValue(TestUtils.getPropertyValue(cachingFactory, "pool"), "permits", Semaphore.class);
     assertThat(semaphore.availablePermits()).isEqualTo(0);
     conn1.close();
     assertThat(semaphore.availablePermits()).isEqualTo(1);
     cachingFactory.setPoolSize(2);
     assertThat(semaphore.availablePermits()).isEqualTo(0);
     assertThat(cachingFactory.getActiveCount()).isEqualTo(3);
     conn2.close();
     assertThat(semaphore.availablePermits()).isEqualTo(0);
     assertThat(cachingFactory.getActiveCount()).isEqualTo(2);
     conn3.close();
     assertThat(cachingFactory.getActiveCount()).isEqualTo(1);
     assertThat(cachingFactory.getIdleCount()).isEqualTo(1);
     conn4.close();
     assertThat(semaphore.availablePermits()).isEqualTo(2);
     assertThat(cachingFactory.getActiveCount()).isEqualTo(0);
     assertThat(cachingFactory.getIdleCount()).isEqualTo(2);
     verify(mockConn1).close();
     verify(mockConn2).close();
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testReducePool() throws Exception {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isRunning()).thenReturn(true);
    TcpConnectionSupport mockConn1 = makeMockConnection("conn1", true);
    TcpConnectionSupport mockConn2 = makeMockConnection("conn2", true);
    TcpConnectionSupport mockConn3 = makeMockConnection("conn3", true);
    TcpConnectionSupport mockConn4 = makeMockConnection("conn4", true);
    when(factory.getConnection()).thenReturn(mockConn1).thenReturn(mockConn2).thenReturn(mockConn3).thenReturn(mockConn4);
    CachingClientConnectionFactory cachingFactory = new CachingClientConnectionFactory(factory, 4);
    cachingFactory.start();
    TcpConnection conn1 = cachingFactory.getConnection();
    TcpConnection conn2 = cachingFactory.getConnection();
    TcpConnection conn3 = cachingFactory.getConnection();
    TcpConnection conn4 = cachingFactory.getConnection();
    Semaphore semaphore = TestUtils.getPropertyValue(TestUtils.getPropertyValue(cachingFactory, "pool"), "permits", Semaphore.class);
    assertThat(semaphore.availablePermits()).isEqualTo(0);
    conn1.close();
    assertThat(semaphore.availablePermits()).isEqualTo(1);
    cachingFactory.setPoolSize(2);
    assertThat(semaphore.availablePermits()).isEqualTo(0);
    assertThat(cachingFactory.getActiveCount()).isEqualTo(3);
    conn2.close();
    assertThat(semaphore.availablePermits()).isEqualTo(0);
    assertThat(cachingFactory.getActiveCount()).isEqualTo(2);
    conn3.close();
    assertThat(cachingFactory.getActiveCount()).isEqualTo(1);
    assertThat(cachingFactory.getIdleCount()).isEqualTo(1);
    conn4.close();
    assertThat(semaphore.availablePermits()).isEqualTo(2);
    assertThat(cachingFactory.getActiveCount()).isEqualTo(0);
    assertThat(cachingFactory.getIdleCount()).isEqualTo(2);
    verify(mockConn1).close();
    verify(mockConn2).close();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AbstractClientConnectionFactory createMockAbstractClientConnectionFactory(boolean isRunningReturn) {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isRunning()).thenReturn(isRunningReturn);
    return factory;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_68
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.ip.tcp.connection.AbstractClientConnectionFactory`
- **Test Case Count**: 3
- **MO Count**: 6

### Reusable Method
```java
private static AbstractClientConnectionFactory createMockAbstractClientConnectionFactory() {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isActive()).thenReturn(true);
    return factory;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_68_1
#### Test Case Name: `testRefreshShared`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\FailoverClientConnectionFactoryTests.java`)
#### Mock Object Variable Name: `factory1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
-    AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);
+    AbstractClientConnectionFactory factory1 = createMockAbstractClientConnectionFactory();
     AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);
     List<AbstractClientConnectionFactory> factories = new ArrayList<>();
     factories.add(factory1);
     factories.add(factory2);
     TcpConnectionSupport conn1 = makeMockConnection();
     doReturn("conn1").when(conn1).getConnectionId();
     TcpConnectionSupport conn2 = makeMockConnection();
     doReturn("conn2").when(conn2).getConnectionId();
     doThrow(new UncheckedIOException(new IOException("fail"))).when(factory1).getConnection();
     if (closeOnRefresh) {
         when(factory2.getConnection()).thenReturn(conn1, conn2);
     } else {
         when(factory2.getConnection()).thenReturn(conn1);
     }
-    when(factory1.isActive()).thenReturn(true);
     when(factory2.isActive()).thenReturn(true);
     FailoverClientConnectionFactory failoverFactory = new FailoverClientConnectionFactory(factories);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
private void testRefreshShared(boolean closeOnRefresh, long interval) throws Exception {
    AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);
    AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);
    List<AbstractClientConnectionFactory> factories = new ArrayList<>();
    factories.add(factory1);
    factories.add(factory2);
    TcpConnectionSupport conn1 = makeMockConnection();
    doReturn("conn1").when(conn1).getConnectionId();
    TcpConnectionSupport conn2 = makeMockConnection();
    doReturn("conn2").when(conn2).getConnectionId();
    doThrow(new UncheckedIOException(new IOException("fail"))).when(factory1).getConnection();
    if (closeOnRefresh) {
        when(factory2.getConnection()).thenReturn(conn1, conn2);
    } else {
        when(factory2.getConnection()).thenReturn(conn1);
    }
    when(factory1.isActive()).thenReturn(true);
    when(factory2.isActive()).thenReturn(true);
    FailoverClientConnectionFactory failoverFactory = new FailoverClientConnectionFactory(factories);
    failoverFactory.setCloseOnRefresh(closeOnRefresh);
    failoverFactory.start();
    TcpConnectionSupport connection = failoverFactory.getConnection();
    assertThat(TestUtils.getPropertyValue(failoverFactory, "theConnection")).isNotNull();
    failoverFactory.setRefreshSharedInterval(interval);
    InOrder inOrder = inOrder(factory1, factory2, conn1, conn2);
    inOrder.verify(factory1).getConnection();
    inOrder.verify(factory2).getConnection();
    inOrder.verify(conn1).registerListener(any());
    inOrder.verify(conn1).isOpen();
    assertThat(failoverFactory.getConnection()).isSameAs(connection);
    inOrder.verifyNoMoreInteractions();
    failoverFactory.setRefreshSharedInterval(-1);
    assertThat(failoverFactory.getConnection()).isNotSameAs(connection);
    inOrder.verify(factory1).getConnection();
    inOrder.verify(factory2).getConnection();
    if (closeOnRefresh) {
        inOrder.verify(conn2).registerListener(any());
        inOrder.verify(conn2).isOpen();
        inOrder.verify(conn1).close();
    } else {
        inOrder.verify(conn1).registerListener(any());
        inOrder.verify(conn1).isOpen();
        inOrder.verify(conn1, never()).close();
    }
    inOrder.verifyNoMoreInteractions();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AbstractClientConnectionFactory createMockAbstractClientConnectionFactory() {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isActive()).thenReturn(true);
    return factory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_68_2
#### Test Case Name: `testRefreshShared`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\FailoverClientConnectionFactoryTests.java`)
#### Mock Object Variable Name: `factory2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
     AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);
-    AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);
+    AbstractClientConnectionFactory factory2 = createMockAbstractClientConnectionFactory();
     List<AbstractClientConnectionFactory> factories = new ArrayList<>();
     factories.add(factory1);
     factories.add(factory2);
     TcpConnectionSupport conn1 = makeMockConnection();
     doReturn("conn1").when(conn1).getConnectionId();
     TcpConnectionSupport conn2 = makeMockConnection();
     doReturn("conn2").when(conn2).getConnectionId();
     doThrow(new UncheckedIOException(new IOException("fail"))).when(factory1).getConnection();
     if (closeOnRefresh) {
         when(factory2.getConnection()).thenReturn(conn1, conn2);
     } else {
         when(factory2.getConnection()).thenReturn(conn1);
     }
-    when(factory1.isActive()).thenReturn(true);
-    when(factory2.isActive()).thenReturn(true);
+    when(factory1.isActive()).thenReturn(true);
     FailoverClientConnectionFactory failoverFactory = new FailoverClientConnectionFactory(factories);
     failoverFactory.setCloseOnRefresh(closeOnRefresh);
     failoverFactory.start();
     TcpConnectionSupport connection = failoverFactory.getConnection();
     assertThat(TestUtils.getPropertyValue(failoverFactory, "theConnection")).isNotNull();
     failoverFactory.setRefreshSharedInterval(interval);
     InOrder inOrder = inOrder(factory1, factory2, conn1, conn2);
     inOrder.verify(factory1).getConnection();
     inOrder.verify(factory2).getConnection();
     inOrder.verify(conn1).registerListener(any());
     inOrder.verify(conn1).isOpen();
     assertThat(failoverFactory.getConnection()).isSameAs(connection);
     inOrder.verifyNoMoreInteractions();
     failoverFactory.setRefreshSharedInterval(-1);
     assertThat(failoverFactory.getConnection()).isNotSameAs(connection);
     inOrder.verify(factory1).getConnection();
     inOrder.verify(factory2).getConnection();
     if (closeOnRefresh) {
         inOrder.verify(conn2).registerListener(any());
         inOrder.verify(conn2).isOpen();
         inOrder.verify(conn1).close();
     } else {
         inOrder.verify(conn1).registerListener(any());
         inOrder.verify(conn1).isOpen();
         inOrder.verify(conn1, never()).close();
     }
     inOrder.verifyNoMoreInteractions();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
private void testRefreshShared(boolean closeOnRefresh, long interval) throws Exception {
    AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);
    AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);
    List<AbstractClientConnectionFactory> factories = new ArrayList<>();
    factories.add(factory1);
    factories.add(factory2);
    TcpConnectionSupport conn1 = makeMockConnection();
    doReturn("conn1").when(conn1).getConnectionId();
    TcpConnectionSupport conn2 = makeMockConnection();
    doReturn("conn2").when(conn2).getConnectionId();
    doThrow(new UncheckedIOException(new IOException("fail"))).when(factory1).getConnection();
    if (closeOnRefresh) {
        when(factory2.getConnection()).thenReturn(conn1, conn2);
    } else {
        when(factory2.getConnection()).thenReturn(conn1);
    }
    when(factory1.isActive()).thenReturn(true);
    when(factory2.isActive()).thenReturn(true);
    FailoverClientConnectionFactory failoverFactory = new FailoverClientConnectionFactory(factories);
    failoverFactory.setCloseOnRefresh(closeOnRefresh);
    failoverFactory.start();
    TcpConnectionSupport connection = failoverFactory.getConnection();
    assertThat(TestUtils.getPropertyValue(failoverFactory, "theConnection")).isNotNull();
    failoverFactory.setRefreshSharedInterval(interval);
    InOrder inOrder = inOrder(factory1, factory2, conn1, conn2);
    inOrder.verify(factory1).getConnection();
    inOrder.verify(factory2).getConnection();
    inOrder.verify(conn1).registerListener(any());
    inOrder.verify(conn1).isOpen();
    assertThat(failoverFactory.getConnection()).isSameAs(connection);
    inOrder.verifyNoMoreInteractions();
    failoverFactory.setRefreshSharedInterval(-1);
    assertThat(failoverFactory.getConnection()).isNotSameAs(connection);
    inOrder.verify(factory1).getConnection();
    inOrder.verify(factory2).getConnection();
    if (closeOnRefresh) {
        inOrder.verify(conn2).registerListener(any());
        inOrder.verify(conn2).isOpen();
        inOrder.verify(conn1).close();
    } else {
        inOrder.verify(conn1).registerListener(any());
        inOrder.verify(conn1).isOpen();
        inOrder.verify(conn1, never()).close();
    }
    inOrder.verifyNoMoreInteractions();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AbstractClientConnectionFactory createMockAbstractClientConnectionFactory() {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isActive()).thenReturn(true);
    return factory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_68_3
#### Test Case Name: `testFailoverConnectNone`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\FailoverClientConnectionFactoryTests.java`)
#### Mock Object Variable Name: `factory1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testFailoverConnectNone() throws Exception {
-    AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);
+    AbstractClientConnectionFactory factory1 = createMockAbstractClientConnectionFactory();
     AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);
     List<AbstractClientConnectionFactory> factories = new ArrayList<>();
     factories.add(factory1);
     factories.add(factory2);
-    when(factory1.getConnection()).thenThrow(new UncheckedIOException(new IOException("fail")));
     when(factory2.getConnection()).thenThrow(new UncheckedIOException(new IOException("fail")));
-    when(factory1.isActive()).thenReturn(true);
     when(factory2.isActive()).thenReturn(true);
     FailoverClientConnectionFactory failoverFactory = new FailoverClientConnectionFactory(factories);
     failoverFactory.start();
     GenericMessage<String> message = new GenericMessage<>("foo");
     assertThatExceptionOfType(UncheckedIOException.class).isThrownBy(() -> failoverFactory.getConnection().send(message));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testFailoverConnectNone() throws Exception {
    AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);
    AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);
    List<AbstractClientConnectionFactory> factories = new ArrayList<>();
    factories.add(factory1);
    factories.add(factory2);
    when(factory1.getConnection()).thenThrow(new UncheckedIOException(new IOException("fail")));
    when(factory2.getConnection()).thenThrow(new UncheckedIOException(new IOException("fail")));
    when(factory1.isActive()).thenReturn(true);
    when(factory2.isActive()).thenReturn(true);
    FailoverClientConnectionFactory failoverFactory = new FailoverClientConnectionFactory(factories);
    failoverFactory.start();
    GenericMessage<String> message = new GenericMessage<>("foo");
    assertThatExceptionOfType(UncheckedIOException.class).isThrownBy(() -> failoverFactory.getConnection().send(message));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AbstractClientConnectionFactory createMockAbstractClientConnectionFactory() {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isActive()).thenReturn(true);
    return factory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_68_4
#### Test Case Name: `testFailoverConnectNone`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\FailoverClientConnectionFactoryTests.java`)
#### Mock Object Variable Name: `factory2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
     AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);
-    AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);
+    AbstractClientConnectionFactory factory2 = createMockAbstractClientConnectionFactory();
     List<AbstractClientConnectionFactory> factories = new ArrayList<>();
     factories.add(factory1);
     factories.add(factory2);
     when(factory1.getConnection()).thenThrow(new UncheckedIOException(new IOException("fail")));
-    when(factory2.getConnection()).thenThrow(new UncheckedIOException(new IOException("fail")));
     when(factory1.isActive()).thenReturn(true);
-    when(factory2.isActive()).thenReturn(true);
     FailoverClientConnectionFactory failoverFactory = new FailoverClientConnectionFactory(factories);
     failoverFactory.start();
     GenericMessage<String> message = new GenericMessage<>("foo");
     assertThatExceptionOfType(UncheckedIOException.class).isThrownBy(() -> failoverFactory.getConnection().send(message));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testFailoverConnectNone() throws Exception {
    AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);
    AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);
    List<AbstractClientConnectionFactory> factories = new ArrayList<>();
    factories.add(factory1);
    factories.add(factory2);
    when(factory1.getConnection()).thenThrow(new UncheckedIOException(new IOException("fail")));
    when(factory2.getConnection()).thenThrow(new UncheckedIOException(new IOException("fail")));
    when(factory1.isActive()).thenReturn(true);
    when(factory2.isActive()).thenReturn(true);
    FailoverClientConnectionFactory failoverFactory = new FailoverClientConnectionFactory(factories);
    failoverFactory.start();
    GenericMessage<String> message = new GenericMessage<>("foo");
    assertThatExceptionOfType(UncheckedIOException.class).isThrownBy(() -> failoverFactory.getConnection().send(message));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AbstractClientConnectionFactory createMockAbstractClientConnectionFactory() {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isActive()).thenReturn(true);
    return factory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_68_5
#### Test Case Name: `testFailoverConnectToFirstAfterTriedAll`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\FailoverClientConnectionFactoryTests.java`)
#### Mock Object Variable Name: `factory1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 public void testFailoverConnectToFirstAfterTriedAll() throws Exception {
-    AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);
+    AbstractClientConnectionFactory factory1 = createMockAbstractClientConnectionFactory();
     AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);
     List<AbstractClientConnectionFactory> factories = new ArrayList<>();
     factories.add(factory1);
     factories.add(factory2);
     TcpConnectionSupport conn1 = makeMockConnection();
     doAnswer(invocation -> null).when(conn1).send(Mockito.any(Message.class));
-    when(factory1.getConnection()).thenThrow(new UncheckedIOException(new IOException("fail"))).thenReturn(conn1);
+    when(factory1.getConnection()).thenThrow(new UncheckedIOException(new IOException("fail"))).thenReturn(conn1);
     when(factory2.getConnection()).thenThrow(new UncheckedIOException(new IOException("fail")));
-    when(factory1.isActive()).thenReturn(true);
     when(factory2.isActive()).thenReturn(true);
     FailoverClientConnectionFactory failoverFactory = new FailoverClientConnectionFactory(factories);
     failoverFactory.start();
     GenericMessage<String> message = new GenericMessage<String>("foo");
     failoverFactory.getConnection().send(message);
     Mockito.verify(conn1).send(message);
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testFailoverConnectToFirstAfterTriedAll() throws Exception {
    AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);
    AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);
    List<AbstractClientConnectionFactory> factories = new ArrayList<>();
    factories.add(factory1);
    factories.add(factory2);
    TcpConnectionSupport conn1 = makeMockConnection();
    doAnswer(invocation -> null).when(conn1).send(Mockito.any(Message.class));
    when(factory1.getConnection()).thenThrow(new UncheckedIOException(new IOException("fail"))).thenReturn(conn1);
    when(factory2.getConnection()).thenThrow(new UncheckedIOException(new IOException("fail")));
    when(factory1.isActive()).thenReturn(true);
    when(factory2.isActive()).thenReturn(true);
    FailoverClientConnectionFactory failoverFactory = new FailoverClientConnectionFactory(factories);
    failoverFactory.start();
    GenericMessage<String> message = new GenericMessage<String>("foo");
    failoverFactory.getConnection().send(message);
    Mockito.verify(conn1).send(message);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AbstractClientConnectionFactory createMockAbstractClientConnectionFactory() {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isActive()).thenReturn(true);
    return factory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_68_6
#### Test Case Name: `testFailoverConnectToFirstAfterTriedAll`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\FailoverClientConnectionFactoryTests.java`)
#### Mock Object Variable Name: `factory2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);
-    AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);
+    AbstractClientConnectionFactory factory2 = createMockAbstractClientConnectionFactory();
    List<AbstractClientConnectionFactory> factories = new ArrayList<>();
    factories.add(factory1);
    factories.add(factory2);
    TcpConnectionSupport conn1 = makeMockConnection();
    doAnswer(invocation -> null).when(conn1).send(Mockito.any(Message.class));
    when(factory1.getConnection()).thenThrow(new UncheckedIOException(new IOException("fail"))).thenReturn(conn1);
-    when(factory2.getConnection()).thenThrow(new UncheckedIOException(new IOException("fail")));
+    when(factory2.getConnection()).thenThrow(new UncheckedIOException(new IOException("fail")));
    when(factory1.isActive()).thenReturn(true);
-    when(factory2.isActive()).thenReturn(true);
    FailoverClientConnectionFactory failoverFactory = new FailoverClientConnectionFactory(factories);
    failoverFactory.start();
    GenericMessage<String> message = new GenericMessage<String>("foo");
    failoverFactory.getConnection().send(message);
    Mockito.verify(conn1).send(message);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testFailoverConnectToFirstAfterTriedAll() throws Exception {
    AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);
    AbstractClientConnectionFactory factory2 = mock(AbstractClientConnectionFactory.class);
    List<AbstractClientConnectionFactory> factories = new ArrayList<>();
    factories.add(factory1);
    factories.add(factory2);
    TcpConnectionSupport conn1 = makeMockConnection();
    doAnswer(invocation -> null).when(conn1).send(Mockito.any(Message.class));
    when(factory1.getConnection()).thenThrow(new UncheckedIOException(new IOException("fail"))).thenReturn(conn1);
    when(factory2.getConnection()).thenThrow(new UncheckedIOException(new IOException("fail")));
    when(factory1.isActive()).thenReturn(true);
    when(factory2.isActive()).thenReturn(true);
    FailoverClientConnectionFactory failoverFactory = new FailoverClientConnectionFactory(factories);
    failoverFactory.start();
    GenericMessage<String> message = new GenericMessage<String>("foo");
    failoverFactory.getConnection().send(message);
    Mockito.verify(conn1).send(message);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AbstractClientConnectionFactory createMockAbstractClientConnectionFactory() {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.isActive()).thenReturn(true);
    return factory;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_69
- **Scope**: method level
- **Mocked Class**: `org.springframework.integration.ip.tcp.connection.AbstractClientConnectionFactory`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static AbstractClientConnectionFactory createMockAbstractClientConnectionFactory(TcpConnectionSupport connectionSupport) {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.getConnection()).thenReturn(connectionSupport);
    return factory;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_69_1
#### Test Case Name: `testCachingFailover`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\TcpOutboundGatewayTests.java`)
#### Mock Object Variable Name: `factory1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    assertThat(latch.await(10000, TimeUnit.MILLISECONDS)).isTrue();
    // Failover
-    AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);
     TcpConnectionSupport mockConn1 = makeMockConnection();
-    when(factory1.getConnection()).thenReturn(mockConn1);
+    AbstractClientConnectionFactory factory1 = createMockAbstractClientConnectionFactory(mockConn1);
     doThrow(new UncheckedIOException(new IOException("fail"))).when(mockConn1).send(any(Message.class));
     AbstractClientConnectionFactory factory2 = new TcpNetClientConnectionFactory("localhost", serverSocket.get().getLocalPort());
     factory2.setSerializer(new DefaultSerializer());
     factory2.setDeserializer(new DefaultDeserializer());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testCachingFailover() throws Exception {
    final AtomicReference<ServerSocket> serverSocket = new AtomicReference<>();
    final CountDownLatch latch = new CountDownLatch(1);
    final AtomicBoolean done = new AtomicBoolean();
    final CountDownLatch serverLatch = new CountDownLatch(1);
    this.executor.execute(() -> {
        try {
            ServerSocket server = ServerSocketFactory.getDefault().createServerSocket(0);
            serverSocket.set(server);
            latch.countDown();
            while (!done.get()) {
                Socket socket = server.accept();
                while (!socket.isClosed()) {
                    try {
                        ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                        String request = (String) ois.readObject();
                        logger.debug("Read " + request);
                        ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
                        oos.writeObject("bar");
                        logger.debug("Replied to " + request);
                        serverLatch.countDown();
                    } catch (IOException e1) {
                        logger.debug("error on write " + e1.getClass().getSimpleName());
                        socket.close();
                    }
                }
            }
        } catch (Exception e2) {
            if (!done.get()) {
                e2.printStackTrace();
            }
        }
    });
    assertThat(latch.await(10000, TimeUnit.MILLISECONDS)).isTrue();
    // Failover
    AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);
    TcpConnectionSupport mockConn1 = makeMockConnection();
    when(factory1.getConnection()).thenReturn(mockConn1);
    doThrow(new UncheckedIOException(new IOException("fail"))).when(mockConn1).send(any(Message.class));
    AbstractClientConnectionFactory factory2 = new TcpNetClientConnectionFactory("localhost", serverSocket.get().getLocalPort());
    factory2.setSerializer(new DefaultSerializer());
    factory2.setDeserializer(new DefaultDeserializer());
    factory2.setSoTimeout(10000);
    factory2.setSingleUse(false);
    List<AbstractClientConnectionFactory> factories = new ArrayList<>();
    factories.add(factory1);
    factories.add(factory2);
    FailoverClientConnectionFactory failoverFactory = new FailoverClientConnectionFactory(factories);
    failoverFactory.start();
    // Cache
    CachingClientConnectionFactory cachingFactory = new CachingClientConnectionFactory(failoverFactory, 2);
    cachingFactory.start();
    TcpOutboundGateway gateway = new TcpOutboundGateway();
    gateway.setConnectionFactory(cachingFactory);
    PollableChannel outputChannel = new QueueChannel();
    gateway.setOutputChannel(outputChannel);
    gateway.setBeanFactory(mock(BeanFactory.class));
    gateway.afterPropertiesSet();
    gateway.start();
    GenericMessage<String> message = new GenericMessage<>("foo");
    gateway.handleMessage(message);
    Message<?> reply = outputChannel.receive(0);
    assertThat(reply).isNotNull();
    assertThat(reply.getPayload()).isEqualTo("bar");
    done.set(true);
    gateway.stop();
    verify(mockConn1).send(any(Message.class));
    factory2.stop();
    serverSocket.get().close();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AbstractClientConnectionFactory createMockAbstractClientConnectionFactory(TcpConnectionSupport connectionSupport) {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.getConnection()).thenReturn(connectionSupport);
    return factory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_69_2
#### Test Case Name: `testFailoverCached`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\TcpOutboundGatewayTests.java`)
#### Mock Object Variable Name: `factory1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    assertThat(latch.await(10000, TimeUnit.MILLISECONDS)).isTrue();
    // Cache
-    AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);
    TcpConnectionSupport mockConn1 = makeMockConnection();
-    when(factory1.getConnection()).thenReturn(mockConn1);
-    when(factory1.isSingleUse()).thenReturn(true);
+    AbstractClientConnectionFactory factory1 = createMockAbstractClientConnectionFactory(mockConn1);
+    when(factory1.isSingleUse()).thenReturn(true);
    doThrow(new UncheckedIOException(new IOException("fail"))).when(mockConn1).send(any(Message.class));
    CachingClientConnectionFactory cachingFactory1 = new CachingClientConnectionFactory(factory1, 1);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testFailoverCached() throws Exception {
    final AtomicReference<ServerSocket> serverSocket = new AtomicReference<>();
    final CountDownLatch latch = new CountDownLatch(1);
    final AtomicBoolean done = new AtomicBoolean();
    final CountDownLatch serverLatch = new CountDownLatch(1);
    this.executor.execute(() -> {
        try {
            ServerSocket server = ServerSocketFactory.getDefault().createServerSocket(0);
            serverSocket.set(server);
            latch.countDown();
            while (!done.get()) {
                Socket socket = server.accept();
                while (!socket.isClosed()) {
                    try {
                        ObjectInputStream ois = new ObjectInputStream(socket.getInputStream());
                        String request = (String) ois.readObject();
                        logger.debug("Read " + request);
                        ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream());
                        oos.writeObject("bar");
                        logger.debug("Replied to " + request);
                        serverLatch.countDown();
                    } catch (IOException e1) {
                        logger.debug("error on write " + e1.getClass().getSimpleName());
                        socket.close();
                    }
                }
            }
        } catch (Exception e2) {
            if (!done.get()) {
                e2.printStackTrace();
            }
        }
    });
    assertThat(latch.await(10000, TimeUnit.MILLISECONDS)).isTrue();
    // Cache
    AbstractClientConnectionFactory factory1 = mock(AbstractClientConnectionFactory.class);
    TcpConnectionSupport mockConn1 = makeMockConnection();
    when(factory1.getConnection()).thenReturn(mockConn1);
    when(factory1.isSingleUse()).thenReturn(true);
    doThrow(new UncheckedIOException(new IOException("fail"))).when(mockConn1).send(any(Message.class));
    CachingClientConnectionFactory cachingFactory1 = new CachingClientConnectionFactory(factory1, 1);
    AbstractClientConnectionFactory factory2 = new TcpNetClientConnectionFactory("localhost", serverSocket.get().getLocalPort());
    factory2.setSerializer(new DefaultSerializer());
    factory2.setDeserializer(new DefaultDeserializer());
    factory2.setSoTimeout(10000);
    factory2.setSingleUse(true);
    CachingClientConnectionFactory cachingFactory2 = new CachingClientConnectionFactory(factory2, 1);
    // Failover
    List<AbstractClientConnectionFactory> factories = new ArrayList<>();
    factories.add(cachingFactory1);
    factories.add(cachingFactory2);
    FailoverClientConnectionFactory failoverFactory = new FailoverClientConnectionFactory(factories);
    failoverFactory.setSingleUse(true);
    failoverFactory.afterPropertiesSet();
    failoverFactory.start();
    TcpOutboundGateway gateway = new TcpOutboundGateway();
    gateway.setConnectionFactory(failoverFactory);
    PollableChannel outputChannel = new QueueChannel();
    gateway.setOutputChannel(outputChannel);
    gateway.setBeanFactory(mock(BeanFactory.class));
    gateway.afterPropertiesSet();
    gateway.start();
    GenericMessage<String> message = new GenericMessage<>("foo");
    gateway.handleMessage(message);
    Message<?> reply = outputChannel.receive(0);
    assertThat(reply).isNotNull();
    assertThat(reply.getPayload()).isEqualTo("bar");
    done.set(true);
    gateway.stop();
    verify(mockConn1).send(any(Message.class));
    factory2.stop();
    serverSocket.get().close();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AbstractClientConnectionFactory createMockAbstractClientConnectionFactory(TcpConnectionSupport connectionSupport) {
    AbstractClientConnectionFactory factory = mock(AbstractClientConnectionFactory.class);
    when(factory.getConnection()).thenReturn(connectionSupport);
    return factory;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_70
- **Scope**: method level
- **Mocked Class**: `org.springframework.beans.factory.BeanFactory`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static BeanFactory createMockBeanFactory() {
    BeanFactory mock = mock(BeanFactory.class);
    given(mock.getBean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class))
        .willReturn(mock(ApplicationEventMulticaster.class));
    return mock;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_70_1
#### Test Case Name: `testNoFilter`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpConnectionEventListenerTests.java`)
#### Mock Object Variable Name: `mock`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    eventProducer.setEventTypes(TcpConnectionEvent.class);
-    BeanFactory mock = mock(BeanFactory.class);
-    given(mock.getBean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class)).willReturn(mock(ApplicationEventMulticaster.class));
+    BeanFactory mock = createMockBeanFactory();
    eventProducer.setBeanFactory(mock);
    eventProducer.afterPropertiesSet();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testNoFilter() {
    ApplicationEventListeningMessageProducer eventProducer = new ApplicationEventListeningMessageProducer();
    QueueChannel outputChannel = new QueueChannel();
    eventProducer.setOutputChannel(outputChannel);
    eventProducer.setEventTypes(TcpConnectionEvent.class);
    BeanFactory mock = mock(BeanFactory.class);
    given(mock.getBean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class)).willReturn(mock(ApplicationEventMulticaster.class));
    eventProducer.setBeanFactory(mock);
    eventProducer.afterPropertiesSet();
    eventProducer.start();
    TcpConnectionSupport connection = Mockito.mock(TcpConnectionSupport.class);
    assertThat(eventProducer.supportsEventType(ResolvableType.forClass(TcpConnectionOpenEvent.class))).isTrue();
    TcpConnectionEvent event1 = new TcpConnectionOpenEvent(connection, "foo");
    eventProducer.onApplicationEvent(event1);
    assertThat(eventProducer.supportsEventType(ResolvableType.forClass(FooEvent.class))).isTrue();
    FooEvent event2 = new FooEvent(connection, "foo");
    eventProducer.onApplicationEvent(event2);
    assertThat(eventProducer.supportsEventType(ResolvableType.forClass(BarEvent.class))).isTrue();
    BarEvent event3 = new BarEvent(connection, "foo");
    eventProducer.onApplicationEvent(event3);
    Message<?> message = outputChannel.receive(0);
    assertThat(message).isNotNull();
    assertThat(message.getPayload()).isSameAs(event1);
    message = outputChannel.receive(0);
    assertThat(message).isNotNull();
    assertThat(message.getPayload()).isSameAs(event2);
    message = outputChannel.receive(0);
    assertThat(message).isNotNull();
    assertThat(message.getPayload()).isSameAs(event3);
    message = outputChannel.receive(0);
    assertThat(message).isNull();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static BeanFactory createMockBeanFactory() {
    BeanFactory mock = mock(BeanFactory.class);
    given(mock.getBean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class))
        .willReturn(mock(ApplicationEventMulticaster.class));
    return mock;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_70_2
#### Test Case Name: `testFilter`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpConnectionEventListenerTests.java`)
#### Mock Object Variable Name: `mock`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
     eventProducer.setEventTypes(FooEvent.class, BarEvent.class);
-    BeanFactory mock = mock(BeanFactory.class);
-    given(mock.getBean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class)).willReturn(mock(ApplicationEventMulticaster.class));
+    BeanFactory mock = createMockBeanFactory();
     eventProducer.setBeanFactory(mock);
     eventProducer.afterPropertiesSet();
     eventProducer.start();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testFilter() {
    ApplicationEventListeningMessageProducer eventProducer = new ApplicationEventListeningMessageProducer();
    QueueChannel outputChannel = new QueueChannel();
    eventProducer.setOutputChannel(outputChannel);
    eventProducer.setEventTypes(FooEvent.class, BarEvent.class);
    BeanFactory mock = mock(BeanFactory.class);
    given(mock.getBean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class)).willReturn(mock(ApplicationEventMulticaster.class));
    eventProducer.setBeanFactory(mock);
    eventProducer.afterPropertiesSet();
    eventProducer.start();
    TcpConnectionSupport connection = Mockito.mock(TcpConnectionSupport.class);
    assertThat(eventProducer.supportsEventType(ResolvableType.forClass(TcpConnectionOpenEvent.class))).isFalse();
    assertThat(eventProducer.supportsEventType(ResolvableType.forClass(FooEvent.class))).isTrue();
    FooEvent event2 = new FooEvent(connection, "foo");
    eventProducer.onApplicationEvent(event2);
    assertThat(eventProducer.supportsEventType(ResolvableType.forClass(BarEvent.class))).isTrue();
    BarEvent event3 = new BarEvent(connection, "foo");
    eventProducer.onApplicationEvent(event3);
    Message<?> message = outputChannel.receive(0);
    assertThat(message).isNotNull();
    assertThat(message.getPayload()).isSameAs(event2);
    message = outputChannel.receive(0);
    assertThat(message).isNotNull();
    assertThat(message.getPayload()).isSameAs(event3);
    message = outputChannel.receive(0);
    assertThat(message).isNull();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static BeanFactory createMockBeanFactory() {
    BeanFactory mock = mock(BeanFactory.class);
    given(mock.getBean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class))
        .willReturn(mock(ApplicationEventMulticaster.class));
    return mock;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_71
- **Scope**: method level
- **Mocked Class**: `org.springframework.beans.factory.BeanFactory`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static BeanFactory createMockBeanFactory(org.mockito.stubbing.Answer<?> getBeanAnswer) {
    BeanFactory beanFactory = mock(BeanFactory.class);
    doAnswer(getBeanAnswer).when(beanFactory).getBean(anyString(), eq(MessageChannel.class));
    return beanFactory;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_71_1
#### Test Case Name: `testBFCRWithRegistry`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\channel\registry\HeaderChannelRegistryTests.java`)
#### Mock Object Variable Name: `beanFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    BeanFactoryChannelResolver resolver = new BeanFactoryChannelResolver();
-    BeanFactory beanFactory = mock(BeanFactory.class);
-    when(beanFactory.getBean(IntegrationContextUtils.INTEGRATION_HEADER_CHANNEL_REGISTRY_BEAN_NAME, HeaderChannelRegistry.class)).thenReturn(mock(HeaderChannelRegistry.class));
-    doAnswer(invocation -> {
-        throw new NoSuchBeanDefinitionException("bar");
-    }).when(beanFactory).getBean("foo", MessageChannel.class);
+    BeanFactory beanFactory = createMockBeanFactory(invocation -> {
+        throw new NoSuchBeanDefinitionException("bar");
+    });
+    when(beanFactory.getBean(IntegrationContextUtils.INTEGRATION_HEADER_CHANNEL_REGISTRY_BEAN_NAME, HeaderChannelRegistry.class)).thenReturn(mock(HeaderChannelRegistry.class));
    resolver.setBeanFactory(beanFactory);
    assertThatExceptionOfType(DestinationResolutionException.class).isThrownBy(() -> resolver.resolveDestination("foo")).withMessageContaining("failed to look up MessageChannel with name 'foo' in the BeanFactory.");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testBFCRWithRegistry() {
    BeanFactoryChannelResolver resolver = new BeanFactoryChannelResolver();
    BeanFactory beanFactory = mock(BeanFactory.class);
    when(beanFactory.getBean(IntegrationContextUtils.INTEGRATION_HEADER_CHANNEL_REGISTRY_BEAN_NAME, HeaderChannelRegistry.class)).thenReturn(mock(HeaderChannelRegistry.class));
    doAnswer(invocation -> {
        throw new NoSuchBeanDefinitionException("bar");
    }).when(beanFactory).getBean("foo", MessageChannel.class);
    resolver.setBeanFactory(beanFactory);
    assertThatExceptionOfType(DestinationResolutionException.class).isThrownBy(() -> resolver.resolveDestination("foo")).withMessageContaining("failed to look up MessageChannel with name 'foo' in the BeanFactory.");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static BeanFactory createMockBeanFactory(org.mockito.stubbing.Answer<?> getBeanAnswer) {
    BeanFactory beanFactory = mock(BeanFactory.class);
    doAnswer(getBeanAnswer).when(beanFactory).getBean(anyString(), eq(MessageChannel.class));
    return beanFactory;
}
```
</details>

---
#### Test Case ID #spring-integration_Test_71_2
#### Test Case Name: `testBFCRNoRegistry`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-core\src\test\java\org\springframework\integration\channel\registry\HeaderChannelRegistryTests.java`)
#### Mock Object Variable Name: `beanFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    BeanFactoryChannelResolver resolver = new BeanFactoryChannelResolver();
-    BeanFactory beanFactory = mock(BeanFactory.class);
-    doAnswer(invocation -> {
-        throw new NoSuchBeanDefinitionException("bar");
-    }).when(beanFactory).getBean("foo", MessageChannel.class);
+    BeanFactory beanFactory = createMockBeanFactory(invocation -> {
+        throw new NoSuchBeanDefinitionException("bar");
+    });
    resolver.setBeanFactory(beanFactory);
    assertThatExceptionOfType(DestinationResolutionException.class).isThrownBy(() -> resolver.resolveDestination("foo")).withMessageContaining("failed to look up MessageChannel with name 'foo' in the BeanFactory" + " (and there is no HeaderChannelRegistry present).");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testBFCRNoRegistry() {
    BeanFactoryChannelResolver resolver = new BeanFactoryChannelResolver();
    BeanFactory beanFactory = mock(BeanFactory.class);
    doAnswer(invocation -> {
        throw new NoSuchBeanDefinitionException("bar");
    }).when(beanFactory).getBean("foo", MessageChannel.class);
    resolver.setBeanFactory(beanFactory);
    assertThatExceptionOfType(DestinationResolutionException.class).isThrownBy(() -> resolver.resolveDestination("foo")).withMessageContaining("failed to look up MessageChannel with name 'foo' in the BeanFactory" + " (and there is no HeaderChannelRegistry present).");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static BeanFactory createMockBeanFactory(org.mockito.stubbing.Answer<?> getBeanAnswer) {
    BeanFactory beanFactory = mock(BeanFactory.class);
    doAnswer(getBeanAnswer).when(beanFactory).getBean(anyString(), eq(MessageChannel.class));
    return beanFactory;
}
```
</details>

---
## Mock Clone Instance #spring-integration_MCI_72
- **Scope**: class level
- **Mocked Class**: `java.io.InputStream`
- **Test Case Count**: 4
- **MO Count**: 4

### Reusable Method
```java
public class MockInputStream {
    /**
     * Creates a mock InputStream with configurable return value for read().
     *
     * @param readReturn the int value to be returned by read()
     * @return the configured mock InputStream
     */
    public static InputStream createMockInputStream(int readReturn) {
        InputStream inputStream = mock(InputStream.class);
        when(inputStream.read()).thenReturn(readReturn);
        return inputStream;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #spring-integration_Test_72_1
#### Test Case Name: `testNetClient`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\SocketSupportTests.java`)
#### Mock Object Variable Name: `is`
<summary>Suggested Diff</summary>

```diff
@@
     Socket socket = mock(Socket.class);
-    InputStream is = mock(InputStream.class);
-    when(is.read()).thenReturn(-1);
+    InputStream is = MockInputStream.createMockInputStream(-1);
     when(socket.getInputStream()).thenReturn(is);
     InetAddress inetAddress = InetAddress.getLocalHost();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testNetClient() throws Exception {
    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
    SocketFactory factory = Mockito.mock(SocketFactory.class);
    when(factorySupport.getSocketFactory()).thenReturn(factory);
    Socket socket = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
    when(socket.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
    when(socket.getInetAddress()).thenReturn(inetAddress);
    when(factory.createSocket()).thenReturn(socket);
    TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);
    TcpNetClientConnectionFactory connectionFactory = new TcpNetClientConnectionFactory("x", 0);
    connectionFactory.setTcpSocketFactorySupport(factorySupport);
    connectionFactory.setTcpSocketSupport(socketSupport);
    connectionFactory.start();
    connectionFactory.getConnection();
    verify(socketSupport).postProcessSocket(socket);
    connectionFactory.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInputStream {
    /**
     * Creates a mock InputStream with configurable return value for read().
     *
     * @param readReturn the int value to be returned by read()
     * @return the configured mock InputStream
     */
    public static InputStream createMockInputStream(int readReturn) {
        InputStream inputStream = mock(InputStream.class);
        when(inputStream.read()).thenReturn(readReturn);
        return inputStream;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_72_2
#### Test Case Name: `testNetClientSocketTimeout`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\SocketSupportTests.java`)
#### Mock Object Variable Name: `is`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Socket socket = mock(Socket.class);
-    InputStream is = mock(InputStream.class);
-    when(is.read()).thenReturn(-1);
+    InputStream is = MockInputStream.createMockInputStream(-1);
    when(socket.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testNetClientSocketTimeout() throws Exception {
    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
    SocketFactory factory = Mockito.mock(SocketFactory.class);
    when(factorySupport.getSocketFactory()).thenReturn(factory);
    Socket socket = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
    when(socket.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
    when(socket.getInetAddress()).thenReturn(inetAddress);
    when(factory.createSocket()).thenReturn(socket);
    doThrow(new SocketTimeoutException()).when(socket).connect(any(), eq(1000));
    TcpSocketSupport socketSupport = Mockito.mock(TcpSocketSupport.class);
    TcpNetClientConnectionFactory connectionFactory = new TcpNetClientConnectionFactory("x", 0);
    connectionFactory.setConnectTimeout(1);
    connectionFactory.setTcpSocketFactorySupport(factorySupport);
    connectionFactory.setTcpSocketSupport(socketSupport);
    connectionFactory.start();
    assertThatThrownBy(connectionFactory::getConnection).isInstanceOf(UncheckedIOException.class).hasCauseInstanceOf(SocketTimeoutException.class);
    connectionFactory.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInputStream {
    /**
     * Creates a mock InputStream with configurable return value for read().
     *
     * @param readReturn the int value to be returned by read()
     * @return the configured mock InputStream
     */
    public static InputStream createMockInputStream(int readReturn) {
        InputStream inputStream = mock(InputStream.class);
        when(inputStream.read()).thenReturn(readReturn);
        return inputStream;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_72_3
#### Test Case Name: `testNetServer`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\SocketSupportTests.java`)
#### Mock Object Variable Name: `is`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Socket socket = mock(Socket.class);
    Socket socket1 = mock(Socket.class);
-    InputStream is = mock(InputStream.class);
-    when(is.read()).thenReturn(-1);
+    InputStream is = MockInputStream.createMockInputStream(-1);
    when(socket.getInputStream()).thenReturn(is);
    when(socket1.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testNetServer() throws Exception {
    TcpSocketFactorySupport factorySupport = mock(TcpSocketFactorySupport.class);
    ServerSocketFactory factory = mock(ServerSocketFactory.class);
    when(factorySupport.getServerSocketFactory()).thenReturn(factory);
    Socket socket = mock(Socket.class);
    Socket socket1 = mock(Socket.class);
    InputStream is = mock(InputStream.class);
    when(is.read()).thenReturn(-1);
    when(socket.getInputStream()).thenReturn(is);
    when(socket1.getInputStream()).thenReturn(is);
    InetAddress inetAddress = InetAddress.getLocalHost();
    when(socket.getInetAddress()).thenReturn(inetAddress);
    when(socket1.getInetAddress()).thenReturn(inetAddress);
    ServerSocket serverSocket = mock(ServerSocket.class);
    AtomicBoolean closed = new AtomicBoolean();
    doAnswer(invoc -> {
        closed.set(true);
        return null;
    }).when(serverSocket).close();
    when(serverSocket.getInetAddress()).thenReturn(inetAddress);
    when(factory.createServerSocket(0, 5)).thenReturn(serverSocket);
    final CountDownLatch latch1 = new CountDownLatch(1);
    final CountDownLatch latch2 = new CountDownLatch(1);
    when(serverSocket.accept()).thenReturn(socket).then(invocation -> {
        if (closed.get()) {
            throw new SocketException();
        }
        latch1.countDown();
        latch2.await(10, TimeUnit.SECONDS);
        Thread.sleep(50);
        return socket1;
    });
    TcpSocketSupport socketSupport = mock(TcpSocketSupport.class);
    TcpNetServerConnectionFactory connectionFactory = new TcpNetServerConnectionFactory(0);
    connectionFactory.setTcpSocketFactorySupport(factorySupport);
    connectionFactory.setTcpSocketSupport(socketSupport);
    connectionFactory.registerListener(mock(TcpListener.class));
    connectionFactory.start();
    assertThat(latch1.await(10, TimeUnit.SECONDS)).isTrue();
    verify(socketSupport).postProcessServerSocket(serverSocket);
    verify(socketSupport).postProcessSocket(socket);
    latch2.countDown();
    connectionFactory.stop();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInputStream {
    /**
     * Creates a mock InputStream with configurable return value for read().
     *
     * @param readReturn the int value to be returned by read()
     * @return the configured mock InputStream
     */
    public static InputStream createMockInputStream(int readReturn) {
        InputStream inputStream = mock(InputStream.class);
        when(inputStream.read()).thenReturn(readReturn);
        return inputStream;
    }
}
```
</details>

---
#### Test Case ID #spring-integration_Test_72_4
#### Test Case Name: `testErrorLog`(File: `C:\Java_projects\Spring\spring-integration\spring-integration-ip\src\test\java\org\springframework\integration\ip\tcp\connection\TcpNetConnectionTests.java`)
#### Mock Object Variable Name: `stream`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Socket socket = mock(Socket.class);
-    InputStream stream = mock(InputStream.class);
-    when(socket.getInputStream()).thenReturn(stream);
-    when(stream.read()).thenReturn((int) 'x');
+    InputStream stream = MockInputStream.createMockInputStream((int) 'x');
+    when(socket.getInputStream()).thenReturn(stream);
    TcpNetConnection connection = new TcpNetConnection(socket, true, false, e -> {
    }, null);
    connection.setDeserializer(new ByteArrayStxEtxSerializer());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testErrorLog() throws Exception {
    Socket socket = mock(Socket.class);
    InputStream stream = mock(InputStream.class);
    when(socket.getInputStream()).thenReturn(stream);
    when(stream.read()).thenReturn((int) 'x');
    TcpNetConnection connection = new TcpNetConnection(socket, true, false, e -> {
    }, null);
    connection.setDeserializer(new ByteArrayStxEtxSerializer());
    final AtomicReference<Object> log = new AtomicReference<Object>();
    Log logger = mock(Log.class);
    given(logger.isErrorEnabled()).willReturn(true);
    doAnswer(invocation -> {
        log.set(invocation.getArguments()[0]);
        return null;
    }).when(logger).error(Mockito.anyString());
    DirectFieldAccessor accessor = new DirectFieldAccessor(connection);
    accessor.setPropertyValue("logger", logger);
    connection.registerListener(mock(TcpListener.class));
    connection.setMapper(new TcpMessageMapper());
    connection.run();
    assertThat(log.get()).isNotNull();
    assertThat(log.get()).isEqualTo("Read exception " + connection.getConnectionId() + " MessageMappingException:Expected STX to begin message");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInputStream {
    /**
     * Creates a mock InputStream with configurable return value for read().
     *
     * @param readReturn the int value to be returned by read()
     * @return the configured mock InputStream
     */
    public static InputStream createMockInputStream(int readReturn) {
        InputStream inputStream = mock(InputStream.class);
        when(inputStream.read()).thenReturn(readReturn);
        return inputStream;
    }
}
```
</details>

---