# A guide to Refactoring mock clones in dubbo

## Mock Clone Instance #dubbo_MCI_1
- **Scope**: method level
- **Mocked Class**: `java.sql.Connection`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static Connection createMockConnectionWithTypeInfoNext(boolean nextReturn) throws SQLException {
    Connection connection = mock(Connection.class, Answers.RETURNS_DEEP_STUBS);
    given(connection.getMetaData().getTypeInfo().next()).willReturn(nextReturn);
    return connection;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_1_1
#### Test Case Name: `testWithDatasourceHasNextResult`(File: `C:\Java_projects\Apache\dubbo\dubbo-config\dubbo-config-spring\src\test\java\org\apache\dubbo\config\spring\status\DataSourceStatusCheckerTest.java`)
#### Mock Object Variable Name: `connection`
<summary>Suggested Diff</summary>

```diff
@@
     Map<String, DataSource> map = new HashMap<String, DataSource>();
     DataSource dataSource = mock(DataSource.class);
-    Connection connection = mock(Connection.class, Answers.RETURNS_DEEP_STUBS);
+    Connection connection = createMockConnectionWithTypeInfoNext(true);
     given(dataSource.getConnection()).willReturn(connection);
-    given(connection.getMetaData().getTypeInfo().next()).willReturn(true);
     map.put("mockDatabase", dataSource);
     given(applicationContext.getBeansOfType(eq(DataSource.class), anyBoolean(), anyBoolean())).willReturn(map);
     Status status = dataSourceStatusChecker.check();
     assertThat(status.getLevel(), is(Status.Level.OK));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testWithDatasourceHasNextResult() throws SQLException {
    Map<String, DataSource> map = new HashMap<String, DataSource>();
    DataSource dataSource = mock(DataSource.class);
    Connection connection = mock(Connection.class, Answers.RETURNS_DEEP_STUBS);
    given(dataSource.getConnection()).willReturn(connection);
    given(connection.getMetaData().getTypeInfo().next()).willReturn(true);
    map.put("mockDatabase", dataSource);
    given(applicationContext.getBeansOfType(eq(DataSource.class), anyBoolean(), anyBoolean())).willReturn(map);
    Status status = dataSourceStatusChecker.check();
    assertThat(status.getLevel(), is(Status.Level.OK));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Connection createMockConnectionWithTypeInfoNext(boolean nextReturn) throws SQLException {
    Connection connection = mock(Connection.class, Answers.RETURNS_DEEP_STUBS);
    given(connection.getMetaData().getTypeInfo().next()).willReturn(nextReturn);
    return connection;
}
```
</details>

---
#### Test Case ID #dubbo_Test_1_2
#### Test Case Name: `testWithDatasourceNotHasNextResult`(File: `C:\Java_projects\Apache\dubbo\dubbo-config\dubbo-config-spring\src\test\java\org\apache\dubbo\config\spring\status\DataSourceStatusCheckerTest.java`)
#### Mock Object Variable Name: `connection`
<summary>Suggested Diff</summary>

```diff
@@
     Map<String, DataSource> map = new HashMap<String, DataSource>();
     DataSource dataSource = mock(DataSource.class);
-    Connection connection = mock(Connection.class, Answers.RETURNS_DEEP_STUBS);
+    Connection connection = createMockConnectionWithTypeInfoNext(false);
     given(dataSource.getConnection()).willReturn(connection);
-    given(connection.getMetaData().getTypeInfo().next()).willReturn(false);
     map.put("mockDatabase", dataSource);
     given(applicationContext.getBeansOfType(eq(DataSource.class), anyBoolean(), anyBoolean())).willReturn(map);
     Status status = dataSourceStatusChecker.check();
     assertThat(status.getLevel(), is(Status.Level.ERROR));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testWithDatasourceNotHasNextResult() throws SQLException {
    Map<String, DataSource> map = new HashMap<String, DataSource>();
    DataSource dataSource = mock(DataSource.class);
    Connection connection = mock(Connection.class, Answers.RETURNS_DEEP_STUBS);
    given(dataSource.getConnection()).willReturn(connection);
    given(connection.getMetaData().getTypeInfo().next()).willReturn(false);
    map.put("mockDatabase", dataSource);
    given(applicationContext.getBeansOfType(eq(DataSource.class), anyBoolean(), anyBoolean())).willReturn(map);
    Status status = dataSourceStatusChecker.check();
    assertThat(status.getLevel(), is(Status.Level.ERROR));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Connection createMockConnectionWithTypeInfoNext(boolean nextReturn) throws SQLException {
    Connection connection = mock(Connection.class, Answers.RETURNS_DEEP_STUBS);
    given(connection.getMetaData().getTypeInfo().next()).willReturn(nextReturn);
    return connection;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_2
- **Scope**: class level
- **Mocked Class**: `Directory<DemoService>`
- **Test Case Count**: 4
- **MO Count**: 4

### Reusable Method
```java
public class MockDirectory {
    public static Directory<DemoService> createMockDirectory(org.apache.dubbo.common.URL url) {
        Directory<DemoService> dic = mock(Directory.class);
        given(dic.getUrl()).willReturn(url);
        given(dic.getConsumerUrl()).willReturn(url);
        given(dic.getInterface()).willReturn(DemoService.class);
        return dic;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_2_1
#### Test Case Name: `testNormal`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\BroadCastClusterInvokerTest.java`)
#### Mock Object Variable Name: `dic`
<summary>Suggested Diff</summary>

```diff
@@
 @BeforeEach
 public void setUp() throws Exception {
-    dic = mock(Directory.class);
+    dic = MockDirectory.createMockDirectory(url);
     invoker1 = new MockInvoker();
     invoker2 = new MockInvoker();
     invoker3 = new MockInvoker();
     invoker4 = new MockInvoker();
     url = URL.valueOf("test://127.0.0.1:8080/test");
-    given(dic.getUrl()).willReturn(url);
-    given(dic.getConsumerUrl()).willReturn(url);
-    given(dic.getInterface()).willReturn(DemoService.class);
     invocation = new RpcInvocation();
     invocation.setMethodName("test");
     clusterInvoker = new BroadcastClusterInvoker(dic);
 }

```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testNormal() {
    given(dic.list(invocation)).willReturn(Arrays.asList(invoker1, invoker2, invoker3, invoker4));
    // Every invoker will be called
    clusterInvoker.invoke(invocation);
    assertTrue(invoker1.isInvoked());
    assertTrue(invoker2.isInvoked());
    assertTrue(invoker3.isInvoked());
    assertTrue(invoker4.isInvoked());
}
@BeforeEach
public void setUp() throws Exception {
    dic = mock(Directory.class);
    invoker1 = new MockInvoker();
    invoker2 = new MockInvoker();
    invoker3 = new MockInvoker();
    invoker4 = new MockInvoker();
    url = URL.valueOf("test://127.0.0.1:8080/test");
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.getInterface()).willReturn(DemoService.class);
    invocation = new RpcInvocation();
    invocation.setMethodName("test");
    clusterInvoker = new BroadcastClusterInvoker(dic);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockDirectory {
    public static Directory<DemoService> createMockDirectory(org.apache.dubbo.common.URL url) {
        Directory<DemoService> dic = mock(Directory.class);
        given(dic.getUrl()).willReturn(url);
        given(dic.getConsumerUrl()).willReturn(url);
        given(dic.getInterface()).willReturn(DemoService.class);
        return dic;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_2_2
#### Test Case Name: `testEx`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\BroadCastClusterInvokerTest.java`)
#### Mock Object Variable Name: `dic`
<summary>Suggested Diff</summary>

```diff
--- Original
+++ Refactored
@@
 @BeforeEach
 public void setUp() throws Exception {
-    dic = mock(Directory.class);
     invoker1 = new MockInvoker();
     invoker2 = new MockInvoker();
     invoker3 = new MockInvoker();
     invoker4 = new MockInvoker();
     url = URL.valueOf("test://127.0.0.1:8080/test");
-    given(dic.getUrl()).willReturn(url);
-    given(dic.getConsumerUrl()).willReturn(url);
-    given(dic.getInterface()).willReturn(DemoService.class);
+    dic = MockDirectory.createMockDirectory(url);
     invocation = new RpcInvocation();
     invocation.setMethodName("test");
     clusterInvoker = new BroadcastClusterInvoker(dic);
 }

 @Test
 void testEx() {
     given(dic.list(invocation)).willReturn(Arrays.asList(invoker1, invoker2, invoker3, invoker4));
     invoker1.invokeThrowEx();
     assertThrows(RpcException.class, () -> {
         clusterInvoker.invoke(invocation);
     });
     // The default failure percentage is 100, even if a certain invoker#invoke throws an exception, other invokers will still be called
     assertTrue(invoker1.isInvoked());
     assertTrue(invoker2.isInvoked());
     assertTrue(invoker3.isInvoked());
     assertTrue(invoker4.isInvoked());
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setUp() throws Exception {
    dic = mock(Directory.class);
    invoker1 = new MockInvoker();
    invoker2 = new MockInvoker();
    invoker3 = new MockInvoker();
    invoker4 = new MockInvoker();
    url = URL.valueOf("test://127.0.0.1:8080/test");
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.getInterface()).willReturn(DemoService.class);
    invocation = new RpcInvocation();
    invocation.setMethodName("test");
    clusterInvoker = new BroadcastClusterInvoker(dic);
}
@Test
void testEx() {
    given(dic.list(invocation)).willReturn(Arrays.asList(invoker1, invoker2, invoker3, invoker4));
    invoker1.invokeThrowEx();
    assertThrows(RpcException.class, () -> {
        clusterInvoker.invoke(invocation);
    });
    // The default failure percentage is 100, even if a certain invoker#invoke throws an exception, other invokers will still be called
    assertTrue(invoker1.isInvoked());
    assertTrue(invoker2.isInvoked());
    assertTrue(invoker3.isInvoked());
    assertTrue(invoker4.isInvoked());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockDirectory {
    public static Directory<DemoService> createMockDirectory(org.apache.dubbo.common.URL url) {
        Directory<DemoService> dic = mock(Directory.class);
        given(dic.getUrl()).willReturn(url);
        given(dic.getConsumerUrl()).willReturn(url);
        given(dic.getInterface()).willReturn(DemoService.class);
        return dic;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_2_3
#### Test Case Name: `testFailPercent`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\BroadCastClusterInvokerTest.java`)
#### Mock Object Variable Name: `dic`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    @BeforeEach
    public void setUp() throws Exception {
-        dic = mock(Directory.class);
+        dic = MockDirectory.createMockDirectory(url);
        invoker1 = new MockInvoker();
        invoker2 = new MockInvoker();
        invoker3 = new MockInvoker();
        invoker4 = new MockInvoker();
        url = URL.valueOf("test://127.0.0.1:8080/test");
-        given(dic.getUrl()).willReturn(url);
-        given(dic.getConsumerUrl()).willReturn(url);
-        given(dic.getInterface()).willReturn(DemoService.class);
        invocation = new RpcInvocation();
        invocation.setMethodName("test");
        clusterInvoker = new BroadcastClusterInvoker(dic);
    }

    @Test
    void testFailPercent() {
        given(dic.list(invocation)).willReturn(Arrays.asList(invoker1, invoker2, invoker3, invoker4));
        // We set the failure percentage to 75, which means that when the number of call failures is 4*(75/100) = 3,
        // an exception will be thrown directly and subsequent invokers will not be called.
        url = url.addParameter("broadcast.fail.percent", 75);
-        given(dic.getConsumerUrl()).willReturn(url);
+        given(dic.getConsumerUrl()).willReturn(url);
        invoker1.invokeThrowEx();
        invoker2.invokeThrowEx();
        invoker3.invokeThrowEx();
        invoker4.invokeThrowEx();
        assertThrows(RpcException.class, () -> {
            clusterInvoker.invoke(invocation);
        });
        assertTrue(invoker1.isInvoked());
        assertTrue(invoker2.isInvoked());
        assertTrue(invoker3.isInvoked());
        assertFalse(invoker4.isInvoked());
    }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testFailPercent() {
    given(dic.list(invocation)).willReturn(Arrays.asList(invoker1, invoker2, invoker3, invoker4));
    // We set the failure percentage to 75, which means that when the number of call failures is 4*(75/100) = 3,
    // an exception will be thrown directly and subsequent invokers will not be called.
    url = url.addParameter("broadcast.fail.percent", 75);
    given(dic.getConsumerUrl()).willReturn(url);
    invoker1.invokeThrowEx();
    invoker2.invokeThrowEx();
    invoker3.invokeThrowEx();
    invoker4.invokeThrowEx();
    assertThrows(RpcException.class, () -> {
        clusterInvoker.invoke(invocation);
    });
    assertTrue(invoker1.isInvoked());
    assertTrue(invoker2.isInvoked());
    assertTrue(invoker3.isInvoked());
    assertFalse(invoker4.isInvoked());
}
@BeforeEach
public void setUp() throws Exception {
    dic = mock(Directory.class);
    invoker1 = new MockInvoker();
    invoker2 = new MockInvoker();
    invoker3 = new MockInvoker();
    invoker4 = new MockInvoker();
    url = URL.valueOf("test://127.0.0.1:8080/test");
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.getInterface()).willReturn(DemoService.class);
    invocation = new RpcInvocation();
    invocation.setMethodName("test");
    clusterInvoker = new BroadcastClusterInvoker(dic);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockDirectory {
    public static Directory<DemoService> createMockDirectory(org.apache.dubbo.common.URL url) {
        Directory<DemoService> dic = mock(Directory.class);
        given(dic.getUrl()).willReturn(url);
        given(dic.getConsumerUrl()).willReturn(url);
        given(dic.getInterface()).willReturn(DemoService.class);
        return dic;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_2_4
#### Test Case Name: `testNoInvoke`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\FailSafeClusterInvokerTest.java`)
#### Mock Object Variable Name: `dic`
<summary>Suggested Diff</summary>

```diff
--- a/TestClass.java
+++ b/TestClass.java
@@
 @Test
 void testNoInvoke() {
-    dic = mock(Directory.class);
-    given(dic.getUrl()).willReturn(url);
-    given(dic.getConsumerUrl()).willReturn(url);
-    given(dic.list(invocation)).willReturn(null);
-    given(dic.getInterface()).willReturn(DemoService.class);
+    dic = MockDirectory.createMockDirectory(url);
+    given(dic.list(invocation)).willReturn(null);
     invocation.setMethodName("method1");
     resetInvokerToNoException();
     FailsafeClusterInvoker<DemoService> invoker = new FailsafeClusterInvoker<DemoService>(dic);
     LogUtil.start();
     invoker.invoke(invocation);
     assertTrue(LogUtil.findMessage("No provider") > 0);
     LogUtil.stop();
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testNoInvoke() {
    dic = mock(Directory.class);
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.list(invocation)).willReturn(null);
    given(dic.getInterface()).willReturn(DemoService.class);
    invocation.setMethodName("method1");
    resetInvokerToNoException();
    FailsafeClusterInvoker<DemoService> invoker = new FailsafeClusterInvoker<DemoService>(dic);
    LogUtil.start();
    invoker.invoke(invocation);
    assertTrue(LogUtil.findMessage("No provider") > 0);
    LogUtil.stop();
}
/**
 * @throws java.lang.Exception
 */
@BeforeEach
public void setUp() throws Exception {
    dic = mock(Directory.class);
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.list(invocation)).willReturn(invokers);
    given(dic.getInterface()).willReturn(DemoService.class);
    invocation.setMethodName("method1");
    invokers.add(invoker);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockDirectory {
    public static Directory<DemoService> createMockDirectory(org.apache.dubbo.common.URL url) {
        Directory<DemoService> dic = mock(Directory.class);
        given(dic.getUrl()).willReturn(url);
        given(dic.getConsumerUrl()).willReturn(url);
        given(dic.getInterface()).willReturn(DemoService.class);
        return dic;
    }
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_3
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.registry.integration.RegistryProtocol`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static RegistryProtocol createMockRegistryProtocol(ClusterInvoker invoker, ClusterInvoker serviceDiscoveryInvoker) {
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    return registryProtocol;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_3_1
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationInvokerTest.java`)
#### Mock Object Variable Name: `registryProtocol`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void test() {
-    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
     ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
     ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
     DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
     DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
     Mockito.when(invoker.getDirectory()).thenReturn(directory);
     Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
     Mockito.when(invoker.isAvailable()).thenReturn(true);
     Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
     Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
     Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
     List<Invoker<?>> invokers = new LinkedList<>();
     invokers.add(Mockito.mock(Invoker.class));
     invokers.add(Mockito.mock(Invoker.class));
     List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
     serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
     serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
     Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
     Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
+    RegistryProtocol registryProtocol = createMockRegistryProtocol(invoker, serviceDiscoveryInvoker);
@@
-    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
-    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
     URL consumerURL = Mockito.mock(URL.class);
     Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
     Mockito.when(consumerURL.getGroup()).thenReturn("Group");
     Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
     Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
     Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
     Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
     Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
     Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
     MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("all")
@Test
void test() {
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
    Mockito.when(invoker.isAvailable()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(1)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(2)).invoke(null);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(3)).invoke(null);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(4)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(5)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(3)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(4)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(5)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(6)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(6)).invoke(null);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(7)).invoke(null);
    Assertions.assertNull(migrationInvoker.getInvoker());
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(7)).invoke(null);
    Assertions.assertNull(migrationInvoker.getServiceDiscoveryInvoker());
    ArgumentCaptor<InvokersChangedListener> argument = ArgumentCaptor.forClass(InvokersChangedListener.class);
    Mockito.verify(serviceDiscoveryDirectory, Mockito.atLeastOnce()).setInvokersChangedListener(argument.capture());
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    for (int i = 0; i < 20; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(27)).invoke(null);
    serviceDiscoveryInvokers.remove(1);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(false);
    argument.getAllValues().get(argument.getAllValues().size() - 1).onChange();
    for (int i = 0; i < 20; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(invoker, Mockito.times(27)).invoke(null);
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    argument.getAllValues().get(argument.getAllValues().size() - 1).onChange();
    Mockito.when(migrationRule.getProportion(Mockito.any())).thenReturn(50);
    migrationInvoker.setMigrationRule(migrationRule);
    for (int i = 0; i < 1000; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(serviceDiscoveryInvoker, Mockito.atMost(1026)).invoke(null);
    Mockito.verify(invoker, Mockito.atLeast(28)).invoke(null);
    Mockito.when(migrationRule.getDelay(Mockito.any())).thenReturn(1);
    long currentTimeMillis = System.currentTimeMillis();
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    Assertions.assertTrue(System.currentTimeMillis() - currentTimeMillis >= 2000);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static RegistryProtocol createMockRegistryProtocol(ClusterInvoker invoker, ClusterInvoker serviceDiscoveryInvoker) {
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    return registryProtocol;
}
```
</details>

---
#### Test Case ID #dubbo_Test_3_2
#### Test Case Name: `testDecide`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationInvokerTest.java`)
#### Mock Object Variable Name: `registryProtocol`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 void testDecide() {
-    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
     ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
     ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
     DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
     DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
     Mockito.when(invoker.getDirectory()).thenReturn(directory);
     Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
     Mockito.when(invoker.isAvailable()).thenReturn(true);
     Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
     Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
     Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
     List<Invoker<?>> invokers = new LinkedList<>();
     invokers.add(Mockito.mock(Invoker.class));
     invokers.add(Mockito.mock(Invoker.class));
     List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
     serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
     serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
     Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
     Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
+    RegistryProtocol registryProtocol = createMockRegistryProtocol(invoker, serviceDiscoveryInvoker);
     URL consumerURL = Mockito.mock(URL.class);
     Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
     Mockito.when(consumerURL.getGroup()).thenReturn("Group");
     Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
     Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
     Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
     Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
     Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
     Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
     MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
     MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
     Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
     migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
     migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
     migrationInvoker.invoke(null);
     Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
     Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(false);
     migrationInvoker.invoke(null);
     Mockito.verify(invoker, Mockito.times(1)).invoke(null);
     Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
     migrationInvoker.invoke(null);
     Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("all")
@Test
void testDecide() {
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
    Mockito.when(invoker.isAvailable()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(false);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(1)).invoke(null);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static RegistryProtocol createMockRegistryProtocol(ClusterInvoker invoker, ClusterInvoker serviceDiscoveryInvoker) {
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    return registryProtocol;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_4
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.registry.client.migration.MigrationRuleHandler<?>`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
// === Declare in class scope ===
private MigrationRuleHandler<?> handler;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
}

// === Replace local variable in test with ===
handler

```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_4_1
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationRuleListenerTest.java`)
#### Mock Object Variable Name: `handler`
<summary>Suggested Diff</summary>

```diff
@@
     System.setProperty("dubbo.application.migration.delay", "1");
-    MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
+    // removed local mock; replaced with global field `handler`
     CountDownLatch countDownLatch = new CountDownLatch(1);
     MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule()) {
@@
     migrationRuleListener.getHandlers().put(migrationInvoker, handler);
     countDownLatch.countDown();
     await().untilAsserted(() -> {
-        Mockito.verify(handler).doMigrate(Mockito.any());
+        Mockito.verify(handler).doMigrate(Mockito.any());
     });
     //        Mockito.verify(handler, Mockito.timeout(5000)).doMigrate(Mockito.any());
     migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);
-    Mockito.verify(handler, Mockito.times(2)).doMigrate(Mockito.any());
+    Mockito.verify(handler, Mockito.times(2)).doMigrate(Mockito.any());
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Listener started with config center and local rule, no initial remote rule.
 * Check local rule take effect
 */
@Test
void test() {
    DynamicConfiguration dynamicConfiguration = Mockito.mock(DynamicConfiguration.class);
    ApplicationModel.reset();
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setDynamicConfiguration(dynamicConfiguration);
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setLocalMigrationRule(localRule);
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("demo-consumer");
    ApplicationModel.defaultModel().getApplicationConfigManager().setApplication(applicationConfig);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Test");
    Mockito.when(consumerURL.getParameter("timestamp")).thenReturn("1");
    System.setProperty("dubbo.application.migration.delay", "1");
    MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
    CountDownLatch countDownLatch = new CountDownLatch(1);
    MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule()) {

        @Override
        public synchronized void process(ConfigChangedEvent event) {
            try {
                countDownLatch.await();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            super.process(event);
        }
    };
    MigrationInvoker<?> migrationInvoker = Mockito.mock(MigrationInvoker.class);
    migrationRuleListener.getHandlers().put(migrationInvoker, handler);
    countDownLatch.countDown();
    await().untilAsserted(() -> {
        Mockito.verify(handler).doMigrate(Mockito.any());
    });
    //        Mockito.verify(handler, Mockito.timeout(5000)).doMigrate(Mockito.any());
    migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);
    Mockito.verify(handler, Mockito.times(2)).doMigrate(Mockito.any());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MigrationRuleHandler<?> handler;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
}

// === Replace local variable in test with ===
handler

```
</details>

---
#### Test Case ID #dubbo_Test_4_2
#### Test Case Name: `testWithInitAndNoLocalRule`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationRuleListenerTest.java`)
#### Mock Object Variable Name: `handler`
<summary>Suggested Diff</summary>

```diff
@@
     System.setProperty("dubbo.application.migration.delay", "1000");
-    MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
+    // removed local mock; replaced with global field `handler`
     MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule());
     MigrationInvoker<?> migrationInvoker = Mockito.mock(MigrationInvoker.class);
     migrationRuleListener.getHandlers().put(migrationInvoker, handler);
     migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);
     // check migration happened after invoker referred
-    Mockito.verify(handler, Mockito.times(1)).doMigrate(MigrationRule.getInitRule());
+    Mockito.verify(handler, Mockito.times(1)).doMigrate(MigrationRule.getInitRule());
     // check no delay tasks created for there's no local rule and no config center
     Assertions.assertNull(migrationRuleListener.localRuleMigrationFuture);
     Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);
     Assertions.assertEquals(0, migrationRuleListener.ruleQueue.size());
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Test listener started without local rule and config center, INIT should be used and no scheduled task should be started.
 */
@Test
void testWithInitAndNoLocalRule() {
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setDynamicConfiguration(null);
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setLocalMigrationRule("");
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("demo-consumer");
    ApplicationModel.defaultModel().getApplicationConfigManager().setApplication(applicationConfig);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Test");
    Mockito.when(consumerURL.getParameter("timestamp")).thenReturn("1");
    System.setProperty("dubbo.application.migration.delay", "1000");
    MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
    MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule());
    MigrationInvoker<?> migrationInvoker = Mockito.mock(MigrationInvoker.class);
    migrationRuleListener.getHandlers().put(migrationInvoker, handler);
    migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);
    // check migration happened after invoker referred
    Mockito.verify(handler, Mockito.times(1)).doMigrate(MigrationRule.getInitRule());
    // check no delay tasks created for there's no local rule and no config center
    Assertions.assertNull(migrationRuleListener.localRuleMigrationFuture);
    Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);
    Assertions.assertEquals(0, migrationRuleListener.ruleQueue.size());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MigrationRuleHandler<?> handler;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
}

// === Replace local variable in test with ===
handler

```
</details>

---
#### Test Case ID #dubbo_Test_4_3
#### Test Case Name: `testWithConfigurationListenerAndLocalRule`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationRuleListenerTest.java`)
#### Mock Object Variable Name: `handler`
<summary>Suggested Diff</summary>

```diff
@@
     System.setProperty("dubbo.application.migration.delay", "10");
-    MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
+    // removed local mock; replaced with global field `handler`
     MigrationRuleHandler<?> handler2 = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
     // Both local rule and remote rule are here
     // Local rule with one delayed task started to apply
     MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule());
@@
     migrationRuleListener.getHandlers().put(migrationInvoker, handler);
     migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);
     MigrationRule tmpRemoteRule = migrationRuleListener.getRule();
     ArgumentCaptor<MigrationRule> captor = ArgumentCaptor.forClass(MigrationRule.class);
-    Mockito.verify(handler, Mockito.times(1)).doMigrate(captor.capture());
+    Mockito.verify(handler, Mockito.times(1)).doMigrate(captor.capture());
     Assertions.assertEquals(tmpRemoteRule, captor.getValue());
     await().until(() -> migrationRuleListener.localRuleMigrationFuture.isDone());
     Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);
     Assertions.assertEquals(tmpRemoteRule, migrationRuleListener.getRule());
-    Mockito.verify(handler, Mockito.times(1)).doMigrate(Mockito.any());
+    Mockito.verify(handler, Mockito.times(1)).doMigrate(Mockito.any());
     ArgumentCaptor<MigrationRule> captor2 = ArgumentCaptor.forClass(MigrationRule.class);
     migrationRuleListener.getHandlers().put(migrationInvoker2, handler2);
     migrationRuleListener.onRefer(null, migrationInvoker2, consumerURL2, null);
     Mockito.verify(handler2, Mockito.times(1)).doMigrate(captor2.capture());
     Assertions.assertEquals(tmpRemoteRule, captor2.getValue());
     migrationRuleListener.process(new ConfigChangedEvent("key", "group", dynamicRemoteRule));
     await().until(migrationRuleListener.ruleQueue::isEmpty);
     await().untilAsserted(() -> {
-        Mockito.verify(handler, Mockito.times(2)).doMigrate(Mockito.any());
+        Mockito.verify(handler, Mockito.times(2)).doMigrate(Mockito.any());
         Mockito.verify(handler2, Mockito.times(2)).doMigrate(Mockito.any());
     });
     Assertions.assertNotNull(migrationRuleListener.ruleMigrationFuture);
     ArgumentCaptor<MigrationRule> captor_event = ArgumentCaptor.forClass(MigrationRule.class);
-    Mockito.verify(handler, Mockito.times(2)).doMigrate(captor_event.capture());
+    Mockito.verify(handler, Mockito.times(2)).doMigrate(captor_event.capture());
     Assertions.assertEquals("APPLICATION_FIRST", captor_event.getValue().getStep().toString());
     Mockito.verify(handler2, Mockito.times(2)).doMigrate(captor_event.capture());
     Assertions.assertEquals("APPLICATION_FIRST", captor_event.getValue().getStep().toString());
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Listener with config center initial remote rule and local rule, check
 * 1. initial remote rule other than local rule take effect
 * 2. remote rule change and all invokers gets notified
 */
@Test
void testWithConfigurationListenerAndLocalRule() {
    DynamicConfiguration dynamicConfiguration = Mockito.mock(DynamicConfiguration.class);
    Mockito.doReturn(remoteRule).when(dynamicConfiguration).getConfig(Mockito.anyString(), Mockito.anyString());
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setDynamicConfiguration(dynamicConfiguration);
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setLocalMigrationRule(localRule);
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("demo-consumer");
    ApplicationModel.defaultModel().getApplicationConfigManager().setApplication(applicationConfig);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Test");
    Mockito.when(consumerURL.getParameter("timestamp")).thenReturn("1");
    URL consumerURL2 = Mockito.mock(URL.class);
    Mockito.when(consumerURL2.getServiceKey()).thenReturn("Test2");
    Mockito.when(consumerURL2.getParameter("timestamp")).thenReturn("2");
    System.setProperty("dubbo.application.migration.delay", "10");
    MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
    MigrationRuleHandler<?> handler2 = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
    // Both local rule and remote rule are here
    // Local rule with one delayed task started to apply
    MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule());
    Assertions.assertNotNull(migrationRuleListener.localRuleMigrationFuture);
    Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);
    MigrationInvoker<?> migrationInvoker = Mockito.mock(MigrationInvoker.class);
    MigrationInvoker<?> migrationInvoker2 = Mockito.mock(MigrationInvoker.class);
    // Remote rule will be applied when onRefer gets executed
    migrationRuleListener.getHandlers().put(migrationInvoker, handler);
    migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);
    MigrationRule tmpRemoteRule = migrationRuleListener.getRule();
    ArgumentCaptor<MigrationRule> captor = ArgumentCaptor.forClass(MigrationRule.class);
    Mockito.verify(handler, Mockito.times(1)).doMigrate(captor.capture());
    Assertions.assertEquals(tmpRemoteRule, captor.getValue());
    await().until(() -> migrationRuleListener.localRuleMigrationFuture.isDone());
    Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);
    Assertions.assertEquals(tmpRemoteRule, migrationRuleListener.getRule());
    Mockito.verify(handler, Mockito.times(1)).doMigrate(Mockito.any());
    ArgumentCaptor<MigrationRule> captor2 = ArgumentCaptor.forClass(MigrationRule.class);
    migrationRuleListener.getHandlers().put(migrationInvoker2, handler2);
    migrationRuleListener.onRefer(null, migrationInvoker2, consumerURL2, null);
    Mockito.verify(handler2, Mockito.times(1)).doMigrate(captor2.capture());
    Assertions.assertEquals(tmpRemoteRule, captor2.getValue());
    migrationRuleListener.process(new ConfigChangedEvent("key", "group", dynamicRemoteRule));
    await().until(migrationRuleListener.ruleQueue::isEmpty);
    await().untilAsserted(() -> {
        Mockito.verify(handler, Mockito.times(2)).doMigrate(Mockito.any());
        Mockito.verify(handler2, Mockito.times(2)).doMigrate(Mockito.any());
    });
    Assertions.assertNotNull(migrationRuleListener.ruleMigrationFuture);
    ArgumentCaptor<MigrationRule> captor_event = ArgumentCaptor.forClass(MigrationRule.class);
    Mockito.verify(handler, Mockito.times(2)).doMigrate(captor_event.capture());
    Assertions.assertEquals("APPLICATION_FIRST", captor_event.getValue().getStep().toString());
    Mockito.verify(handler2, Mockito.times(2)).doMigrate(captor_event.capture());
    Assertions.assertEquals("APPLICATION_FIRST", captor_event.getValue().getStep().toString());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MigrationRuleHandler<?> handler;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
}

// === Replace local variable in test with ===
handler

```
</details>

---
## Mock Clone Instance #dubbo_MCI_5
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.registry.nacos.NacosConnectionManager`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static NacosConnectionManager createMockNacosConnectionManager(NamingService namingService) {
    NacosConnectionManager connectionManager = Mockito.mock(NacosConnectionManager.class);
    Mockito.when(connectionManager.getNamingService()).thenReturn(namingService);
    return connectionManager;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_5_1
#### Test Case Name: `testSubscribe`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-nacos\src\test\java\org\apache\dubbo\registry\nacos\NacosNamingServiceWrapperTest.java`)
#### Mock Object Variable Name: `connectionManager`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 void testSubscribe() throws NacosException {
-    NacosConnectionManager connectionManager = Mockito.mock(NacosConnectionManager.class);
     NamingService namingService = Mockito.mock(NamingService.class);
-    Mockito.when(connectionManager.getNamingService()).thenReturn(namingService);
+    NacosConnectionManager connectionManager = createMockNacosConnectionManager(namingService);
     NacosNamingServiceWrapper nacosNamingServiceWrapper = new NacosNamingServiceWrapper(connectionManager, 0, 0);
     EventListener eventListener = Mockito.mock(EventListener.class);
     nacosNamingServiceWrapper.subscribe("service_name", "test", eventListener);
     Mockito.verify(namingService, Mockito.times(1)).subscribe("service_name", "test", eventListener);
     nacosNamingServiceWrapper.subscribe("service_name", "test", eventListener);
     Mockito.verify(namingService, Mockito.times(2)).subscribe("service_name", "test", eventListener);
     nacosNamingServiceWrapper.unsubscribe("service_name", "test", eventListener);
     Mockito.verify(namingService, Mockito.times(1)).unsubscribe("service_name", "test", eventListener);
     nacosNamingServiceWrapper.unsubscribe("service_name", "test", eventListener);
     Mockito.verify(namingService, Mockito.times(1)).unsubscribe("service_name", "test", eventListener);
     nacosNamingServiceWrapper.unsubscribe("service_name", "mock", eventListener);
     Mockito.verify(namingService, Mockito.times(0)).unsubscribe("service_name", "mock", eventListener);
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testSubscribe() throws NacosException {
    NacosConnectionManager connectionManager = Mockito.mock(NacosConnectionManager.class);
    NamingService namingService = Mockito.mock(NamingService.class);
    Mockito.when(connectionManager.getNamingService()).thenReturn(namingService);
    NacosNamingServiceWrapper nacosNamingServiceWrapper = new NacosNamingServiceWrapper(connectionManager, 0, 0);
    EventListener eventListener = Mockito.mock(EventListener.class);
    nacosNamingServiceWrapper.subscribe("service_name", "test", eventListener);
    Mockito.verify(namingService, Mockito.times(1)).subscribe("service_name", "test", eventListener);
    nacosNamingServiceWrapper.subscribe("service_name", "test", eventListener);
    Mockito.verify(namingService, Mockito.times(2)).subscribe("service_name", "test", eventListener);
    nacosNamingServiceWrapper.unsubscribe("service_name", "test", eventListener);
    Mockito.verify(namingService, Mockito.times(1)).unsubscribe("service_name", "test", eventListener);
    nacosNamingServiceWrapper.unsubscribe("service_name", "test", eventListener);
    Mockito.verify(namingService, Mockito.times(1)).unsubscribe("service_name", "test", eventListener);
    nacosNamingServiceWrapper.unsubscribe("service_name", "mock", eventListener);
    Mockito.verify(namingService, Mockito.times(0)).unsubscribe("service_name", "mock", eventListener);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static NacosConnectionManager createMockNacosConnectionManager(NamingService namingService) {
    NacosConnectionManager connectionManager = Mockito.mock(NacosConnectionManager.class);
    Mockito.when(connectionManager.getNamingService()).thenReturn(namingService);
    return connectionManager;
}
```
</details>

---
#### Test Case ID #dubbo_Test_5_2
#### Test Case Name: `testConcurrency`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-nacos\src\test\java\org\apache\dubbo\registry\nacos\NacosNamingServiceWrapperTest.java`)
#### Mock Object Variable Name: `connectionManager`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testConcurrency() throws NacosException, InterruptedException {
-    NacosConnectionManager connectionManager = Mockito.mock(NacosConnectionManager.class);
     CountDownLatch startLatch = new CountDownLatch(1);
     CountDownLatch stopLatch = new CountDownLatch(1);
     NamingService namingService = Mockito.mock(NamingService.class);
+    NacosConnectionManager connectionManager = createMockNacosConnectionManager(namingService);
-    Mockito.when(connectionManager.getNamingService()).thenReturn(namingService);
     NacosNamingServiceWrapper nacosNamingServiceWrapper = new NacosNamingServiceWrapper(connectionManager, false, 0, 0);
     Instance instance = new Instance();
     nacosNamingServiceWrapper.registerInstance("service_name", "test", instance);
     NacosNamingServiceWrapper.InstancesInfo instancesInfo = nacosNamingServiceWrapper.getRegisterStatus().get(new NacosNamingServiceWrapper.InstanceId("service_name", "test"));
     Assertions.assertEquals(1, instancesInfo.getInstances().size());
     nacosNamingServiceWrapper.getRegisterStatus().put(new NacosNamingServiceWrapper.InstanceId("service_name", "test"), new NacosNamingServiceWrapper.InstancesInfo() {

         private final NacosNamingServiceWrapper.InstancesInfo delegate = instancesInfo;

         @Override
         public void lock() {
             delegate.lock();
         }

         @Override
         public void unlock() {
             delegate.unlock();
         }

         @Override
         public List<NacosNamingServiceWrapper.InstanceInfo> getInstances() {
             try {
                 if (startLatch.getCount() > 0) {
                     Thread.sleep(1000);
                     startLatch.countDown();
                     Thread.sleep(1000);
                 }
             } catch (InterruptedException e) {
                 throw new RuntimeException(e);
             }
             return delegate.getInstances();
         }

         @Override
         public boolean isBatchRegistered() {
             return delegate.isBatchRegistered();
         }

         @Override
         public void setBatchRegistered(boolean batchRegistered) {
             delegate.setBatchRegistered(batchRegistered);
         }

         @Override
         public boolean isValid() {
             return delegate.isValid();
         }

         @Override
         public void setValid(boolean valid) {
             delegate.setValid(valid);
         }
     });
     new Thread(() -> {
         try {
             startLatch.await();
             nacosNamingServiceWrapper.registerInstance("service_name", "test", instance);
             stopLatch.countDown();
         } catch (Exception e) {
             throw new RuntimeException(e);
         }
     }).start();
     new Thread(() -> {
         try {
             nacosNamingServiceWrapper.deregisterInstance("service_name", "test", instance);
         } catch (NacosException e) {
             throw new RuntimeException(e);
         }
     }).start();
     stopLatch.await();
     NacosNamingServiceWrapper.InstancesInfo instancesInfoNew = nacosNamingServiceWrapper.getRegisterStatus().get(new NacosNamingServiceWrapper.InstanceId("service_name", "test"));
     Assertions.assertEquals(1, instancesInfoNew.getInstances().size());
     Assertions.assertNotEquals(instancesInfo, instancesInfoNew);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testConcurrency() throws NacosException, InterruptedException {
    NacosConnectionManager connectionManager = Mockito.mock(NacosConnectionManager.class);
    CountDownLatch startLatch = new CountDownLatch(1);
    CountDownLatch stopLatch = new CountDownLatch(1);
    NamingService namingService = Mockito.mock(NamingService.class);
    Mockito.when(connectionManager.getNamingService()).thenReturn(namingService);
    NacosNamingServiceWrapper nacosNamingServiceWrapper = new NacosNamingServiceWrapper(connectionManager, false, 0, 0);
    Instance instance = new Instance();
    nacosNamingServiceWrapper.registerInstance("service_name", "test", instance);
    NacosNamingServiceWrapper.InstancesInfo instancesInfo = nacosNamingServiceWrapper.getRegisterStatus().get(new NacosNamingServiceWrapper.InstanceId("service_name", "test"));
    Assertions.assertEquals(1, instancesInfo.getInstances().size());
    nacosNamingServiceWrapper.getRegisterStatus().put(new NacosNamingServiceWrapper.InstanceId("service_name", "test"), new NacosNamingServiceWrapper.InstancesInfo() {

        private final NacosNamingServiceWrapper.InstancesInfo delegate = instancesInfo;

        @Override
        public void lock() {
            delegate.lock();
        }

        @Override
        public void unlock() {
            delegate.unlock();
        }

        @Override
        public List<NacosNamingServiceWrapper.InstanceInfo> getInstances() {
            try {
                if (startLatch.getCount() > 0) {
                    Thread.sleep(1000);
                    startLatch.countDown();
                    Thread.sleep(1000);
                }
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            return delegate.getInstances();
        }

        @Override
        public boolean isBatchRegistered() {
            return delegate.isBatchRegistered();
        }

        @Override
        public void setBatchRegistered(boolean batchRegistered) {
            delegate.setBatchRegistered(batchRegistered);
        }

        @Override
        public boolean isValid() {
            return delegate.isValid();
        }

        @Override
        public void setValid(boolean valid) {
            delegate.setValid(valid);
        }
    });
    new Thread(() -> {
        try {
            startLatch.await();
            nacosNamingServiceWrapper.registerInstance("service_name", "test", instance);
            stopLatch.countDown();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }).start();
    new Thread(() -> {
        try {
            nacosNamingServiceWrapper.deregisterInstance("service_name", "test", instance);
        } catch (NacosException e) {
            throw new RuntimeException(e);
        }
    }).start();
    stopLatch.await();
    NacosNamingServiceWrapper.InstancesInfo instancesInfoNew = nacosNamingServiceWrapper.getRegisterStatus().get(new NacosNamingServiceWrapper.InstanceId("service_name", "test"));
    Assertions.assertEquals(1, instancesInfoNew.getInstances().size());
    Assertions.assertNotEquals(instancesInfo, instancesInfoNew);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static NacosConnectionManager createMockNacosConnectionManager(NamingService namingService) {
    NacosConnectionManager connectionManager = Mockito.mock(NacosConnectionManager.class);
    Mockito.when(connectionManager.getNamingService()).thenReturn(namingService);
    return connectionManager;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_6
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.common.utils.Log`
- **Test Case Count**: 4
- **MO Count**: 4

### Reusable Method
```java
private static Log createMockLog(Level logLevelReturn) {
    Log log = mock(Log.class);
    when(log.getLogLevel()).thenReturn(logLevelReturn);
    return log;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_6_1
#### Test Case Name: `testCheckNoError`(File: `C:\Java_projects\Apache\dubbo\dubbo-common\src\test\java\org\apache\dubbo\common\utils\LogUtilTest.java`)
#### Mock Object Variable Name: `log`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void testCheckNoError() {
-    Log log = mock(Log.class);
-    DubboAppender.logList.add(log);
-    when(log.getLogLevel()).thenReturn(Level.ERROR);
+    Log log = createMockLog(Level.ERROR);
+    DubboAppender.logList.add(log);
     assertThat(LogUtil.checkNoError(), is(false));
-    when(log.getLogLevel()).thenReturn(Level.INFO);
+    when(log.getLogLevel()).thenReturn(Level.INFO);
     assertThat(LogUtil.checkNoError(), is(true));
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testCheckNoError() {
    Log log = mock(Log.class);
    DubboAppender.logList.add(log);
    when(log.getLogLevel()).thenReturn(Level.ERROR);
    assertThat(LogUtil.checkNoError(), is(false));
    when(log.getLogLevel()).thenReturn(Level.INFO);
    assertThat(LogUtil.checkNoError(), is(true));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Log createMockLog(Level logLevelReturn) {
    Log log = mock(Log.class);
    when(log.getLogLevel()).thenReturn(logLevelReturn);
    return log;
}
```
</details>

---
#### Test Case ID #dubbo_Test_6_2
#### Test Case Name: `testFindLevel`(File: `C:\Java_projects\Apache\dubbo\dubbo-common\src\test\java\org\apache\dubbo\common\utils\LogUtilTest.java`)
#### Mock Object Variable Name: `log`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 void testFindLevel() {
-    Log log = mock(Log.class);
+    Log log = createMockLog(Level.ERROR);
     DubboAppender.logList.add(log);
-    when(log.getLogLevel()).thenReturn(Level.ERROR);
     assertThat(LogUtil.findLevel(Level.ERROR), equalTo(1));
     assertThat(LogUtil.findLevel(Level.INFO), equalTo(0));
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testFindLevel() {
    Log log = mock(Log.class);
    DubboAppender.logList.add(log);
    when(log.getLogLevel()).thenReturn(Level.ERROR);
    assertThat(LogUtil.findLevel(Level.ERROR), equalTo(1));
    assertThat(LogUtil.findLevel(Level.INFO), equalTo(0));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Log createMockLog(Level logLevelReturn) {
    Log log = mock(Log.class);
    when(log.getLogLevel()).thenReturn(logLevelReturn);
    return log;
}
```
</details>

---
#### Test Case ID #dubbo_Test_6_3
#### Test Case Name: `testFindLevelWithThreadName`(File: `C:\Java_projects\Apache\dubbo\dubbo-common\src\test\java\org\apache\dubbo\common\utils\LogUtilTest.java`)
#### Mock Object Variable Name: `log`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 void testFindLevelWithThreadName() {
-    Log log = mock(Log.class);
-    DubboAppender.logList.add(log);
-    when(log.getLogLevel()).thenReturn(Level.ERROR);
-    when(log.getLogThread()).thenReturn("thread-1");
+    Log log = createMockLog(Level.ERROR);
+    when(log.getLogThread()).thenReturn("thread-1");
+    DubboAppender.logList.add(log);
-    log = mock(Log.class);
-    DubboAppender.logList.add(log);
-    when(log.getLogLevel()).thenReturn(Level.ERROR);
-    when(log.getLogThread()).thenReturn("thread-2");
+    log = createMockLog(Level.ERROR);
+    when(log.getLogThread()).thenReturn("thread-2");
+    DubboAppender.logList.add(log);
     assertThat(LogUtil.findLevelWithThreadName(Level.ERROR, "thread-2"), equalTo(1));
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testFindLevelWithThreadName() {
    Log log = mock(Log.class);
    DubboAppender.logList.add(log);
    when(log.getLogLevel()).thenReturn(Level.ERROR);
    when(log.getLogThread()).thenReturn("thread-1");
    log = mock(Log.class);
    DubboAppender.logList.add(log);
    when(log.getLogLevel()).thenReturn(Level.ERROR);
    when(log.getLogThread()).thenReturn("thread-2");
    assertThat(LogUtil.findLevelWithThreadName(Level.ERROR, "thread-2"), equalTo(1));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Log createMockLog(Level logLevelReturn) {
    Log log = mock(Log.class);
    when(log.getLogLevel()).thenReturn(logLevelReturn);
    return log;
}
```
</details>

---
#### Test Case ID #dubbo_Test_6_4
#### Test Case Name: `testFindMessage2`(File: `C:\Java_projects\Apache\dubbo\dubbo-common\src\test\java\org\apache\dubbo\common\utils\LogUtilTest.java`)
#### Mock Object Variable Name: `log`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testFindMessage2() {
-    Log log = mock(Log.class);
-    DubboAppender.logList.add(log);
-    when(log.getLogMessage()).thenReturn("message");
-    when(log.getLogLevel()).thenReturn(Level.ERROR);
-    log = mock(Log.class);
-    DubboAppender.logList.add(log);
-    when(log.getLogMessage()).thenReturn("message");
-    when(log.getLogLevel()).thenReturn(Level.INFO);
+    Log log = createMockLog(Level.ERROR);
+    when(log.getLogMessage()).thenReturn("message");
+    DubboAppender.logList.add(log);
+    log = createMockLog(Level.INFO);
+    when(log.getLogMessage()).thenReturn("message");
+    DubboAppender.logList.add(log);
    assertThat(LogUtil.findMessage(Level.ERROR, "message"), equalTo(1));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testFindMessage2() {
    Log log = mock(Log.class);
    DubboAppender.logList.add(log);
    when(log.getLogMessage()).thenReturn("message");
    when(log.getLogLevel()).thenReturn(Level.ERROR);
    log = mock(Log.class);
    DubboAppender.logList.add(log);
    when(log.getLogMessage()).thenReturn("message");
    when(log.getLogLevel()).thenReturn(Level.INFO);
    assertThat(LogUtil.findMessage(Level.ERROR, "message"), equalTo(1));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Log createMockLog(Level logLevelReturn) {
    Log log = mock(Log.class);
    when(log.getLogLevel()).thenReturn(logLevelReturn);
    return log;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_7
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.monitor.MonitorService`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
// === Declare in class scope ===
private MonitorService monitorService;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    monitorService = mock(MonitorService.class);
}

// === Replace local variable in test with ===
monitorService

```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_7_1
#### Test Case Name: `testAvailable`(File: `C:\Java_projects\Apache\dubbo\dubbo-monitor\dubbo-monitor-default\src\test\java\org\apache\dubbo\monitor\dubbo\DubboMonitorTest.java`)
#### Mock Object Variable Name: `monitorService`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void testAvailable() {
     Invoker invoker = mock(Invoker.class);
-    MonitorService monitorService = mock(MonitorService.class);
+    // removed local mock; replaced with global field `monitorService`
     given(invoker.isAvailable()).willReturn(true);
     given(invoker.getUrl()).willReturn(URL.valueOf("dubbo://127.0.0.1:7070?interval=20"));
-    DubboMonitor dubboMonitor = new DubboMonitor(invoker, monitorService);
+    DubboMonitor dubboMonitor = new DubboMonitor(invoker, monitorService);
     assertThat(dubboMonitor.isAvailable(), is(true));
     verify(invoker).isAvailable();
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testAvailable() {
    Invoker invoker = mock(Invoker.class);
    MonitorService monitorService = mock(MonitorService.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getUrl()).willReturn(URL.valueOf("dubbo://127.0.0.1:7070?interval=20"));
    DubboMonitor dubboMonitor = new DubboMonitor(invoker, monitorService);
    assertThat(dubboMonitor.isAvailable(), is(true));
    verify(invoker).isAvailable();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MonitorService monitorService;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    monitorService = mock(MonitorService.class);
}

// === Replace local variable in test with ===
monitorService

```
</details>

---
#### Test Case ID #dubbo_Test_7_2
#### Test Case Name: `testSum`(File: `C:\Java_projects\Apache\dubbo\dubbo-monitor\dubbo-monitor-default\src\test\java\org\apache\dubbo\monitor\dubbo\DubboMonitorTest.java`)
#### Mock Object Variable Name: `monitorService`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void testSum() {
     URL statistics = new URLBuilder(DUBBO_PROTOCOL, "10.20.153.11", 0).addParameter(APPLICATION_KEY, "morgan").addParameter(INTERFACE_KEY, "MemberService").addParameter(METHOD_KEY, "findPerson").addParameter(CONSUMER, "10.20.153.11").addParameter(SUCCESS_KEY, 1).addParameter(FAILURE_KEY, 0).addParameter(ELAPSED_KEY, 3).addParameter(MAX_ELAPSED_KEY, 3).addParameter(CONCURRENT_KEY, 1).addParameter(MAX_CONCURRENT_KEY, 1).build();
     Invoker invoker = mock(Invoker.class);
-    MonitorService monitorService = mock(MonitorService.class);
+    // removed local mock; replaced with global field `monitorService`
     given(invoker.getUrl()).willReturn(URL.valueOf("dubbo://127.0.0.1:7070?interval=20"));
     DubboMonitor dubboMonitor = new DubboMonitor(invoker, monitorService);
     dubboMonitor.collect(statistics.toSerializableURL());
     dubboMonitor.collect(statistics.addParameter(SUCCESS_KEY, 3).addParameter(CONCURRENT_KEY, 2).addParameter(INPUT_KEY, 1).addParameter(OUTPUT_KEY, 2).toSerializableURL());
     dubboMonitor.collect(statistics.addParameter(SUCCESS_KEY, 6).addParameter(ELAPSED_KEY, 2).toSerializableURL());
     dubboMonitor.send();
     ArgumentCaptor<URL> summaryCaptor = ArgumentCaptor.forClass(URL.class);
-    verify(monitorService, atLeastOnce()).collect(summaryCaptor.capture());
+    verify(monitorService, atLeastOnce()).collect(summaryCaptor.capture());
     List<URL> allValues = summaryCaptor.getAllValues();
     assertThat(allValues, not(nullValue()));
     assertThat(allValues, hasItem(new CustomMatcher<URL>("Monitor count should greater than 1") {

         @Override
         public boolean matches(Object item) {
             URL url = (URL) item;
             return Integer.valueOf(url.getParameter(SUCCESS_KEY)) > 1;
         }
     }));
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testSum() {
    URL statistics = new URLBuilder(DUBBO_PROTOCOL, "10.20.153.11", 0).addParameter(APPLICATION_KEY, "morgan").addParameter(INTERFACE_KEY, "MemberService").addParameter(METHOD_KEY, "findPerson").addParameter(CONSUMER, "10.20.153.11").addParameter(SUCCESS_KEY, 1).addParameter(FAILURE_KEY, 0).addParameter(ELAPSED_KEY, 3).addParameter(MAX_ELAPSED_KEY, 3).addParameter(CONCURRENT_KEY, 1).addParameter(MAX_CONCURRENT_KEY, 1).build();
    Invoker invoker = mock(Invoker.class);
    MonitorService monitorService = mock(MonitorService.class);
    given(invoker.getUrl()).willReturn(URL.valueOf("dubbo://127.0.0.1:7070?interval=20"));
    DubboMonitor dubboMonitor = new DubboMonitor(invoker, monitorService);
    dubboMonitor.collect(statistics.toSerializableURL());
    dubboMonitor.collect(statistics.addParameter(SUCCESS_KEY, 3).addParameter(CONCURRENT_KEY, 2).addParameter(INPUT_KEY, 1).addParameter(OUTPUT_KEY, 2).toSerializableURL());
    dubboMonitor.collect(statistics.addParameter(SUCCESS_KEY, 6).addParameter(ELAPSED_KEY, 2).toSerializableURL());
    dubboMonitor.send();
    ArgumentCaptor<URL> summaryCaptor = ArgumentCaptor.forClass(URL.class);
    verify(monitorService, atLeastOnce()).collect(summaryCaptor.capture());
    List<URL> allValues = summaryCaptor.getAllValues();
    assertThat(allValues, not(nullValue()));
    assertThat(allValues, hasItem(new CustomMatcher<URL>("Monitor count should greater than 1") {

        @Override
        public boolean matches(Object item) {
            URL url = (URL) item;
            return Integer.valueOf(url.getParameter(SUCCESS_KEY)) > 1;
        }
    }));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MonitorService monitorService;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    monitorService = mock(MonitorService.class);
}

// === Replace local variable in test with ===
monitorService

```
</details>

---
#### Test Case ID #dubbo_Test_7_3
#### Test Case Name: `testLookUp`(File: `C:\Java_projects\Apache\dubbo\dubbo-monitor\dubbo-monitor-default\src\test\java\org\apache\dubbo\monitor\dubbo\DubboMonitorTest.java`)
#### Mock Object Variable Name: `monitorService`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void testLookUp() {
     Invoker invoker = mock(Invoker.class);
-    MonitorService monitorService = mock(MonitorService.class);
+    // removed local mock; replaced with global field `monitorService`
     URL queryUrl = URL.valueOf("dubbo://127.0.0.1:7070?interval=20");
     given(invoker.getUrl()).willReturn(queryUrl);
     DubboMonitor dubboMonitor = new DubboMonitor(invoker, monitorService);
     dubboMonitor.lookup(queryUrl);
     verify(monitorService).lookup(queryUrl);
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testLookUp() {
    Invoker invoker = mock(Invoker.class);
    MonitorService monitorService = mock(MonitorService.class);
    URL queryUrl = URL.valueOf("dubbo://127.0.0.1:7070?interval=20");
    given(invoker.getUrl()).willReturn(queryUrl);
    DubboMonitor dubboMonitor = new DubboMonitor(invoker, monitorService);
    dubboMonitor.lookup(queryUrl);
    verify(monitorService).lookup(queryUrl);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MonitorService monitorService;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    monitorService = mock(MonitorService.class);
}

// === Replace local variable in test with ===
monitorService

```
</details>

---
## Mock Clone Instance #dubbo_MCI_8
- **Scope**: method level
- **Mocked Class**: `java.net.InetAddress`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static InetAddress createMockInetAddress(String hostAddressReturn) {
    InetAddress addr = mock(InetAddress.class);
    when(addr.isLoopbackAddress()).thenReturn(false);
    when(addr.getHostAddress()).thenReturn(hostAddressReturn);
    return addr;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_8_1
#### Test Case Name: `shouldShowIpNotPermittedMsg_GivenAcceptForeignIpFalseAndNotMatchWhiteList`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-qos\src\test\java\org\apache\dubbo\qos\server\handler\ForeignHostPermitHandlerTest.java`)
#### Mock Object Variable Name: `addr`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(context.channel()).thenReturn(channel);
-    InetAddress addr = mock(InetAddress.class);
-    when(addr.isLoopbackAddress()).thenReturn(false);
-    when(addr.getHostAddress()).thenReturn("179.23.44.1");
+    InetAddress addr = createMockInetAddress("179.23.44.1");
    InetSocketAddress address = new InetSocketAddress(addr, 12345);
    when(channel.remoteAddress()).thenReturn(address);
    ChannelFuture future = mock(ChannelFuture.class);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void shouldShowIpNotPermittedMsg_GivenAcceptForeignIpFalseAndNotMatchWhiteList() throws Exception {
    ChannelHandlerContext context = mock(ChannelHandlerContext.class);
    Channel channel = mock(Channel.class);
    when(context.channel()).thenReturn(channel);
    InetAddress addr = mock(InetAddress.class);
    when(addr.isLoopbackAddress()).thenReturn(false);
    when(addr.getHostAddress()).thenReturn("179.23.44.1");
    InetSocketAddress address = new InetSocketAddress(addr, 12345);
    when(channel.remoteAddress()).thenReturn(address);
    ChannelFuture future = mock(ChannelFuture.class);
    when(context.writeAndFlush(any(ByteBuf.class))).thenReturn(future);
    ForeignHostPermitHandler handler = new ForeignHostPermitHandler(QosConfiguration.builder().acceptForeignIp(false).acceptForeignIpWhitelist("175.23.44.1 ,  192.168.1.192/26").anonymousAccessPermissionLevel(PermissionLevel.NONE.name()).build());
    handler.handlerAdded(context);
    ArgumentCaptor<ByteBuf> captor = ArgumentCaptor.forClass(ByteBuf.class);
    verify(context).writeAndFlush(captor.capture());
    assertThat(new String(captor.getValue().array()), containsString("Foreign Ip Not Permitted, Consider Config It In Whitelist"));
    verify(future).addListener(ChannelFutureListener.CLOSE);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static InetAddress createMockInetAddress(String hostAddressReturn) {
    InetAddress addr = mock(InetAddress.class);
    when(addr.isLoopbackAddress()).thenReturn(false);
    when(addr.getHostAddress()).thenReturn(hostAddressReturn);
    return addr;
}
```
</details>

---
#### Test Case ID #dubbo_Test_8_2
#### Test Case Name: `shouldNotShowIpNotPermittedMsg_GivenAcceptForeignIpFalseAndMatchWhiteList`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-qos\src\test\java\org\apache\dubbo\qos\server\handler\ForeignHostPermitHandlerTest.java`)
#### Mock Object Variable Name: `addr`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(context.channel()).thenReturn(channel);
-    InetAddress addr = mock(InetAddress.class);
-    when(addr.isLoopbackAddress()).thenReturn(false);
-    when(addr.getHostAddress()).thenReturn("175.23.44.1");
+    InetAddress addr = createMockInetAddress("175.23.44.1");
    InetSocketAddress address = new InetSocketAddress(addr, 12345);
    when(channel.remoteAddress()).thenReturn(address);
    ForeignHostPermitHandler handler = new ForeignHostPermitHandler(QosConfiguration.builder().acceptForeignIp(false).acceptForeignIpWhitelist("175.23.44.1, 192.168.1.192/26  ").build());
    handler.handlerAdded(context);
    verify(context, never()).writeAndFlush(any());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void shouldNotShowIpNotPermittedMsg_GivenAcceptForeignIpFalseAndMatchWhiteList() throws Exception {
    ChannelHandlerContext context = mock(ChannelHandlerContext.class);
    Channel channel = mock(Channel.class);
    when(context.channel()).thenReturn(channel);
    InetAddress addr = mock(InetAddress.class);
    when(addr.isLoopbackAddress()).thenReturn(false);
    when(addr.getHostAddress()).thenReturn("175.23.44.1");
    InetSocketAddress address = new InetSocketAddress(addr, 12345);
    when(channel.remoteAddress()).thenReturn(address);
    ForeignHostPermitHandler handler = new ForeignHostPermitHandler(QosConfiguration.builder().acceptForeignIp(false).acceptForeignIpWhitelist("175.23.44.1, 192.168.1.192/26  ").build());
    handler.handlerAdded(context);
    verify(context, never()).writeAndFlush(any());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static InetAddress createMockInetAddress(String hostAddressReturn) {
    InetAddress addr = mock(InetAddress.class);
    when(addr.isLoopbackAddress()).thenReturn(false);
    when(addr.getHostAddress()).thenReturn(hostAddressReturn);
    return addr;
}
```
</details>

---
#### Test Case ID #dubbo_Test_8_3
#### Test Case Name: `shouldNotShowIpNotPermittedMsg_GivenAcceptForeignIpFalseAndMatchWhiteListRange`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-qos\src\test\java\org\apache\dubbo\qos\server\handler\ForeignHostPermitHandlerTest.java`)
#### Mock Object Variable Name: `addr`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(context.channel()).thenReturn(channel);
-    InetAddress addr = mock(InetAddress.class);
-    when(addr.isLoopbackAddress()).thenReturn(false);
-    when(addr.getHostAddress()).thenReturn("192.168.1.199");
+    InetAddress addr = createMockInetAddress("192.168.1.199");
    InetSocketAddress address = new InetSocketAddress(addr, 12345);
    when(channel.remoteAddress()).thenReturn(address);
    ForeignHostPermitHandler handler = new ForeignHostPermitHandler(QosConfiguration.builder().acceptForeignIp(false).acceptForeignIpWhitelist("175.23.44.1, 192.168.1.192/26").build());
    handler.handlerAdded(context);
    verify(context, never()).writeAndFlush(any());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void shouldNotShowIpNotPermittedMsg_GivenAcceptForeignIpFalseAndMatchWhiteListRange() throws Exception {
    ChannelHandlerContext context = mock(ChannelHandlerContext.class);
    Channel channel = mock(Channel.class);
    when(context.channel()).thenReturn(channel);
    InetAddress addr = mock(InetAddress.class);
    when(addr.isLoopbackAddress()).thenReturn(false);
    when(addr.getHostAddress()).thenReturn("192.168.1.199");
    InetSocketAddress address = new InetSocketAddress(addr, 12345);
    when(channel.remoteAddress()).thenReturn(address);
    ForeignHostPermitHandler handler = new ForeignHostPermitHandler(QosConfiguration.builder().acceptForeignIp(false).acceptForeignIpWhitelist("175.23.44.1, 192.168.1.192/26").build());
    handler.handlerAdded(context);
    verify(context, never()).writeAndFlush(any());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static InetAddress createMockInetAddress(String hostAddressReturn) {
    InetAddress addr = mock(InetAddress.class);
    when(addr.isLoopbackAddress()).thenReturn(false);
    when(addr.getHostAddress()).thenReturn(hostAddressReturn);
    return addr;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_9
- **Scope**: method level
- **Mocked Class**: `java.net.InetAddress`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static InetAddress createMockInetAddress(String hostAddressReturn) {
    InetAddress address = mock(InetAddress.class);
    when(address.getHostAddress()).thenReturn(hostAddressReturn);
    return address;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_9_1
#### Test Case Name: `testIsValidAddress`(File: `C:\Java_projects\Apache\dubbo\dubbo-common\src\test\java\org\apache\dubbo\common\utils\NetUtilsTest.java`)
#### Mock Object Variable Name: `address`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 void testIsValidAddress() {
     assertFalse(NetUtils.isValidV4Address((InetAddress) null));
-    InetAddress address = mock(InetAddress.class);
-    when(address.isLoopbackAddress()).thenReturn(true);
+    InetAddress address = mock(InetAddress.class);
+    when(address.isLoopbackAddress()).thenReturn(true);
     assertFalse(NetUtils.isValidV4Address(address));
-    address = mock(InetAddress.class);
-    when(address.getHostAddress()).thenReturn("localhost");
+    address = createMockInetAddress("localhost");
     assertFalse(NetUtils.isValidV4Address(address));
-    address = mock(InetAddress.class);
-    when(address.getHostAddress()).thenReturn("0.0.0.0");
+    address = createMockInetAddress("0.0.0.0");
     assertFalse(NetUtils.isValidV4Address(address));
-    address = mock(InetAddress.class);
-    when(address.getHostAddress()).thenReturn("127.0.0.1");
+    address = createMockInetAddress("127.0.0.1");
     assertFalse(NetUtils.isValidV4Address(address));
-    address = mock(InetAddress.class);
-    when(address.getHostAddress()).thenReturn("1.2.3.4");
+    address = createMockInetAddress("1.2.3.4");
     assertTrue(NetUtils.isValidV4Address(address));
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testIsValidAddress() {
    assertFalse(NetUtils.isValidV4Address((InetAddress) null));
    InetAddress address = mock(InetAddress.class);
    when(address.isLoopbackAddress()).thenReturn(true);
    assertFalse(NetUtils.isValidV4Address(address));
    address = mock(InetAddress.class);
    when(address.getHostAddress()).thenReturn("localhost");
    assertFalse(NetUtils.isValidV4Address(address));
    address = mock(InetAddress.class);
    when(address.getHostAddress()).thenReturn("0.0.0.0");
    assertFalse(NetUtils.isValidV4Address(address));
    address = mock(InetAddress.class);
    when(address.getHostAddress()).thenReturn("127.0.0.1");
    assertFalse(NetUtils.isValidV4Address(address));
    address = mock(InetAddress.class);
    when(address.getHostAddress()).thenReturn("1.2.3.4");
    assertTrue(NetUtils.isValidV4Address(address));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static InetAddress createMockInetAddress(String hostAddressReturn) {
    InetAddress address = mock(InetAddress.class);
    when(address.getHostAddress()).thenReturn(hostAddressReturn);
    return address;
}
```
</details>

---
#### Test Case ID #dubbo_Test_9_2
#### Test Case Name: `testToAddressString`(File: `C:\Java_projects\Apache\dubbo\dubbo-common\src\test\java\org\apache\dubbo\common\utils\NetUtilsTest.java`)
#### Mock Object Variable Name: `address`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void testToAddressString() {
-    InetAddress address = mock(InetAddress.class);
-    when(address.getHostAddress()).thenReturn("dubbo");
+    InetAddress address = createMockInetAddress("dubbo");
     InetSocketAddress socketAddress = new InetSocketAddress(address, 1234);
     assertThat(NetUtils.toAddressString(socketAddress), equalTo("dubbo:1234"));
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testToAddressString() {
    InetAddress address = mock(InetAddress.class);
    when(address.getHostAddress()).thenReturn("dubbo");
    InetSocketAddress socketAddress = new InetSocketAddress(address, 1234);
    assertThat(NetUtils.toAddressString(socketAddress), equalTo("dubbo:1234"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static InetAddress createMockInetAddress(String hostAddressReturn) {
    InetAddress address = mock(InetAddress.class);
    when(address.getHostAddress()).thenReturn(hostAddressReturn);
    return address;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_10
- **Scope**: class level
- **Mocked Class**: `org.apache.dubbo.rpc.protocol.tri.observer.ServerCallToObserverAdapter<java.lang.String>`
- **Test Case Count**: 3
- **MO Count**: 5

### Reusable Method
```java
public class MockServerCallToObserverAdapter {
    public static ServerCallToObserverAdapter<String> createMockServerCallToObserverAdapter(
            java.util.concurrent.atomic.AtomicInteger nextCounter,
            java.util.concurrent.atomic.AtomicInteger completeCounter,
            java.util.concurrent.atomic.AtomicInteger errorCounter) {
        ServerCallToObserverAdapter<String> responseObserver = Mockito.mock(ServerCallToObserverAdapter.class);
        doAnswer(o -> nextCounter.incrementAndGet()).when(responseObserver).onNext(anyString());
        doAnswer(o -> completeCounter.incrementAndGet()).when(responseObserver).onCompleted();
        doAnswer(o -> errorCounter.incrementAndGet()).when(responseObserver).onError(any(Throwable.class));
        return responseObserver;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_10_1
#### Test Case Name: `testInvoke`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-reactive\src\test\java\org\apache\dubbo\reactive\ManyToManyMethodHandlerTest.java`)
#### Mock Object Variable Name: `responseObserver`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    AtomicInteger nextCounter = new AtomicInteger();
    AtomicInteger completeCounter = new AtomicInteger();
    AtomicInteger errorCounter = new AtomicInteger();
-    ServerCallToObserverAdapter<String> responseObserver = Mockito.mock(ServerCallToObserverAdapter.class);
-    doAnswer(o -> nextCounter.incrementAndGet()).when(responseObserver).onNext(anyString());
-    doAnswer(o -> completeCounter.incrementAndGet()).when(responseObserver).onCompleted();
-    doAnswer(o -> errorCounter.incrementAndGet()).when(responseObserver).onError(any(Throwable.class));
+    ServerCallToObserverAdapter<String> responseObserver = MockServerCallToObserverAdapter.createMockServerCallToObserverAdapter(nextCounter, completeCounter, errorCounter);
    ManyToManyMethodHandler<String, String> handler = new ManyToManyMethodHandler<>(requestFlux -> requestFlux.map(r -> r + "0"));
    CompletableFuture<StreamObserver<String>> future = handler.invoke(new Object[] { responseObserver });
    StreamObserver<String> requestObserver = future.get();
    for (int i = 0; i < 10; i++) {
        requestObserver.onNext(String.valueOf(i));
    }
    requestObserver.onCompleted();
    Assertions.assertEquals(10, nextCounter.get());
    Assertions.assertEquals(0, errorCounter.get());
    Assertions.assertEquals(1, completeCounter.get());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testInvoke() throws ExecutionException, InterruptedException {
    AtomicInteger nextCounter = new AtomicInteger();
    AtomicInteger completeCounter = new AtomicInteger();
    AtomicInteger errorCounter = new AtomicInteger();
    ServerCallToObserverAdapter<String> responseObserver = Mockito.mock(ServerCallToObserverAdapter.class);
    doAnswer(o -> nextCounter.incrementAndGet()).when(responseObserver).onNext(anyString());
    doAnswer(o -> completeCounter.incrementAndGet()).when(responseObserver).onCompleted();
    doAnswer(o -> errorCounter.incrementAndGet()).when(responseObserver).onError(any(Throwable.class));
    ManyToManyMethodHandler<String, String> handler = new ManyToManyMethodHandler<>(requestFlux -> requestFlux.map(r -> r + "0"));
    CompletableFuture<StreamObserver<String>> future = handler.invoke(new Object[] { responseObserver });
    StreamObserver<String> requestObserver = future.get();
    for (int i = 0; i < 10; i++) {
        requestObserver.onNext(String.valueOf(i));
    }
    requestObserver.onCompleted();
    Assertions.assertEquals(10, nextCounter.get());
    Assertions.assertEquals(0, errorCounter.get());
    Assertions.assertEquals(1, completeCounter.get());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockServerCallToObserverAdapter {
    public static ServerCallToObserverAdapter<String> createMockServerCallToObserverAdapter(
            java.util.concurrent.atomic.AtomicInteger nextCounter,
            java.util.concurrent.atomic.AtomicInteger completeCounter,
            java.util.concurrent.atomic.AtomicInteger errorCounter) {
        ServerCallToObserverAdapter<String> responseObserver = Mockito.mock(ServerCallToObserverAdapter.class);
        doAnswer(o -> nextCounter.incrementAndGet()).when(responseObserver).onNext(anyString());
        doAnswer(o -> completeCounter.incrementAndGet()).when(responseObserver).onCompleted();
        doAnswer(o -> errorCounter.incrementAndGet()).when(responseObserver).onError(any(Throwable.class));
        return responseObserver;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_10_2
#### Test Case Name: `testInvoker`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-reactive\src\test\java\org\apache\dubbo\reactive\ManyToOneMethodHandlerTest.java`)
#### Mock Object Variable Name: `responseObserver`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    AtomicInteger nextCounter = new AtomicInteger();
    AtomicInteger completeCounter = new AtomicInteger();
    AtomicInteger errorCounter = new AtomicInteger();
-    ServerCallToObserverAdapter<String> responseObserver = Mockito.mock(ServerCallToObserverAdapter.class);
-    doAnswer(o -> nextCounter.incrementAndGet()).when(responseObserver).onNext(anyString());
-    doAnswer(o -> completeCounter.incrementAndGet()).when(responseObserver).onCompleted();
-    doAnswer(o -> errorCounter.incrementAndGet()).when(responseObserver).onError(any(Throwable.class));
+    ServerCallToObserverAdapter<String> responseObserver = MockServerCallToObserverAdapter.createMockServerCallToObserverAdapter(nextCounter, completeCounter, errorCounter);
    ManyToOneMethodHandler<String, String> handler = new ManyToOneMethodHandler<>(requestFlux -> requestFlux.map(Integer::valueOf).reduce(Integer::sum).map(String::valueOf));
    CompletableFuture<StreamObserver<String>> future = handler.invoke(new Object[] { responseObserver });
    StreamObserver<String> requestObserver = future.get();
    for (int i = 0; i < 10; i++) {
        requestObserver.onNext(String.valueOf(i));
    }
    requestObserver.onCompleted();
    Assertions.assertEquals(1, nextCounter.get());
    Assertions.assertEquals(0, errorCounter.get());
    Assertions.assertEquals(1, completeCounter.get());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testInvoker() throws ExecutionException, InterruptedException {
    AtomicInteger nextCounter = new AtomicInteger();
    AtomicInteger completeCounter = new AtomicInteger();
    AtomicInteger errorCounter = new AtomicInteger();
    ServerCallToObserverAdapter<String> responseObserver = Mockito.mock(ServerCallToObserverAdapter.class);
    doAnswer(o -> nextCounter.incrementAndGet()).when(responseObserver).onNext(anyString());
    doAnswer(o -> completeCounter.incrementAndGet()).when(responseObserver).onCompleted();
    doAnswer(o -> errorCounter.incrementAndGet()).when(responseObserver).onError(any(Throwable.class));
    ManyToOneMethodHandler<String, String> handler = new ManyToOneMethodHandler<>(requestFlux -> requestFlux.map(Integer::valueOf).reduce(Integer::sum).map(String::valueOf));
    CompletableFuture<StreamObserver<String>> future = handler.invoke(new Object[] { responseObserver });
    StreamObserver<String> requestObserver = future.get();
    for (int i = 0; i < 10; i++) {
        requestObserver.onNext(String.valueOf(i));
    }
    requestObserver.onCompleted();
    Assertions.assertEquals(1, nextCounter.get());
    Assertions.assertEquals(0, errorCounter.get());
    Assertions.assertEquals(1, completeCounter.get());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockServerCallToObserverAdapter {
    public static ServerCallToObserverAdapter<String> createMockServerCallToObserverAdapter(
            java.util.concurrent.atomic.AtomicInteger nextCounter,
            java.util.concurrent.atomic.AtomicInteger completeCounter,
            java.util.concurrent.atomic.AtomicInteger errorCounter) {
        ServerCallToObserverAdapter<String> responseObserver = Mockito.mock(ServerCallToObserverAdapter.class);
        doAnswer(o -> nextCounter.incrementAndGet()).when(responseObserver).onNext(anyString());
        doAnswer(o -> completeCounter.incrementAndGet()).when(responseObserver).onCompleted();
        doAnswer(o -> errorCounter.incrementAndGet()).when(responseObserver).onError(any(Throwable.class));
        return responseObserver;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_10_3
#### Test Case Name: `testError`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-reactive\src\test\java\org\apache\dubbo\reactive\ManyToOneMethodHandlerTest.java`)
#### Mock Object Variable Name: `responseObserver`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    AtomicInteger nextCounter = new AtomicInteger();
    AtomicInteger completeCounter = new AtomicInteger();
    AtomicInteger errorCounter = new AtomicInteger();
-    ServerCallToObserverAdapter<String> responseObserver = Mockito.mock(ServerCallToObserverAdapter.class);
-    doAnswer(o -> nextCounter.incrementAndGet()).when(responseObserver).onNext(anyString());
-    doAnswer(o -> completeCounter.incrementAndGet()).when(responseObserver).onCompleted();
-    doAnswer(o -> errorCounter.incrementAndGet()).when(responseObserver).onError(any(Throwable.class));
+    ServerCallToObserverAdapter<String> responseObserver = MockServerCallToObserverAdapter.createMockServerCallToObserverAdapter(nextCounter, completeCounter, errorCounter);
    ManyToOneMethodHandler<String, String> handler = new ManyToOneMethodHandler<>(requestFlux -> requestFlux.map(Integer::valueOf).reduce(Integer::sum).map(String::valueOf));
    CompletableFuture<StreamObserver<String>> future = handler.invoke(new Object[] { responseObserver });
    StreamObserver<String> requestObserver = future.get();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testError() throws ExecutionException, InterruptedException {
    AtomicInteger nextCounter = new AtomicInteger();
    AtomicInteger completeCounter = new AtomicInteger();
    AtomicInteger errorCounter = new AtomicInteger();
    ServerCallToObserverAdapter<String> responseObserver = Mockito.mock(ServerCallToObserverAdapter.class);
    doAnswer(o -> nextCounter.incrementAndGet()).when(responseObserver).onNext(anyString());
    doAnswer(o -> completeCounter.incrementAndGet()).when(responseObserver).onCompleted();
    doAnswer(o -> errorCounter.incrementAndGet()).when(responseObserver).onError(any(Throwable.class));
    ManyToOneMethodHandler<String, String> handler = new ManyToOneMethodHandler<>(requestFlux -> requestFlux.map(Integer::valueOf).reduce(Integer::sum).map(String::valueOf));
    CompletableFuture<StreamObserver<String>> future = handler.invoke(new Object[] { responseObserver });
    StreamObserver<String> requestObserver = future.get();
    for (int i = 0; i < 10; i++) {
        if (i == 6) {
            requestObserver.onError(new Throwable());
        }
        requestObserver.onNext(String.valueOf(i));
    }
    requestObserver.onCompleted();
    Assertions.assertEquals(0, nextCounter.get());
    Assertions.assertEquals(1, errorCounter.get());
    Assertions.assertEquals(0, completeCounter.get());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockServerCallToObserverAdapter {
    public static ServerCallToObserverAdapter<String> createMockServerCallToObserverAdapter(
            java.util.concurrent.atomic.AtomicInteger nextCounter,
            java.util.concurrent.atomic.AtomicInteger completeCounter,
            java.util.concurrent.atomic.AtomicInteger errorCounter) {
        ServerCallToObserverAdapter<String> responseObserver = Mockito.mock(ServerCallToObserverAdapter.class);
        doAnswer(o -> nextCounter.incrementAndGet()).when(responseObserver).onNext(anyString());
        doAnswer(o -> completeCounter.incrementAndGet()).when(responseObserver).onCompleted();
        doAnswer(o -> errorCounter.incrementAndGet()).when(responseObserver).onError(any(Throwable.class));
        return responseObserver;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_10_4
#### Test Case Name: `testInvoke`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-reactive\src\test\java\org\apache\dubbo\reactive\OneToManyMethodHandlerTest.java`)
#### Mock Object Variable Name: `responseObserver`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    AtomicInteger nextCounter = new AtomicInteger();
    AtomicInteger completeCounter = new AtomicInteger();
    AtomicInteger errorCounter = new AtomicInteger();
-    ServerCallToObserverAdapter<String> responseObserver = Mockito.mock(ServerCallToObserverAdapter.class);
-    doAnswer(o -> nextCounter.incrementAndGet()).when(responseObserver).onNext(anyString());
-    doAnswer(o -> completeCounter.incrementAndGet()).when(responseObserver).onCompleted();
-    doAnswer(o -> errorCounter.incrementAndGet()).when(responseObserver).onError(any(Throwable.class));
+    ServerCallToObserverAdapter<String> responseObserver = MockServerCallToObserverAdapter.createMockServerCallToObserverAdapter(nextCounter, completeCounter, errorCounter);
    OneToManyMethodHandler<String, String> handler = new OneToManyMethodHandler<>(requestMono -> requestMono.flatMapMany(r -> Flux.fromArray(r.split(","))));
    CompletableFuture<?> future = handler.invoke(new Object[] { request, responseObserver });
    Assertions.assertTrue(future.isDone());
    Assertions.assertEquals(7, nextCounter.get());
    Assertions.assertEquals(0, errorCounter.get());
    Assertions.assertEquals(1, completeCounter.get());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testInvoke() {
    String request = "1,2,3,4,5,6,7";
    AtomicInteger nextCounter = new AtomicInteger();
    AtomicInteger completeCounter = new AtomicInteger();
    AtomicInteger errorCounter = new AtomicInteger();
    ServerCallToObserverAdapter<String> responseObserver = Mockito.mock(ServerCallToObserverAdapter.class);
    doAnswer(o -> nextCounter.incrementAndGet()).when(responseObserver).onNext(anyString());
    doAnswer(o -> completeCounter.incrementAndGet()).when(responseObserver).onCompleted();
    doAnswer(o -> errorCounter.incrementAndGet()).when(responseObserver).onError(any(Throwable.class));
    OneToManyMethodHandler<String, String> handler = new OneToManyMethodHandler<>(requestMono -> requestMono.flatMapMany(r -> Flux.fromArray(r.split(","))));
    CompletableFuture<?> future = handler.invoke(new Object[] { request, responseObserver });
    Assertions.assertTrue(future.isDone());
    Assertions.assertEquals(7, nextCounter.get());
    Assertions.assertEquals(0, errorCounter.get());
    Assertions.assertEquals(1, completeCounter.get());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockServerCallToObserverAdapter {
    public static ServerCallToObserverAdapter<String> createMockServerCallToObserverAdapter(
            java.util.concurrent.atomic.AtomicInteger nextCounter,
            java.util.concurrent.atomic.AtomicInteger completeCounter,
            java.util.concurrent.atomic.AtomicInteger errorCounter) {
        ServerCallToObserverAdapter<String> responseObserver = Mockito.mock(ServerCallToObserverAdapter.class);
        doAnswer(o -> nextCounter.incrementAndGet()).when(responseObserver).onNext(anyString());
        doAnswer(o -> completeCounter.incrementAndGet()).when(responseObserver).onCompleted();
        doAnswer(o -> errorCounter.incrementAndGet()).when(responseObserver).onError(any(Throwable.class));
        return responseObserver;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_10_5
#### Test Case Name: `testError`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-reactive\src\test\java\org\apache\dubbo\reactive\OneToManyMethodHandlerTest.java`)
#### Mock Object Variable Name: `responseObserver`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    AtomicInteger nextCounter = new AtomicInteger();
    AtomicInteger completeCounter = new AtomicInteger();
    AtomicInteger errorCounter = new AtomicInteger();
-    ServerCallToObserverAdapter<String> responseObserver = Mockito.mock(ServerCallToObserverAdapter.class);
-    doAnswer(o -> nextCounter.incrementAndGet()).when(responseObserver).onNext(anyString());
-    doAnswer(o -> completeCounter.incrementAndGet()).when(responseObserver).onCompleted();
-    doAnswer(o -> errorCounter.incrementAndGet()).when(responseObserver).onError(any(Throwable.class));
+    ServerCallToObserverAdapter<String> responseObserver = MockServerCallToObserverAdapter.createMockServerCallToObserverAdapter(nextCounter, completeCounter, errorCounter);
    OneToManyMethodHandler<String, String> handler = new OneToManyMethodHandler<>(requestMono -> Flux.create(emitter -> {
        for (int i = 0; i < 10; i++) {
            if (i == 6) {
                emitter.error(new Throwable());
            } else {
                emitter.next(String.valueOf(i));
            }
        }
    }));
    CompletableFuture<?> future = handler.invoke(new Object[] { request, responseObserver });
    Assertions.assertTrue(future.isDone());
    Assertions.assertEquals(6, nextCounter.get());
    Assertions.assertEquals(1, errorCounter.get());
    Assertions.assertEquals(0, completeCounter.get());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testError() {
    String request = "1,2,3,4,5,6,7";
    AtomicInteger nextCounter = new AtomicInteger();
    AtomicInteger completeCounter = new AtomicInteger();
    AtomicInteger errorCounter = new AtomicInteger();
    ServerCallToObserverAdapter<String> responseObserver = Mockito.mock(ServerCallToObserverAdapter.class);
    doAnswer(o -> nextCounter.incrementAndGet()).when(responseObserver).onNext(anyString());
    doAnswer(o -> completeCounter.incrementAndGet()).when(responseObserver).onCompleted();
    doAnswer(o -> errorCounter.incrementAndGet()).when(responseObserver).onError(any(Throwable.class));
    OneToManyMethodHandler<String, String> handler = new OneToManyMethodHandler<>(requestMono -> Flux.create(emitter -> {
        for (int i = 0; i < 10; i++) {
            if (i == 6) {
                emitter.error(new Throwable());
            } else {
                emitter.next(String.valueOf(i));
            }
        }
    }));
    CompletableFuture<?> future = handler.invoke(new Object[] { request, responseObserver });
    Assertions.assertTrue(future.isDone());
    Assertions.assertEquals(6, nextCounter.get());
    Assertions.assertEquals(1, errorCounter.get());
    Assertions.assertEquals(0, completeCounter.get());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockServerCallToObserverAdapter {
    public static ServerCallToObserverAdapter<String> createMockServerCallToObserverAdapter(
            java.util.concurrent.atomic.AtomicInteger nextCounter,
            java.util.concurrent.atomic.AtomicInteger completeCounter,
            java.util.concurrent.atomic.AtomicInteger errorCounter) {
        ServerCallToObserverAdapter<String> responseObserver = Mockito.mock(ServerCallToObserverAdapter.class);
        doAnswer(o -> nextCounter.incrementAndGet()).when(responseObserver).onNext(anyString());
        doAnswer(o -> completeCounter.incrementAndGet()).when(responseObserver).onCompleted();
        doAnswer(o -> errorCounter.incrementAndGet()).when(responseObserver).onError(any(Throwable.class));
        return responseObserver;
    }
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_11
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.common.URL`
- **Test Case Count**: 5
- **MO Count**: 5

### Reusable Method
```java
private static URL createMockUrl(ConsumerModel consumerModel) {
    URL url = Mockito.mock(URL.class);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    return url;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_11_1
#### Test Case Name: `unaryCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `url`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
-    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
+    URL url = createMockUrl(consumerModel);
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void unaryCall() throws Throwable {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    when(invoker.invoke(any(Invocation.class))).thenReturn(result);
    String response = "response";
    when(result.recreate()).thenReturn(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    Object ret = StubInvocationUtil.unaryCall(invoker, method, request);
    Assertions.assertEquals(response, ret);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static URL createMockUrl(ConsumerModel consumerModel) {
    URL url = Mockito.mock(URL.class);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    return url;
}
```
</details>

---
#### Test Case ID #dubbo_Test_11_2
#### Test Case Name: `unaryCall2`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `url`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
-    URL url = Mockito.mock(URL.class);
-    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
+    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
+    URL url = createMockUrl(consumerModel);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
-    when(url.getServiceModel()).thenReturn(consumerModel);
-    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
-    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void unaryCall2() throws Throwable {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    when(invoker.invoke(any(Invocation.class))).thenThrow(new RuntimeException("a")).thenThrow(new Error("b"));
    String response = "response";
    when(result.recreate()).thenReturn(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    try {
        StubInvocationUtil.unaryCall(invoker, method, request);
        fail();
    } catch (Throwable t) {
        // pass
    }
    try {
        StubInvocationUtil.unaryCall(invoker, method, request);
        fail();
    } catch (Throwable t) {
        // pass
    }
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static URL createMockUrl(ConsumerModel consumerModel) {
    URL url = Mockito.mock(URL.class);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    return url;
}
```
</details>

---
#### Test Case ID #dubbo_Test_11_3
#### Test Case Name: `testUnaryCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `url`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
-    URL url = Mockito.mock(URL.class);
+    URL url = createMockUrl(consumerModel);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
-    when(url.getServiceModel()).thenReturn(consumerModel);
-    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
-    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testUnaryCall() throws Throwable {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> result);
    when(result.recreate()).thenReturn(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    CountDownLatch latch = new CountDownLatch(1);
    AtomicReference<Object> atomicReference = new AtomicReference<>();
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            atomicReference.set(data);
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StubInvocationUtil.unaryCall(invoker, method, request, responseObserver);
    latch.await(1, TimeUnit.SECONDS);
    Assertions.assertEquals(response, atomicReference.get());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static URL createMockUrl(ConsumerModel consumerModel) {
    URL url = Mockito.mock(URL.class);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    return url;
}
```
</details>

---
#### Test Case ID #dubbo_Test_11_4
#### Test Case Name: `biOrClientStreamCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `url`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
-    URL url = Mockito.mock(URL.class);
+    URL url = createMockUrl(consumerModel);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
-    when(url.getServiceModel()).thenReturn(consumerModel);
-    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
-    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void biOrClientStreamCall() throws InterruptedException {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> {
        Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];
        StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[0];
        observer.onNext(response);
        observer.onCompleted();
        when(result.recreate()).then(invocationOnMock1 -> new StreamObserver<Object>() {

            @Override
            public void onNext(Object data) {
                observer.onNext(data);
            }

            @Override
            public void onError(Throwable throwable) {
            }

            @Override
            public void onCompleted() {
                observer.onCompleted();
            }
        });
        return result;
    });
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    CountDownLatch latch = new CountDownLatch(11);
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            latch.countDown();
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StreamObserver<Object> observer = StubInvocationUtil.biOrClientStreamCall(invoker, method, responseObserver);
    for (int i = 0; i < 10; i++) {
        observer.onNext(request);
    }
    observer.onCompleted();
    Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static URL createMockUrl(ConsumerModel consumerModel) {
    URL url = Mockito.mock(URL.class);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    return url;
}
```
</details>

---
#### Test Case ID #dubbo_Test_11_5
#### Test Case Name: `serverStreamCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `url`
<summary>Suggested Diff</summary>

```diff
@@
 void serverStreamCall() throws InterruptedException {
     Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
-    URL url = Mockito.mock(URL.class);
     ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
     ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
     when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
+    URL url = createMockUrl(consumerModel);
     when(invoker.getUrl()).thenReturn(url);
     when(invoker.getInterface()).thenReturn(IGreeter.class);
     Result result = Mockito.mock(Result.class);
     String response = "response";
     when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> {
         Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];
         StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[1];
         for (int i = 0; i < 10; i++) {
             observer.onNext(response);
         }
         observer.onCompleted();
         return result;
     });
     MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
     when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
     when(method.getMethodName()).thenReturn("sayHello");
     String request = "request";
     CountDownLatch latch = new CountDownLatch(11);
     StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

         @Override
         public void onNext(Object data) {
             latch.countDown();
         }

         @Override
         public void onError(Throwable throwable) {
         }

         @Override
         public void onCompleted() {
             latch.countDown();
         }
     };
     StubInvocationUtil.serverStreamCall(invoker, method, request, responseObserver);
     Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void serverStreamCall() throws InterruptedException {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> {
        Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];
        StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[1];
        for (int i = 0; i < 10; i++) {
            observer.onNext(response);
        }
        observer.onCompleted();
        return result;
    });
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    CountDownLatch latch = new CountDownLatch(11);
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            latch.countDown();
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StubInvocationUtil.serverStreamCall(invoker, method, request, responseObserver);
    Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static URL createMockUrl(ConsumerModel consumerModel) {
    URL url = Mockito.mock(URL.class);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    return url;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_12
- **Scope**: class level
- **Mocked Class**: `org.apache.dubbo.common.URL`
- **Test Case Count**: 1
- **MO Count**: 2

### Reusable Method
```java
public class MockURL {
    public static URL createMockURL(ProviderModel providerModel) {
        URL url = Mockito.mock(URL.class);
        when(url.getServiceModel()).thenReturn(providerModel);
        return url;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_12_1
#### Test Case Name: `doStartCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\protocol\tri\call\ReflectionServerCallTest.java`)
#### Mock Object Variable Name: `url`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Method method = DescriptorService.class.getMethod("sayHello", HelloReply.class);
    MethodDescriptor methodDescriptor = new ReflectionMethodDescriptor(method);
-    URL url = Mockito.mock(URL.class);
+    URL url = MockURL.createMockURL(providerModel);
    when(invoker.getUrl()).thenReturn(url);
-    when(url.getServiceModel()).thenReturn(providerModel);
    String service = "testService";
    String methodName = "method";
    try {
        ReflectionAbstractServerCall call = new ReflectionAbstractServerCall(invoker, serverStream, new FrameworkModel(), "", service, methodName, Collections.emptyList(), ImmediateEventExecutor.INSTANCE);
        fail();
    } catch (Exception e) {
        // pass
    }
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(serviceDescriptor.getMethods(anyString())).thenReturn(Collections.singletonList(methodDescriptor));
    when(providerModel.getServiceModel()).thenReturn(serviceDescriptor);
    ReflectionAbstractServerCall call2 = new ReflectionAbstractServerCall(invoker, serverStream, new FrameworkModel(), "", service, methodName, Collections.emptyList(), ImmediateEventExecutor.INSTANCE);
    call2.onHeader(Collections.emptyMap());
    call2.onMessage(new byte[0], false);
    call2.onComplete();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void doStartCall() throws NoSuchMethodException {
    Invoker<?> invoker = Mockito.mock(Invoker.class);
    TripleServerStream serverStream = Mockito.mock(TripleServerStream.class);
    ProviderModel providerModel = Mockito.mock(ProviderModel.class);
    Method method = DescriptorService.class.getMethod("sayHello", HelloReply.class);
    MethodDescriptor methodDescriptor = new ReflectionMethodDescriptor(method);
    URL url = Mockito.mock(URL.class);
    when(invoker.getUrl()).thenReturn(url);
    when(url.getServiceModel()).thenReturn(providerModel);
    String service = "testService";
    String methodName = "method";
    try {
        ReflectionAbstractServerCall call = new ReflectionAbstractServerCall(invoker, serverStream, new FrameworkModel(), "", service, methodName, Collections.emptyList(), ImmediateEventExecutor.INSTANCE);
        fail();
    } catch (Exception e) {
        // pass
    }
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(serviceDescriptor.getMethods(anyString())).thenReturn(Collections.singletonList(methodDescriptor));
    when(providerModel.getServiceModel()).thenReturn(serviceDescriptor);
    ReflectionAbstractServerCall call2 = new ReflectionAbstractServerCall(invoker, serverStream, new FrameworkModel(), "", service, methodName, Collections.emptyList(), ImmediateEventExecutor.INSTANCE);
    call2.onHeader(Collections.emptyMap());
    call2.onMessage(new byte[0], false);
    call2.onComplete();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockURL {
    public static URL createMockURL(ProviderModel providerModel) {
        URL url = Mockito.mock(URL.class);
        when(url.getServiceModel()).thenReturn(providerModel);
        return url;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_12_2
#### Test Case Name: `doStartCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\protocol\tri\call\StubServerCallTest.java`)
#### Mock Object Variable Name: `url`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    StubMethodDescriptor methodDescriptor = Mockito.mock(StubMethodDescriptor.class);
-    URL url = Mockito.mock(URL.class);
-    when(invoker.getUrl()).thenReturn(url);
-    when(url.getServiceModel()).thenReturn(providerModel);
+    URL url = MockURL.createMockURL(providerModel);
+    when(invoker.getUrl()).thenReturn(url);
    when(providerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(serviceDescriptor.getMethods(anyString())).thenReturn(Collections.singletonList(methodDescriptor));
    when(methodDescriptor.getRpcType()).thenReturn(RpcType.UNARY);
    when(methodDescriptor.parseRequest(any(byte[].class))).thenReturn("test");
    String service = "testService";
    String method = "method";
    StubAbstractServerCall call = new StubAbstractServerCall(invoker, tripleServerStream, new FrameworkModel(), "", service, method, ImmediateEventExecutor.INSTANCE);
    call.onHeader(Collections.emptyMap());
    call.onMessage(new byte[0], false);
    call.onComplete();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void doStartCall() throws IOException, ClassNotFoundException {
    Invoker<?> invoker = Mockito.mock(Invoker.class);
    TripleServerStream tripleServerStream = Mockito.mock(TripleServerStream.class);
    ProviderModel providerModel = Mockito.mock(ProviderModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    StubMethodDescriptor methodDescriptor = Mockito.mock(StubMethodDescriptor.class);
    URL url = Mockito.mock(URL.class);
    when(invoker.getUrl()).thenReturn(url);
    when(url.getServiceModel()).thenReturn(providerModel);
    when(providerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(serviceDescriptor.getMethods(anyString())).thenReturn(Collections.singletonList(methodDescriptor));
    when(methodDescriptor.getRpcType()).thenReturn(RpcType.UNARY);
    when(methodDescriptor.parseRequest(any(byte[].class))).thenReturn("test");
    String service = "testService";
    String method = "method";
    StubAbstractServerCall call = new StubAbstractServerCall(invoker, tripleServerStream, new FrameworkModel(), "", service, method, ImmediateEventExecutor.INSTANCE);
    call.onHeader(Collections.emptyMap());
    call.onMessage(new byte[0], false);
    call.onComplete();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockURL {
    public static URL createMockURL(ProviderModel providerModel) {
        URL url = Mockito.mock(URL.class);
        when(url.getServiceModel()).thenReturn(providerModel);
        return url;
    }
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_13
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.common.URL`
- **Test Case Count**: 3
- **MO Count**: 4

### Reusable Method
```java
private static org.apache.dubbo.common.URL createMockUrl(String serviceKeyReturn, String getParameterKey, String getParameterReturn) {
    org.apache.dubbo.common.URL url = Mockito.mock(org.apache.dubbo.common.URL.class);
    Mockito.when(url.getServiceKey()).thenReturn(serviceKeyReturn);
    Mockito.when(url.getParameter(getParameterKey)).thenReturn(getParameterReturn);
    return url;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_13_1
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationRuleListenerTest.java`)
#### Mock Object Variable Name: `consumerURL`
<summary>Suggested Diff</summary>

```diff
@@
    applicationConfig.setName("demo-consumer");
    ApplicationModel.defaultModel().getApplicationConfigManager().setApplication(applicationConfig);
-    URL consumerURL = Mockito.mock(URL.class);
-    Mockito.when(consumerURL.getServiceKey()).thenReturn("Test");
-    Mockito.when(consumerURL.getParameter("timestamp")).thenReturn("1");
+    URL consumerURL = createMockUrl("Test", "timestamp", "1");
    System.setProperty("dubbo.application.migration.delay", "1");
    MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
    CountDownLatch countDownLatch = new CountDownLatch(1);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Listener started with config center and local rule, no initial remote rule.
 * Check local rule take effect
 */
@Test
void test() {
    DynamicConfiguration dynamicConfiguration = Mockito.mock(DynamicConfiguration.class);
    ApplicationModel.reset();
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setDynamicConfiguration(dynamicConfiguration);
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setLocalMigrationRule(localRule);
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("demo-consumer");
    ApplicationModel.defaultModel().getApplicationConfigManager().setApplication(applicationConfig);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Test");
    Mockito.when(consumerURL.getParameter("timestamp")).thenReturn("1");
    System.setProperty("dubbo.application.migration.delay", "1");
    MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
    CountDownLatch countDownLatch = new CountDownLatch(1);
    MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule()) {

        @Override
        public synchronized void process(ConfigChangedEvent event) {
            try {
                countDownLatch.await();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            super.process(event);
        }
    };
    MigrationInvoker<?> migrationInvoker = Mockito.mock(MigrationInvoker.class);
    migrationRuleListener.getHandlers().put(migrationInvoker, handler);
    countDownLatch.countDown();
    await().untilAsserted(() -> {
        Mockito.verify(handler).doMigrate(Mockito.any());
    });
    //        Mockito.verify(handler, Mockito.timeout(5000)).doMigrate(Mockito.any());
    migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);
    Mockito.verify(handler, Mockito.times(2)).doMigrate(Mockito.any());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static org.apache.dubbo.common.URL createMockUrl(String serviceKeyReturn, String getParameterKey, String getParameterReturn) {
    org.apache.dubbo.common.URL url = Mockito.mock(org.apache.dubbo.common.URL.class);
    Mockito.when(url.getServiceKey()).thenReturn(serviceKeyReturn);
    Mockito.when(url.getParameter(getParameterKey)).thenReturn(getParameterReturn);
    return url;
}
```
</details>

---
#### Test Case ID #dubbo_Test_13_2
#### Test Case Name: `testWithInitAndNoLocalRule`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationRuleListenerTest.java`)
#### Mock Object Variable Name: `consumerURL`
<summary>Suggested Diff</summary>

```diff
@@
     applicationConfig.setName("demo-consumer");
     ApplicationModel.defaultModel().getApplicationConfigManager().setApplication(applicationConfig);
-    URL consumerURL = Mockito.mock(URL.class);
-    Mockito.when(consumerURL.getServiceKey()).thenReturn("Test");
-    Mockito.when(consumerURL.getParameter("timestamp")).thenReturn("1");
+    URL consumerURL = createMockUrl("Test", "timestamp", "1");
     System.setProperty("dubbo.application.migration.delay", "1000");
     MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
     MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule());
     MigrationInvoker<?> migrationInvoker = Mockito.mock(MigrationInvoker.class);
     migrationRuleListener.getHandlers().put(migrationInvoker, handler);
     migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);
     // check migration happened after invoker referred
     Mockito.verify(handler, Mockito.times(1)).doMigrate(MigrationRule.getInitRule());
     // check no delay tasks created for there's no local rule and no config center
     Assertions.assertNull(migrationRuleListener.localRuleMigrationFuture);
     Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);
     Assertions.assertEquals(0, migrationRuleListener.ruleQueue.size());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Test listener started without local rule and config center, INIT should be used and no scheduled task should be started.
 */
@Test
void testWithInitAndNoLocalRule() {
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setDynamicConfiguration(null);
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setLocalMigrationRule("");
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("demo-consumer");
    ApplicationModel.defaultModel().getApplicationConfigManager().setApplication(applicationConfig);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Test");
    Mockito.when(consumerURL.getParameter("timestamp")).thenReturn("1");
    System.setProperty("dubbo.application.migration.delay", "1000");
    MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
    MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule());
    MigrationInvoker<?> migrationInvoker = Mockito.mock(MigrationInvoker.class);
    migrationRuleListener.getHandlers().put(migrationInvoker, handler);
    migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);
    // check migration happened after invoker referred
    Mockito.verify(handler, Mockito.times(1)).doMigrate(MigrationRule.getInitRule());
    // check no delay tasks created for there's no local rule and no config center
    Assertions.assertNull(migrationRuleListener.localRuleMigrationFuture);
    Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);
    Assertions.assertEquals(0, migrationRuleListener.ruleQueue.size());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static org.apache.dubbo.common.URL createMockUrl(String serviceKeyReturn, String getParameterKey, String getParameterReturn) {
    org.apache.dubbo.common.URL url = Mockito.mock(org.apache.dubbo.common.URL.class);
    Mockito.when(url.getServiceKey()).thenReturn(serviceKeyReturn);
    Mockito.when(url.getParameter(getParameterKey)).thenReturn(getParameterReturn);
    return url;
}
```
</details>

---
#### Test Case ID #dubbo_Test_13_3
#### Test Case Name: `testWithConfigurationListenerAndLocalRule`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationRuleListenerTest.java`)
#### Mock Object Variable Name: `consumerURL`
<summary>Suggested Diff</summary>

```diff
@@
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("demo-consumer");
    ApplicationModel.defaultModel().getApplicationConfigManager().setApplication(applicationConfig);
-    URL consumerURL = Mockito.mock(URL.class);
-    Mockito.when(consumerURL.getServiceKey()).thenReturn("Test");
-    Mockito.when(consumerURL.getParameter("timestamp")).thenReturn("1");
+    URL consumerURL = createMockUrl("Test", "timestamp", "1");
    URL consumerURL2 = Mockito.mock(URL.class);
    Mockito.when(consumerURL2.getServiceKey()).thenReturn("Test2");
    Mockito.when(consumerURL2.getParameter("timestamp")).thenReturn("2");
    System.setProperty("dubbo.application.migration.delay", "10");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Listener with config center initial remote rule and local rule, check
 * 1. initial remote rule other than local rule take effect
 * 2. remote rule change and all invokers gets notified
 */
@Test
void testWithConfigurationListenerAndLocalRule() {
    DynamicConfiguration dynamicConfiguration = Mockito.mock(DynamicConfiguration.class);
    Mockito.doReturn(remoteRule).when(dynamicConfiguration).getConfig(Mockito.anyString(), Mockito.anyString());
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setDynamicConfiguration(dynamicConfiguration);
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setLocalMigrationRule(localRule);
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("demo-consumer");
    ApplicationModel.defaultModel().getApplicationConfigManager().setApplication(applicationConfig);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Test");
    Mockito.when(consumerURL.getParameter("timestamp")).thenReturn("1");
    URL consumerURL2 = Mockito.mock(URL.class);
    Mockito.when(consumerURL2.getServiceKey()).thenReturn("Test2");
    Mockito.when(consumerURL2.getParameter("timestamp")).thenReturn("2");
    System.setProperty("dubbo.application.migration.delay", "10");
    MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
    MigrationRuleHandler<?> handler2 = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
    // Both local rule and remote rule are here
    // Local rule with one delayed task started to apply
    MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule());
    Assertions.assertNotNull(migrationRuleListener.localRuleMigrationFuture);
    Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);
    MigrationInvoker<?> migrationInvoker = Mockito.mock(MigrationInvoker.class);
    MigrationInvoker<?> migrationInvoker2 = Mockito.mock(MigrationInvoker.class);
    // Remote rule will be applied when onRefer gets executed
    migrationRuleListener.getHandlers().put(migrationInvoker, handler);
    migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);
    MigrationRule tmpRemoteRule = migrationRuleListener.getRule();
    ArgumentCaptor<MigrationRule> captor = ArgumentCaptor.forClass(MigrationRule.class);
    Mockito.verify(handler, Mockito.times(1)).doMigrate(captor.capture());
    Assertions.assertEquals(tmpRemoteRule, captor.getValue());
    await().until(() -> migrationRuleListener.localRuleMigrationFuture.isDone());
    Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);
    Assertions.assertEquals(tmpRemoteRule, migrationRuleListener.getRule());
    Mockito.verify(handler, Mockito.times(1)).doMigrate(Mockito.any());
    ArgumentCaptor<MigrationRule> captor2 = ArgumentCaptor.forClass(MigrationRule.class);
    migrationRuleListener.getHandlers().put(migrationInvoker2, handler2);
    migrationRuleListener.onRefer(null, migrationInvoker2, consumerURL2, null);
    Mockito.verify(handler2, Mockito.times(1)).doMigrate(captor2.capture());
    Assertions.assertEquals(tmpRemoteRule, captor2.getValue());
    migrationRuleListener.process(new ConfigChangedEvent("key", "group", dynamicRemoteRule));
    await().until(migrationRuleListener.ruleQueue::isEmpty);
    await().untilAsserted(() -> {
        Mockito.verify(handler, Mockito.times(2)).doMigrate(Mockito.any());
        Mockito.verify(handler2, Mockito.times(2)).doMigrate(Mockito.any());
    });
    Assertions.assertNotNull(migrationRuleListener.ruleMigrationFuture);
    ArgumentCaptor<MigrationRule> captor_event = ArgumentCaptor.forClass(MigrationRule.class);
    Mockito.verify(handler, Mockito.times(2)).doMigrate(captor_event.capture());
    Assertions.assertEquals("APPLICATION_FIRST", captor_event.getValue().getStep().toString());
    Mockito.verify(handler2, Mockito.times(2)).doMigrate(captor_event.capture());
    Assertions.assertEquals("APPLICATION_FIRST", captor_event.getValue().getStep().toString());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static org.apache.dubbo.common.URL createMockUrl(String serviceKeyReturn, String getParameterKey, String getParameterReturn) {
    org.apache.dubbo.common.URL url = Mockito.mock(org.apache.dubbo.common.URL.class);
    Mockito.when(url.getServiceKey()).thenReturn(serviceKeyReturn);
    Mockito.when(url.getParameter(getParameterKey)).thenReturn(getParameterReturn);
    return url;
}
```
</details>

---
#### Test Case ID #dubbo_Test_13_4
#### Test Case Name: `testWithConfigurationListenerAndLocalRule`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationRuleListenerTest.java`)
#### Mock Object Variable Name: `consumerURL2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Test");
    Mockito.when(consumerURL.getParameter("timestamp")).thenReturn("1");
-    URL consumerURL2 = Mockito.mock(URL.class);
-    Mockito.when(consumerURL2.getServiceKey()).thenReturn("Test2");
-    Mockito.when(consumerURL2.getParameter("timestamp")).thenReturn("2");
+    URL consumerURL2 = createMockUrl("Test2", "timestamp", "2");
    System.setProperty("dubbo.application.migration.delay", "10");
    MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
    MigrationRuleHandler<?> handler2 = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Listener with config center initial remote rule and local rule, check
 * 1. initial remote rule other than local rule take effect
 * 2. remote rule change and all invokers gets notified
 */
@Test
void testWithConfigurationListenerAndLocalRule() {
    DynamicConfiguration dynamicConfiguration = Mockito.mock(DynamicConfiguration.class);
    Mockito.doReturn(remoteRule).when(dynamicConfiguration).getConfig(Mockito.anyString(), Mockito.anyString());
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setDynamicConfiguration(dynamicConfiguration);
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setLocalMigrationRule(localRule);
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("demo-consumer");
    ApplicationModel.defaultModel().getApplicationConfigManager().setApplication(applicationConfig);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Test");
    Mockito.when(consumerURL.getParameter("timestamp")).thenReturn("1");
    URL consumerURL2 = Mockito.mock(URL.class);
    Mockito.when(consumerURL2.getServiceKey()).thenReturn("Test2");
    Mockito.when(consumerURL2.getParameter("timestamp")).thenReturn("2");
    System.setProperty("dubbo.application.migration.delay", "10");
    MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
    MigrationRuleHandler<?> handler2 = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
    // Both local rule and remote rule are here
    // Local rule with one delayed task started to apply
    MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule());
    Assertions.assertNotNull(migrationRuleListener.localRuleMigrationFuture);
    Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);
    MigrationInvoker<?> migrationInvoker = Mockito.mock(MigrationInvoker.class);
    MigrationInvoker<?> migrationInvoker2 = Mockito.mock(MigrationInvoker.class);
    // Remote rule will be applied when onRefer gets executed
    migrationRuleListener.getHandlers().put(migrationInvoker, handler);
    migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);
    MigrationRule tmpRemoteRule = migrationRuleListener.getRule();
    ArgumentCaptor<MigrationRule> captor = ArgumentCaptor.forClass(MigrationRule.class);
    Mockito.verify(handler, Mockito.times(1)).doMigrate(captor.capture());
    Assertions.assertEquals(tmpRemoteRule, captor.getValue());
    await().until(() -> migrationRuleListener.localRuleMigrationFuture.isDone());
    Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);
    Assertions.assertEquals(tmpRemoteRule, migrationRuleListener.getRule());
    Mockito.verify(handler, Mockito.times(1)).doMigrate(Mockito.any());
    ArgumentCaptor<MigrationRule> captor2 = ArgumentCaptor.forClass(MigrationRule.class);
    migrationRuleListener.getHandlers().put(migrationInvoker2, handler2);
    migrationRuleListener.onRefer(null, migrationInvoker2, consumerURL2, null);
    Mockito.verify(handler2, Mockito.times(1)).doMigrate(captor2.capture());
    Assertions.assertEquals(tmpRemoteRule, captor2.getValue());
    migrationRuleListener.process(new ConfigChangedEvent("key", "group", dynamicRemoteRule));
    await().until(migrationRuleListener.ruleQueue::isEmpty);
    await().untilAsserted(() -> {
        Mockito.verify(handler, Mockito.times(2)).doMigrate(Mockito.any());
        Mockito.verify(handler2, Mockito.times(2)).doMigrate(Mockito.any());
    });
    Assertions.assertNotNull(migrationRuleListener.ruleMigrationFuture);
    ArgumentCaptor<MigrationRule> captor_event = ArgumentCaptor.forClass(MigrationRule.class);
    Mockito.verify(handler, Mockito.times(2)).doMigrate(captor_event.capture());
    Assertions.assertEquals("APPLICATION_FIRST", captor_event.getValue().getStep().toString());
    Mockito.verify(handler2, Mockito.times(2)).doMigrate(captor_event.capture());
    Assertions.assertEquals("APPLICATION_FIRST", captor_event.getValue().getStep().toString());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static org.apache.dubbo.common.URL createMockUrl(String serviceKeyReturn, String getParameterKey, String getParameterReturn) {
    org.apache.dubbo.common.URL url = Mockito.mock(org.apache.dubbo.common.URL.class);
    Mockito.when(url.getServiceKey()).thenReturn(serviceKeyReturn);
    Mockito.when(url.getParameter(getParameterKey)).thenReturn(getParameterReturn);
    return url;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_14
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.common.URL`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static URL createMockConsumerURL(String serviceInterface, String group, String version, String serviceKey, String displayServiceKey, ApplicationModel applicationModel) {
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn(serviceInterface);
    Mockito.when(consumerURL.getGroup()).thenReturn(group);
    Mockito.when(consumerURL.getVersion()).thenReturn(version);
    Mockito.when(consumerURL.getServiceKey()).thenReturn(serviceKey);
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn(displayServiceKey);
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(applicationModel);
    return consumerURL;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_14_1
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationInvokerTest.java`)
#### Mock Object Variable Name: `consumerURL`
<summary>Suggested Diff</summary>

```diff
@@
     Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
     Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
-    URL consumerURL = Mockito.mock(URL.class);
-    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
-    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
-    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
-    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
-    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
-    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
+    URL consumerURL = createMockConsumerURL(
+        "Test",
+        "Group",
+        "0.0.0",
+        "Group/Test:0.0.0",
+        "Test:0.0.0",
+        ApplicationModel.defaultModel()
+    );
     Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
     Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
     MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("all")
@Test
void test() {
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
    Mockito.when(invoker.isAvailable()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(1)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(2)).invoke(null);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(3)).invoke(null);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(4)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(5)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(3)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(4)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(5)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(6)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(6)).invoke(null);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(7)).invoke(null);
    Assertions.assertNull(migrationInvoker.getInvoker());
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(7)).invoke(null);
    Assertions.assertNull(migrationInvoker.getServiceDiscoveryInvoker());
    ArgumentCaptor<InvokersChangedListener> argument = ArgumentCaptor.forClass(InvokersChangedListener.class);
    Mockito.verify(serviceDiscoveryDirectory, Mockito.atLeastOnce()).setInvokersChangedListener(argument.capture());
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    for (int i = 0; i < 20; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(27)).invoke(null);
    serviceDiscoveryInvokers.remove(1);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(false);
    argument.getAllValues().get(argument.getAllValues().size() - 1).onChange();
    for (int i = 0; i < 20; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(invoker, Mockito.times(27)).invoke(null);
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    argument.getAllValues().get(argument.getAllValues().size() - 1).onChange();
    Mockito.when(migrationRule.getProportion(Mockito.any())).thenReturn(50);
    migrationInvoker.setMigrationRule(migrationRule);
    for (int i = 0; i < 1000; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(serviceDiscoveryInvoker, Mockito.atMost(1026)).invoke(null);
    Mockito.verify(invoker, Mockito.atLeast(28)).invoke(null);
    Mockito.when(migrationRule.getDelay(Mockito.any())).thenReturn(1);
    long currentTimeMillis = System.currentTimeMillis();
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    Assertions.assertTrue(System.currentTimeMillis() - currentTimeMillis >= 2000);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static URL createMockConsumerURL(String serviceInterface, String group, String version, String serviceKey, String displayServiceKey, ApplicationModel applicationModel) {
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn(serviceInterface);
    Mockito.when(consumerURL.getGroup()).thenReturn(group);
    Mockito.when(consumerURL.getVersion()).thenReturn(version);
    Mockito.when(consumerURL.getServiceKey()).thenReturn(serviceKey);
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn(displayServiceKey);
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(applicationModel);
    return consumerURL;
}
```
</details>

---
#### Test Case ID #dubbo_Test_14_2
#### Test Case Name: `testDecide`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationInvokerTest.java`)
#### Mock Object Variable Name: `consumerURL`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
-    URL consumerURL = Mockito.mock(URL.class);
-    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
-    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
-    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
-    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
-    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
-    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
+    URL consumerURL = createMockConsumerURL(
+        "Test",
+        "Group",
+        "0.0.0",
+        "Group/Test:0.0.0",
+        "Test:0.0.0",
+        ApplicationModel.defaultModel()
+    );
    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("all")
@Test
void testDecide() {
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
    Mockito.when(invoker.isAvailable()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(false);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(1)).invoke(null);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static URL createMockConsumerURL(String serviceInterface, String group, String version, String serviceKey, String displayServiceKey, ApplicationModel applicationModel) {
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn(serviceInterface);
    Mockito.when(consumerURL.getGroup()).thenReturn(group);
    Mockito.when(consumerURL.getVersion()).thenReturn(version);
    Mockito.when(consumerURL.getServiceKey()).thenReturn(serviceKey);
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn(displayServiceKey);
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(applicationModel);
    return consumerURL;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_15
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.common.URL`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static URL createMockUrl() {
    URL url = Mockito.mock(URL.class);
    when(url.getPath()).thenReturn("DemoInterface");
    return url;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_15_1
#### Test Case Name: `testRoutePathMatch`(File: `C:\Java_projects\Apache\dubbo\dubbo-xds\src\test\java\org\apache\dubbo\rpc\cluster\router\xds\XdsRouteTest.java`)
#### Mock Object Variable Name: `url1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Invocation invocation = Mockito.mock(Invocation.class);
    Invoker invoker = Mockito.mock(Invoker.class);
-    URL url1 = Mockito.mock(URL.class);
-    when(invoker.getUrl()).thenReturn(url1);
-    when(url1.getPath()).thenReturn("DemoInterface");
+    URL url1 = createMockUrl();
+    when(invoker.getUrl()).thenReturn(url1);
    when(invocation.getInvoker()).thenReturn(invoker);
    when(invocation.getMethodName()).thenReturn("call");
    Set<Endpoint> endpoints = new HashSet<>();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testRoutePathMatch() {
    XdsRouter<Object> xdsRouter = new XdsRouter<>(url, rdsRouteRuleManager, edsEndpointManager, true);
    String appName = "app1";
    String cluster1 = "cluster-test1";
    Invoker<Object> invoker1 = createInvoker(appName, "1.1.1.1:20880");
    BitList<Invoker<Object>> invokers = new BitList<>(Arrays.asList(invoker1, createInvoker(appName, "2.2.2.2:20880")));
    xdsRouter.notify(invokers);
    String path = "/DemoInterface/call";
    VirtualHost virtualHost = VirtualHost.newBuilder().addDomains(appName).addRoutes(Route.newBuilder().setName("route-test").setMatch(RouteMatch.newBuilder().setPath(path).build()).setRoute(RouteAction.newBuilder().setCluster(cluster1).build()).build()).build();
    RdsVirtualHostListener hostListener = new RdsVirtualHostListener(appName, rdsRouteRuleManager);
    hostListener.parseVirtualHost(virtualHost);
    Invocation invocation = Mockito.mock(Invocation.class);
    Invoker invoker = Mockito.mock(Invoker.class);
    URL url1 = Mockito.mock(URL.class);
    when(invoker.getUrl()).thenReturn(url1);
    when(url1.getPath()).thenReturn("DemoInterface");
    when(invocation.getInvoker()).thenReturn(invoker);
    when(invocation.getMethodName()).thenReturn("call");
    Set<Endpoint> endpoints = new HashSet<>();
    Endpoint endpoint1 = new Endpoint();
    endpoint1.setAddress("1.1.1.1");
    endpoint1.setPortValue(20880);
    endpoints.add(endpoint1);
    edsEndpointManager.notifyEndpointChange(cluster1, endpoints);
    BitList<Invoker<Object>> routes = xdsRouter.route(invokers.clone(), null, invocation, false, null);
    assertEquals(1, routes.size());
    assertEquals(invoker1, routes.get(0));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static URL createMockUrl() {
    URL url = Mockito.mock(URL.class);
    when(url.getPath()).thenReturn("DemoInterface");
    return url;
}
```
</details>

---
#### Test Case ID #dubbo_Test_15_2
#### Test Case Name: `testRouteMultiApp`(File: `C:\Java_projects\Apache\dubbo\dubbo-xds\src\test\java\org\apache\dubbo\rpc\cluster\router\xds\XdsRouteTest.java`)
#### Mock Object Variable Name: `url1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Invocation invocation = Mockito.mock(Invocation.class);
    Invoker invoker = Mockito.mock(Invoker.class);
-    URL url1 = Mockito.mock(URL.class);
-    when(invoker.getUrl()).thenReturn(url1);
-    when(url1.getPath()).thenReturn("DemoInterface");
+    URL url1 = createMockUrl();
+    when(invoker.getUrl()).thenReturn(url1);
    when(invocation.getInvoker()).thenReturn(invoker);
    when(invocation.getMethodName()).thenReturn("call");
    Set<Endpoint> endpoints = new HashSet<>();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testRouteMultiApp() {
    XdsRouter<Object> xdsRouter = new XdsRouter<>(url, rdsRouteRuleManager, edsEndpointManager, true);
    String appName1 = "app1";
    String appName2 = "app2";
    String cluster1 = "cluster-test1";
    Invoker<Object> invoker1 = createInvoker(appName2, "1.1.1.1:20880");
    Invoker<Object> invoker2 = createInvoker(appName1, "2.2.2.2:20880");
    BitList<Invoker<Object>> invokers = new BitList<>(Arrays.asList(invoker1, invoker2));
    xdsRouter.notify(invokers);
    assertEquals(xdsRouter.getSubscribeApplications().size(), 2);
    String path = "/DemoInterface/call";
    VirtualHost virtualHost = VirtualHost.newBuilder().addDomains(appName2).addRoutes(Route.newBuilder().setName("route-test").setMatch(RouteMatch.newBuilder().setPath(path).build()).setRoute(RouteAction.newBuilder().setCluster(cluster1).build()).build()).build();
    RdsVirtualHostListener hostListener = new RdsVirtualHostListener(appName2, rdsRouteRuleManager);
    hostListener.parseVirtualHost(virtualHost);
    Invocation invocation = Mockito.mock(Invocation.class);
    Invoker invoker = Mockito.mock(Invoker.class);
    URL url1 = Mockito.mock(URL.class);
    when(invoker.getUrl()).thenReturn(url1);
    when(url1.getPath()).thenReturn("DemoInterface");
    when(invocation.getInvoker()).thenReturn(invoker);
    when(invocation.getMethodName()).thenReturn("call");
    Set<Endpoint> endpoints = new HashSet<>();
    Endpoint endpoint1 = new Endpoint();
    endpoint1.setAddress("1.1.1.1");
    endpoint1.setPortValue(20880);
    endpoints.add(endpoint1);
    edsEndpointManager.notifyEndpointChange(cluster1, endpoints);
    BitList<Invoker<Object>> routes = xdsRouter.route(invokers.clone(), null, invocation, false, null);
    assertEquals(1, routes.size());
    assertEquals(invoker1, routes.get(0));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static URL createMockUrl() {
    URL url = Mockito.mock(URL.class);
    when(url.getPath()).thenReturn("DemoInterface");
    return url;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_16
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.model.MethodDescriptor`
- **Test Case Count**: 5
- **MO Count**: 5

### Reusable Method
```java
private static MethodDescriptor createMockMethodDescriptor() {
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    return method;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_16_1
#### Test Case Name: `unaryCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `method`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(result.recreate()).thenReturn(response);
-    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
-    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
-    when(method.getMethodName()).thenReturn("sayHello");
+    MethodDescriptor method = createMockMethodDescriptor();
    String request = "request";
    Object ret = StubInvocationUtil.unaryCall(invoker, method, request);
    Assertions.assertEquals(response, ret);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void unaryCall() throws Throwable {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    when(invoker.invoke(any(Invocation.class))).thenReturn(result);
    String response = "response";
    when(result.recreate()).thenReturn(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    Object ret = StubInvocationUtil.unaryCall(invoker, method, request);
    Assertions.assertEquals(response, ret);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static MethodDescriptor createMockMethodDescriptor() {
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    return method;
}
```
</details>

---
#### Test Case ID #dubbo_Test_16_2
#### Test Case Name: `unaryCall2`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `method`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(result.recreate()).thenReturn(response);
-    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
-    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
-    when(method.getMethodName()).thenReturn("sayHello");
+    MethodDescriptor method = createMockMethodDescriptor();
    String request = "request";
    try {
        StubInvocationUtil.unaryCall(invoker, method, request);
        fail();
    } catch (Throwable t) {
        // pass
    }
    try {
        StubInvocationUtil.unaryCall(invoker, method, request);
        fail();
    } catch (Throwable t) {
        // pass
    }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void unaryCall2() throws Throwable {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    when(invoker.invoke(any(Invocation.class))).thenThrow(new RuntimeException("a")).thenThrow(new Error("b"));
    String response = "response";
    when(result.recreate()).thenReturn(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    try {
        StubInvocationUtil.unaryCall(invoker, method, request);
        fail();
    } catch (Throwable t) {
        // pass
    }
    try {
        StubInvocationUtil.unaryCall(invoker, method, request);
        fail();
    } catch (Throwable t) {
        // pass
    }
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static MethodDescriptor createMockMethodDescriptor() {
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    return method;
}
```
</details>

---
#### Test Case ID #dubbo_Test_16_3
#### Test Case Name: `testUnaryCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `method`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(result.recreate()).thenReturn(response);
-    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
-    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
-    when(method.getMethodName()).thenReturn("sayHello");
+    MethodDescriptor method = createMockMethodDescriptor();
    String request = "request";
    CountDownLatch latch = new CountDownLatch(1);
    AtomicReference<Object> atomicReference = new AtomicReference<>();
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testUnaryCall() throws Throwable {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> result);
    when(result.recreate()).thenReturn(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    CountDownLatch latch = new CountDownLatch(1);
    AtomicReference<Object> atomicReference = new AtomicReference<>();
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            atomicReference.set(data);
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StubInvocationUtil.unaryCall(invoker, method, request, responseObserver);
    latch.await(1, TimeUnit.SECONDS);
    Assertions.assertEquals(response, atomicReference.get());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static MethodDescriptor createMockMethodDescriptor() {
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    return method;
}
```
</details>

---
#### Test Case ID #dubbo_Test_16_4
#### Test Case Name: `biOrClientStreamCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `method`
<summary>Suggested Diff</summary>

```diff
@@
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> {
        Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];
        StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[0];
        observer.onNext(response);
        observer.onCompleted();
        when(result.recreate()).then(invocationOnMock1 -> new StreamObserver<Object>() {

            @Override
            public void onNext(Object data) {
                observer.onNext(data);
            }

            @Override
            public void onError(Throwable throwable) {
            }

            @Override
            public void onCompleted() {
                observer.onCompleted();
            }
        });
        return result;
    });
-    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
-    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
-    when(method.getMethodName()).thenReturn("sayHello");
+    MethodDescriptor method = createMockMethodDescriptor();
    String request = "request";
    CountDownLatch latch = new CountDownLatch(11);
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            latch.countDown();
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StreamObserver<Object> observer = StubInvocationUtil.biOrClientStreamCall(invoker, method, responseObserver);
    for (int i = 0; i < 10; i++) {
        observer.onNext(request);
    }
    observer.onCompleted();
    Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void biOrClientStreamCall() throws InterruptedException {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> {
        Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];
        StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[0];
        observer.onNext(response);
        observer.onCompleted();
        when(result.recreate()).then(invocationOnMock1 -> new StreamObserver<Object>() {

            @Override
            public void onNext(Object data) {
                observer.onNext(data);
            }

            @Override
            public void onError(Throwable throwable) {
            }

            @Override
            public void onCompleted() {
                observer.onCompleted();
            }
        });
        return result;
    });
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    CountDownLatch latch = new CountDownLatch(11);
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            latch.countDown();
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StreamObserver<Object> observer = StubInvocationUtil.biOrClientStreamCall(invoker, method, responseObserver);
    for (int i = 0; i < 10; i++) {
        observer.onNext(request);
    }
    observer.onCompleted();
    Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static MethodDescriptor createMockMethodDescriptor() {
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    return method;
}
```
</details>

---
#### Test Case ID #dubbo_Test_16_5
#### Test Case Name: `serverStreamCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `method`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> {
        Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];
        StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[1];
        for (int i = 0; i < 10; i++) {
            observer.onNext(response);
        }
        observer.onCompleted();
        return result;
    });
-    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
-    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
-    when(method.getMethodName()).thenReturn("sayHello");
+    MethodDescriptor method = createMockMethodDescriptor();
    String request = "request";
    CountDownLatch latch = new CountDownLatch(11);
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            latch.countDown();
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StubInvocationUtil.serverStreamCall(invoker, method, request, responseObserver);
    Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void serverStreamCall() throws InterruptedException {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> {
        Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];
        StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[1];
        for (int i = 0; i < 10; i++) {
            observer.onNext(response);
        }
        observer.onCompleted();
        return result;
    });
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    CountDownLatch latch = new CountDownLatch(11);
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            latch.countDown();
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StubInvocationUtil.serverStreamCall(invoker, method, request, responseObserver);
    Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static MethodDescriptor createMockMethodDescriptor() {
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    return method;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_17
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.cluster.router.mesh.route.MeshEnvListenerFactory`
- **Test Case Count**: 1
- **MO Count**: 2

### Reusable Method
```java
private static MeshEnvListenerFactory createMockMeshEnvListenerFactory(MeshEnvListener meshEnvListener) {
    MeshEnvListenerFactory meshEnvListenerFactory = Mockito.mock(MeshEnvListenerFactory.class);
    when(meshEnvListenerFactory.getListener()).thenReturn(meshEnvListener);
    return meshEnvListenerFactory;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_17_1
#### Test Case Name: `testRegister3`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\router\mesh\route\MeshRuleManagerTest.java`)
#### Mock Object Variable Name: `meshEnvListenerFactory1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testRegister3() {
-    MeshEnvListenerFactory meshEnvListenerFactory1 = Mockito.mock(MeshEnvListenerFactory.class);
     MeshEnvListenerFactory meshEnvListenerFactory2 = Mockito.mock(MeshEnvListenerFactory.class);
     MeshEnvListener meshEnvListener1 = Mockito.mock(MeshEnvListener.class);
+    MeshEnvListenerFactory meshEnvListenerFactory1 = createMockMeshEnvListenerFactory(meshEnvListener1);
     when(meshEnvListenerFactory2.getListener()).thenReturn(meshEnvListener2);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testRegister3() {
    MeshEnvListenerFactory meshEnvListenerFactory1 = Mockito.mock(MeshEnvListenerFactory.class);
    MeshEnvListenerFactory meshEnvListenerFactory2 = Mockito.mock(MeshEnvListenerFactory.class);
    MeshEnvListener meshEnvListener1 = Mockito.mock(MeshEnvListener.class);
    when(meshEnvListenerFactory1.getListener()).thenReturn(meshEnvListener1);
    MeshEnvListener meshEnvListener2 = Mockito.mock(MeshEnvListener.class);
    when(meshEnvListenerFactory2.getListener()).thenReturn(meshEnvListener2);
    envListenerFactories.add(meshEnvListenerFactory1);
    envListenerFactories.add(meshEnvListenerFactory2);
    MeshRuleManager meshRuleManager = new MeshRuleManager(moduleModel);
    MeshRuleListener meshRuleListener1 = new MeshRuleListener() {

        @Override
        public void onRuleChange(String appName, List<Map<String, Object>> rules) {
            fail();
        }

        @Override
        public void clearRule(String appName) {
        }

        @Override
        public String ruleSuffix() {
            return "Type1";
        }
    };
    when(meshEnvListener1.isEnable()).thenReturn(false);
    when(meshEnvListener2.isEnable()).thenReturn(true);
    meshRuleManager.register("dubbo-demo", meshRuleListener1);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    verify(ruleRepository, times(1)).getRule("dubbo-demo.MESHAPPRULE", "dubbo", 5000L);
    MeshAppRuleListener meshAppRuleListener = meshRuleManager.getAppRuleListeners().values().iterator().next();
    verify(ruleRepository, times(1)).addListener("dubbo-demo.MESHAPPRULE", "dubbo", meshAppRuleListener);
    verify(meshEnvListener2, times(1)).onSubscribe("dubbo-demo", meshAppRuleListener);
    meshRuleManager.register("dubbo-demo", meshRuleListener1);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    MeshRuleListener meshRuleListener2 = new MeshRuleListener() {

        @Override
        public void onRuleChange(String appName, List<Map<String, Object>> rules) {
            fail();
        }

        @Override
        public void clearRule(String appName) {
        }

        @Override
        public String ruleSuffix() {
            return "Type2";
        }
    };
    meshRuleManager.register("dubbo-demo", meshRuleListener2);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    assertEquals(2, meshAppRuleListener.getMeshRuleDispatcher().getListenerMap().size());
    meshRuleManager.unregister("dubbo-demo", meshRuleListener1);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    assertEquals(1, meshAppRuleListener.getMeshRuleDispatcher().getListenerMap().size());
    meshRuleManager.unregister("dubbo-demo", meshRuleListener2);
    assertEquals(0, meshRuleManager.getAppRuleListeners().size());
    verify(ruleRepository, times(1)).removeListener("dubbo-demo.MESHAPPRULE", "dubbo", meshAppRuleListener);
    verify(meshEnvListener2, times(1)).onUnSubscribe("dubbo-demo");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static MeshEnvListenerFactory createMockMeshEnvListenerFactory(MeshEnvListener meshEnvListener) {
    MeshEnvListenerFactory meshEnvListenerFactory = Mockito.mock(MeshEnvListenerFactory.class);
    when(meshEnvListenerFactory.getListener()).thenReturn(meshEnvListener);
    return meshEnvListenerFactory;
}
```
</details>

---
#### Test Case ID #dubbo_Test_17_2
#### Test Case Name: `testRegister3`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\router\mesh\route\MeshRuleManagerTest.java`)
#### Mock Object Variable Name: `meshEnvListenerFactory2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    MeshEnvListenerFactory meshEnvListenerFactory1 = Mockito.mock(MeshEnvListenerFactory.class);
-    MeshEnvListenerFactory meshEnvListenerFactory2 = Mockito.mock(MeshEnvListenerFactory.class);
    MeshEnvListener meshEnvListener1 = Mockito.mock(MeshEnvListener.class);
    when(meshEnvListenerFactory1.getListener()).thenReturn(meshEnvListener1);
    MeshEnvListener meshEnvListener2 = Mockito.mock(MeshEnvListener.class);
-    when(meshEnvListenerFactory2.getListener()).thenReturn(meshEnvListener2);
+    MeshEnvListenerFactory meshEnvListenerFactory2 = createMockMeshEnvListenerFactory(meshEnvListener2);
    envListenerFactories.add(meshEnvListenerFactory1);
    envListenerFactories.add(meshEnvListenerFactory2);
    MeshRuleManager meshRuleManager = new MeshRuleManager(moduleModel);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testRegister3() {
    MeshEnvListenerFactory meshEnvListenerFactory1 = Mockito.mock(MeshEnvListenerFactory.class);
    MeshEnvListenerFactory meshEnvListenerFactory2 = Mockito.mock(MeshEnvListenerFactory.class);
    MeshEnvListener meshEnvListener1 = Mockito.mock(MeshEnvListener.class);
    when(meshEnvListenerFactory1.getListener()).thenReturn(meshEnvListener1);
    MeshEnvListener meshEnvListener2 = Mockito.mock(MeshEnvListener.class);
    when(meshEnvListenerFactory2.getListener()).thenReturn(meshEnvListener2);
    envListenerFactories.add(meshEnvListenerFactory1);
    envListenerFactories.add(meshEnvListenerFactory2);
    MeshRuleManager meshRuleManager = new MeshRuleManager(moduleModel);
    MeshRuleListener meshRuleListener1 = new MeshRuleListener() {

        @Override
        public void onRuleChange(String appName, List<Map<String, Object>> rules) {
            fail();
        }

        @Override
        public void clearRule(String appName) {
        }

        @Override
        public String ruleSuffix() {
            return "Type1";
        }
    };
    when(meshEnvListener1.isEnable()).thenReturn(false);
    when(meshEnvListener2.isEnable()).thenReturn(true);
    meshRuleManager.register("dubbo-demo", meshRuleListener1);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    verify(ruleRepository, times(1)).getRule("dubbo-demo.MESHAPPRULE", "dubbo", 5000L);
    MeshAppRuleListener meshAppRuleListener = meshRuleManager.getAppRuleListeners().values().iterator().next();
    verify(ruleRepository, times(1)).addListener("dubbo-demo.MESHAPPRULE", "dubbo", meshAppRuleListener);
    verify(meshEnvListener2, times(1)).onSubscribe("dubbo-demo", meshAppRuleListener);
    meshRuleManager.register("dubbo-demo", meshRuleListener1);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    MeshRuleListener meshRuleListener2 = new MeshRuleListener() {

        @Override
        public void onRuleChange(String appName, List<Map<String, Object>> rules) {
            fail();
        }

        @Override
        public void clearRule(String appName) {
        }

        @Override
        public String ruleSuffix() {
            return "Type2";
        }
    };
    meshRuleManager.register("dubbo-demo", meshRuleListener2);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    assertEquals(2, meshAppRuleListener.getMeshRuleDispatcher().getListenerMap().size());
    meshRuleManager.unregister("dubbo-demo", meshRuleListener1);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    assertEquals(1, meshAppRuleListener.getMeshRuleDispatcher().getListenerMap().size());
    meshRuleManager.unregister("dubbo-demo", meshRuleListener2);
    assertEquals(0, meshRuleManager.getAppRuleListeners().size());
    verify(ruleRepository, times(1)).removeListener("dubbo-demo.MESHAPPRULE", "dubbo", meshAppRuleListener);
    verify(meshEnvListener2, times(1)).onUnSubscribe("dubbo-demo");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static MeshEnvListenerFactory createMockMeshEnvListenerFactory(MeshEnvListener meshEnvListener) {
    MeshEnvListenerFactory meshEnvListenerFactory = Mockito.mock(MeshEnvListenerFactory.class);
    when(meshEnvListenerFactory.getListener()).thenReturn(meshEnvListener);
    return meshEnvListenerFactory;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_18
- **Scope**: class level
- **Mocked Class**: `org.apache.dubbo.registry.client.ServiceDiscovery`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
public class MockServiceDiscovery {
    /**
     * Creates a mock ServiceDiscovery with standard stubbing for getRemoteMetadata and getUrl.
     * @param registryURL the URL to return from getUrl()
     * @param metadataInfo_111 MetadataInfo for revision "111"
     * @param metadataInfo_222 MetadataInfo for revision "222"
     * @param metadataInfo_333 MetadataInfo for revision "333"
     * @param metadataInfo_555_tri MetadataInfo for revision "555"
     * @param answer222 Answer<MetadataInfo> for getRemoteMetadata("222", ...)
     * @return configured mock ServiceDiscovery
     */
    public static ServiceDiscovery createMockServiceDiscovery(
            URL registryURL,
            MetadataInfo metadataInfo_111,
            MetadataInfo metadataInfo_222,
            MetadataInfo metadataInfo_333,
            MetadataInfo metadataInfo_555_tri,
            org.mockito.stubbing.Answer<MetadataInfo> answer222) {
        ServiceDiscovery serviceDiscovery = Mockito.mock(ServiceDiscovery.class);
        when(serviceDiscovery.getUrl()).thenReturn(registryURL);
        when(serviceDiscovery.getRemoteMetadata(eq("111"), anyList())).thenReturn(metadataInfo_111);
        when(serviceDiscovery.getRemoteMetadata(eq("222"), anyList())).thenReturn(metadataInfo_222);
        when(serviceDiscovery.getRemoteMetadata(eq("333"), anyList())).thenReturn(metadataInfo_333);
        when(serviceDiscovery.getRemoteMetadata(eq("444"), anyList())).thenReturn(MetadataInfo.EMPTY);
        when(serviceDiscovery.getRemoteMetadata(eq("555"), anyList())).thenReturn(metadataInfo_555_tri);
        when(serviceDiscovery.getRemoteMetadata(eq("222"), anyList())).thenAnswer(answer222);
        return serviceDiscovery;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_18_1
#### Test Case Name: `testRevisionFailureOnNotification`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerTest.java`)
#### Mock Object Variable Name: `serviceDiscovery`
<summary>Suggested Diff</summary>

```diff
--- Original.java
+++ Refactored.java
@@
    @BeforeAll
    public static void setUp() {
        metadataService = Mockito.mock(MetadataService.class);
        List<Object> urlsSameRevision = new ArrayList<>();
        urlsSameRevision.add("127.0.0.1:20880?revision=111");
        urlsSameRevision.add("127.0.0.2:20880?revision=111");
        urlsSameRevision.add("127.0.0.3:20880?revision=111");
        List<Object> urlsDifferentRevision = new ArrayList<>();
        urlsDifferentRevision.add("30.10.0.1:20880?revision=222");
        urlsDifferentRevision.add("30.10.0.2:20880?revision=222");
        urlsDifferentRevision.add("30.10.0.3:20880?revision=333");
        urlsDifferentRevision.add("30.10.0.4:20880?revision=333");
        List<Object> urlsFailedRevision = new ArrayList<>();
        urlsFailedRevision.add("30.10.0.5:20880?revision=222");
        urlsFailedRevision.add("30.10.0.6:20880?revision=222");
        // revision will fail
        urlsFailedRevision.add("30.10.0.7:20880?revision=444");
        // revision will fail
        urlsFailedRevision.add("30.10.0.8:20880?revision=444");
        List<Object> urlsFailedRevision2 = new ArrayList<>();
        urlsFailedRevision2.add("30.10.0.1:20880?revision=222");
        urlsFailedRevision2.add("30.10.0.2:20880?revision=222");
        List<Object> urlsWithoutRevision = new ArrayList<>();
        urlsWithoutRevision.add("30.10.0.1:20880");
        List<Object> urlsMultipleProtocols = new ArrayList<>();
        //triple
        urlsMultipleProtocols.add("30.10.0.1:20880?revision=555");
        // dubbo
        urlsMultipleProtocols.addAll(urlsSameRevision);
        app1Instances = buildInstances(urlsSameRevision);
        app2Instances = buildInstances(urlsDifferentRevision);
        app1FailedInstances = buildInstances(urlsFailedRevision);
        app1FailedInstances2 = buildInstances(urlsFailedRevision2);
        app1InstancesWithNoRevision = buildInstances(urlsWithoutRevision);
        app1InstancesMultipleProtocols = buildInstances(urlsMultipleProtocols);
        metadataInfo_111 = JsonUtils.toJavaObject(metadata_111, MetadataInfo.class);
        metadataInfo_222 = JsonUtils.toJavaObject(metadata_222, MetadataInfo.class);
        metadataInfo_333 = JsonUtils.toJavaObject(metadata_333, MetadataInfo.class);
        metadataInfo_444 = JsonUtils.toJavaObject(metadata_444, MetadataInfo.class);
        metadataInfo_555_tri = JsonUtils.toJavaObject(metadata_555_triple, MetadataInfo.class);
-        serviceDiscovery = Mockito.mock(ServiceDiscovery.class);
-        when(serviceDiscovery.getUrl()).thenReturn(registryURL);
-        when(serviceDiscovery.getRemoteMetadata(eq("111"), anyList())).thenReturn(metadataInfo_111);
-        when(serviceDiscovery.getRemoteMetadata(eq("222"), anyList())).thenReturn(metadataInfo_222);
-        when(serviceDiscovery.getRemoteMetadata(eq("333"), anyList())).thenReturn(metadataInfo_333);
-        when(serviceDiscovery.getRemoteMetadata(eq("444"), anyList())).thenReturn(MetadataInfo.EMPTY);
-        when(serviceDiscovery.getRemoteMetadata(eq("555"), anyList())).thenReturn(metadataInfo_555_tri);
    }

    // revision revisionrevision
    @Test
    @Order(11)
    public void testRevisionFailureOnNotification() {
        Set<String> serviceNames = new HashSet<>();
        serviceNames.add("app1");
        serviceNames.add("app2");
+        serviceDiscovery = MockServiceDiscovery.createMockServiceDiscovery(
+            registryURL,
+            metadataInfo_111,
+            metadataInfo_222,
+            metadataInfo_333,
+            metadataInfo_555_tri,
+            new Answer<MetadataInfo>() {
+                @Override
+                public MetadataInfo answer(InvocationOnMock invocationOnMock) throws Throwable {
+                    if (Thread.currentThread().getName().contains("Dubbo-framework-metadata-retry")) {
+                        return metadataInfo_222;
+                    }
+                    return MetadataInfo.EMPTY;
+                }
+            }
+        );
        listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
        // notify app1 instance change
        ServiceInstancesChangedEvent event = new ServiceInstancesChangedEvent("app1", app1Instances);
        listener.onEvent(event);
-        when(serviceDiscovery.getRemoteMetadata(eq("222"), anyList())).thenAnswer(new Answer<MetadataInfo>() {
-
-            @Override
-            public MetadataInfo answer(InvocationOnMock invocationOnMock) throws Throwable {
-                if (Thread.currentThread().getName().contains("Dubbo-framework-metadata-retry")) {
-                    return metadataInfo_222;
-                }
-                return MetadataInfo.EMPTY;
-            }
-        });
        ServiceInstancesChangedEvent event2 = new ServiceInstancesChangedEvent("app2", app1FailedInstances2);
        listener.onEvent(event2);
        // event2 did not really take effect
        ProtocolServiceKey protocolServiceKey1 = new ProtocolServiceKey(service1, null, null, "dubbo");
        ProtocolServiceKey protocolServiceKey2 = new ProtocolServiceKey(service2, null, null, "dubbo");
        Assertions.assertEquals(3, listener.getAddresses(protocolServiceKey1, consumerURL).size());
        assertTrue(isEmpty(listener.getAddresses(protocolServiceKey2, consumerURL)));
        //
        init();
        try {
            Thread.sleep(15000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // check recovered after retry.
        List<URL> serviceUrls_after_retry = listener.getAddresses(protocolServiceKey1, consumerURL);
        Assertions.assertEquals(5, serviceUrls_after_retry.size());
        List<URL> serviceUrls2_after_retry = listener.getAddresses(protocolServiceKey2, consumerURL);
        Assertions.assertEquals(2, serviceUrls2_after_retry.size());
    }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeAll
public static void setUp() {
    metadataService = Mockito.mock(MetadataService.class);
    List<Object> urlsSameRevision = new ArrayList<>();
    urlsSameRevision.add("127.0.0.1:20880?revision=111");
    urlsSameRevision.add("127.0.0.2:20880?revision=111");
    urlsSameRevision.add("127.0.0.3:20880?revision=111");
    List<Object> urlsDifferentRevision = new ArrayList<>();
    urlsDifferentRevision.add("30.10.0.1:20880?revision=222");
    urlsDifferentRevision.add("30.10.0.2:20880?revision=222");
    urlsDifferentRevision.add("30.10.0.3:20880?revision=333");
    urlsDifferentRevision.add("30.10.0.4:20880?revision=333");
    List<Object> urlsFailedRevision = new ArrayList<>();
    urlsFailedRevision.add("30.10.0.5:20880?revision=222");
    urlsFailedRevision.add("30.10.0.6:20880?revision=222");
    // revision will fail
    urlsFailedRevision.add("30.10.0.7:20880?revision=444");
    // revision will fail
    urlsFailedRevision.add("30.10.0.8:20880?revision=444");
    List<Object> urlsFailedRevision2 = new ArrayList<>();
    urlsFailedRevision2.add("30.10.0.1:20880?revision=222");
    urlsFailedRevision2.add("30.10.0.2:20880?revision=222");
    List<Object> urlsWithoutRevision = new ArrayList<>();
    urlsWithoutRevision.add("30.10.0.1:20880");
    List<Object> urlsMultipleProtocols = new ArrayList<>();
    //triple
    urlsMultipleProtocols.add("30.10.0.1:20880?revision=555");
    // dubbo
    urlsMultipleProtocols.addAll(urlsSameRevision);
    app1Instances = buildInstances(urlsSameRevision);
    app2Instances = buildInstances(urlsDifferentRevision);
    app1FailedInstances = buildInstances(urlsFailedRevision);
    app1FailedInstances2 = buildInstances(urlsFailedRevision2);
    app1InstancesWithNoRevision = buildInstances(urlsWithoutRevision);
    app1InstancesMultipleProtocols = buildInstances(urlsMultipleProtocols);
    metadataInfo_111 = JsonUtils.toJavaObject(metadata_111, MetadataInfo.class);
    metadataInfo_222 = JsonUtils.toJavaObject(metadata_222, MetadataInfo.class);
    metadataInfo_333 = JsonUtils.toJavaObject(metadata_333, MetadataInfo.class);
    metadataInfo_444 = JsonUtils.toJavaObject(metadata_444, MetadataInfo.class);
    metadataInfo_555_tri = JsonUtils.toJavaObject(metadata_555_triple, MetadataInfo.class);
    serviceDiscovery = Mockito.mock(ServiceDiscovery.class);
    when(serviceDiscovery.getUrl()).thenReturn(registryURL);
    when(serviceDiscovery.getRemoteMetadata(eq("111"), anyList())).thenReturn(metadataInfo_111);
    when(serviceDiscovery.getRemoteMetadata(eq("222"), anyList())).thenReturn(metadataInfo_222);
    when(serviceDiscovery.getRemoteMetadata(eq("333"), anyList())).thenReturn(metadataInfo_333);
    when(serviceDiscovery.getRemoteMetadata(eq("444"), anyList())).thenReturn(MetadataInfo.EMPTY);
    when(serviceDiscovery.getRemoteMetadata(eq("555"), anyList())).thenReturn(metadataInfo_555_tri);
}
// revision revisionrevision
@Test
@Order(11)
public void testRevisionFailureOnNotification() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    serviceNames.add("app2");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    // notify app1 instance change
    ServiceInstancesChangedEvent event = new ServiceInstancesChangedEvent("app1", app1Instances);
    listener.onEvent(event);
    when(serviceDiscovery.getRemoteMetadata(eq("222"), anyList())).thenAnswer(new Answer<MetadataInfo>() {

        @Override
        public MetadataInfo answer(InvocationOnMock invocationOnMock) throws Throwable {
            if (Thread.currentThread().getName().contains("Dubbo-framework-metadata-retry")) {
                return metadataInfo_222;
            }
            return MetadataInfo.EMPTY;
        }
    });
    ServiceInstancesChangedEvent event2 = new ServiceInstancesChangedEvent("app2", app1FailedInstances2);
    listener.onEvent(event2);
    // event2 did not really take effect
    ProtocolServiceKey protocolServiceKey1 = new ProtocolServiceKey(service1, null, null, "dubbo");
    ProtocolServiceKey protocolServiceKey2 = new ProtocolServiceKey(service2, null, null, "dubbo");
    Assertions.assertEquals(3, listener.getAddresses(protocolServiceKey1, consumerURL).size());
    assertTrue(isEmpty(listener.getAddresses(protocolServiceKey2, consumerURL)));
    //
    init();
    try {
        Thread.sleep(15000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    // check recovered after retry.
    List<URL> serviceUrls_after_retry = listener.getAddresses(protocolServiceKey1, consumerURL);
    Assertions.assertEquals(5, serviceUrls_after_retry.size());
    List<URL> serviceUrls2_after_retry = listener.getAddresses(protocolServiceKey2, consumerURL);
    Assertions.assertEquals(2, serviceUrls2_after_retry.size());
}
@AfterAll
public static void destroy() throws Exception {
    serviceDiscovery.destroy();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockServiceDiscovery {
    /**
     * Creates a mock ServiceDiscovery with standard stubbing for getRemoteMetadata and getUrl.
     * @param registryURL the URL to return from getUrl()
     * @param metadataInfo_111 MetadataInfo for revision "111"
     * @param metadataInfo_222 MetadataInfo for revision "222"
     * @param metadataInfo_333 MetadataInfo for revision "333"
     * @param metadataInfo_555_tri MetadataInfo for revision "555"
     * @param answer222 Answer<MetadataInfo> for getRemoteMetadata("222", ...)
     * @return configured mock ServiceDiscovery
     */
    public static ServiceDiscovery createMockServiceDiscovery(
            URL registryURL,
            MetadataInfo metadataInfo_111,
            MetadataInfo metadataInfo_222,
            MetadataInfo metadataInfo_333,
            MetadataInfo metadataInfo_555_tri,
            org.mockito.stubbing.Answer<MetadataInfo> answer222) {
        ServiceDiscovery serviceDiscovery = Mockito.mock(ServiceDiscovery.class);
        when(serviceDiscovery.getUrl()).thenReturn(registryURL);
        when(serviceDiscovery.getRemoteMetadata(eq("111"), anyList())).thenReturn(metadataInfo_111);
        when(serviceDiscovery.getRemoteMetadata(eq("222"), anyList())).thenReturn(metadataInfo_222);
        when(serviceDiscovery.getRemoteMetadata(eq("333"), anyList())).thenReturn(metadataInfo_333);
        when(serviceDiscovery.getRemoteMetadata(eq("444"), anyList())).thenReturn(MetadataInfo.EMPTY);
        when(serviceDiscovery.getRemoteMetadata(eq("555"), anyList())).thenReturn(metadataInfo_555_tri);
        when(serviceDiscovery.getRemoteMetadata(eq("222"), anyList())).thenAnswer(answer222);
        return serviceDiscovery;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_18_2
#### Test Case Name: `testRevisionFailureOnNotification`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerWithoutEmptyProtectTest.java`)
#### Mock Object Variable Name: `serviceDiscovery`
<summary>Suggested Diff</summary>

```diff
--- Original.java
+++ Refactored.java
@@
    @BeforeAll
    public static void setUp() {
        metadataService = Mockito.mock(MetadataService.class);
        List<Object> urlsSameRevision = new ArrayList<>();
        urlsSameRevision.add("127.0.0.1:20880?revision=111");
        urlsSameRevision.add("127.0.0.2:20880?revision=111");
        urlsSameRevision.add("127.0.0.3:20880?revision=111");
        List<Object> urlsDifferentRevision = new ArrayList<>();
        urlsDifferentRevision.add("30.10.0.1:20880?revision=222");
        urlsDifferentRevision.add("30.10.0.2:20880?revision=222");
        urlsDifferentRevision.add("30.10.0.3:20880?revision=333");
        urlsDifferentRevision.add("30.10.0.4:20880?revision=333");
        List<Object> urlsFailedRevision = new ArrayList<>();
        urlsFailedRevision.add("30.10.0.5:20880?revision=222");
        urlsFailedRevision.add("30.10.0.6:20880?revision=222");
        // revision will fail
        urlsFailedRevision.add("30.10.0.7:20880?revision=444");
        // revision will fail
        urlsFailedRevision.add("30.10.0.8:20880?revision=444");
        List<Object> urlsFailedRevision2 = new ArrayList<>();
        urlsFailedRevision2.add("30.10.0.1:20880?revision=222");
        urlsFailedRevision2.add("30.10.0.2:20880?revision=222");
        List<Object> urlsWithoutRevision = new ArrayList<>();
        urlsWithoutRevision.add("30.10.0.1:20880");
        List<Object> urlsMultipleProtocols = new ArrayList<>();
        //triple
        urlsMultipleProtocols.add("30.10.0.1:20880?revision=555");
        // dubbo
        urlsMultipleProtocols.addAll(urlsSameRevision);
        app1Instances = buildInstances(urlsSameRevision);
        app2Instances = buildInstances(urlsDifferentRevision);
        app1FailedInstances = buildInstances(urlsFailedRevision);
        app1FailedInstances2 = buildInstances(urlsFailedRevision2);
        app1InstancesWithNoRevision = buildInstances(urlsWithoutRevision);
        app1InstancesMultipleProtocols = buildInstances(urlsMultipleProtocols);
        metadataInfo_111 = JsonUtils.toJavaObject(metadata_111, MetadataInfo.class);
        metadataInfo_222 = JsonUtils.toJavaObject(metadata_222, MetadataInfo.class);
        metadataInfo_333 = JsonUtils.toJavaObject(metadata_333, MetadataInfo.class);
        metadataInfo_444 = JsonUtils.toJavaObject(metadata_444, MetadataInfo.class);
        metadataInfo_555_tri = JsonUtils.toJavaObject(metadata_555_triple, MetadataInfo.class);
-        serviceDiscovery = Mockito.mock(ServiceDiscovery.class);
-        when(serviceDiscovery.getUrl()).thenReturn(registryURL);
-        when(serviceDiscovery.getRemoteMetadata(eq("111"), anyList())).thenReturn(metadataInfo_111);
-        when(serviceDiscovery.getRemoteMetadata(eq("222"), anyList())).thenReturn(metadataInfo_222);
-        when(serviceDiscovery.getRemoteMetadata(eq("333"), anyList())).thenReturn(metadataInfo_333);
-        when(serviceDiscovery.getRemoteMetadata(eq("444"), anyList())).thenReturn(MetadataInfo.EMPTY);
-        when(serviceDiscovery.getRemoteMetadata(eq("555"), anyList())).thenReturn(metadataInfo_555_tri);
    }

    // revision revisionrevision
    @Test
    @Order(11)
    public void testRevisionFailureOnNotification() {
        Set<String> serviceNames = new HashSet<>();
        serviceNames.add("app1");
        serviceNames.add("app2");
+        org.mockito.stubbing.Answer<MetadataInfo> answer222 = new Answer<MetadataInfo>() {
+            @Override
+            public MetadataInfo answer(InvocationOnMock invocationOnMock) throws Throwable {
+                if (Thread.currentThread().getName().contains("Dubbo-framework-metadata-retry")) {
+                    return metadataInfo_222;
+                }
+                return MetadataInfo.EMPTY;
+            }
+        };
+        serviceDiscovery = MockServiceDiscovery.createMockServiceDiscovery(
+            registryURL,
+            metadataInfo_111,
+            metadataInfo_222,
+            metadataInfo_333,
+            metadataInfo_555_tri,
+            answer222
+        );
        listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
        // notify app1 instance change
        ServiceInstancesChangedEvent event = new ServiceInstancesChangedEvent("app1", app1Instances);
        listener.onEvent(event);
-        when(serviceDiscovery.getRemoteMetadata(eq("222"), anyList())).thenAnswer(new Answer<MetadataInfo>() {
-
-            @Override
-            public MetadataInfo answer(InvocationOnMock invocationOnMock) throws Throwable {
-                if (Thread.currentThread().getName().contains("Dubbo-framework-metadata-retry")) {
-                    return metadataInfo_222;
-                }
-                return MetadataInfo.EMPTY;
-            }
-        });
        ServiceInstancesChangedEvent event2 = new ServiceInstancesChangedEvent("app2", app1FailedInstances2);
        listener.onEvent(event2);
        // event2 did not really take effect
        ProtocolServiceKey protocolServiceKey1 = new ProtocolServiceKey(service1, null, null, "dubbo");
        ProtocolServiceKey protocolServiceKey2 = new ProtocolServiceKey(service2, null, null, "dubbo");
        Assertions.assertEquals(3, listener.getAddresses(protocolServiceKey1, consumerURL).size());
        assertTrue(isEmpty(listener.getAddresses(protocolServiceKey2, consumerURL)));
        //
        init();
        try {
            Thread.sleep(15000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // check recovered after retry.
        List<URL> serviceUrls_after_retry = listener.getAddresses(protocolServiceKey1, consumerURL);
        Assertions.assertEquals(5, serviceUrls_after_retry.size());
        List<URL> serviceUrls2_after_retry = listener.getAddresses(protocolServiceKey2, consumerURL);
        Assertions.assertEquals(2, serviceUrls2_after_retry.size());
    }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeAll
public static void setUp() {
    metadataService = Mockito.mock(MetadataService.class);
    List<Object> urlsSameRevision = new ArrayList<>();
    urlsSameRevision.add("127.0.0.1:20880?revision=111");
    urlsSameRevision.add("127.0.0.2:20880?revision=111");
    urlsSameRevision.add("127.0.0.3:20880?revision=111");
    List<Object> urlsDifferentRevision = new ArrayList<>();
    urlsDifferentRevision.add("30.10.0.1:20880?revision=222");
    urlsDifferentRevision.add("30.10.0.2:20880?revision=222");
    urlsDifferentRevision.add("30.10.0.3:20880?revision=333");
    urlsDifferentRevision.add("30.10.0.4:20880?revision=333");
    List<Object> urlsFailedRevision = new ArrayList<>();
    urlsFailedRevision.add("30.10.0.5:20880?revision=222");
    urlsFailedRevision.add("30.10.0.6:20880?revision=222");
    // revision will fail
    urlsFailedRevision.add("30.10.0.7:20880?revision=444");
    // revision will fail
    urlsFailedRevision.add("30.10.0.8:20880?revision=444");
    List<Object> urlsFailedRevision2 = new ArrayList<>();
    urlsFailedRevision2.add("30.10.0.1:20880?revision=222");
    urlsFailedRevision2.add("30.10.0.2:20880?revision=222");
    List<Object> urlsWithoutRevision = new ArrayList<>();
    urlsWithoutRevision.add("30.10.0.1:20880");
    List<Object> urlsMultipleProtocols = new ArrayList<>();
    //triple
    urlsMultipleProtocols.add("30.10.0.1:20880?revision=555");
    // dubbo
    urlsMultipleProtocols.addAll(urlsSameRevision);
    app1Instances = buildInstances(urlsSameRevision);
    app2Instances = buildInstances(urlsDifferentRevision);
    app1FailedInstances = buildInstances(urlsFailedRevision);
    app1FailedInstances2 = buildInstances(urlsFailedRevision2);
    app1InstancesWithNoRevision = buildInstances(urlsWithoutRevision);
    app1InstancesMultipleProtocols = buildInstances(urlsMultipleProtocols);
    metadataInfo_111 = JsonUtils.toJavaObject(metadata_111, MetadataInfo.class);
    metadataInfo_222 = JsonUtils.toJavaObject(metadata_222, MetadataInfo.class);
    metadataInfo_333 = JsonUtils.toJavaObject(metadata_333, MetadataInfo.class);
    metadataInfo_444 = JsonUtils.toJavaObject(metadata_444, MetadataInfo.class);
    metadataInfo_555_tri = JsonUtils.toJavaObject(metadata_555_triple, MetadataInfo.class);
    serviceDiscovery = Mockito.mock(ServiceDiscovery.class);
    when(serviceDiscovery.getUrl()).thenReturn(registryURL);
    when(serviceDiscovery.getRemoteMetadata(eq("111"), anyList())).thenReturn(metadataInfo_111);
    when(serviceDiscovery.getRemoteMetadata(eq("222"), anyList())).thenReturn(metadataInfo_222);
    when(serviceDiscovery.getRemoteMetadata(eq("333"), anyList())).thenReturn(metadataInfo_333);
    when(serviceDiscovery.getRemoteMetadata(eq("444"), anyList())).thenReturn(MetadataInfo.EMPTY);
    when(serviceDiscovery.getRemoteMetadata(eq("555"), anyList())).thenReturn(metadataInfo_555_tri);
}
// revision revisionrevision
@Test
@Order(11)
public void testRevisionFailureOnNotification() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    serviceNames.add("app2");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    // notify app1 instance change
    ServiceInstancesChangedEvent event = new ServiceInstancesChangedEvent("app1", app1Instances);
    listener.onEvent(event);
    when(serviceDiscovery.getRemoteMetadata(eq("222"), anyList())).thenAnswer(new Answer<MetadataInfo>() {

        @Override
        public MetadataInfo answer(InvocationOnMock invocationOnMock) throws Throwable {
            if (Thread.currentThread().getName().contains("Dubbo-framework-metadata-retry")) {
                return metadataInfo_222;
            }
            return MetadataInfo.EMPTY;
        }
    });
    ServiceInstancesChangedEvent event2 = new ServiceInstancesChangedEvent("app2", app1FailedInstances2);
    listener.onEvent(event2);
    // event2 did not really take effect
    ProtocolServiceKey protocolServiceKey1 = new ProtocolServiceKey(service1, null, null, "dubbo");
    ProtocolServiceKey protocolServiceKey2 = new ProtocolServiceKey(service2, null, null, "dubbo");
    Assertions.assertEquals(3, listener.getAddresses(protocolServiceKey1, consumerURL).size());
    assertTrue(isEmpty(listener.getAddresses(protocolServiceKey2, consumerURL)));
    //
    init();
    try {
        Thread.sleep(15000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    // check recovered after retry.
    List<URL> serviceUrls_after_retry = listener.getAddresses(protocolServiceKey1, consumerURL);
    Assertions.assertEquals(5, serviceUrls_after_retry.size());
    List<URL> serviceUrls2_after_retry = listener.getAddresses(protocolServiceKey2, consumerURL);
    Assertions.assertEquals(2, serviceUrls2_after_retry.size());
}
@AfterAll
public static void destroy() throws Exception {
    serviceDiscovery.destroy();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockServiceDiscovery {
    /**
     * Creates a mock ServiceDiscovery with standard stubbing for getRemoteMetadata and getUrl.
     * @param registryURL the URL to return from getUrl()
     * @param metadataInfo_111 MetadataInfo for revision "111"
     * @param metadataInfo_222 MetadataInfo for revision "222"
     * @param metadataInfo_333 MetadataInfo for revision "333"
     * @param metadataInfo_555_tri MetadataInfo for revision "555"
     * @param answer222 Answer<MetadataInfo> for getRemoteMetadata("222", ...)
     * @return configured mock ServiceDiscovery
     */
    public static ServiceDiscovery createMockServiceDiscovery(
            URL registryURL,
            MetadataInfo metadataInfo_111,
            MetadataInfo metadataInfo_222,
            MetadataInfo metadataInfo_333,
            MetadataInfo metadataInfo_555_tri,
            org.mockito.stubbing.Answer<MetadataInfo> answer222) {
        ServiceDiscovery serviceDiscovery = Mockito.mock(ServiceDiscovery.class);
        when(serviceDiscovery.getUrl()).thenReturn(registryURL);
        when(serviceDiscovery.getRemoteMetadata(eq("111"), anyList())).thenReturn(metadataInfo_111);
        when(serviceDiscovery.getRemoteMetadata(eq("222"), anyList())).thenReturn(metadataInfo_222);
        when(serviceDiscovery.getRemoteMetadata(eq("333"), anyList())).thenReturn(metadataInfo_333);
        when(serviceDiscovery.getRemoteMetadata(eq("444"), anyList())).thenReturn(MetadataInfo.EMPTY);
        when(serviceDiscovery.getRemoteMetadata(eq("555"), anyList())).thenReturn(metadataInfo_555_tri);
        when(serviceDiscovery.getRemoteMetadata(eq("222"), anyList())).thenAnswer(answer222);
        return serviceDiscovery;
    }
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_19
- **Scope**: class level
- **Mocked Class**: `org.apache.dubbo.metadata.MetadataService`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
public class MockMetadataService {
    public static MetadataService createMockMetadataService() {
        MetadataService metadataService = Mockito.mock(MetadataService.class);
        Mockito.doReturn(null).when(metadataService).getMetadataInfo(org.mockito.ArgumentMatchers.eq(null));
        return metadataService;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_19_1
#### Test Case Name: `testInstanceWithoutRevision`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerTest.java`)
#### Mock Object Variable Name: `metadataService`
<summary>Suggested Diff</summary>

```diff
--- Original
+++ Refactored
@@
    ServiceDiscovery serviceDiscovery = Mockito.mock(ServiceDiscovery.class);
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    ServiceInstancesChangedListener spyListener = Mockito.spy(listener);
-    Mockito.doReturn(null).when(metadataService).getMetadataInfo(eq(null));
+    metadataService = MockMetadataService.createMockMetadataService();
    ServiceInstancesChangedEvent event = new ServiceInstancesChangedEvent("app1", app1InstancesWithNoRevision);
    spyListener.onEvent(event);
    // notification succeeded
    assertTrue(true);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeAll
public static void setUp() {
    metadataService = Mockito.mock(MetadataService.class);
    List<Object> urlsSameRevision = new ArrayList<>();
    urlsSameRevision.add("127.0.0.1:20880?revision=111");
    urlsSameRevision.add("127.0.0.2:20880?revision=111");
    urlsSameRevision.add("127.0.0.3:20880?revision=111");
    List<Object> urlsDifferentRevision = new ArrayList<>();
    urlsDifferentRevision.add("30.10.0.1:20880?revision=222");
    urlsDifferentRevision.add("30.10.0.2:20880?revision=222");
    urlsDifferentRevision.add("30.10.0.3:20880?revision=333");
    urlsDifferentRevision.add("30.10.0.4:20880?revision=333");
    List<Object> urlsFailedRevision = new ArrayList<>();
    urlsFailedRevision.add("30.10.0.5:20880?revision=222");
    urlsFailedRevision.add("30.10.0.6:20880?revision=222");
    // revision will fail
    urlsFailedRevision.add("30.10.0.7:20880?revision=444");
    // revision will fail
    urlsFailedRevision.add("30.10.0.8:20880?revision=444");
    List<Object> urlsFailedRevision2 = new ArrayList<>();
    urlsFailedRevision2.add("30.10.0.1:20880?revision=222");
    urlsFailedRevision2.add("30.10.0.2:20880?revision=222");
    List<Object> urlsWithoutRevision = new ArrayList<>();
    urlsWithoutRevision.add("30.10.0.1:20880");
    List<Object> urlsMultipleProtocols = new ArrayList<>();
    //triple
    urlsMultipleProtocols.add("30.10.0.1:20880?revision=555");
    // dubbo
    urlsMultipleProtocols.addAll(urlsSameRevision);
    app1Instances = buildInstances(urlsSameRevision);
    app2Instances = buildInstances(urlsDifferentRevision);
    app1FailedInstances = buildInstances(urlsFailedRevision);
    app1FailedInstances2 = buildInstances(urlsFailedRevision2);
    app1InstancesWithNoRevision = buildInstances(urlsWithoutRevision);
    app1InstancesMultipleProtocols = buildInstances(urlsMultipleProtocols);
    metadataInfo_111 = JsonUtils.toJavaObject(metadata_111, MetadataInfo.class);
    metadataInfo_222 = JsonUtils.toJavaObject(metadata_222, MetadataInfo.class);
    metadataInfo_333 = JsonUtils.toJavaObject(metadata_333, MetadataInfo.class);
    metadataInfo_444 = JsonUtils.toJavaObject(metadata_444, MetadataInfo.class);
    metadataInfo_555_tri = JsonUtils.toJavaObject(metadata_555_triple, MetadataInfo.class);
    serviceDiscovery = Mockito.mock(ServiceDiscovery.class);
    when(serviceDiscovery.getUrl()).thenReturn(registryURL);
    when(serviceDiscovery.getRemoteMetadata(eq("111"), anyList())).thenReturn(metadataInfo_111);
    when(serviceDiscovery.getRemoteMetadata(eq("222"), anyList())).thenReturn(metadataInfo_222);
    when(serviceDiscovery.getRemoteMetadata(eq("333"), anyList())).thenReturn(metadataInfo_333);
    when(serviceDiscovery.getRemoteMetadata(eq("444"), anyList())).thenReturn(MetadataInfo.EMPTY);
    when(serviceDiscovery.getRemoteMetadata(eq("555"), anyList())).thenReturn(metadataInfo_555_tri);
}
// Abnormal case. Instance does not have revision
@Test
@Order(12)
public void testInstanceWithoutRevision() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    ServiceDiscovery serviceDiscovery = Mockito.mock(ServiceDiscovery.class);
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    ServiceInstancesChangedListener spyListener = Mockito.spy(listener);
    Mockito.doReturn(null).when(metadataService).getMetadataInfo(eq(null));
    ServiceInstancesChangedEvent event = new ServiceInstancesChangedEvent("app1", app1InstancesWithNoRevision);
    spyListener.onEvent(event);
    // notification succeeded
    assertTrue(true);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockMetadataService {
    public static MetadataService createMockMetadataService() {
        MetadataService metadataService = Mockito.mock(MetadataService.class);
        Mockito.doReturn(null).when(metadataService).getMetadataInfo(org.mockito.ArgumentMatchers.eq(null));
        return metadataService;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_19_2
#### Test Case Name: `testInstanceWithoutRevision`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerWithoutEmptyProtectTest.java`)
#### Mock Object Variable Name: `metadataService`
<summary>Suggested Diff</summary>

```diff
--- Original
+++ Refactored
@@
    ServiceDiscovery serviceDiscovery = Mockito.mock(ServiceDiscovery.class);
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    ServiceInstancesChangedListener spyListener = Mockito.spy(listener);
-    Mockito.doReturn(null).when(metadataService).getMetadataInfo(eq(null));
+    metadataService = MockMetadataService.createMockMetadataService();
    ServiceInstancesChangedEvent event = new ServiceInstancesChangedEvent("app1", app1InstancesWithNoRevision);
    spyListener.onEvent(event);
    // notification succeeded
    assertTrue(true);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeAll
public static void setUp() {
    metadataService = Mockito.mock(MetadataService.class);
    List<Object> urlsSameRevision = new ArrayList<>();
    urlsSameRevision.add("127.0.0.1:20880?revision=111");
    urlsSameRevision.add("127.0.0.2:20880?revision=111");
    urlsSameRevision.add("127.0.0.3:20880?revision=111");
    List<Object> urlsDifferentRevision = new ArrayList<>();
    urlsDifferentRevision.add("30.10.0.1:20880?revision=222");
    urlsDifferentRevision.add("30.10.0.2:20880?revision=222");
    urlsDifferentRevision.add("30.10.0.3:20880?revision=333");
    urlsDifferentRevision.add("30.10.0.4:20880?revision=333");
    List<Object> urlsFailedRevision = new ArrayList<>();
    urlsFailedRevision.add("30.10.0.5:20880?revision=222");
    urlsFailedRevision.add("30.10.0.6:20880?revision=222");
    // revision will fail
    urlsFailedRevision.add("30.10.0.7:20880?revision=444");
    // revision will fail
    urlsFailedRevision.add("30.10.0.8:20880?revision=444");
    List<Object> urlsFailedRevision2 = new ArrayList<>();
    urlsFailedRevision2.add("30.10.0.1:20880?revision=222");
    urlsFailedRevision2.add("30.10.0.2:20880?revision=222");
    List<Object> urlsWithoutRevision = new ArrayList<>();
    urlsWithoutRevision.add("30.10.0.1:20880");
    List<Object> urlsMultipleProtocols = new ArrayList<>();
    //triple
    urlsMultipleProtocols.add("30.10.0.1:20880?revision=555");
    // dubbo
    urlsMultipleProtocols.addAll(urlsSameRevision);
    app1Instances = buildInstances(urlsSameRevision);
    app2Instances = buildInstances(urlsDifferentRevision);
    app1FailedInstances = buildInstances(urlsFailedRevision);
    app1FailedInstances2 = buildInstances(urlsFailedRevision2);
    app1InstancesWithNoRevision = buildInstances(urlsWithoutRevision);
    app1InstancesMultipleProtocols = buildInstances(urlsMultipleProtocols);
    metadataInfo_111 = JsonUtils.toJavaObject(metadata_111, MetadataInfo.class);
    metadataInfo_222 = JsonUtils.toJavaObject(metadata_222, MetadataInfo.class);
    metadataInfo_333 = JsonUtils.toJavaObject(metadata_333, MetadataInfo.class);
    metadataInfo_444 = JsonUtils.toJavaObject(metadata_444, MetadataInfo.class);
    metadataInfo_555_tri = JsonUtils.toJavaObject(metadata_555_triple, MetadataInfo.class);
    serviceDiscovery = Mockito.mock(ServiceDiscovery.class);
    when(serviceDiscovery.getUrl()).thenReturn(registryURL);
    when(serviceDiscovery.getRemoteMetadata(eq("111"), anyList())).thenReturn(metadataInfo_111);
    when(serviceDiscovery.getRemoteMetadata(eq("222"), anyList())).thenReturn(metadataInfo_222);
    when(serviceDiscovery.getRemoteMetadata(eq("333"), anyList())).thenReturn(metadataInfo_333);
    when(serviceDiscovery.getRemoteMetadata(eq("444"), anyList())).thenReturn(MetadataInfo.EMPTY);
    when(serviceDiscovery.getRemoteMetadata(eq("555"), anyList())).thenReturn(metadataInfo_555_tri);
}
// Abnormal case. Instance does not have revision
@Test
@Order(12)
public void testInstanceWithoutRevision() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    ServiceDiscovery serviceDiscovery = Mockito.mock(ServiceDiscovery.class);
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    ServiceInstancesChangedListener spyListener = Mockito.spy(listener);
    Mockito.doReturn(null).when(metadataService).getMetadataInfo(eq(null));
    ServiceInstancesChangedEvent event = new ServiceInstancesChangedEvent("app1", app1InstancesWithNoRevision);
    spyListener.onEvent(event);
    // notification succeeded
    assertTrue(true);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockMetadataService {
    public static MetadataService createMockMetadataService() {
        MetadataService metadataService = Mockito.mock(MetadataService.class);
        Mockito.doReturn(null).when(metadataService).getMetadataInfo(org.mockito.ArgumentMatchers.eq(null));
        return metadataService;
    }
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_20
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.remoting.Channel`
- **Test Case Count**: 4
- **MO Count**: 4

### Reusable Method
```java
private static Channel createMockChannel(URL url) {
    Channel channel = mock(Channel.class);
    given(channel.getUrl()).willReturn(url);
    return channel;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_20_1
#### Test Case Name: `testCheckPayloadDefault8M`(File: `C:\Java_projects\Apache\dubbo\dubbo-remoting\dubbo-remoting-api\src\test\java\org\apache\dubbo\remoting\transport\AbstractCodecTest.java`)
#### Mock Object Variable Name: `channel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testCheckPayloadDefault8M() throws Exception {
-    Channel channel = mock(Channel.class);
-    given(channel.getUrl()).willReturn(URL.valueOf("dubbo://1.1.1.1"));
+    Channel channel = createMockChannel(URL.valueOf("dubbo://1.1.1.1"));
    AbstractCodec.checkPayload(channel, 1 * 1024 * 1024);
    try {
        AbstractCodec.checkPayload(channel, 15 * 1024 * 1024);
    } catch (IOException expected) {
        assertThat(expected.getMessage(), allOf(containsString("Data length too large: "), containsString("max payload: " + 8 * 1024 * 1024)));
    }
    verify(channel, VerificationModeFactory.atLeastOnce()).getUrl();
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testCheckPayloadDefault8M() throws Exception {
    Channel channel = mock(Channel.class);
    given(channel.getUrl()).willReturn(URL.valueOf("dubbo://1.1.1.1"));
    AbstractCodec.checkPayload(channel, 1 * 1024 * 1024);
    try {
        AbstractCodec.checkPayload(channel, 15 * 1024 * 1024);
    } catch (IOException expected) {
        assertThat(expected.getMessage(), allOf(containsString("Data length too large: "), containsString("max payload: " + 8 * 1024 * 1024)));
    }
    verify(channel, VerificationModeFactory.atLeastOnce()).getUrl();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Channel createMockChannel(URL url) {
    Channel channel = mock(Channel.class);
    given(channel.getUrl()).willReturn(url);
    return channel;
}
```
</details>

---
#### Test Case ID #dubbo_Test_20_2
#### Test Case Name: `testCheckProviderPayload`(File: `C:\Java_projects\Apache\dubbo\dubbo-remoting\dubbo-remoting-api\src\test\java\org\apache\dubbo\remoting\transport\AbstractCodecTest.java`)
#### Mock Object Variable Name: `channel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 void testCheckProviderPayload() throws Exception {
-    Channel channel = mock(Channel.class);
-    given(channel.getUrl()).willReturn(URL.valueOf("dubbo://1.1.1.1"));
+    Channel channel = createMockChannel(URL.valueOf("dubbo://1.1.1.1"));
     AbstractCodec.checkPayload(channel, 1024 * 1024 + 1, 1024 * 1024);
     try {
         AbstractCodec.checkPayload(channel, 1024 * 1024, 1024 * 1024);
     } catch (IOException expected) {
         assertThat(expected.getMessage(), allOf(containsString("Data length too large: "), containsString("max payload: " + 1024 * 1024)));
     }
     try {
         AbstractCodec.checkPayload(channel, 0, 15 * 1024 * 1024);
     } catch (IOException expected) {
         assertThat(expected.getMessage(), allOf(containsString("Data length too large: "), containsString("max payload: " + 8 * 1024 * 1024)));
     }
     verify(channel, VerificationModeFactory.atLeastOnce()).getUrl();
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testCheckProviderPayload() throws Exception {
    Channel channel = mock(Channel.class);
    given(channel.getUrl()).willReturn(URL.valueOf("dubbo://1.1.1.1"));
    AbstractCodec.checkPayload(channel, 1024 * 1024 + 1, 1024 * 1024);
    try {
        AbstractCodec.checkPayload(channel, 1024 * 1024, 1024 * 1024);
    } catch (IOException expected) {
        assertThat(expected.getMessage(), allOf(containsString("Data length too large: "), containsString("max payload: " + 1024 * 1024)));
    }
    try {
        AbstractCodec.checkPayload(channel, 0, 15 * 1024 * 1024);
    } catch (IOException expected) {
        assertThat(expected.getMessage(), allOf(containsString("Data length too large: "), containsString("max payload: " + 8 * 1024 * 1024)));
    }
    verify(channel, VerificationModeFactory.atLeastOnce()).getUrl();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Channel createMockChannel(URL url) {
    Channel channel = mock(Channel.class);
    given(channel.getUrl()).willReturn(url);
    return channel;
}
```
</details>

---
#### Test Case ID #dubbo_Test_20_3
#### Test Case Name: `tesCheckPayloadMinusPayloadNoLimit`(File: `C:\Java_projects\Apache\dubbo\dubbo-remoting\dubbo-remoting-api\src\test\java\org\apache\dubbo\remoting\transport\AbstractCodecTest.java`)
#### Mock Object Variable Name: `channel`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void tesCheckPayloadMinusPayloadNoLimit() throws Exception {
-    Channel channel = mock(Channel.class);
-    given(channel.getUrl()).willReturn(URL.valueOf("dubbo://1.1.1.1?payload=-1"));
+    Channel channel = createMockChannel(URL.valueOf("dubbo://1.1.1.1?payload=-1"));
     AbstractCodec.checkPayload(channel, 15 * 1024 * 1024);
     verify(channel, VerificationModeFactory.atLeastOnce()).getUrl();
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void tesCheckPayloadMinusPayloadNoLimit() throws Exception {
    Channel channel = mock(Channel.class);
    given(channel.getUrl()).willReturn(URL.valueOf("dubbo://1.1.1.1?payload=-1"));
    AbstractCodec.checkPayload(channel, 15 * 1024 * 1024);
    verify(channel, VerificationModeFactory.atLeastOnce()).getUrl();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Channel createMockChannel(URL url) {
    Channel channel = mock(Channel.class);
    given(channel.getUrl()).willReturn(url);
    return channel;
}
```
</details>

---
#### Test Case ID #dubbo_Test_20_4
#### Test Case Name: `testIsClientSide`(File: `C:\Java_projects\Apache\dubbo\dubbo-remoting\dubbo-remoting-api\src\test\java\org\apache\dubbo\remoting\transport\AbstractCodecTest.java`)
#### Mock Object Variable Name: `channel`
<summary>Suggested Diff</summary>

```diff
@@
     AbstractCodec codec = getAbstractCodec();
-    Channel channel = mock(Channel.class);
-    given(channel.getRemoteAddress()).willReturn(new InetSocketAddress("172.24.157.13", 9103));
-    given(channel.getUrl()).willReturn(URL.valueOf("dubbo://172.24.157.13:9103"));
+    Channel channel = createMockChannel(URL.valueOf("dubbo://172.24.157.13:9103"));
+    given(channel.getRemoteAddress()).willReturn(new InetSocketAddress("172.24.157.13", 9103));
     assertThat(codec.isClientSide(channel), is(true));
     assertThat(codec.isServerSide(channel), is(false));
-    given(channel.getRemoteAddress()).willReturn(new InetSocketAddress("172.24.157.14", 9103));
-    given(channel.getUrl()).willReturn(URL.valueOf("dubbo://172.24.157.13:9103"));
+    given(channel.getRemoteAddress()).willReturn(new InetSocketAddress("172.24.157.14", 9103));
+    given(channel.getUrl()).willReturn(URL.valueOf("dubbo://172.24.157.13:9103"));
     assertThat(codec.isClientSide(channel), is(false));
     assertThat(codec.isServerSide(channel), is(true));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testIsClientSide() {
    AbstractCodec codec = getAbstractCodec();
    Channel channel = mock(Channel.class);
    given(channel.getRemoteAddress()).willReturn(new InetSocketAddress("172.24.157.13", 9103));
    given(channel.getUrl()).willReturn(URL.valueOf("dubbo://172.24.157.13:9103"));
    assertThat(codec.isClientSide(channel), is(true));
    assertThat(codec.isServerSide(channel), is(false));
    given(channel.getRemoteAddress()).willReturn(new InetSocketAddress("172.24.157.14", 9103));
    given(channel.getUrl()).willReturn(URL.valueOf("dubbo://172.24.157.13:9103"));
    assertThat(codec.isClientSide(channel), is(false));
    assertThat(codec.isServerSide(channel), is(true));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Channel createMockChannel(URL url) {
    Channel channel = mock(Channel.class);
    given(channel.getUrl()).willReturn(url);
    return channel;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_21
- **Scope**: class level
- **Mocked Class**: `org.apache.dubbo.remoting.Channel`
- **Test Case Count**: 2
- **MO Count**: 3

### Reusable Method
```java
public class MockChannel {
    /**
     * Creates a mock Channel with the given URL to be returned by getUrl().
     *
     * @param url the URL to return from channel.getUrl()
     * @return a mock Channel
     */
    public static Channel createMockChannel(org.apache.dubbo.common.URL url) {
        Channel channel = Mockito.mock(Channel.class);
        Mockito.when(channel.getUrl()).thenReturn(url);
        return channel;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_21_1
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-remoting\dubbo-remoting-api\src\test\java\org\apache\dubbo\remoting\telnet\support\HelpTelnetHandlerTest.java`)
#### Mock Object Variable Name: `channel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void test() {
-    Channel channel = Mockito.mock(Channel.class);
-    Mockito.when(channel.getUrl()).thenReturn(URL.valueOf("dubbo://127.0.0.1:12345"));
+    Channel channel = MockChannel.createMockChannel(URL.valueOf("dubbo://127.0.0.1:12345"));
    HelpTelnetHandler helpTelnetHandler = new HelpTelnetHandler(FrameworkModel.defaultModel());
    // default output
    String prompt = "Please input \"help [command]\" show detail.\r\n";
    Assertions.assertTrue(helpTelnetHandler.telnet(channel, "").contains(prompt));
    // "help" command output
    String demoOutput = "Command:\r\n" + "    help [command]\r\n" + "Summary:\r\n" + "    Show help.\r\n" + "Detail:\r\n" + "    Show help.";
    Assertions.assertEquals(helpTelnetHandler.telnet(channel, "help"), demoOutput);
}
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void test() {
    Channel channel = Mockito.mock(Channel.class);
    Mockito.when(channel.getUrl()).thenReturn(URL.valueOf("dubbo://127.0.0.1:12345"));
    HelpTelnetHandler helpTelnetHandler = new HelpTelnetHandler(FrameworkModel.defaultModel());
    // default output
    String prompt = "Please input \"help [command]\" show detail.\r\n";
    Assertions.assertTrue(helpTelnetHandler.telnet(channel, "").contains(prompt));
    // "help" command output
    String demoOutput = "Command:\r\n" + "    help [command]\r\n" + "Summary:\r\n" + "    Show help.\r\n" + "Detail:\r\n" + "    Show help.";
    Assertions.assertEquals(helpTelnetHandler.telnet(channel, "help"), demoOutput);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockChannel {
    /**
     * Creates a mock Channel with the given URL to be returned by getUrl().
     *
     * @param url the URL to return from channel.getUrl()
     * @return a mock Channel
     */
    public static Channel createMockChannel(org.apache.dubbo.common.URL url) {
        Channel channel = Mockito.mock(Channel.class);
        Mockito.when(channel.getUrl()).thenReturn(url);
        return channel;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_21_2
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-remoting\dubbo-remoting-api\src\test\java\org\apache\dubbo\remoting\telnet\support\StatusTelnetHandlerTest.java`)
#### Mock Object Variable Name: `channel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 void test() {
-    Channel channel = Mockito.mock(Channel.class);
-    Mockito.when(channel.getUrl()).thenReturn(URL.valueOf("dubbo://127.0.0.1:12345"));
+    Channel channel = MockChannel.createMockChannel(URL.valueOf("dubbo://127.0.0.1:12345"));
     StatusTelnetHandler statusTelnetHandler = new StatusTelnetHandler();
     Assertions.assertNotNull(statusTelnetHandler.telnet(channel, ""));
     Assertions.assertNotNull(statusTelnetHandler.telnet(channel, "-l"));
     String errorPrompt = "Unsupported parameter ";
     Assertions.assertTrue(statusTelnetHandler.telnet(channel, "other").contains(errorPrompt));
-    Mockito.when(channel.getUrl()).thenReturn(URL.valueOf("dubbo://127.0.0.1:12345?status=load,memory"));
+    Mockito.when(channel.getUrl()).thenReturn(URL.valueOf("dubbo://127.0.0.1:12345?status=load,memory"));
     Assertions.assertNotNull(statusTelnetHandler.telnet(channel, ""));
     Assertions.assertNotNull(statusTelnetHandler.telnet(channel, "-l"));
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void test() {
    Channel channel = Mockito.mock(Channel.class);
    Mockito.when(channel.getUrl()).thenReturn(URL.valueOf("dubbo://127.0.0.1:12345"));
    StatusTelnetHandler statusTelnetHandler = new StatusTelnetHandler();
    Assertions.assertNotNull(statusTelnetHandler.telnet(channel, ""));
    Assertions.assertNotNull(statusTelnetHandler.telnet(channel, "-l"));
    String errorPrompt = "Unsupported parameter ";
    Assertions.assertTrue(statusTelnetHandler.telnet(channel, "other").contains(errorPrompt));
    Mockito.when(channel.getUrl()).thenReturn(URL.valueOf("dubbo://127.0.0.1:12345?status=load,memory"));
    Assertions.assertNotNull(statusTelnetHandler.telnet(channel, ""));
    Assertions.assertNotNull(statusTelnetHandler.telnet(channel, "-l"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockChannel {
    /**
     * Creates a mock Channel with the given URL to be returned by getUrl().
     *
     * @param url the URL to return from channel.getUrl()
     * @return a mock Channel
     */
    public static Channel createMockChannel(org.apache.dubbo.common.URL url) {
        Channel channel = Mockito.mock(Channel.class);
        Mockito.when(channel.getUrl()).thenReturn(url);
        return channel;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_21_3
#### Test Case Name: `testTelnet`(File: `C:\Java_projects\Apache\dubbo\dubbo-remoting\dubbo-remoting-api\src\test\java\org\apache\dubbo\remoting\telnet\support\TelnetHandlerAdapterTest.java`)
#### Mock Object Variable Name: `channel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 void testTelnet() throws RemotingException {
-    Channel channel = Mockito.mock(Channel.class);
     Map<String, String> param = new HashMap<>();
     param.put("telnet", "status");
     URL url = new URL("p1", "127.0.0.1", 12345, "path1", param);
+    Channel channel = MockChannel.createMockChannel(url);
     TelnetHandlerAdapter telnetHandlerAdapter = new TelnetHandlerAdapter(FrameworkModel.defaultModel());
     String message = "--no-prompt status ";
     String expectedResult = "OK\r\n";
     Assertions.assertEquals(expectedResult, telnetHandlerAdapter.telnet(channel, message));
     message = "--no-prompt status test";
     expectedResult = "Unsupported parameter test for status.\r\n";
     Assertions.assertEquals(expectedResult, telnetHandlerAdapter.telnet(channel, message));
     message = "--no-prompt test";
     expectedResult = "Unsupported command: test\r\n";
     Assertions.assertEquals(expectedResult, telnetHandlerAdapter.telnet(channel, message));
     message = "--no-prompt help";
     expectedResult = "Command: help disabled for security reasons, please enable support by listing the commands through 'telnet'\r\n";
     Assertions.assertEquals(expectedResult, telnetHandlerAdapter.telnet(channel, message));
     message = "--no-prompt";
     expectedResult = StringUtils.EMPTY_STRING;
     Assertions.assertEquals(expectedResult, telnetHandlerAdapter.telnet(channel, message));
     message = "help";
     expectedResult = "Command: help disabled for security reasons, please enable support by listing the commands through 'telnet'\r\ndubbo>";
     Assertions.assertEquals(expectedResult, telnetHandlerAdapter.telnet(channel, message));
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testTelnet() throws RemotingException {
    Channel channel = Mockito.mock(Channel.class);
    Map<String, String> param = new HashMap<>();
    param.put("telnet", "status");
    URL url = new URL("p1", "127.0.0.1", 12345, "path1", param);
    Mockito.when(channel.getUrl()).thenReturn(url);
    TelnetHandlerAdapter telnetHandlerAdapter = new TelnetHandlerAdapter(FrameworkModel.defaultModel());
    String message = "--no-prompt status ";
    String expectedResult = "OK\r\n";
    Assertions.assertEquals(expectedResult, telnetHandlerAdapter.telnet(channel, message));
    message = "--no-prompt status test";
    expectedResult = "Unsupported parameter test for status.\r\n";
    Assertions.assertEquals(expectedResult, telnetHandlerAdapter.telnet(channel, message));
    message = "--no-prompt test";
    expectedResult = "Unsupported command: test\r\n";
    Assertions.assertEquals(expectedResult, telnetHandlerAdapter.telnet(channel, message));
    message = "--no-prompt help";
    expectedResult = "Command: help disabled for security reasons, please enable support by listing the commands through 'telnet'\r\n";
    Assertions.assertEquals(expectedResult, telnetHandlerAdapter.telnet(channel, message));
    message = "--no-prompt";
    expectedResult = StringUtils.EMPTY_STRING;
    Assertions.assertEquals(expectedResult, telnetHandlerAdapter.telnet(channel, message));
    message = "help";
    expectedResult = "Command: help disabled for security reasons, please enable support by listing the commands through 'telnet'\r\ndubbo>";
    Assertions.assertEquals(expectedResult, telnetHandlerAdapter.telnet(channel, message));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockChannel {
    /**
     * Creates a mock Channel with the given URL to be returned by getUrl().
     *
     * @param url the URL to return from channel.getUrl()
     * @return a mock Channel
     */
    public static Channel createMockChannel(org.apache.dubbo.common.URL url) {
        Channel channel = Mockito.mock(Channel.class);
        Mockito.when(channel.getUrl()).thenReturn(url);
        return channel;
    }
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_22
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.remoting.Channel`
- **Test Case Count**: 1
- **MO Count**: 2

### Reusable Method
```java
private static Channel createMockChannel(Object attributeValue) {
    Channel channel = Mockito.mock(Channel.class);
    Mockito.when(channel.getAttribute(HeaderExchangeChannel.class.getName() + ".CHANNEL")).thenReturn(attributeValue);
    return channel;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_22_1
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-remoting\dubbo-remoting-api\src\test\java\org\apache\dubbo\remoting\exchange\support\header\HeaderExchangeServerTest.java`)
#### Mock Object Variable Name: `channel1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
     // test getChannels() and getExchangeChannels()
-    Channel channel1 = Mockito.mock(Channel.class);
+    Channel channel1 = createMockChannel(exchangeChannel1);
     Channel channel2 = Mockito.mock(Channel.class);
     Channel exchangeChannel1 = new HeaderExchangeChannel(channel1);
     Channel exchangeChannel2 = new HeaderExchangeChannel(channel2);
-    Mockito.when(channel1.getAttribute(HeaderExchangeChannel.class.getName() + ".CHANNEL")).thenReturn(exchangeChannel1);
     Mockito.when(channel2.getAttribute(HeaderExchangeChannel.class.getName() + ".CHANNEL")).thenReturn(exchangeChannel2);
     Collection<Channel> exChannels = Arrays.asList(exchangeChannel1, exchangeChannel2);
     Mockito.when(server.getChannels()).thenReturn(Arrays.asList(channel1, channel2));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void test() throws InterruptedException, RemotingException {
    RemotingServer server = Mockito.mock(RemotingServer.class);
    URL url = new ServiceConfigURL("dubbo", "127.0.0.1", 20881);
    Mockito.when(server.getUrl()).thenReturn(url);
    Mockito.when(server.canHandleIdle()).thenReturn(false);
    HeaderExchangeServer headerExchangeServer = new HeaderExchangeServer(server);
    Assertions.assertEquals(headerExchangeServer.getServer(), server);
    Assertions.assertEquals(headerExchangeServer.getUrl(), url);
    // test getChannels() and getExchangeChannels()
    Channel channel1 = Mockito.mock(Channel.class);
    Channel channel2 = Mockito.mock(Channel.class);
    Channel exchangeChannel1 = new HeaderExchangeChannel(channel1);
    Channel exchangeChannel2 = new HeaderExchangeChannel(channel2);
    Mockito.when(channel1.getAttribute(HeaderExchangeChannel.class.getName() + ".CHANNEL")).thenReturn(exchangeChannel1);
    Mockito.when(channel2.getAttribute(HeaderExchangeChannel.class.getName() + ".CHANNEL")).thenReturn(exchangeChannel2);
    Collection<Channel> exChannels = Arrays.asList(exchangeChannel1, exchangeChannel2);
    Mockito.when(server.getChannels()).thenReturn(Arrays.asList(channel1, channel2));
    Assertions.assertEquals(headerExchangeServer.getChannels(), exChannels);
    Assertions.assertEquals(headerExchangeServer.getExchangeChannels(), exChannels);
    // test getChannel(InetSocketAddress) and getExchangeChannel(InetSocketAddress)
    InetSocketAddress address1 = Mockito.mock(InetSocketAddress.class);
    InetSocketAddress address2 = Mockito.mock(InetSocketAddress.class);
    Mockito.when(server.getChannel(Mockito.eq(address1))).thenReturn(channel1);
    Mockito.when(server.getChannel(Mockito.eq(address2))).thenReturn(channel2);
    Assertions.assertEquals(headerExchangeServer.getChannel(address1), exchangeChannel1);
    Assertions.assertEquals(headerExchangeServer.getChannel(address2), exchangeChannel2);
    Assertions.assertEquals(headerExchangeServer.getExchangeChannel(address1), exchangeChannel1);
    Assertions.assertEquals(headerExchangeServer.getExchangeChannel(address2), exchangeChannel2);
    // test send(Object message) and send(Object message, boolean sent)
    headerExchangeServer.send("test");
    Mockito.verify(server, Mockito.times(1)).send("test");
    headerExchangeServer.send("test", true);
    Mockito.verify(server, Mockito.times(1)).send("test", true);
    // test reset(URL url)
    url = url.addParameter(Constants.HEARTBEAT_KEY, 3000).addParameter(Constants.HEARTBEAT_TIMEOUT_KEY, 3000 * 3);
    headerExchangeServer.reset(url);
    // test close(int timeout)
    Mockito.when(exchangeChannel1.isConnected()).thenReturn(true);
    headerExchangeServer.close(1000);
    Mockito.verify(server, Mockito.times(1)).startClose();
    Thread.sleep(1000);
    Mockito.verify(server, Mockito.times(1)).close(1000);
    Assertions.assertThrows(RemotingException.class, () -> headerExchangeServer.send("test"));
    Assertions.assertThrows(RemotingException.class, () -> headerExchangeServer.send("test", true));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Channel createMockChannel(Object attributeValue) {
    Channel channel = Mockito.mock(Channel.class);
    Mockito.when(channel.getAttribute(HeaderExchangeChannel.class.getName() + ".CHANNEL")).thenReturn(attributeValue);
    return channel;
}
```
</details>

---
#### Test Case ID #dubbo_Test_22_2
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-remoting\dubbo-remoting-api\src\test\java\org\apache\dubbo\remoting\exchange\support\header\HeaderExchangeServerTest.java`)
#### Mock Object Variable Name: `channel2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Channel channel1 = Mockito.mock(Channel.class);
-    Channel channel2 = Mockito.mock(Channel.class);
    Channel exchangeChannel1 = new HeaderExchangeChannel(channel1);
    Channel exchangeChannel2 = new HeaderExchangeChannel(channel2);
    Mockito.when(channel1.getAttribute(HeaderExchangeChannel.class.getName() + ".CHANNEL")).thenReturn(exchangeChannel1);
-    Mockito.when(channel2.getAttribute(HeaderExchangeChannel.class.getName() + ".CHANNEL")).thenReturn(exchangeChannel2);
+    Channel channel2 = createMockChannel(exchangeChannel2);
    Collection<Channel> exChannels = Arrays.asList(exchangeChannel1, exchangeChannel2);
    Mockito.when(server.getChannels()).thenReturn(Arrays.asList(channel1, channel2));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void test() throws InterruptedException, RemotingException {
    RemotingServer server = Mockito.mock(RemotingServer.class);
    URL url = new ServiceConfigURL("dubbo", "127.0.0.1", 20881);
    Mockito.when(server.getUrl()).thenReturn(url);
    Mockito.when(server.canHandleIdle()).thenReturn(false);
    HeaderExchangeServer headerExchangeServer = new HeaderExchangeServer(server);
    Assertions.assertEquals(headerExchangeServer.getServer(), server);
    Assertions.assertEquals(headerExchangeServer.getUrl(), url);
    // test getChannels() and getExchangeChannels()
    Channel channel1 = Mockito.mock(Channel.class);
    Channel channel2 = Mockito.mock(Channel.class);
    Channel exchangeChannel1 = new HeaderExchangeChannel(channel1);
    Channel exchangeChannel2 = new HeaderExchangeChannel(channel2);
    Mockito.when(channel1.getAttribute(HeaderExchangeChannel.class.getName() + ".CHANNEL")).thenReturn(exchangeChannel1);
    Mockito.when(channel2.getAttribute(HeaderExchangeChannel.class.getName() + ".CHANNEL")).thenReturn(exchangeChannel2);
    Collection<Channel> exChannels = Arrays.asList(exchangeChannel1, exchangeChannel2);
    Mockito.when(server.getChannels()).thenReturn(Arrays.asList(channel1, channel2));
    Assertions.assertEquals(headerExchangeServer.getChannels(), exChannels);
    Assertions.assertEquals(headerExchangeServer.getExchangeChannels(), exChannels);
    // test getChannel(InetSocketAddress) and getExchangeChannel(InetSocketAddress)
    InetSocketAddress address1 = Mockito.mock(InetSocketAddress.class);
    InetSocketAddress address2 = Mockito.mock(InetSocketAddress.class);
    Mockito.when(server.getChannel(Mockito.eq(address1))).thenReturn(channel1);
    Mockito.when(server.getChannel(Mockito.eq(address2))).thenReturn(channel2);
    Assertions.assertEquals(headerExchangeServer.getChannel(address1), exchangeChannel1);
    Assertions.assertEquals(headerExchangeServer.getChannel(address2), exchangeChannel2);
    Assertions.assertEquals(headerExchangeServer.getExchangeChannel(address1), exchangeChannel1);
    Assertions.assertEquals(headerExchangeServer.getExchangeChannel(address2), exchangeChannel2);
    // test send(Object message) and send(Object message, boolean sent)
    headerExchangeServer.send("test");
    Mockito.verify(server, Mockito.times(1)).send("test");
    headerExchangeServer.send("test", true);
    Mockito.verify(server, Mockito.times(1)).send("test", true);
    // test reset(URL url)
    url = url.addParameter(Constants.HEARTBEAT_KEY, 3000).addParameter(Constants.HEARTBEAT_TIMEOUT_KEY, 3000 * 3);
    headerExchangeServer.reset(url);
    // test close(int timeout)
    Mockito.when(exchangeChannel1.isConnected()).thenReturn(true);
    headerExchangeServer.close(1000);
    Mockito.verify(server, Mockito.times(1)).startClose();
    Thread.sleep(1000);
    Mockito.verify(server, Mockito.times(1)).close(1000);
    Assertions.assertThrows(RemotingException.class, () -> headerExchangeServer.send("test"));
    Assertions.assertThrows(RemotingException.class, () -> headerExchangeServer.send("test", true));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Channel createMockChannel(Object attributeValue) {
    Channel channel = Mockito.mock(Channel.class);
    Mockito.when(channel.getAttribute(HeaderExchangeChannel.class.getName() + ".CHANNEL")).thenReturn(attributeValue);
    return channel;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_23
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.model.ServiceDescriptor`
- **Test Case Count**: 5
- **MO Count**: 5

### Reusable Method
```java
// === Declare in class scope ===
private ServiceDescriptor serviceDescriptor;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
}

// === Replace local variable in test with ===
serviceDescriptor;

```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_23_1
#### Test Case Name: `unaryCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `serviceDescriptor`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void unaryCall() throws Throwable {
     Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
     URL url = Mockito.mock(URL.class);
     ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
-    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
+    // removed local mock; replaced with global field `serviceDescriptor`
     when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
     when(url.getServiceModel()).thenReturn(consumerModel);
     when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
     when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
     when(invoker.getUrl()).thenReturn(url);
     when(invoker.getInterface()).thenReturn(IGreeter.class);
     Result result = Mockito.mock(Result.class);
     when(invoker.invoke(any(Invocation.class))).thenReturn(result);
     String response = "response";
     when(result.recreate()).thenReturn(response);
     MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
     when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
     when(method.getMethodName()).thenReturn("sayHello");
     String request = "request";
     Object ret = StubInvocationUtil.unaryCall(invoker, method, request);
     Assertions.assertEquals(response, ret);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void unaryCall() throws Throwable {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    when(invoker.invoke(any(Invocation.class))).thenReturn(result);
    String response = "response";
    when(result.recreate()).thenReturn(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    Object ret = StubInvocationUtil.unaryCall(invoker, method, request);
    Assertions.assertEquals(response, ret);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private ServiceDescriptor serviceDescriptor;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
}

// === Replace local variable in test with ===
serviceDescriptor;

```
</details>

---
#### Test Case ID #dubbo_Test_23_2
#### Test Case Name: `unaryCall2`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `serviceDescriptor`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void unaryCall2() throws Throwable {
     Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
     URL url = Mockito.mock(URL.class);
     ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
-    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
+    // removed local mock; replaced with global field `serviceDescriptor`
     when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
     when(url.getServiceModel()).thenReturn(consumerModel);
     when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
     when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
     when(invoker.getUrl()).thenReturn(url);
     when(invoker.getInterface()).thenReturn(IGreeter.class);
     Result result = Mockito.mock(Result.class);
     when(invoker.invoke(any(Invocation.class))).thenThrow(new RuntimeException("a")).thenThrow(new Error("b"));
     String response = "response";
     when(result.recreate()).thenReturn(response);
     MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
     when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
     when(method.getMethodName()).thenReturn("sayHello");
     String request = "request";
     try {
         StubInvocationUtil.unaryCall(invoker, method, request);
         fail();
     } catch (Throwable t) {
         // pass
     }
     try {
         StubInvocationUtil.unaryCall(invoker, method, request);
         fail();
     } catch (Throwable t) {
         // pass
     }
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void unaryCall2() throws Throwable {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    when(invoker.invoke(any(Invocation.class))).thenThrow(new RuntimeException("a")).thenThrow(new Error("b"));
    String response = "response";
    when(result.recreate()).thenReturn(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    try {
        StubInvocationUtil.unaryCall(invoker, method, request);
        fail();
    } catch (Throwable t) {
        // pass
    }
    try {
        StubInvocationUtil.unaryCall(invoker, method, request);
        fail();
    } catch (Throwable t) {
        // pass
    }
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private ServiceDescriptor serviceDescriptor;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
}

// === Replace local variable in test with ===
serviceDescriptor;

```
</details>

---
#### Test Case ID #dubbo_Test_23_3
#### Test Case Name: `testUnaryCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `serviceDescriptor`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void testUnaryCall() throws Throwable {
     Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
     URL url = Mockito.mock(URL.class);
     ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
-    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
+    // removed local mock; replaced with global field `serviceDescriptor`
     when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
     when(url.getServiceModel()).thenReturn(consumerModel);
     when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
     when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
     when(invoker.getUrl()).thenReturn(url);
     when(invoker.getInterface()).thenReturn(IGreeter.class);
     Result result = Mockito.mock(Result.class);
     String response = "response";
     when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> result);
     when(result.recreate()).thenReturn(response);
     MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
     when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
     when(method.getMethodName()).thenReturn("sayHello");
     String request = "request";
     CountDownLatch latch = new CountDownLatch(1);
     AtomicReference<Object> atomicReference = new AtomicReference<>();
     StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

         @Override
         public void onNext(Object data) {
             atomicReference.set(data);
         }

         @Override
         public void onError(Throwable throwable) {
         }

         @Override
         public void onCompleted() {
             latch.countDown();
         }
     };
     StubInvocationUtil.unaryCall(invoker, method, request, responseObserver);
     latch.await(1, TimeUnit.SECONDS);
     Assertions.assertEquals(response, atomicReference.get());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testUnaryCall() throws Throwable {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> result);
    when(result.recreate()).thenReturn(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    CountDownLatch latch = new CountDownLatch(1);
    AtomicReference<Object> atomicReference = new AtomicReference<>();
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            atomicReference.set(data);
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StubInvocationUtil.unaryCall(invoker, method, request, responseObserver);
    latch.await(1, TimeUnit.SECONDS);
    Assertions.assertEquals(response, atomicReference.get());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private ServiceDescriptor serviceDescriptor;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
}

// === Replace local variable in test with ===
serviceDescriptor;

```
</details>

---
#### Test Case ID #dubbo_Test_23_4
#### Test Case Name: `biOrClientStreamCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `serviceDescriptor`
<summary>Suggested Diff</summary>

```diff
@@
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
-    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
+    // removed local mock; replaced with global field `serviceDescriptor`
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void biOrClientStreamCall() throws InterruptedException {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> {
        Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];
        StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[0];
        observer.onNext(response);
        observer.onCompleted();
        when(result.recreate()).then(invocationOnMock1 -> new StreamObserver<Object>() {

            @Override
            public void onNext(Object data) {
                observer.onNext(data);
            }

            @Override
            public void onError(Throwable throwable) {
            }

            @Override
            public void onCompleted() {
                observer.onCompleted();
            }
        });
        return result;
    });
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    CountDownLatch latch = new CountDownLatch(11);
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            latch.countDown();
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StreamObserver<Object> observer = StubInvocationUtil.biOrClientStreamCall(invoker, method, responseObserver);
    for (int i = 0; i < 10; i++) {
        observer.onNext(request);
    }
    observer.onCompleted();
    Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private ServiceDescriptor serviceDescriptor;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
}

// === Replace local variable in test with ===
serviceDescriptor;

```
</details>

---
#### Test Case ID #dubbo_Test_23_5
#### Test Case Name: `serverStreamCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `serviceDescriptor`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void serverStreamCall() throws InterruptedException {
     Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
     URL url = Mockito.mock(URL.class);
     ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
-    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
+    // removed local mock; replaced with global field `serviceDescriptor`
     when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
     when(url.getServiceModel()).thenReturn(consumerModel);
     when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
     when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
     when(invoker.getUrl()).thenReturn(url);
     when(invoker.getInterface()).thenReturn(IGreeter.class);
     Result result = Mockito.mock(Result.class);
     String response = "response";
     when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> {
         Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];
         StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[1];
         for (int i = 0; i < 10; i++) {
             observer.onNext(response);
         }
         observer.onCompleted();
         return result;
     });
     MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
     when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
     when(method.getMethodName()).thenReturn("sayHello");
     String request = "request";
     CountDownLatch latch = new CountDownLatch(11);
     StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

         @Override
         public void onNext(Object data) {
             latch.countDown();
         }

         @Override
         public void onError(Throwable throwable) {
         }

         @Override
         public void onCompleted() {
             latch.countDown();
         }
     };
     StubInvocationUtil.serverStreamCall(invoker, method, request, responseObserver);
     Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void serverStreamCall() throws InterruptedException {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> {
        Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];
        StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[1];
        for (int i = 0; i < 10; i++) {
            observer.onNext(response);
        }
        observer.onCompleted();
        return result;
    });
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    CountDownLatch latch = new CountDownLatch(11);
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            latch.countDown();
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StubInvocationUtil.serverStreamCall(invoker, method, request, responseObserver);
    Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private ServiceDescriptor serviceDescriptor;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
}

// === Replace local variable in test with ===
serviceDescriptor;

```
</details>

---
## Mock Clone Instance #dubbo_MCI_24
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.cluster.ClusterInvoker`
- **Test Case Count**: 2
- **MO Count**: 4

### Reusable Method
```java
private static ClusterInvoker createMockClusterInvoker(DynamicDirectory directory, URL url, boolean hasProxyInvokers, boolean isAvailable) {
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(invoker.getUrl()).thenReturn(url);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(hasProxyInvokers);
    Mockito.when(invoker.isAvailable()).thenReturn(isAvailable);
    return invoker;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_24_1
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationInvokerTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
-    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
+    ClusterInvoker invoker = createMockClusterInvoker(directory, consumerURL, true, true);
    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
-    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
-    Mockito.when(invoker.isAvailable()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
-    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
-    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("all")
@Test
void test() {
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
    Mockito.when(invoker.isAvailable()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(1)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(2)).invoke(null);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(3)).invoke(null);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(4)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(5)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(3)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(4)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(5)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(6)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(6)).invoke(null);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(7)).invoke(null);
    Assertions.assertNull(migrationInvoker.getInvoker());
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(7)).invoke(null);
    Assertions.assertNull(migrationInvoker.getServiceDiscoveryInvoker());
    ArgumentCaptor<InvokersChangedListener> argument = ArgumentCaptor.forClass(InvokersChangedListener.class);
    Mockito.verify(serviceDiscoveryDirectory, Mockito.atLeastOnce()).setInvokersChangedListener(argument.capture());
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    for (int i = 0; i < 20; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(27)).invoke(null);
    serviceDiscoveryInvokers.remove(1);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(false);
    argument.getAllValues().get(argument.getAllValues().size() - 1).onChange();
    for (int i = 0; i < 20; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(invoker, Mockito.times(27)).invoke(null);
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    argument.getAllValues().get(argument.getAllValues().size() - 1).onChange();
    Mockito.when(migrationRule.getProportion(Mockito.any())).thenReturn(50);
    migrationInvoker.setMigrationRule(migrationRule);
    for (int i = 0; i < 1000; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(serviceDiscoveryInvoker, Mockito.atMost(1026)).invoke(null);
    Mockito.verify(invoker, Mockito.atLeast(28)).invoke(null);
    Mockito.when(migrationRule.getDelay(Mockito.any())).thenReturn(1);
    long currentTimeMillis = System.currentTimeMillis();
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    Assertions.assertTrue(System.currentTimeMillis() - currentTimeMillis >= 2000);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ClusterInvoker createMockClusterInvoker(DynamicDirectory directory, URL url, boolean hasProxyInvokers, boolean isAvailable) {
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(invoker.getUrl()).thenReturn(url);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(hasProxyInvokers);
    Mockito.when(invoker.isAvailable()).thenReturn(isAvailable);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_24_2
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationInvokerTest.java`)
#### Mock Object Variable Name: `serviceDiscoveryInvoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
-    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
-    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
    Mockito.when(invoker.isAvailable()).thenReturn(true);
-    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
-    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
-    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
+    ClusterInvoker serviceDiscoveryInvoker = createMockClusterInvoker(serviceDiscoveryDirectory, consumerURL, true, true);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(1)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(2)).invoke(null);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(3)).invoke(null);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(4)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(5)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(3)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(4)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(5)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(6)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(6)).invoke(null);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(7)).invoke(null);
    Assertions.assertNull(migrationInvoker.getInvoker());
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(7)).invoke(null);
    Assertions.assertNull(migrationInvoker.getServiceDiscoveryInvoker());
    ArgumentCaptor<InvokersChangedListener> argument = ArgumentCaptor.forClass(InvokersChangedListener.class);
    Mockito.verify(serviceDiscoveryDirectory, Mockito.atLeastOnce()).setInvokersChangedListener(argument.capture());
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    for (int i = 0; i < 20; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(27)).invoke(null);
    serviceDiscoveryInvokers.remove(1);
-    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(false);
+    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(false);
    argument.getAllValues().get(argument.getAllValues().size() - 1).onChange();
    for (int i = 0; i < 20; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(invoker, Mockito.times(27)).invoke(null);
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
-    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
+    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    argument.getAllValues().get(argument.getAllValues().size() - 1).onChange();
    Mockito.when(migrationRule.getProportion(Mockito.any())).thenReturn(50);
    migrationInvoker.setMigrationRule(migrationRule);
    for (int i = 0; i < 1000; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(serviceDiscoveryInvoker, Mockito.atMost(1026)).invoke(null);
    Mockito.verify(invoker, Mockito.atLeast(28)).invoke(null);
    Mockito.when(migrationRule.getDelay(Mockito.any())).thenReturn(1);
    long currentTimeMillis = System.currentTimeMillis();
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    Assertions.assertTrue(System.currentTimeMillis() - currentTimeMillis >= 2000);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("all")
@Test
void test() {
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
    Mockito.when(invoker.isAvailable()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(1)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(2)).invoke(null);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(3)).invoke(null);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(4)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(5)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(3)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(4)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(5)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(6)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(6)).invoke(null);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(7)).invoke(null);
    Assertions.assertNull(migrationInvoker.getInvoker());
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(7)).invoke(null);
    Assertions.assertNull(migrationInvoker.getServiceDiscoveryInvoker());
    ArgumentCaptor<InvokersChangedListener> argument = ArgumentCaptor.forClass(InvokersChangedListener.class);
    Mockito.verify(serviceDiscoveryDirectory, Mockito.atLeastOnce()).setInvokersChangedListener(argument.capture());
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    for (int i = 0; i < 20; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(27)).invoke(null);
    serviceDiscoveryInvokers.remove(1);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(false);
    argument.getAllValues().get(argument.getAllValues().size() - 1).onChange();
    for (int i = 0; i < 20; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(invoker, Mockito.times(27)).invoke(null);
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    argument.getAllValues().get(argument.getAllValues().size() - 1).onChange();
    Mockito.when(migrationRule.getProportion(Mockito.any())).thenReturn(50);
    migrationInvoker.setMigrationRule(migrationRule);
    for (int i = 0; i < 1000; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(serviceDiscoveryInvoker, Mockito.atMost(1026)).invoke(null);
    Mockito.verify(invoker, Mockito.atLeast(28)).invoke(null);
    Mockito.when(migrationRule.getDelay(Mockito.any())).thenReturn(1);
    long currentTimeMillis = System.currentTimeMillis();
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    Assertions.assertTrue(System.currentTimeMillis() - currentTimeMillis >= 2000);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ClusterInvoker createMockClusterInvoker(DynamicDirectory directory, URL url, boolean hasProxyInvokers, boolean isAvailable) {
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(invoker.getUrl()).thenReturn(url);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(hasProxyInvokers);
    Mockito.when(invoker.isAvailable()).thenReturn(isAvailable);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_24_3
#### Test Case Name: `testDecide`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationInvokerTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
-    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
+    ClusterInvoker invoker = createMockClusterInvoker(directory, consumerURL, true, true);
    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
-    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
-    Mockito.when(invoker.isAvailable()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
-    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
-    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(false);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(1)).invoke(null);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("all")
@Test
void testDecide() {
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
    Mockito.when(invoker.isAvailable()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(false);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(1)).invoke(null);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ClusterInvoker createMockClusterInvoker(DynamicDirectory directory, URL url, boolean hasProxyInvokers, boolean isAvailable) {
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(invoker.getUrl()).thenReturn(url);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(hasProxyInvokers);
    Mockito.when(invoker.isAvailable()).thenReturn(isAvailable);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_24_4
#### Test Case Name: `testDecide`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationInvokerTest.java`)
#### Mock Object Variable Name: `serviceDiscoveryInvoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
-    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
-    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
    Mockito.when(invoker.isAvailable()).thenReturn(true);
-    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
-    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
-    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
+    ClusterInvoker serviceDiscoveryInvoker = createMockClusterInvoker(serviceDiscoveryDirectory, consumerURL, true, true);
+    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
-    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(false);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(1)).invoke(null);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("all")
@Test
void testDecide() {
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
    Mockito.when(invoker.isAvailable()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(false);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(1)).invoke(null);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ClusterInvoker createMockClusterInvoker(DynamicDirectory directory, URL url, boolean hasProxyInvokers, boolean isAvailable) {
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(invoker.getUrl()).thenReturn(url);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(hasProxyInvokers);
    Mockito.when(invoker.isAvailable()).thenReturn(isAvailable);
    return invoker;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_25
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.cluster.ClusterInvoker`
- **Test Case Count**: 1
- **MO Count**: 2

### Reusable Method
```java
private static ClusterInvoker createMockClusterInvoker(URL url, boolean hasProxyInvokers) {
    ClusterInvoker mockClusterInvoker = Mockito.mock(ClusterInvoker.class);
    Mockito.when(mockClusterInvoker.getUrl()).thenReturn(url);
    Mockito.when(mockClusterInvoker.hasProxyInvokers()).thenReturn(hasProxyInvokers);
    return mockClusterInvoker;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_25_1
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\DefaultMigrationAddressComparatorTest.java`)
#### Mock Object Variable Name: `newInvoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    DefaultMigrationAddressComparator comparator = new DefaultMigrationAddressComparator();
-    ClusterInvoker newInvoker = Mockito.mock(ClusterInvoker.class);
+    ClusterInvoker newInvoker = createMockClusterInvoker(url, false);
    ClusterInvoker oldInvoker = Mockito.mock(ClusterInvoker.class);
    Directory newDirectory = Mockito.mock(Directory.class);
    Directory oldDirectory = Mockito.mock(Directory.class);
    MigrationRule rule = Mockito.mock(MigrationRule.class);
    URL url = Mockito.mock(URL.class);
    Mockito.when(url.getDisplayServiceKey()).thenReturn("test");
-    Mockito.when(newInvoker.getDirectory()).thenReturn(newDirectory);
+    Mockito.when(newInvoker.getDirectory()).thenReturn(newDirectory);
    Mockito.when(oldInvoker.getDirectory()).thenReturn(oldDirectory);
-    Mockito.when(newInvoker.getUrl()).thenReturn(url);
    Mockito.when(oldInvoker.getUrl()).thenReturn(url);
-    Mockito.when(newInvoker.hasProxyInvokers()).thenReturn(false);
    Mockito.when(newDirectory.getAllInvokers()).thenReturn(Collections.emptyList());
    Assertions.assertFalse(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(-1, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
    Mockito.when(newInvoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(oldInvoker.hasProxyInvokers()).thenReturn(false);
    Mockito.when(oldDirectory.getAllInvokers()).thenReturn(Collections.emptyList());
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(-1, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
    Mockito.when(oldInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> newInvokerList = new LinkedList<>();
    newInvokerList.add(Mockito.mock(Invoker.class));
    newInvokerList.add(Mockito.mock(Invoker.class));
    newInvokerList.add(Mockito.mock(Invoker.class));
    Mockito.when(newDirectory.getAllInvokers()).thenReturn(newInvokerList);
    List<Invoker<?>> oldInvokerList = new LinkedList<>();
    oldInvokerList.add(Mockito.mock(Invoker.class));
    oldInvokerList.add(Mockito.mock(Invoker.class));
    Mockito.when(oldDirectory.getAllInvokers()).thenReturn(oldInvokerList);
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, null));
    Mockito.when(rule.getThreshold(url)).thenReturn(0.5f);
    newInvokerList.clear();
    newInvokerList.add(Mockito.mock(Invoker.class));
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    newInvokerList.clear();
    // hasProxyInvokers will check if invokers list is empty
    // if hasProxyInvokers return true, comparator will directly because default threshold is 0.0
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, null));
    Assertions.assertFalse(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(2, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("all")
@Test
void test() {
    DefaultMigrationAddressComparator comparator = new DefaultMigrationAddressComparator();
    ClusterInvoker newInvoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker oldInvoker = Mockito.mock(ClusterInvoker.class);
    Directory newDirectory = Mockito.mock(Directory.class);
    Directory oldDirectory = Mockito.mock(Directory.class);
    MigrationRule rule = Mockito.mock(MigrationRule.class);
    URL url = Mockito.mock(URL.class);
    Mockito.when(url.getDisplayServiceKey()).thenReturn("test");
    Mockito.when(newInvoker.getDirectory()).thenReturn(newDirectory);
    Mockito.when(oldInvoker.getDirectory()).thenReturn(oldDirectory);
    Mockito.when(newInvoker.getUrl()).thenReturn(url);
    Mockito.when(oldInvoker.getUrl()).thenReturn(url);
    Mockito.when(newInvoker.hasProxyInvokers()).thenReturn(false);
    Mockito.when(newDirectory.getAllInvokers()).thenReturn(Collections.emptyList());
    Assertions.assertFalse(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(-1, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
    Mockito.when(newInvoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(oldInvoker.hasProxyInvokers()).thenReturn(false);
    Mockito.when(oldDirectory.getAllInvokers()).thenReturn(Collections.emptyList());
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(-1, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
    Mockito.when(oldInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> newInvokerList = new LinkedList<>();
    newInvokerList.add(Mockito.mock(Invoker.class));
    newInvokerList.add(Mockito.mock(Invoker.class));
    newInvokerList.add(Mockito.mock(Invoker.class));
    Mockito.when(newDirectory.getAllInvokers()).thenReturn(newInvokerList);
    List<Invoker<?>> oldInvokerList = new LinkedList<>();
    oldInvokerList.add(Mockito.mock(Invoker.class));
    oldInvokerList.add(Mockito.mock(Invoker.class));
    Mockito.when(oldDirectory.getAllInvokers()).thenReturn(oldInvokerList);
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, null));
    Mockito.when(rule.getThreshold(url)).thenReturn(0.5f);
    newInvokerList.clear();
    newInvokerList.add(Mockito.mock(Invoker.class));
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    newInvokerList.clear();
    // hasProxyInvokers will check if invokers list is empty
    // if hasProxyInvokers return true, comparator will directly because default threshold is 0.0
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, null));
    Assertions.assertFalse(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(2, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ClusterInvoker createMockClusterInvoker(URL url, boolean hasProxyInvokers) {
    ClusterInvoker mockClusterInvoker = Mockito.mock(ClusterInvoker.class);
    Mockito.when(mockClusterInvoker.getUrl()).thenReturn(url);
    Mockito.when(mockClusterInvoker.hasProxyInvokers()).thenReturn(hasProxyInvokers);
    return mockClusterInvoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_25_2
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\DefaultMigrationAddressComparatorTest.java`)
#### Mock Object Variable Name: `oldInvoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ClusterInvoker newInvoker = Mockito.mock(ClusterInvoker.class);
-    ClusterInvoker oldInvoker = Mockito.mock(ClusterInvoker.class);
+    ClusterInvoker oldInvoker = createMockClusterInvoker(url, false);
    Directory newDirectory = Mockito.mock(Directory.class);
    Directory oldDirectory = Mockito.mock(Directory.class);
    MigrationRule rule = Mockito.mock(MigrationRule.class);
    URL url = Mockito.mock(URL.class);
    Mockito.when(url.getDisplayServiceKey()).thenReturn("test");
    Mockito.when(newInvoker.getDirectory()).thenReturn(newDirectory);
-    Mockito.when(oldInvoker.getDirectory()).thenReturn(oldDirectory);
+    Mockito.when(oldInvoker.getDirectory()).thenReturn(oldDirectory);
    Mockito.when(newInvoker.getUrl()).thenReturn(url);
-    Mockito.when(oldInvoker.getUrl()).thenReturn(url);
    Mockito.when(newInvoker.hasProxyInvokers()).thenReturn(false);
    Mockito.when(newDirectory.getAllInvokers()).thenReturn(Collections.emptyList());
    Assertions.assertFalse(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(-1, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
    Mockito.when(newInvoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(oldDirectory.getAllInvokers()).thenReturn(Collections.emptyList());
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(-1, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
-    Mockito.when(oldInvoker.hasProxyInvokers()).thenReturn(true);
+    Mockito.when(oldInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> newInvokerList = new LinkedList<>();
    newInvokerList.add(Mockito.mock(Invoker.class));
    newInvokerList.add(Mockito.mock(Invoker.class));
    newInvokerList.add(Mockito.mock(Invoker.class));
    Mockito.when(newDirectory.getAllInvokers()).thenReturn(newInvokerList);
    List<Invoker<?>> oldInvokerList = new LinkedList<>();
    oldInvokerList.add(Mockito.mock(Invoker.class));
    oldInvokerList.add(Mockito.mock(Invoker.class));
    Mockito.when(oldDirectory.getAllInvokers()).thenReturn(oldInvokerList);
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, null));
    Mockito.when(rule.getThreshold(url)).thenReturn(0.5f);
    newInvokerList.clear();
    newInvokerList.add(Mockito.mock(Invoker.class));
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    newInvokerList.clear();
    // hasProxyInvokers will check if invokers list is empty
    // if hasProxyInvokers return true, comparator will directly because default threshold is 0.0
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, null));
    Assertions.assertFalse(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(2, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("all")
@Test
void test() {
    DefaultMigrationAddressComparator comparator = new DefaultMigrationAddressComparator();
    ClusterInvoker newInvoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker oldInvoker = Mockito.mock(ClusterInvoker.class);
    Directory newDirectory = Mockito.mock(Directory.class);
    Directory oldDirectory = Mockito.mock(Directory.class);
    MigrationRule rule = Mockito.mock(MigrationRule.class);
    URL url = Mockito.mock(URL.class);
    Mockito.when(url.getDisplayServiceKey()).thenReturn("test");
    Mockito.when(newInvoker.getDirectory()).thenReturn(newDirectory);
    Mockito.when(oldInvoker.getDirectory()).thenReturn(oldDirectory);
    Mockito.when(newInvoker.getUrl()).thenReturn(url);
    Mockito.when(oldInvoker.getUrl()).thenReturn(url);
    Mockito.when(newInvoker.hasProxyInvokers()).thenReturn(false);
    Mockito.when(newDirectory.getAllInvokers()).thenReturn(Collections.emptyList());
    Assertions.assertFalse(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(-1, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
    Mockito.when(newInvoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(oldInvoker.hasProxyInvokers()).thenReturn(false);
    Mockito.when(oldDirectory.getAllInvokers()).thenReturn(Collections.emptyList());
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(-1, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
    Mockito.when(oldInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> newInvokerList = new LinkedList<>();
    newInvokerList.add(Mockito.mock(Invoker.class));
    newInvokerList.add(Mockito.mock(Invoker.class));
    newInvokerList.add(Mockito.mock(Invoker.class));
    Mockito.when(newDirectory.getAllInvokers()).thenReturn(newInvokerList);
    List<Invoker<?>> oldInvokerList = new LinkedList<>();
    oldInvokerList.add(Mockito.mock(Invoker.class));
    oldInvokerList.add(Mockito.mock(Invoker.class));
    Mockito.when(oldDirectory.getAllInvokers()).thenReturn(oldInvokerList);
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, null));
    Mockito.when(rule.getThreshold(url)).thenReturn(0.5f);
    newInvokerList.clear();
    newInvokerList.add(Mockito.mock(Invoker.class));
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    newInvokerList.clear();
    // hasProxyInvokers will check if invokers list is empty
    // if hasProxyInvokers return true, comparator will directly because default threshold is 0.0
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, null));
    Assertions.assertFalse(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(2, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ClusterInvoker createMockClusterInvoker(URL url, boolean hasProxyInvokers) {
    ClusterInvoker mockClusterInvoker = Mockito.mock(ClusterInvoker.class);
    Mockito.when(mockClusterInvoker.getUrl()).thenReturn(url);
    Mockito.when(mockClusterInvoker.hasProxyInvokers()).thenReturn(hasProxyInvokers);
    return mockClusterInvoker;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_26
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.common.config.CompositeConfiguration`
- **Test Case Count**: 7
- **MO Count**: 7

### Reusable Method
```java
private static CompositeConfiguration createMockCompositeConfiguration() {
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    return compositeConfiguration;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_26_1
#### Test Case Name: `testConsumerUrlWithoutProtocol`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `compositeConfiguration`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
-    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
-    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
+    CompositeConfiguration compositeConfiguration = createMockCompositeConfiguration();
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify the generated consumer url information
 */
@Test
void testConsumerUrlWithoutProtocol() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    // verify that the protocol header of consumerUrl is set to "consumer"
    Assertions.assertEquals("consumer", consumerUrl.getProtocol());
    Assertions.assertEquals(parameters.get(REGISTER_IP_KEY), consumerUrl.getHost());
    Assertions.assertFalse(consumerUrl.getAttributes().containsKey(REFER_KEY));
    Assertions.assertEquals("value1", consumerUrl.getAttribute("key1"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static CompositeConfiguration createMockCompositeConfiguration() {
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    return compositeConfiguration;
}
```
</details>

---
#### Test Case ID #dubbo_Test_26_2
#### Test Case Name: `testConsumerUrlWithProtocol`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `compositeConfiguration`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
-    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
-    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
+    CompositeConfiguration compositeConfiguration = createMockCompositeConfiguration();
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that when the protocol is configured, the protocol of consumer url is the configured protocol
 */
@Test
void testConsumerUrlWithProtocol() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    parameters.put(PROTOCOL_KEY, "tri");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    // verify that the protocol of consumer url
    Assertions.assertEquals("tri", consumerUrl.getProtocol());
    Assertions.assertEquals(parameters.get(REGISTER_IP_KEY), consumerUrl.getHost());
    Assertions.assertFalse(consumerUrl.getAttributes().containsKey(REFER_KEY));
    Assertions.assertEquals("value1", consumerUrl.getAttribute("key1"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static CompositeConfiguration createMockCompositeConfiguration() {
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    return compositeConfiguration;
}
```
</details>

---
#### Test Case ID #dubbo_Test_26_3
#### Test Case Name: `testReferWithoutGroup`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `compositeConfiguration`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
-    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
-    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
+    CompositeConfiguration compositeConfiguration = createMockCompositeConfiguration();
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that if multiple groups are not configured, the service reference of the registration center
 * the default is FailoverCluster
 *
 * @see FailoverCluster
 */
@Test
void testReferWithoutGroup() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Invoker<?> invoker = registryProtocol.refer(DemoService.class, url);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    Assertions.assertTrue(((MigrationInvoker<?>) invoker).getCluster() instanceof ScopeClusterWrapper);
    Assertions.assertTrue(((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster() instanceof MockClusterWrapper);
    Assertions.assertTrue(((MockClusterWrapper) ((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster()).getCluster() instanceof FailoverCluster);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static CompositeConfiguration createMockCompositeConfiguration() {
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    return compositeConfiguration;
}
```
</details>

---
#### Test Case ID #dubbo_Test_26_4
#### Test Case Name: `testReferWithGroup`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `compositeConfiguration`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
-    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
-    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
+    CompositeConfiguration compositeConfiguration = createMockCompositeConfiguration();
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that if multiple groups are configured, the service reference of the registration center
 *
 * @see MergeableCluster
 */
@Test
void testReferWithGroup() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    refer.put(GROUP_KEY, "group1,group2");
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Invoker<?> invoker = registryProtocol.refer(DemoService.class, url);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    Assertions.assertTrue(((MigrationInvoker<?>) invoker).getCluster() instanceof ScopeClusterWrapper);
    Assertions.assertTrue(((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster() instanceof MockClusterWrapper);
    Assertions.assertTrue(((MockClusterWrapper) ((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster()).getCluster() instanceof MergeableCluster);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static CompositeConfiguration createMockCompositeConfiguration() {
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    return compositeConfiguration;
}
```
</details>

---
#### Test Case ID #dubbo_Test_26_5
#### Test Case Name: `testInterceptInvokerForMigrationRuleListener`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `compositeConfiguration`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
-    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
-    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
+    CompositeConfiguration compositeConfiguration = createMockCompositeConfiguration();
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that the default RegistryProtocolListener will be executed
 *
 * @see MigrationRuleListener
 */
@Test
void testInterceptInvokerForMigrationRuleListener() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    refer.put(GROUP_KEY, "group1,group2");
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    MigrationInvoker<?> clusterInvoker = mock(MigrationInvoker.class);
    Map<String, Object> consumerAttribute = new HashMap<>(url.getAttributes());
    consumerAttribute.remove(REFER_KEY);
    URL consumerUrl = new ServiceConfigURL(parameters.get(PROTOCOL_KEY) == null ? DUBBO : parameters.get(PROTOCOL_KEY), null, null, parameters.get(REGISTER_IP_KEY), 0, url.getPath(), parameters, consumerAttribute);
    url = url.putAttribute(CONSUMER_URL_KEY, consumerUrl);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    registryProtocol.interceptInvoker(clusterInvoker, url, consumerUrl);
    verify(migrationRuleListener, times(1)).onRefer(registryProtocol, clusterInvoker, consumerUrl, url);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static CompositeConfiguration createMockCompositeConfiguration() {
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    return compositeConfiguration;
}
```
</details>

---
#### Test Case ID #dubbo_Test_26_6
#### Test Case Name: `testInterceptInvokerForCustomRegistryProtocolListener`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `compositeConfiguration`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
-    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
-    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
+    CompositeConfiguration compositeConfiguration = createMockCompositeConfiguration();
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Verify that if registry.protocol.listener is configured,
 * whether the corresponding RegistryProtocolListener will be executed normally
 *
 * @see CountRegistryProtocolListener
 */
@Test
void testInterceptInvokerForCustomRegistryProtocolListener() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    parameters.put(REGISTRY_PROTOCOL_LISTENER_KEY, "count");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    refer.put(GROUP_KEY, "group1,group2");
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    MigrationInvoker<?> clusterInvoker = mock(MigrationInvoker.class);
    Map<String, Object> consumerAttribute = new HashMap<>(url.getAttributes());
    consumerAttribute.remove(REFER_KEY);
    URL consumerUrl = new ServiceConfigURL(parameters.get(PROTOCOL_KEY) == null ? DUBBO : parameters.get(PROTOCOL_KEY), null, null, parameters.get(REGISTER_IP_KEY), 0, url.getPath(), parameters, consumerAttribute);
    url = url.putAttribute(CONSUMER_URL_KEY, consumerUrl);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(new CountRegistryProtocolListener());
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    registryProtocol.interceptInvoker(clusterInvoker, url, consumerUrl);
    Assertions.assertEquals(1, CountRegistryProtocolListener.getReferCounter().get());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static CompositeConfiguration createMockCompositeConfiguration() {
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    return compositeConfiguration;
}
```
</details>

---
#### Test Case ID #dubbo_Test_26_7
#### Test Case Name: `testRegisterConsumerUrl`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `compositeConfiguration`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
-    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
-    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
+    CompositeConfiguration compositeConfiguration = createMockCompositeConfiguration();
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify the registered consumer url
 */
@Test
void testRegisterConsumerUrl() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "true");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    Map<String, String> urlParameters = consumerUrl.getParameters();
    URL urlToRegistry = new ServiceConfigURL(urlParameters.get(PROTOCOL_KEY) == null ? CONSUMER : urlParameters.get(PROTOCOL_KEY), urlParameters.remove(REGISTER_IP_KEY), 0, consumerUrl.getPath(), urlParameters);
    URL registeredConsumerUrl = urlToRegistry.addParameters(CATEGORY_KEY, CONSUMERS_CATEGORY, CHECK_KEY, String.valueOf(false)).setScopeModel(moduleModel);
    verify(registry, times(1)).register(registeredConsumerUrl);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static CompositeConfiguration createMockCompositeConfiguration() {
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    return compositeConfiguration;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_27
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.Invoker<org.apache.dubbo.rpc.cluster.router.mock.MockInvokersSelectorTest.DemoService>`
- **Test Case Count**: 1
- **MO Count**: 3

### Reusable Method
```java
private static Invoker<DemoService> createMockInvoker(URL url) {
    Invoker<DemoService> invoker = Mockito.mock(Invoker.class);
    Mockito.when(invoker.getUrl()).thenReturn(url);
    return invoker;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_27_1
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\router\mock\MockInvokersSelectorTest.java`)
#### Mock Object Variable Name: `invoker1`
<summary>Suggested Diff</summary>

```diff
@@
     // Data preparation
-    Invoker<DemoService> invoker1 = Mockito.mock(Invoker.class);
+    Invoker<DemoService> invoker1 = createMockInvoker(URL.valueOf("mock://127.0.0.1/test"));
     Invoker<DemoService> invoker2 = Mockito.mock(Invoker.class);
     Invoker<DemoService> invoker3 = Mockito.mock(Invoker.class);
-    Mockito.when(invoker1.getUrl()).thenReturn(URL.valueOf("mock://127.0.0.1/test"));
     Mockito.when(invoker2.getUrl()).thenReturn(URL.valueOf("mock://127.0.0.1/test"));
     Mockito.when(invoker3.getUrl()).thenReturn(URL.valueOf("dubbo://127.0.0.1/test"));
     BitList<Invoker<DemoService>> providers = new BitList<>(Arrays.asList(invoker1, invoker2, invoker3));
     RpcInvocation rpcInvocation = Mockito.mock(RpcInvocation.class);
     URL consumerURL = URL.valueOf("test://127.0.0.1");
     selector.notify(providers);
     // rpcInvocation does not have an attached "invocation.need.mock" parameter, so normal invokers will be filtered out
     List<Invoker<DemoService>> invokers = selector.route(providers.clone(), consumerURL, rpcInvocation, false, new Holder<>());
     Assertions.assertEquals(invokers.size(), 1);
     Assertions.assertTrue(invokers.contains(invoker3));
     // rpcInvocation have an attached "invocation.need.mock" parameter, so it will filter out the invoker whose protocol is mock
     Mockito.when(rpcInvocation.getObjectAttachmentWithoutConvert(INVOCATION_NEED_MOCK)).thenReturn("true");
     invokers = selector.route(providers.clone(), consumerURL, rpcInvocation, false, new Holder<>());
     Assertions.assertEquals(invokers.size(), 2);
     Assertions.assertTrue(invokers.contains(invoker1));
     Assertions.assertTrue(invokers.contains(invoker2));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void test() {
    MockInvokersSelector selector = new MockInvokersSelector(URL.valueOf(""));
    // Data preparation
    Invoker<DemoService> invoker1 = Mockito.mock(Invoker.class);
    Invoker<DemoService> invoker2 = Mockito.mock(Invoker.class);
    Invoker<DemoService> invoker3 = Mockito.mock(Invoker.class);
    Mockito.when(invoker1.getUrl()).thenReturn(URL.valueOf("mock://127.0.0.1/test"));
    Mockito.when(invoker2.getUrl()).thenReturn(URL.valueOf("mock://127.0.0.1/test"));
    Mockito.when(invoker3.getUrl()).thenReturn(URL.valueOf("dubbo://127.0.0.1/test"));
    BitList<Invoker<DemoService>> providers = new BitList<>(Arrays.asList(invoker1, invoker2, invoker3));
    RpcInvocation rpcInvocation = Mockito.mock(RpcInvocation.class);
    URL consumerURL = URL.valueOf("test://127.0.0.1");
    selector.notify(providers);
    // rpcInvocation does not have an attached "invocation.need.mock" parameter, so normal invokers will be filtered out
    List<Invoker<DemoService>> invokers = selector.route(providers.clone(), consumerURL, rpcInvocation, false, new Holder<>());
    Assertions.assertEquals(invokers.size(), 1);
    Assertions.assertTrue(invokers.contains(invoker3));
    // rpcInvocation have an attached "invocation.need.mock" parameter, so it will filter out the invoker whose protocol is mock
    Mockito.when(rpcInvocation.getObjectAttachmentWithoutConvert(INVOCATION_NEED_MOCK)).thenReturn("true");
    invokers = selector.route(providers.clone(), consumerURL, rpcInvocation, false, new Holder<>());
    Assertions.assertEquals(invokers.size(), 2);
    Assertions.assertTrue(invokers.contains(invoker1));
    Assertions.assertTrue(invokers.contains(invoker2));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker<DemoService> createMockInvoker(URL url) {
    Invoker<DemoService> invoker = Mockito.mock(Invoker.class);
    Mockito.when(invoker.getUrl()).thenReturn(url);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_27_2
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\router\mock\MockInvokersSelectorTest.java`)
#### Mock Object Variable Name: `invoker2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Invoker<DemoService> invoker1 = Mockito.mock(Invoker.class);
-    Invoker<DemoService> invoker2 = Mockito.mock(Invoker.class);
+    Invoker<DemoService> invoker2 = createMockInvoker(URL.valueOf("mock://127.0.0.1/test"));
    Invoker<DemoService> invoker3 = Mockito.mock(Invoker.class);
    Mockito.when(invoker1.getUrl()).thenReturn(URL.valueOf("mock://127.0.0.1/test"));
-    Mockito.when(invoker2.getUrl()).thenReturn(URL.valueOf("mock://127.0.0.1/test"));
    Mockito.when(invoker3.getUrl()).thenReturn(URL.valueOf("dubbo://127.0.0.1/test"));
    BitList<Invoker<DemoService>> providers = new BitList<>(Arrays.asList(invoker1, invoker2, invoker3));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void test() {
    MockInvokersSelector selector = new MockInvokersSelector(URL.valueOf(""));
    // Data preparation
    Invoker<DemoService> invoker1 = Mockito.mock(Invoker.class);
    Invoker<DemoService> invoker2 = Mockito.mock(Invoker.class);
    Invoker<DemoService> invoker3 = Mockito.mock(Invoker.class);
    Mockito.when(invoker1.getUrl()).thenReturn(URL.valueOf("mock://127.0.0.1/test"));
    Mockito.when(invoker2.getUrl()).thenReturn(URL.valueOf("mock://127.0.0.1/test"));
    Mockito.when(invoker3.getUrl()).thenReturn(URL.valueOf("dubbo://127.0.0.1/test"));
    BitList<Invoker<DemoService>> providers = new BitList<>(Arrays.asList(invoker1, invoker2, invoker3));
    RpcInvocation rpcInvocation = Mockito.mock(RpcInvocation.class);
    URL consumerURL = URL.valueOf("test://127.0.0.1");
    selector.notify(providers);
    // rpcInvocation does not have an attached "invocation.need.mock" parameter, so normal invokers will be filtered out
    List<Invoker<DemoService>> invokers = selector.route(providers.clone(), consumerURL, rpcInvocation, false, new Holder<>());
    Assertions.assertEquals(invokers.size(), 1);
    Assertions.assertTrue(invokers.contains(invoker3));
    // rpcInvocation have an attached "invocation.need.mock" parameter, so it will filter out the invoker whose protocol is mock
    Mockito.when(rpcInvocation.getObjectAttachmentWithoutConvert(INVOCATION_NEED_MOCK)).thenReturn("true");
    invokers = selector.route(providers.clone(), consumerURL, rpcInvocation, false, new Holder<>());
    Assertions.assertEquals(invokers.size(), 2);
    Assertions.assertTrue(invokers.contains(invoker1));
    Assertions.assertTrue(invokers.contains(invoker2));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker<DemoService> createMockInvoker(URL url) {
    Invoker<DemoService> invoker = Mockito.mock(Invoker.class);
    Mockito.when(invoker.getUrl()).thenReturn(url);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_27_3
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\router\mock\MockInvokersSelectorTest.java`)
#### Mock Object Variable Name: `invoker3`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Invoker<DemoService> invoker1 = Mockito.mock(Invoker.class);
    Invoker<DemoService> invoker2 = Mockito.mock(Invoker.class);
-    Invoker<DemoService> invoker3 = Mockito.mock(Invoker.class);
    Mockito.when(invoker1.getUrl()).thenReturn(URL.valueOf("mock://127.0.0.1/test"));
    Mockito.when(invoker2.getUrl()).thenReturn(URL.valueOf("mock://127.0.0.1/test"));
-    Mockito.when(invoker3.getUrl()).thenReturn(URL.valueOf("dubbo://127.0.0.1/test"));
+    Invoker<DemoService> invoker3 = createMockInvoker(URL.valueOf("dubbo://127.0.0.1/test"));
    BitList<Invoker<DemoService>> providers = new BitList<>(Arrays.asList(invoker1, invoker2, invoker3));
    RpcInvocation rpcInvocation = Mockito.mock(RpcInvocation.class);
    URL consumerURL = URL.valueOf("test://127.0.0.1");
    selector.notify(providers);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void test() {
    MockInvokersSelector selector = new MockInvokersSelector(URL.valueOf(""));
    // Data preparation
    Invoker<DemoService> invoker1 = Mockito.mock(Invoker.class);
    Invoker<DemoService> invoker2 = Mockito.mock(Invoker.class);
    Invoker<DemoService> invoker3 = Mockito.mock(Invoker.class);
    Mockito.when(invoker1.getUrl()).thenReturn(URL.valueOf("mock://127.0.0.1/test"));
    Mockito.when(invoker2.getUrl()).thenReturn(URL.valueOf("mock://127.0.0.1/test"));
    Mockito.when(invoker3.getUrl()).thenReturn(URL.valueOf("dubbo://127.0.0.1/test"));
    BitList<Invoker<DemoService>> providers = new BitList<>(Arrays.asList(invoker1, invoker2, invoker3));
    RpcInvocation rpcInvocation = Mockito.mock(RpcInvocation.class);
    URL consumerURL = URL.valueOf("test://127.0.0.1");
    selector.notify(providers);
    // rpcInvocation does not have an attached "invocation.need.mock" parameter, so normal invokers will be filtered out
    List<Invoker<DemoService>> invokers = selector.route(providers.clone(), consumerURL, rpcInvocation, false, new Holder<>());
    Assertions.assertEquals(invokers.size(), 1);
    Assertions.assertTrue(invokers.contains(invoker3));
    // rpcInvocation have an attached "invocation.need.mock" parameter, so it will filter out the invoker whose protocol is mock
    Mockito.when(rpcInvocation.getObjectAttachmentWithoutConvert(INVOCATION_NEED_MOCK)).thenReturn("true");
    invokers = selector.route(providers.clone(), consumerURL, rpcInvocation, false, new Holder<>());
    Assertions.assertEquals(invokers.size(), 2);
    Assertions.assertTrue(invokers.contains(invoker1));
    Assertions.assertTrue(invokers.contains(invoker2));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker<DemoService> createMockInvoker(URL url) {
    Invoker<DemoService> invoker = Mockito.mock(Invoker.class);
    Mockito.when(invoker.getUrl()).thenReturn(url);
    return invoker;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_28
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.registry.Registry`
- **Test Case Count**: 5
- **MO Count**: 5

### Reusable Method
```java
// === Declare in class scope ===
private Registry registry;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    registry = mock(Registry.class);
}

// === Replace local variable in test with ===
registry

```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_28_1
#### Test Case Name: `testConsumerUrlWithoutProtocol`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `registry`
<summary>Suggested Diff</summary>

```diff
@@
     RegistryFactory registryFactory = mock(RegistryFactory.class);
-    Registry registry = mock(Registry.class);
+    // removed local mock; replaced with global field `registry`
     RegistryProtocol registryProtocol = new RegistryProtocol();
     MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
     List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
     registryProtocolListeners.add(migrationRuleListener);
     ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
     moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
     ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
     Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
     Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
     url = url.setScopeModel(moduleModel);
     when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
     Cluster cluster = mock(Cluster.class);
     Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
     Assertions.assertTrue(invoker instanceof MigrationInvoker);
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify the generated consumer url information
 */
@Test
void testConsumerUrlWithoutProtocol() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    // verify that the protocol header of consumerUrl is set to "consumer"
    Assertions.assertEquals("consumer", consumerUrl.getProtocol());
    Assertions.assertEquals(parameters.get(REGISTER_IP_KEY), consumerUrl.getHost());
    Assertions.assertFalse(consumerUrl.getAttributes().containsKey(REFER_KEY));
    Assertions.assertEquals("value1", consumerUrl.getAttribute("key1"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Registry registry;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    registry = mock(Registry.class);
}

// === Replace local variable in test with ===
registry

```
</details>

---
#### Test Case ID #dubbo_Test_28_2
#### Test Case Name: `testConsumerUrlWithProtocol`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `registry`
<summary>Suggested Diff</summary>

```diff
@@
     RegistryFactory registryFactory = mock(RegistryFactory.class);
     RegistryProtocol registryProtocol = new RegistryProtocol();
-    Registry registry = mock(Registry.class);
+    // removed local mock; replaced with global field `registry`
     MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
     List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
     registryProtocolListeners.add(migrationRuleListener);
@@
-    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
+    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
     Cluster cluster = mock(Cluster.class);
-    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
+    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
     Assertions.assertTrue(invoker instanceof MigrationInvoker);
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that when the protocol is configured, the protocol of consumer url is the configured protocol
 */
@Test
void testConsumerUrlWithProtocol() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    parameters.put(PROTOCOL_KEY, "tri");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    // verify that the protocol of consumer url
    Assertions.assertEquals("tri", consumerUrl.getProtocol());
    Assertions.assertEquals(parameters.get(REGISTER_IP_KEY), consumerUrl.getHost());
    Assertions.assertFalse(consumerUrl.getAttributes().containsKey(REFER_KEY));
    Assertions.assertEquals("value1", consumerUrl.getAttribute("key1"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Registry registry;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    registry = mock(Registry.class);
}

// === Replace local variable in test with ===
registry

```
</details>

---
#### Test Case ID #dubbo_Test_28_3
#### Test Case Name: `testReferWithoutGroup`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `registry`
<summary>Suggested Diff</summary>

```diff
@@
     RegistryFactory registryFactory = mock(RegistryFactory.class);
-    Registry registry = mock(Registry.class);
+    // removed local mock; replaced with global field `registry`
     MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
     List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
     registryProtocolListeners.add(migrationRuleListener);
     RegistryProtocol registryProtocol = new RegistryProtocol();
     ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
     moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
     ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
     Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
     Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
     Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
     Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
     url = url.setScopeModel(moduleModel);
-    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
+    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
     Invoker<?> invoker = registryProtocol.refer(DemoService.class, url);
     Assertions.assertTrue(invoker instanceof MigrationInvoker);
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that if multiple groups are not configured, the service reference of the registration center
 * the default is FailoverCluster
 *
 * @see FailoverCluster
 */
@Test
void testReferWithoutGroup() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Invoker<?> invoker = registryProtocol.refer(DemoService.class, url);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    Assertions.assertTrue(((MigrationInvoker<?>) invoker).getCluster() instanceof ScopeClusterWrapper);
    Assertions.assertTrue(((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster() instanceof MockClusterWrapper);
    Assertions.assertTrue(((MockClusterWrapper) ((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster()).getCluster() instanceof FailoverCluster);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Registry registry;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    registry = mock(Registry.class);
}

// === Replace local variable in test with ===
registry

```
</details>

---
#### Test Case ID #dubbo_Test_28_4
#### Test Case Name: `testReferWithGroup`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `registry`
<summary>Suggested Diff</summary>

```diff
@@
     RegistryFactory registryFactory = mock(RegistryFactory.class);
-    Registry registry = mock(Registry.class);
+    // removed local mock; replaced with global field `registry`
     MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
     List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
     registryProtocolListeners.add(migrationRuleListener);
@@
     Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
     url = url.setScopeModel(moduleModel);
-    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
+    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
     Invoker<?> invoker = registryProtocol.refer(DemoService.class, url);
     Assertions.assertTrue(invoker instanceof MigrationInvoker);
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that if multiple groups are configured, the service reference of the registration center
 *
 * @see MergeableCluster
 */
@Test
void testReferWithGroup() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    refer.put(GROUP_KEY, "group1,group2");
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Invoker<?> invoker = registryProtocol.refer(DemoService.class, url);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    Assertions.assertTrue(((MigrationInvoker<?>) invoker).getCluster() instanceof ScopeClusterWrapper);
    Assertions.assertTrue(((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster() instanceof MockClusterWrapper);
    Assertions.assertTrue(((MockClusterWrapper) ((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster()).getCluster() instanceof MergeableCluster);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Registry registry;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    registry = mock(Registry.class);
}

// === Replace local variable in test with ===
registry

```
</details>

---
#### Test Case ID #dubbo_Test_28_5
#### Test Case Name: `testRegisterConsumerUrl`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `registry`
<summary>Suggested Diff</summary>

```diff
@@
     RegistryFactory registryFactory = mock(RegistryFactory.class);
-    Registry registry = mock(Registry.class);
+    // removed local mock; replaced with global field `registry`
     ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
     moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
@@
     Cluster cluster = mock(Cluster.class);
-    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
+    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
     Assertions.assertTrue(invoker instanceof MigrationInvoker);
     URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
@@
     URL registeredConsumerUrl = urlToRegistry.addParameters(CATEGORY_KEY, CONSUMERS_CATEGORY, CHECK_KEY, String.valueOf(false)).setScopeModel(moduleModel);
-    verify(registry, times(1)).register(registeredConsumerUrl);
+    verify(registry, times(1)).register(registeredConsumerUrl);
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify the registered consumer url
 */
@Test
void testRegisterConsumerUrl() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "true");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    Map<String, String> urlParameters = consumerUrl.getParameters();
    URL urlToRegistry = new ServiceConfigURL(urlParameters.get(PROTOCOL_KEY) == null ? CONSUMER : urlParameters.get(PROTOCOL_KEY), urlParameters.remove(REGISTER_IP_KEY), 0, consumerUrl.getPath(), urlParameters);
    URL registeredConsumerUrl = urlToRegistry.addParameters(CATEGORY_KEY, CONSUMERS_CATEGORY, CHECK_KEY, String.valueOf(false)).setScopeModel(moduleModel);
    verify(registry, times(1)).register(registeredConsumerUrl);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Registry registry;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    registry = mock(Registry.class);
}

// === Replace local variable in test with ===
registry

```
</details>

---
## Mock Clone Instance #dubbo_MCI_29
- **Scope**: class level
- **Mocked Class**: `Invoker<DemoService>`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
public class MockInvoker {
    public static Invoker<DemoService> createMockInvoker(URL url, AppResponse result, Invocation invocation) {
        Invoker<DemoService> invoker = mock(Invoker.class);
        given(invoker.isAvailable()).willReturn(true);
        given(invoker.getInterface()).willReturn(DemoService.class);
        given(invoker.invoke(invocation)).willReturn(result);
        given(invoker.getUrl()).willReturn(url);
        return invoker;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_29_1
#### Test Case Name: `testSetContext`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\ContextFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
     given(invocation.getObjectAttachments()).willReturn(null);
-    invoker = mock(Invoker.class);
-    given(invoker.isAvailable()).willReturn(true);
-    given(invoker.getInterface()).willReturn(DemoService.class);
     AppResponse result = new AppResponse();
     result.setValue("High");
-    given(invoker.invoke(invocation)).willReturn(result);
     URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
-    given(invoker.getUrl()).willReturn(url);
+    invoker = MockInvoker.createMockInvoker(url, result, invocation);
     contextFilter.invoke(invoker, invocation);
     assertNotNull(RpcContext.getServiceContext().getInvoker());
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@SuppressWarnings("unchecked")
@Test
void testSetContext() {
    invocation = mock(Invocation.class);
    given(invocation.getMethodName()).willReturn("$enumlength");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Enum.class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
    given(invocation.getObjectAttachments()).willReturn(null);
    invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("High");
    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    contextFilter.invoke(invoker, invocation);
    assertNotNull(RpcContext.getServiceContext().getInvoker());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    public static Invoker<DemoService> createMockInvoker(URL url, AppResponse result, Invocation invocation) {
        Invoker<DemoService> invoker = mock(Invoker.class);
        given(invoker.isAvailable()).willReturn(true);
        given(invoker.getInterface()).willReturn(DemoService.class);
        given(invoker.invoke(invocation)).willReturn(result);
        given(invoker.getUrl()).willReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_29_2
#### Test Case Name: `testEcho`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\EchoFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    given(invocation.getObjectAttachments()).willReturn(null);
-    Invoker<DemoService> invoker = mock(Invoker.class);
-    given(invoker.isAvailable()).willReturn(true);
-    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("High");
-    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
-    given(invoker.getUrl()).willReturn(url);
+    Invoker<DemoService> invoker = MockInvoker.createMockInvoker(url, result, invocation);
    Result filterResult = echoFilter.invoke(invoker, invocation);
    assertEquals("hello", filterResult.getValue());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("unchecked")
@Test
void testEcho() {
    Invocation invocation = mock(RpcInvocation.class);
    given(invocation.getMethodName()).willReturn("$echo");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Enum.class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
    given(invocation.getObjectAttachments()).willReturn(null);
    Invoker<DemoService> invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("High");
    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    Result filterResult = echoFilter.invoke(invoker, invocation);
    assertEquals("hello", filterResult.getValue());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    public static Invoker<DemoService> createMockInvoker(URL url, AppResponse result, Invocation invocation) {
        Invoker<DemoService> invoker = mock(Invoker.class);
        given(invoker.isAvailable()).willReturn(true);
        given(invoker.getInterface()).willReturn(DemoService.class);
        given(invoker.invoke(invocation)).willReturn(result);
        given(invoker.getUrl()).willReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_29_3
#### Test Case Name: `testNonEcho`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\EchoFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    given(invocation.getObjectAttachments()).willReturn(null);
-    Invoker<DemoService> invoker = mock(Invoker.class);
-    given(invoker.isAvailable()).willReturn(true);
-    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("High");
-    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
-    given(invoker.getUrl()).willReturn(url);
+    Invoker<DemoService> invoker = MockInvoker.createMockInvoker(url, result, invocation);
    Result filterResult = echoFilter.invoke(invoker, invocation);
    assertEquals("High", filterResult.getValue());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("unchecked")
@Test
void testNonEcho() {
    Invocation invocation = mock(Invocation.class);
    given(invocation.getMethodName()).willReturn("echo");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Enum.class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
    given(invocation.getObjectAttachments()).willReturn(null);
    Invoker<DemoService> invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("High");
    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    Result filterResult = echoFilter.invoke(invoker, invocation);
    assertEquals("High", filterResult.getValue());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    public static Invoker<DemoService> createMockInvoker(URL url, AppResponse result, Invocation invocation) {
        Invoker<DemoService> invoker = mock(Invoker.class);
        given(invoker.isAvailable()).willReturn(true);
        given(invoker.getInterface()).willReturn(DemoService.class);
        given(invoker.invoke(invocation)).willReturn(result);
        given(invoker.getUrl()).willReturn(url);
        return invoker;
    }
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_30
- **Scope**: method level
- **Mocked Class**: `Invoker<DemoService>`
- **Test Case Count**: 4
- **MO Count**: 4

### Reusable Method
```java
private static Invoker<DemoService> createMockInvoker() {
    Invoker<DemoService> invoker = mock(Invoker.class);
    when(invoker.getInterface()).thenReturn(DemoService.class);
    return invoker;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_30_1
#### Test Case Name: `testRpcException`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\ExceptionFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    RpcInvocation invocation = new RpcInvocation("sayHello", DemoService.class.getName(), "", new Class<?>[] { String.class }, new Object[] { "world" });
-    Invoker<DemoService> invoker = mock(Invoker.class);
-    given(invoker.getInterface()).willReturn(DemoService.class);
+    Invoker<DemoService> invoker = createMockInvoker();
     given(invoker.invoke(eq(invocation))).willThrow(exception);
     try {
         exceptionFilter.invoke(invoker, invocation);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("unchecked")
@Test
void testRpcException() {
    Logger failLogger = mock(Logger.class);
    FailsafeErrorTypeAwareLogger failsafeLogger = new FailsafeErrorTypeAwareLogger(failLogger);
    RpcContext.getServiceContext().setRemoteAddress("127.0.0.1", 1234);
    RpcException exception = new RpcException("TestRpcException");
    ExceptionFilter exceptionFilter = new ExceptionFilter();
    RpcInvocation invocation = new RpcInvocation("sayHello", DemoService.class.getName(), "", new Class<?>[] { String.class }, new Object[] { "world" });
    Invoker<DemoService> invoker = mock(Invoker.class);
    given(invoker.getInterface()).willReturn(DemoService.class);
    given(invoker.invoke(eq(invocation))).willThrow(exception);
    try {
        exceptionFilter.invoke(invoker, invocation);
    } catch (RpcException e) {
        assertEquals("TestRpcException", e.getMessage());
        exceptionFilter.setLogger(failsafeLogger);
        exceptionFilter.onError(e, invoker, invocation);
    }
    failsafeLogger.error(CONFIG_FILTER_VALIDATION_EXCEPTION, "", "", eq("Got unchecked and undeclared exception which called by 127.0.0.1. service: " + DemoService.class.getName() + ", method: sayHello, exception: " + RpcException.class.getName() + ": TestRpcException"), eq(exception));
    RpcContext.removeContext();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker<DemoService> createMockInvoker() {
    Invoker<DemoService> invoker = mock(Invoker.class);
    when(invoker.getInterface()).thenReturn(DemoService.class);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_30_2
#### Test Case Name: `testJavaException`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\ExceptionFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
    appResponse.setException(new IllegalArgumentException("java"));
-    Invoker<DemoService> invoker = mock(Invoker.class);
-    when(invoker.invoke(invocation)).thenReturn(appResponse);
-    when(invoker.getInterface()).thenReturn(DemoService.class);
+    Invoker<DemoService> invoker = createMockInvoker();
+    when(invoker.invoke(invocation)).thenReturn(appResponse);
    Result newResult = exceptionFilter.invoke(invoker, invocation);
    Assertions.assertEquals(appResponse.getException(), newResult.getException());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("unchecked")
@Test
void testJavaException() {
    ExceptionFilter exceptionFilter = new ExceptionFilter();
    RpcInvocation invocation = new RpcInvocation("sayHello", DemoService.class.getName(), "", new Class<?>[] { String.class }, new Object[] { "world" });
    AppResponse appResponse = new AppResponse();
    appResponse.setException(new IllegalArgumentException("java"));
    Invoker<DemoService> invoker = mock(Invoker.class);
    when(invoker.invoke(invocation)).thenReturn(appResponse);
    when(invoker.getInterface()).thenReturn(DemoService.class);
    Result newResult = exceptionFilter.invoke(invoker, invocation);
    Assertions.assertEquals(appResponse.getException(), newResult.getException());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker<DemoService> createMockInvoker() {
    Invoker<DemoService> invoker = mock(Invoker.class);
    when(invoker.getInterface()).thenReturn(DemoService.class);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_30_3
#### Test Case Name: `testRuntimeException`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\ExceptionFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
    AppResponse appResponse = new AppResponse();
    appResponse.setException(new LocalException("localException"));
-    Invoker<DemoService> invoker = mock(Invoker.class);
-    when(invoker.invoke(invocation)).thenReturn(appResponse);
-    when(invoker.getInterface()).thenReturn(DemoService.class);
+    Invoker<DemoService> invoker = createMockInvoker();
+    when(invoker.invoke(invocation)).thenReturn(appResponse);
    Result newResult = exceptionFilter.invoke(invoker, invocation);
    Assertions.assertEquals(appResponse.getException(), newResult.getException());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("unchecked")
@Test
void testRuntimeException() {
    ExceptionFilter exceptionFilter = new ExceptionFilter();
    RpcInvocation invocation = new RpcInvocation("sayHello", DemoService.class.getName(), "", new Class<?>[] { String.class }, new Object[] { "world" });
    AppResponse appResponse = new AppResponse();
    appResponse.setException(new LocalException("localException"));
    Invoker<DemoService> invoker = mock(Invoker.class);
    when(invoker.invoke(invocation)).thenReturn(appResponse);
    when(invoker.getInterface()).thenReturn(DemoService.class);
    Result newResult = exceptionFilter.invoke(invoker, invocation);
    Assertions.assertEquals(appResponse.getException(), newResult.getException());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker<DemoService> createMockInvoker() {
    Invoker<DemoService> invoker = mock(Invoker.class);
    when(invoker.getInterface()).thenReturn(DemoService.class);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_30_4
#### Test Case Name: `testConvertToRunTimeException`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\ExceptionFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    AppResponse mockRpcResult = new AppResponse();
    mockRpcResult.setException(new HessianException("hessian"));
    Result mockAsyncResult = AsyncRpcResult.newDefaultAsyncResult(mockRpcResult, invocation);
-    Invoker<DemoService> invoker = mock(Invoker.class);
-    when(invoker.invoke(invocation)).thenReturn(mockAsyncResult);
-    when(invoker.getInterface()).thenReturn(DemoService.class);
+    Invoker<DemoService> invoker = createMockInvoker();
+    when(invoker.invoke(invocation)).thenReturn(mockAsyncResult);
    Result asyncResult = exceptionFilter.invoke(invoker, invocation);
    AppResponse appResponse = (AppResponse) asyncResult.get();
    exceptionFilter.onResponse(appResponse, invoker, invocation);
    Assertions.assertFalse(appResponse.getException() instanceof HessianException);
    Assertions.assertEquals(appResponse.getException().getClass(), RuntimeException.class);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("unchecked")
@Test
void testConvertToRunTimeException() throws Exception {
    ExceptionFilter exceptionFilter = new ExceptionFilter();
    RpcInvocation invocation = new RpcInvocation("sayHello", DemoService.class.getName(), "", new Class<?>[] { String.class }, new Object[] { "world" });
    AppResponse mockRpcResult = new AppResponse();
    mockRpcResult.setException(new HessianException("hessian"));
    Result mockAsyncResult = AsyncRpcResult.newDefaultAsyncResult(mockRpcResult, invocation);
    Invoker<DemoService> invoker = mock(Invoker.class);
    when(invoker.invoke(invocation)).thenReturn(mockAsyncResult);
    when(invoker.getInterface()).thenReturn(DemoService.class);
    Result asyncResult = exceptionFilter.invoke(invoker, invocation);
    AppResponse appResponse = (AppResponse) asyncResult.get();
    exceptionFilter.onResponse(appResponse, invoker, invocation);
    Assertions.assertFalse(appResponse.getException() instanceof HessianException);
    Assertions.assertEquals(appResponse.getException().getClass(), RuntimeException.class);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker<DemoService> createMockInvoker() {
    Invoker<DemoService> invoker = mock(Invoker.class);
    when(invoker.getInterface()).thenReturn(DemoService.class);
    return invoker;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_31
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.auth.model.AccessKeyPair`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static AccessKeyPair createMockAccessKeyPair(String secretKeyReturn) {
    AccessKeyPair accessKeyPair = mock(AccessKeyPair.class);
    when(accessKeyPair.getSecretKey()).thenReturn(secretKeyReturn);
    return accessKeyPair;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_31_1
#### Test Case Name: `testSignForRequest`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-auth\src\test\java\org\apache\dubbo\auth\AccessKeyAuthenticatorTest.java`)
#### Mock Object Variable Name: `accessKeyPair`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    doCallRealMethod().when(helper).sign(invocation, url);
    when(helper.getSignature(eq(url), eq(invocation), eq("sk"), anyString())).thenReturn("dubbo");
-    AccessKeyPair accessKeyPair = mock(AccessKeyPair.class);
-    when(accessKeyPair.getSecretKey()).thenReturn("sk");
+    AccessKeyPair accessKeyPair = createMockAccessKeyPair("sk");
    when(helper.getAccessKeyPair(invocation, url)).thenReturn(accessKeyPair);
    helper.sign(invocation, url);
    assertEquals(String.valueOf(invocation.getAttachment(CommonConstants.CONSUMER)), url.getApplication());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testSignForRequest() {
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(CommonConstants.APPLICATION_KEY, "test").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk");
    Invocation invocation = new RpcInvocation();
    AccessKeyAuthenticator helper = mock(AccessKeyAuthenticator.class);
    doCallRealMethod().when(helper).sign(invocation, url);
    when(helper.getSignature(eq(url), eq(invocation), eq("sk"), anyString())).thenReturn("dubbo");
    AccessKeyPair accessKeyPair = mock(AccessKeyPair.class);
    when(accessKeyPair.getSecretKey()).thenReturn("sk");
    when(helper.getAccessKeyPair(invocation, url)).thenReturn(accessKeyPair);
    helper.sign(invocation, url);
    assertEquals(String.valueOf(invocation.getAttachment(CommonConstants.CONSUMER)), url.getApplication());
    assertNotNull(invocation.getAttachments().get(Constants.REQUEST_SIGNATURE_KEY));
    assertEquals(invocation.getAttachments().get(Constants.REQUEST_SIGNATURE_KEY), "dubbo");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AccessKeyPair createMockAccessKeyPair(String secretKeyReturn) {
    AccessKeyPair accessKeyPair = mock(AccessKeyPair.class);
    when(accessKeyPair.getSecretKey()).thenReturn(secretKeyReturn);
    return accessKeyPair;
}
```
</details>

---
#### Test Case ID #dubbo_Test_31_2
#### Test Case Name: `testAuthenticateRequest`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-auth\src\test\java\org\apache\dubbo\auth\AccessKeyAuthenticatorTest.java`)
#### Mock Object Variable Name: `accessKeyPair`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    doCallRealMethod().when(helper).authenticate(invocation, url);
    when(helper.getSignature(eq(url), eq(invocation), eq("sk"), anyString())).thenReturn("dubbo");
-    AccessKeyPair accessKeyPair = mock(AccessKeyPair.class);
-    when(accessKeyPair.getSecretKey()).thenReturn("sk");
+    AccessKeyPair accessKeyPair = createMockAccessKeyPair("sk");
    when(helper.getAccessKeyPair(invocation, url)).thenReturn(accessKeyPair);
    assertDoesNotThrow(() -> helper.authenticate(invocation, url));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testAuthenticateRequest() throws RpcAuthenticationException {
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(CommonConstants.APPLICATION_KEY, "test").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk");
    Invocation invocation = new RpcInvocation();
    invocation.setAttachment(Constants.ACCESS_KEY_ID_KEY, "ak");
    invocation.setAttachment(Constants.REQUEST_SIGNATURE_KEY, "dubbo");
    invocation.setAttachment(Constants.REQUEST_TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));
    invocation.setAttachment(CommonConstants.CONSUMER, "test");
    AccessKeyAuthenticator helper = mock(AccessKeyAuthenticator.class);
    doCallRealMethod().when(helper).authenticate(invocation, url);
    when(helper.getSignature(eq(url), eq(invocation), eq("sk"), anyString())).thenReturn("dubbo");
    AccessKeyPair accessKeyPair = mock(AccessKeyPair.class);
    when(accessKeyPair.getSecretKey()).thenReturn("sk");
    when(helper.getAccessKeyPair(invocation, url)).thenReturn(accessKeyPair);
    assertDoesNotThrow(() -> helper.authenticate(invocation, url));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AccessKeyPair createMockAccessKeyPair(String secretKeyReturn) {
    AccessKeyPair accessKeyPair = mock(AccessKeyPair.class);
    when(accessKeyPair.getSecretKey()).thenReturn(secretKeyReturn);
    return accessKeyPair;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_32
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.common.extension.ExtensionLoader`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static ExtensionLoader createMockExtensionLoader(RegistryFactory registryFactory) {
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    return extensionLoaderMock;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_32_1
#### Test Case Name: `testReferWithoutGroup`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `extensionLoaderMock`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
-    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
+    ExtensionLoader extensionLoaderMock = createMockExtensionLoader(registryFactory);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
-    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that if multiple groups are not configured, the service reference of the registration center
 * the default is FailoverCluster
 *
 * @see FailoverCluster
 */
@Test
void testReferWithoutGroup() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Invoker<?> invoker = registryProtocol.refer(DemoService.class, url);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    Assertions.assertTrue(((MigrationInvoker<?>) invoker).getCluster() instanceof ScopeClusterWrapper);
    Assertions.assertTrue(((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster() instanceof MockClusterWrapper);
    Assertions.assertTrue(((MockClusterWrapper) ((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster()).getCluster() instanceof FailoverCluster);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ExtensionLoader createMockExtensionLoader(RegistryFactory registryFactory) {
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    return extensionLoaderMock;
}
```
</details>

---
#### Test Case ID #dubbo_Test_32_2
#### Test Case Name: `testReferWithGroup`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `extensionLoaderMock`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
-    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
+    ExtensionLoader extensionLoaderMock = createMockExtensionLoader(registryFactory);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
-    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that if multiple groups are configured, the service reference of the registration center
 *
 * @see MergeableCluster
 */
@Test
void testReferWithGroup() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    refer.put(GROUP_KEY, "group1,group2");
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Invoker<?> invoker = registryProtocol.refer(DemoService.class, url);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    Assertions.assertTrue(((MigrationInvoker<?>) invoker).getCluster() instanceof ScopeClusterWrapper);
    Assertions.assertTrue(((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster() instanceof MockClusterWrapper);
    Assertions.assertTrue(((MockClusterWrapper) ((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster()).getCluster() instanceof MergeableCluster);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ExtensionLoader createMockExtensionLoader(RegistryFactory registryFactory) {
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    return extensionLoaderMock;
}
```
</details>

---
#### Test Case ID #dubbo_Test_32_3
#### Test Case Name: `testRegisterConsumerUrl`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `extensionLoaderMock`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
-    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
-    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
-    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
+    ExtensionLoader extensionLoaderMock = createMockExtensionLoader(registryFactory);
+    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    url = url.setScopeModel(moduleModel);
    RegistryProtocol registryProtocol = new RegistryProtocol();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify the registered consumer url
 */
@Test
void testRegisterConsumerUrl() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "true");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    Map<String, String> urlParameters = consumerUrl.getParameters();
    URL urlToRegistry = new ServiceConfigURL(urlParameters.get(PROTOCOL_KEY) == null ? CONSUMER : urlParameters.get(PROTOCOL_KEY), urlParameters.remove(REGISTER_IP_KEY), 0, consumerUrl.getPath(), urlParameters);
    URL registeredConsumerUrl = urlToRegistry.addParameters(CATEGORY_KEY, CONSUMERS_CATEGORY, CHECK_KEY, String.valueOf(false)).setScopeModel(moduleModel);
    verify(registry, times(1)).register(registeredConsumerUrl);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ExtensionLoader createMockExtensionLoader(RegistryFactory registryFactory) {
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    return extensionLoaderMock;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_33
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.registry.client.migration.MigrationRuleListener`
- **Test Case Count**: 5
- **MO Count**: 5

### Reusable Method
```java
// === Declare in class scope ===
private MigrationRuleListener migrationRuleListener;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    migrationRuleListener = mock(MigrationRuleListener.class);
}

// === Replace local variable in test with ===
migrationRuleListener

```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_33_1
#### Test Case Name: `testConsumerUrlWithoutProtocol`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `migrationRuleListener`
<summary>Suggested Diff</summary>

```diff
@@
     RegistryProtocol registryProtocol = new RegistryProtocol();
-    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
+    // removed local mock; replaced with global field `migrationRuleListener`
     List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
     registryProtocolListeners.add(migrationRuleListener);
     ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify the generated consumer url information
 */
@Test
void testConsumerUrlWithoutProtocol() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    // verify that the protocol header of consumerUrl is set to "consumer"
    Assertions.assertEquals("consumer", consumerUrl.getProtocol());
    Assertions.assertEquals(parameters.get(REGISTER_IP_KEY), consumerUrl.getHost());
    Assertions.assertFalse(consumerUrl.getAttributes().containsKey(REFER_KEY));
    Assertions.assertEquals("value1", consumerUrl.getAttribute("key1"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MigrationRuleListener migrationRuleListener;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    migrationRuleListener = mock(MigrationRuleListener.class);
}

// === Replace local variable in test with ===
migrationRuleListener

```
</details>

---
#### Test Case ID #dubbo_Test_33_2
#### Test Case Name: `testConsumerUrlWithProtocol`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `migrationRuleListener`
<summary>Suggested Diff</summary>

```diff
@@
     Registry registry = mock(Registry.class);
-    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
+    // removed local mock; replaced with global field `migrationRuleListener`
     List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
     registryProtocolListeners.add(migrationRuleListener);
     ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that when the protocol is configured, the protocol of consumer url is the configured protocol
 */
@Test
void testConsumerUrlWithProtocol() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    parameters.put(PROTOCOL_KEY, "tri");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    // verify that the protocol of consumer url
    Assertions.assertEquals("tri", consumerUrl.getProtocol());
    Assertions.assertEquals(parameters.get(REGISTER_IP_KEY), consumerUrl.getHost());
    Assertions.assertFalse(consumerUrl.getAttributes().containsKey(REFER_KEY));
    Assertions.assertEquals("value1", consumerUrl.getAttribute("key1"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MigrationRuleListener migrationRuleListener;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    migrationRuleListener = mock(MigrationRuleListener.class);
}

// === Replace local variable in test with ===
migrationRuleListener

```
</details>

---
#### Test Case ID #dubbo_Test_33_3
#### Test Case Name: `testReferWithoutGroup`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `migrationRuleListener`
<summary>Suggested Diff</summary>

```diff
@@
     RegistryFactory registryFactory = mock(RegistryFactory.class);
     Registry registry = mock(Registry.class);
-    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
+    // removed local mock; replaced with global field `migrationRuleListener`
     List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
     registryProtocolListeners.add(migrationRuleListener);
     RegistryProtocol registryProtocol = new RegistryProtocol();
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that if multiple groups are not configured, the service reference of the registration center
 * the default is FailoverCluster
 *
 * @see FailoverCluster
 */
@Test
void testReferWithoutGroup() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Invoker<?> invoker = registryProtocol.refer(DemoService.class, url);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    Assertions.assertTrue(((MigrationInvoker<?>) invoker).getCluster() instanceof ScopeClusterWrapper);
    Assertions.assertTrue(((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster() instanceof MockClusterWrapper);
    Assertions.assertTrue(((MockClusterWrapper) ((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster()).getCluster() instanceof FailoverCluster);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MigrationRuleListener migrationRuleListener;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    migrationRuleListener = mock(MigrationRuleListener.class);
}

// === Replace local variable in test with ===
migrationRuleListener

```
</details>

---
#### Test Case ID #dubbo_Test_33_4
#### Test Case Name: `testReferWithGroup`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `migrationRuleListener`
<summary>Suggested Diff</summary>

```diff
@@
     RegistryFactory registryFactory = mock(RegistryFactory.class);
     Registry registry = mock(Registry.class);
-    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
+    // removed local mock; replaced with global field `migrationRuleListener`
     List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
-    registryProtocolListeners.add(migrationRuleListener);
+    registryProtocolListeners.add(migrationRuleListener);
     RegistryProtocol registryProtocol = new RegistryProtocol();
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that if multiple groups are configured, the service reference of the registration center
 *
 * @see MergeableCluster
 */
@Test
void testReferWithGroup() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    refer.put(GROUP_KEY, "group1,group2");
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Invoker<?> invoker = registryProtocol.refer(DemoService.class, url);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    Assertions.assertTrue(((MigrationInvoker<?>) invoker).getCluster() instanceof ScopeClusterWrapper);
    Assertions.assertTrue(((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster() instanceof MockClusterWrapper);
    Assertions.assertTrue(((MockClusterWrapper) ((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster()).getCluster() instanceof MergeableCluster);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MigrationRuleListener migrationRuleListener;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    migrationRuleListener = mock(MigrationRuleListener.class);
}

// === Replace local variable in test with ===
migrationRuleListener

```
</details>

---
#### Test Case ID #dubbo_Test_33_5
#### Test Case Name: `testInterceptInvokerForMigrationRuleListener`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `migrationRuleListener`
<summary>Suggested Diff</summary>

```diff
@@
     url = url.putAttribute(CONSUMER_URL_KEY, consumerUrl);
-    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
+    // removed local mock; replaced with global field `migrationRuleListener`
     List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
     registryProtocolListeners.add(migrationRuleListener);
     RegistryProtocol registryProtocol = new RegistryProtocol();
@@
     registryProtocol.interceptInvoker(clusterInvoker, url, consumerUrl);
-    verify(migrationRuleListener, times(1)).onRefer(registryProtocol, clusterInvoker, consumerUrl, url);
+    verify(migrationRuleListener, times(1)).onRefer(registryProtocol, clusterInvoker, consumerUrl, url);
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that the default RegistryProtocolListener will be executed
 *
 * @see MigrationRuleListener
 */
@Test
void testInterceptInvokerForMigrationRuleListener() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    refer.put(GROUP_KEY, "group1,group2");
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    MigrationInvoker<?> clusterInvoker = mock(MigrationInvoker.class);
    Map<String, Object> consumerAttribute = new HashMap<>(url.getAttributes());
    consumerAttribute.remove(REFER_KEY);
    URL consumerUrl = new ServiceConfigURL(parameters.get(PROTOCOL_KEY) == null ? DUBBO : parameters.get(PROTOCOL_KEY), null, null, parameters.get(REGISTER_IP_KEY), 0, url.getPath(), parameters, consumerAttribute);
    url = url.putAttribute(CONSUMER_URL_KEY, consumerUrl);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    registryProtocol.interceptInvoker(clusterInvoker, url, consumerUrl);
    verify(migrationRuleListener, times(1)).onRefer(registryProtocol, clusterInvoker, consumerUrl, url);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MigrationRuleListener migrationRuleListener;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    migrationRuleListener = mock(MigrationRuleListener.class);
}

// === Replace local variable in test with ===
migrationRuleListener

```
</details>

---
## Mock Clone Instance #dubbo_MCI_34
- **Scope**: class level
- **Mocked Class**: `org.apache.dubbo.rpc.Invoker<?>`
- **Test Case Count**: 1
- **MO Count**: 2

### Reusable Method
```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with getUrl() stubbed to return the given URL.
     *
     * @param url the URL to return from getUrl()
     * @return a mock Invoker with getUrl() stubbed
     */
    public static Invoker<?> createMockInvoker(URL url) {
        Invoker<?> invoker = Mockito.mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_34_1
#### Test Case Name: `doStartCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\protocol\tri\call\ReflectionServerCallTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 void doStartCall() throws NoSuchMethodException {
-    Invoker<?> invoker = Mockito.mock(Invoker.class);
     TripleServerStream serverStream = Mockito.mock(TripleServerStream.class);
     ProviderModel providerModel = Mockito.mock(ProviderModel.class);
     Method method = DescriptorService.class.getMethod("sayHello", HelloReply.class);
     MethodDescriptor methodDescriptor = new ReflectionMethodDescriptor(method);
     URL url = Mockito.mock(URL.class);
+    Invoker<?> invoker = MockInvoker.createMockInvoker(url);
     when(url.getServiceModel()).thenReturn(providerModel);
     String service = "testService";
     String methodName = "method";
     try {
         ReflectionAbstractServerCall call = new ReflectionAbstractServerCall(invoker, serverStream, new FrameworkModel(), "", service, methodName, Collections.emptyList(), ImmediateEventExecutor.INSTANCE);
         fail();
     } catch (Exception e) {
         // pass
     }
     ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
     when(serviceDescriptor.getMethods(anyString())).thenReturn(Collections.singletonList(methodDescriptor));
     when(providerModel.getServiceModel()).thenReturn(serviceDescriptor);
     ReflectionAbstractServerCall call2 = new ReflectionAbstractServerCall(invoker, serverStream, new FrameworkModel(), "", service, methodName, Collections.emptyList(), ImmediateEventExecutor.INSTANCE);
     call2.onHeader(Collections.emptyMap());
     call2.onMessage(new byte[0], false);
     call2.onComplete();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void doStartCall() throws NoSuchMethodException {
    Invoker<?> invoker = Mockito.mock(Invoker.class);
    TripleServerStream serverStream = Mockito.mock(TripleServerStream.class);
    ProviderModel providerModel = Mockito.mock(ProviderModel.class);
    Method method = DescriptorService.class.getMethod("sayHello", HelloReply.class);
    MethodDescriptor methodDescriptor = new ReflectionMethodDescriptor(method);
    URL url = Mockito.mock(URL.class);
    when(invoker.getUrl()).thenReturn(url);
    when(url.getServiceModel()).thenReturn(providerModel);
    String service = "testService";
    String methodName = "method";
    try {
        ReflectionAbstractServerCall call = new ReflectionAbstractServerCall(invoker, serverStream, new FrameworkModel(), "", service, methodName, Collections.emptyList(), ImmediateEventExecutor.INSTANCE);
        fail();
    } catch (Exception e) {
        // pass
    }
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(serviceDescriptor.getMethods(anyString())).thenReturn(Collections.singletonList(methodDescriptor));
    when(providerModel.getServiceModel()).thenReturn(serviceDescriptor);
    ReflectionAbstractServerCall call2 = new ReflectionAbstractServerCall(invoker, serverStream, new FrameworkModel(), "", service, methodName, Collections.emptyList(), ImmediateEventExecutor.INSTANCE);
    call2.onHeader(Collections.emptyMap());
    call2.onMessage(new byte[0], false);
    call2.onComplete();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with getUrl() stubbed to return the given URL.
     *
     * @param url the URL to return from getUrl()
     * @return a mock Invoker with getUrl() stubbed
     */
    public static Invoker<?> createMockInvoker(URL url) {
        Invoker<?> invoker = Mockito.mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_34_2
#### Test Case Name: `doStartCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\protocol\tri\call\StubServerCallTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 void doStartCall() throws IOException, ClassNotFoundException {
-    Invoker<?> invoker = Mockito.mock(Invoker.class);
     TripleServerStream tripleServerStream = Mockito.mock(TripleServerStream.class);
     ProviderModel providerModel = Mockito.mock(ProviderModel.class);
     ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
     StubMethodDescriptor methodDescriptor = Mockito.mock(StubMethodDescriptor.class);
     URL url = Mockito.mock(URL.class);
+    Invoker<?> invoker = MockInvoker.createMockInvoker(url);
     when(url.getServiceModel()).thenReturn(providerModel);
     when(providerModel.getServiceModel()).thenReturn(serviceDescriptor);
     when(serviceDescriptor.getMethods(anyString())).thenReturn(Collections.singletonList(methodDescriptor));
     when(methodDescriptor.getRpcType()).thenReturn(RpcType.UNARY);
     when(methodDescriptor.parseRequest(any(byte[].class))).thenReturn("test");
     String service = "testService";
     String method = "method";
     StubAbstractServerCall call = new StubAbstractServerCall(invoker, tripleServerStream, new FrameworkModel(), "", service, method, ImmediateEventExecutor.INSTANCE);
     call.onHeader(Collections.emptyMap());
     call.onMessage(new byte[0], false);
     call.onComplete();
@@
-    when(invoker.getUrl()).thenReturn(url);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void doStartCall() throws IOException, ClassNotFoundException {
    Invoker<?> invoker = Mockito.mock(Invoker.class);
    TripleServerStream tripleServerStream = Mockito.mock(TripleServerStream.class);
    ProviderModel providerModel = Mockito.mock(ProviderModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    StubMethodDescriptor methodDescriptor = Mockito.mock(StubMethodDescriptor.class);
    URL url = Mockito.mock(URL.class);
    when(invoker.getUrl()).thenReturn(url);
    when(url.getServiceModel()).thenReturn(providerModel);
    when(providerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(serviceDescriptor.getMethods(anyString())).thenReturn(Collections.singletonList(methodDescriptor));
    when(methodDescriptor.getRpcType()).thenReturn(RpcType.UNARY);
    when(methodDescriptor.parseRequest(any(byte[].class))).thenReturn("test");
    String service = "testService";
    String method = "method";
    StubAbstractServerCall call = new StubAbstractServerCall(invoker, tripleServerStream, new FrameworkModel(), "", service, method, ImmediateEventExecutor.INSTANCE);
    call.onHeader(Collections.emptyMap());
    call.onMessage(new byte[0], false);
    call.onComplete();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with getUrl() stubbed to return the given URL.
     *
     * @param url the URL to return from getUrl()
     * @return a mock Invoker with getUrl() stubbed
     */
    public static Invoker<?> createMockInvoker(URL url) {
        Invoker<?> invoker = Mockito.mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_35
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.registry.client.migration.model.MigrationRule`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static MigrationRule createMockMigrationRule(boolean forceReturn) {
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(forceReturn);
    return migrationRule;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_35_1
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationInvokerTest.java`)
#### Mock Object Variable Name: `migrationRule`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
-    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
-    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
+    MigrationRule migrationRule = createMockMigrationRule(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(1)).invoke(null);
@@
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
-    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
+    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
-    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
+    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(2)).invoke(null);
-    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
-    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
+    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
+    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(3)).invoke(null);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(4)).invoke(null);
-    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
+    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(5)).invoke(null);
-    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
+    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(3)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(4)).invoke(null);
-    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
+    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(5)).invoke(null);
-    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
-    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
+    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
+    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(6)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(6)).invoke(null);
-    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
+    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(7)).invoke(null);
    Assertions.assertNull(migrationInvoker.getInvoker());
-    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
+    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
-    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
+    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(7)).invoke(null);
    Assertions.assertNull(migrationInvoker.getServiceDiscoveryInvoker());
    ArgumentCaptor<InvokersChangedListener> argument = ArgumentCaptor.forClass(InvokersChangedListener.class);
    Mockito.verify(serviceDiscoveryDirectory, Mockito.atLeastOnce()).setInvokersChangedListener(argument.capture());
-    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
+    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    for (int i = 0; i < 20; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(27)).invoke(null);
    serviceDiscoveryInvokers.remove(1);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(false);
    argument.getAllValues().get(argument.getAllValues().size() - 1).onChange();
    for (int i = 0; i < 20; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(invoker, Mockito.times(27)).invoke(null);
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    argument.getAllValues().get(argument.getAllValues().size() - 1).onChange();
-    Mockito.when(migrationRule.getProportion(Mockito.any())).thenReturn(50);
+    Mockito.when(migrationRule.getProportion(Mockito.any())).thenReturn(50);
    migrationInvoker.setMigrationRule(migrationRule);
    for (int i = 0; i < 1000; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(serviceDiscoveryInvoker, Mockito.atMost(1026)).invoke(null);
    Mockito.verify(invoker, Mockito.atLeast(28)).invoke(null);
-    Mockito.when(migrationRule.getDelay(Mockito.any())).thenReturn(1);
+    Mockito.when(migrationRule.getDelay(Mockito.any())).thenReturn(1);
    long currentTimeMillis = System.currentTimeMillis();
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    Assertions.assertTrue(System.currentTimeMillis() - currentTimeMillis >= 2000);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("all")
@Test
void test() {
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
    Mockito.when(invoker.isAvailable()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(1)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(2)).invoke(null);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(3)).invoke(null);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(4)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(5)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(3)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(4)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(5)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(6)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(6)).invoke(null);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(7)).invoke(null);
    Assertions.assertNull(migrationInvoker.getInvoker());
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(7)).invoke(null);
    Assertions.assertNull(migrationInvoker.getServiceDiscoveryInvoker());
    ArgumentCaptor<InvokersChangedListener> argument = ArgumentCaptor.forClass(InvokersChangedListener.class);
    Mockito.verify(serviceDiscoveryDirectory, Mockito.atLeastOnce()).setInvokersChangedListener(argument.capture());
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    for (int i = 0; i < 20; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(27)).invoke(null);
    serviceDiscoveryInvokers.remove(1);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(false);
    argument.getAllValues().get(argument.getAllValues().size() - 1).onChange();
    for (int i = 0; i < 20; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(invoker, Mockito.times(27)).invoke(null);
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    argument.getAllValues().get(argument.getAllValues().size() - 1).onChange();
    Mockito.when(migrationRule.getProportion(Mockito.any())).thenReturn(50);
    migrationInvoker.setMigrationRule(migrationRule);
    for (int i = 0; i < 1000; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(serviceDiscoveryInvoker, Mockito.atMost(1026)).invoke(null);
    Mockito.verify(invoker, Mockito.atLeast(28)).invoke(null);
    Mockito.when(migrationRule.getDelay(Mockito.any())).thenReturn(1);
    long currentTimeMillis = System.currentTimeMillis();
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    Assertions.assertTrue(System.currentTimeMillis() - currentTimeMillis >= 2000);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static MigrationRule createMockMigrationRule(boolean forceReturn) {
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(forceReturn);
    return migrationRule;
}
```
</details>

---
#### Test Case ID #dubbo_Test_35_2
#### Test Case Name: `testDecide`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationInvokerTest.java`)
#### Mock Object Variable Name: `migrationRule`
<summary>Suggested Diff</summary>

```diff
@@
     migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
     migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
     migrationInvoker.invoke(null);
     Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
-    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
-    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
+    MigrationRule migrationRule = createMockMigrationRule(true);
     migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
     migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
     migrationInvoker.invoke(null);
     Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("all")
@Test
void testDecide() {
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
    Mockito.when(invoker.isAvailable()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(false);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(1)).invoke(null);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static MigrationRule createMockMigrationRule(boolean forceReturn) {
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(forceReturn);
    return migrationRule;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_36
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.Invocation`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static org.apache.dubbo.rpc.Invocation createMockInvocation(org.apache.dubbo.rpc.Invoker<?> invoker, String methodName) {
    org.apache.dubbo.rpc.Invocation invocation = Mockito.mock(org.apache.dubbo.rpc.Invocation.class);
    when(invocation.getInvoker()).thenReturn(invoker);
    when(invocation.getMethodName()).thenReturn(methodName);
    return invocation;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_36_1
#### Test Case Name: `testRoutePathMatch`(File: `C:\Java_projects\Apache\dubbo\dubbo-xds\src\test\java\org\apache\dubbo\rpc\cluster\router\xds\XdsRouteTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    hostListener.parseVirtualHost(virtualHost);
-    Invocation invocation = Mockito.mock(Invocation.class);
+    Invocation invocation = createMockInvocation(invoker, "call");
    Invoker invoker = Mockito.mock(Invoker.class);
    URL url1 = Mockito.mock(URL.class);
    when(invoker.getUrl()).thenReturn(url1);
    when(url1.getPath()).thenReturn("DemoInterface");
-    when(invocation.getInvoker()).thenReturn(invoker);
-    when(invocation.getMethodName()).thenReturn("call");
    Set<Endpoint> endpoints = new HashSet<>();
    Endpoint endpoint1 = new Endpoint();
    endpoint1.setAddress("1.1.1.1");
    endpoint1.setPortValue(20880);
    endpoints.add(endpoint1);
    edsEndpointManager.notifyEndpointChange(cluster1, endpoints);
    BitList<Invoker<Object>> routes = xdsRouter.route(invokers.clone(), null, invocation, false, null);
    assertEquals(1, routes.size());
    assertEquals(invoker1, routes.get(0));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testRoutePathMatch() {
    XdsRouter<Object> xdsRouter = new XdsRouter<>(url, rdsRouteRuleManager, edsEndpointManager, true);
    String appName = "app1";
    String cluster1 = "cluster-test1";
    Invoker<Object> invoker1 = createInvoker(appName, "1.1.1.1:20880");
    BitList<Invoker<Object>> invokers = new BitList<>(Arrays.asList(invoker1, createInvoker(appName, "2.2.2.2:20880")));
    xdsRouter.notify(invokers);
    String path = "/DemoInterface/call";
    VirtualHost virtualHost = VirtualHost.newBuilder().addDomains(appName).addRoutes(Route.newBuilder().setName("route-test").setMatch(RouteMatch.newBuilder().setPath(path).build()).setRoute(RouteAction.newBuilder().setCluster(cluster1).build()).build()).build();
    RdsVirtualHostListener hostListener = new RdsVirtualHostListener(appName, rdsRouteRuleManager);
    hostListener.parseVirtualHost(virtualHost);
    Invocation invocation = Mockito.mock(Invocation.class);
    Invoker invoker = Mockito.mock(Invoker.class);
    URL url1 = Mockito.mock(URL.class);
    when(invoker.getUrl()).thenReturn(url1);
    when(url1.getPath()).thenReturn("DemoInterface");
    when(invocation.getInvoker()).thenReturn(invoker);
    when(invocation.getMethodName()).thenReturn("call");
    Set<Endpoint> endpoints = new HashSet<>();
    Endpoint endpoint1 = new Endpoint();
    endpoint1.setAddress("1.1.1.1");
    endpoint1.setPortValue(20880);
    endpoints.add(endpoint1);
    edsEndpointManager.notifyEndpointChange(cluster1, endpoints);
    BitList<Invoker<Object>> routes = xdsRouter.route(invokers.clone(), null, invocation, false, null);
    assertEquals(1, routes.size());
    assertEquals(invoker1, routes.get(0));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static org.apache.dubbo.rpc.Invocation createMockInvocation(org.apache.dubbo.rpc.Invoker<?> invoker, String methodName) {
    org.apache.dubbo.rpc.Invocation invocation = Mockito.mock(org.apache.dubbo.rpc.Invocation.class);
    when(invocation.getInvoker()).thenReturn(invoker);
    when(invocation.getMethodName()).thenReturn(methodName);
    return invocation;
}
```
</details>

---
#### Test Case ID #dubbo_Test_36_2
#### Test Case Name: `testRouteMultiApp`(File: `C:\Java_projects\Apache\dubbo\dubbo-xds\src\test\java\org\apache\dubbo\rpc\cluster\router\xds\XdsRouteTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
@@
    RdsVirtualHostListener hostListener = new RdsVirtualHostListener(appName2, rdsRouteRuleManager);
    hostListener.parseVirtualHost(virtualHost);
-    Invocation invocation = Mockito.mock(Invocation.class);
+    Invocation invocation = createMockInvocation(invoker, "call");
    Invoker invoker = Mockito.mock(Invoker.class);
    URL url1 = Mockito.mock(URL.class);
    when(invoker.getUrl()).thenReturn(url1);
    when(url1.getPath()).thenReturn("DemoInterface");
-    when(invocation.getInvoker()).thenReturn(invoker);
-    when(invocation.getMethodName()).thenReturn("call");
    Set<Endpoint> endpoints = new HashSet<>();
    Endpoint endpoint1 = new Endpoint();
    endpoint1.setAddress("1.1.1.1");
    endpoint1.setPortValue(20880);
    endpoints.add(endpoint1);
    edsEndpointManager.notifyEndpointChange(cluster1, endpoints);
    BitList<Invoker<Object>> routes = xdsRouter.route(invokers.clone(), null, invocation, false, null);
    assertEquals(1, routes.size());
    assertEquals(invoker1, routes.get(0));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testRouteMultiApp() {
    XdsRouter<Object> xdsRouter = new XdsRouter<>(url, rdsRouteRuleManager, edsEndpointManager, true);
    String appName1 = "app1";
    String appName2 = "app2";
    String cluster1 = "cluster-test1";
    Invoker<Object> invoker1 = createInvoker(appName2, "1.1.1.1:20880");
    Invoker<Object> invoker2 = createInvoker(appName1, "2.2.2.2:20880");
    BitList<Invoker<Object>> invokers = new BitList<>(Arrays.asList(invoker1, invoker2));
    xdsRouter.notify(invokers);
    assertEquals(xdsRouter.getSubscribeApplications().size(), 2);
    String path = "/DemoInterface/call";
    VirtualHost virtualHost = VirtualHost.newBuilder().addDomains(appName2).addRoutes(Route.newBuilder().setName("route-test").setMatch(RouteMatch.newBuilder().setPath(path).build()).setRoute(RouteAction.newBuilder().setCluster(cluster1).build()).build()).build();
    RdsVirtualHostListener hostListener = new RdsVirtualHostListener(appName2, rdsRouteRuleManager);
    hostListener.parseVirtualHost(virtualHost);
    Invocation invocation = Mockito.mock(Invocation.class);
    Invoker invoker = Mockito.mock(Invoker.class);
    URL url1 = Mockito.mock(URL.class);
    when(invoker.getUrl()).thenReturn(url1);
    when(url1.getPath()).thenReturn("DemoInterface");
    when(invocation.getInvoker()).thenReturn(invoker);
    when(invocation.getMethodName()).thenReturn("call");
    Set<Endpoint> endpoints = new HashSet<>();
    Endpoint endpoint1 = new Endpoint();
    endpoint1.setAddress("1.1.1.1");
    endpoint1.setPortValue(20880);
    endpoints.add(endpoint1);
    edsEndpointManager.notifyEndpointChange(cluster1, endpoints);
    BitList<Invoker<Object>> routes = xdsRouter.route(invokers.clone(), null, invocation, false, null);
    assertEquals(1, routes.size());
    assertEquals(invoker1, routes.get(0));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static org.apache.dubbo.rpc.Invocation createMockInvocation(org.apache.dubbo.rpc.Invoker<?> invoker, String methodName) {
    org.apache.dubbo.rpc.Invocation invocation = Mockito.mock(org.apache.dubbo.rpc.Invocation.class);
    when(invocation.getInvoker()).thenReturn(invoker);
    when(invocation.getMethodName()).thenReturn(methodName);
    return invocation;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_37
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.Invocation`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static Invocation createMockInvocation(String attachmentKey, String attachmentValue) {
    Invocation invocation = Mockito.mock(Invocation.class);
    when(invocation.getAttachment(attachmentKey)).thenReturn(attachmentValue);
    return invocation;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_37_1
#### Test Case Name: `testRouteHeadMatch`(File: `C:\Java_projects\Apache\dubbo\dubbo-xds\src\test\java\org\apache\dubbo\rpc\cluster\router\xds\XdsRouteTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    hostListener.parseVirtualHost(virtualHost);
-    Invocation invocation = Mockito.mock(Invocation.class);
-    when(invocation.getAttachment("userId")).thenReturn("123");
+    Invocation invocation = createMockInvocation("userId", "123");
    Set<Endpoint> endpoints = new HashSet<>();
    Endpoint endpoint1 = new Endpoint();
    endpoint1.setAddress("1.1.1.1");
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testRouteHeadMatch() {
    XdsRouter<Object> xdsRouter = new XdsRouter<>(url, rdsRouteRuleManager, edsEndpointManager, true);
    String appName = "app1";
    String cluster1 = "cluster-test1";
    Invoker<Object> invoker1 = createInvoker(appName, "1.1.1.1:20880");
    BitList<Invoker<Object>> invokers = new BitList<>(Arrays.asList(invoker1, createInvoker(appName, "2.2.2.2:20880")));
    xdsRouter.notify(invokers);
    VirtualHost virtualHost = VirtualHost.newBuilder().addDomains(appName).addRoutes(Route.newBuilder().setName("route-test").setMatch(RouteMatch.newBuilder().addHeaders(HeaderMatcher.newBuilder().setName("userId").setExactMatch("123").build()).build()).setRoute(RouteAction.newBuilder().setCluster(cluster1).build()).build()).build();
    RdsVirtualHostListener hostListener = new RdsVirtualHostListener(appName, rdsRouteRuleManager);
    hostListener.parseVirtualHost(virtualHost);
    Invocation invocation = Mockito.mock(Invocation.class);
    when(invocation.getAttachment("userId")).thenReturn("123");
    Set<Endpoint> endpoints = new HashSet<>();
    Endpoint endpoint1 = new Endpoint();
    endpoint1.setAddress("1.1.1.1");
    endpoint1.setPortValue(20880);
    endpoints.add(endpoint1);
    edsEndpointManager.notifyEndpointChange(cluster1, endpoints);
    BitList<Invoker<Object>> routes = xdsRouter.route(invokers.clone(), null, invocation, false, null);
    assertEquals(1, routes.size());
    assertEquals(invoker1, routes.get(0));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invocation createMockInvocation(String attachmentKey, String attachmentValue) {
    Invocation invocation = Mockito.mock(Invocation.class);
    when(invocation.getAttachment(attachmentKey)).thenReturn(attachmentValue);
    return invocation;
}
```
</details>

---
#### Test Case ID #dubbo_Test_37_2
#### Test Case Name: `testRouteWeightCluster`(File: `C:\Java_projects\Apache\dubbo\dubbo-xds\src\test\java\org\apache\dubbo\rpc\cluster\router\xds\XdsRouteTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
@@
    hostListener.parseVirtualHost(virtualHost);
-    Invocation invocation = Mockito.mock(Invocation.class);
-    when(invocation.getAttachment("userId")).thenReturn("123");
+    Invocation invocation = createMockInvocation("userId", "123");
    Set<Endpoint> endpoints = new HashSet<>();
    Endpoint endpoint1 = new Endpoint();
    endpoint1.setAddress("1.1.1.1");
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testRouteWeightCluster() {
    XdsRouter<Object> xdsRouter = new XdsRouter<>(url, rdsRouteRuleManager, edsEndpointManager, true);
    String appName = "app1";
    String cluster1 = "cluster-test1";
    String cluster2 = "cluster-test2";
    Invoker<Object> invoker1 = createInvoker(appName, "1.1.1.1:20880");
    BitList<Invoker<Object>> invokers = new BitList<>(Arrays.asList(invoker1, createInvoker(appName, "2.2.2.2:20880")));
    xdsRouter.notify(invokers);
    VirtualHost virtualHost = VirtualHost.newBuilder().addDomains(appName).addRoutes(Route.newBuilder().setName("route-test").setMatch(RouteMatch.newBuilder().addHeaders(HeaderMatcher.newBuilder().setName("userId").setExactMatch("123").build()).build()).setRoute(RouteAction.newBuilder().setWeightedClusters(WeightedCluster.newBuilder().addClusters(WeightedCluster.ClusterWeight.newBuilder().setName(cluster1).setWeight(UInt32Value.newBuilder().setValue(100).build()).build()).addClusters(WeightedCluster.ClusterWeight.newBuilder().setName(cluster2).setWeight(UInt32Value.newBuilder().setValue(0).build()).build()).build()).build()).build()).build();
    RdsVirtualHostListener hostListener = new RdsVirtualHostListener(appName, rdsRouteRuleManager);
    hostListener.parseVirtualHost(virtualHost);
    Invocation invocation = Mockito.mock(Invocation.class);
    when(invocation.getAttachment("userId")).thenReturn("123");
    Set<Endpoint> endpoints = new HashSet<>();
    Endpoint endpoint1 = new Endpoint();
    endpoint1.setAddress("1.1.1.1");
    endpoint1.setPortValue(20880);
    endpoints.add(endpoint1);
    edsEndpointManager.notifyEndpointChange(cluster1, endpoints);
    endpoints = new HashSet<>();
    Endpoint endpoint2 = new Endpoint();
    endpoint2.setAddress("2.2.2.2");
    endpoint2.setPortValue(20880);
    endpoints.add(endpoint2);
    edsEndpointManager.notifyEndpointChange(cluster2, endpoints);
    for (int i = 0; i < 10; i++) {
        BitList<Invoker<Object>> routes = xdsRouter.route(invokers.clone(), null, invocation, false, null);
        assertEquals(1, routes.size());
        assertEquals(invoker1, routes.get(0));
    }
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invocation createMockInvocation(String attachmentKey, String attachmentValue) {
    Invocation invocation = Mockito.mock(Invocation.class);
    when(invocation.getAttachment(attachmentKey)).thenReturn(attachmentValue);
    return invocation;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_38
- **Scope**: class level
- **Mocked Class**: `org.apache.dubbo.rpc.Invocation`
- **Test Case Count**: 9
- **MO Count**: 9

### Reusable Method
```java
public class MockInvocation {
    public static org.apache.dubbo.rpc.Invocation createMockInvocation(String methodName, Class<?>[] parameterTypes, Object[] arguments) {
        org.apache.dubbo.rpc.Invocation invocation = mock(org.apache.dubbo.rpc.Invocation.class);
        given(invocation.getMethodName()).willReturn(methodName);
        given(invocation.getParameterTypes()).willReturn(parameterTypes);
        given(invocation.getArguments()).willReturn(arguments);
        return invocation;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_38_1
#### Test Case Name: `testInvokerGeneric`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\CompatibleFilterFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
@@
 void testInvokerGeneric() {
-    invocation = mock(RpcInvocation.class);
-    given(invocation.getMethodName()).willReturn("$enumlength");
-    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Enum.class });
-    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
+    invocation = MockInvocation.createMockInvocation("$enumlength", new Class<?>[] { Enum.class }, new Object[] { "hello" });
    invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("High");
    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    Result filterResult = compatibleFilter.invoke(invoker, invocation);
    assertEquals(filterResult, result);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testInvokerGeneric() {
    invocation = mock(RpcInvocation.class);
    given(invocation.getMethodName()).willReturn("$enumlength");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Enum.class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
    invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("High");
    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    Result filterResult = compatibleFilter.invoke(invoker, invocation);
    assertEquals(filterResult, result);
}
@AfterEach
public void tearDown() {
    Mockito.reset(invocation, invoker);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvocation {
    public static org.apache.dubbo.rpc.Invocation createMockInvocation(String methodName, Class<?>[] parameterTypes, Object[] arguments) {
        org.apache.dubbo.rpc.Invocation invocation = mock(org.apache.dubbo.rpc.Invocation.class);
        given(invocation.getMethodName()).willReturn(methodName);
        given(invocation.getParameterTypes()).willReturn(parameterTypes);
        given(invocation.getArguments()).willReturn(arguments);
        return invocation;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_38_2
#### Test Case Name: `testResultHasException`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\CompatibleFilterFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void testResultHasException() {
-    invocation = mock(RpcInvocation.class);
-    given(invocation.getMethodName()).willReturn("enumlength");
-    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Enum.class });
-    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
+    invocation = MockInvocation.createMockInvocation("enumlength", new Class<?>[] { Enum.class }, new Object[] { "hello" });
     invoker = mock(Invoker.class);
     given(invoker.isAvailable()).willReturn(true);
     given(invoker.getInterface()).willReturn(DemoService.class);
     AppResponse result = new AppResponse();
     result.setException(new RuntimeException());
     result.setValue("High");
     given(invoker.invoke(invocation)).willReturn(result);
     URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
     given(invoker.getUrl()).willReturn(url);
     Result filterResult = compatibleFilter.invoke(invoker, invocation);
     assertEquals(filterResult, result);
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testResultHasException() {
    invocation = mock(RpcInvocation.class);
    given(invocation.getMethodName()).willReturn("enumlength");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Enum.class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
    invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setException(new RuntimeException());
    result.setValue("High");
    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    Result filterResult = compatibleFilter.invoke(invoker, invocation);
    assertEquals(filterResult, result);
}
@AfterEach
public void tearDown() {
    Mockito.reset(invocation, invoker);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvocation {
    public static org.apache.dubbo.rpc.Invocation createMockInvocation(String methodName, Class<?>[] parameterTypes, Object[] arguments) {
        org.apache.dubbo.rpc.Invocation invocation = mock(org.apache.dubbo.rpc.Invocation.class);
        given(invocation.getMethodName()).willReturn(methodName);
        given(invocation.getParameterTypes()).willReturn(parameterTypes);
        given(invocation.getArguments()).willReturn(arguments);
        return invocation;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_38_3
#### Test Case Name: `testInvokerJsonPojoSerialization`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\CompatibleFilterFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
--- a/TestClass.java
+++ b/TestClass.java
@@
 @Test
 void testInvokerJsonPojoSerialization() throws Exception {
-    invocation = mock(RpcInvocation.class);
-    given(invocation.getMethodName()).willReturn("enumlength");
-    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Type[].class });
-    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
+    invocation = MockInvocation.createMockInvocation("enumlength", new Class<?>[] { Type[].class }, new Object[] { "hello" });
     invoker = mock(Invoker.class);
     given(invoker.isAvailable()).willReturn(true);
     given(invoker.getInterface()).willReturn(DemoService.class);
     AppResponse result = new AppResponse();
     result.setValue("High");
     AsyncRpcResult defaultAsyncResult = AsyncRpcResult.newDefaultAsyncResult(result, invocation);
     given(invoker.invoke(invocation)).willReturn(defaultAsyncResult);
     URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1&serialization=json");
     given(invoker.getUrl()).willReturn(url);
     Result asyncResult = compatibleFilter.invoke(invoker, invocation);
     AppResponse appResponse = (AppResponse) asyncResult.get();
     compatibleFilter.onResponse(appResponse, invoker, invocation);
     assertEquals(Type.High, appResponse.getValue());
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testInvokerJsonPojoSerialization() throws Exception {
    invocation = mock(RpcInvocation.class);
    given(invocation.getMethodName()).willReturn("enumlength");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Type[].class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
    invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("High");
    AsyncRpcResult defaultAsyncResult = AsyncRpcResult.newDefaultAsyncResult(result, invocation);
    given(invoker.invoke(invocation)).willReturn(defaultAsyncResult);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1&serialization=json");
    given(invoker.getUrl()).willReturn(url);
    Result asyncResult = compatibleFilter.invoke(invoker, invocation);
    AppResponse appResponse = (AppResponse) asyncResult.get();
    compatibleFilter.onResponse(appResponse, invoker, invocation);
    assertEquals(Type.High, appResponse.getValue());
}
@AfterEach
public void tearDown() {
    Mockito.reset(invocation, invoker);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvocation {
    public static org.apache.dubbo.rpc.Invocation createMockInvocation(String methodName, Class<?>[] parameterTypes, Object[] arguments) {
        org.apache.dubbo.rpc.Invocation invocation = mock(org.apache.dubbo.rpc.Invocation.class);
        given(invocation.getMethodName()).willReturn(methodName);
        given(invocation.getParameterTypes()).willReturn(parameterTypes);
        given(invocation.getArguments()).willReturn(arguments);
        return invocation;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_38_4
#### Test Case Name: `testInvokerNonJsonEnumSerialization`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\CompatibleFilterFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void testInvokerNonJsonEnumSerialization() throws Exception {
-    invocation = mock(RpcInvocation.class);
-    given(invocation.getMethodName()).willReturn("enumlength");
-    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Type[].class });
-    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
+    invocation = MockInvocation.createMockInvocation("enumlength", new Class<?>[] { Type[].class }, new Object[] { "hello" });
     invoker = mock(Invoker.class);
     given(invoker.isAvailable()).willReturn(true);
     given(invoker.getInterface()).willReturn(DemoService.class);
     AppResponse result = new AppResponse();
     result.setValue("High");
     AsyncRpcResult defaultAsyncResult = AsyncRpcResult.newDefaultAsyncResult(result, invocation);
     given(invoker.invoke(invocation)).willReturn(defaultAsyncResult);
     URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
     given(invoker.getUrl()).willReturn(url);
     Result asyncResult = compatibleFilter.invoke(invoker, invocation);
     AppResponse appResponse = (AppResponse) asyncResult.get();
     compatibleFilter.onResponse(appResponse, invoker, invocation);
     assertEquals(Type.High, appResponse.getValue());
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testInvokerNonJsonEnumSerialization() throws Exception {
    invocation = mock(RpcInvocation.class);
    given(invocation.getMethodName()).willReturn("enumlength");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Type[].class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
    invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("High");
    AsyncRpcResult defaultAsyncResult = AsyncRpcResult.newDefaultAsyncResult(result, invocation);
    given(invoker.invoke(invocation)).willReturn(defaultAsyncResult);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    Result asyncResult = compatibleFilter.invoke(invoker, invocation);
    AppResponse appResponse = (AppResponse) asyncResult.get();
    compatibleFilter.onResponse(appResponse, invoker, invocation);
    assertEquals(Type.High, appResponse.getValue());
}
@AfterEach
public void tearDown() {
    Mockito.reset(invocation, invoker);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvocation {
    public static org.apache.dubbo.rpc.Invocation createMockInvocation(String methodName, Class<?>[] parameterTypes, Object[] arguments) {
        org.apache.dubbo.rpc.Invocation invocation = mock(org.apache.dubbo.rpc.Invocation.class);
        given(invocation.getMethodName()).willReturn(methodName);
        given(invocation.getParameterTypes()).willReturn(parameterTypes);
        given(invocation.getArguments()).willReturn(arguments);
        return invocation;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_38_5
#### Test Case Name: `testInvokerNonJsonNonPojoSerialization`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\CompatibleFilterFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
@@
 void testInvokerNonJsonNonPojoSerialization() {
-    invocation = mock(RpcInvocation.class);
-    given(invocation.getMethodName()).willReturn("echo");
-    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { String.class });
-    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
+    invocation = MockInvocation.createMockInvocation("echo", new Class<?>[] { String.class }, new Object[] { "hello" });
    invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue(new String[] { "High" });
    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    Result filterResult = compatibleFilter.invoke(invoker, invocation);
    assertArrayEquals(new String[] { "High" }, (String[]) filterResult.getValue());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testInvokerNonJsonNonPojoSerialization() {
    invocation = mock(RpcInvocation.class);
    given(invocation.getMethodName()).willReturn("echo");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { String.class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
    invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue(new String[] { "High" });
    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    Result filterResult = compatibleFilter.invoke(invoker, invocation);
    assertArrayEquals(new String[] { "High" }, (String[]) filterResult.getValue());
}
@AfterEach
public void tearDown() {
    Mockito.reset(invocation, invoker);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvocation {
    public static org.apache.dubbo.rpc.Invocation createMockInvocation(String methodName, Class<?>[] parameterTypes, Object[] arguments) {
        org.apache.dubbo.rpc.Invocation invocation = mock(org.apache.dubbo.rpc.Invocation.class);
        given(invocation.getMethodName()).willReturn(methodName);
        given(invocation.getParameterTypes()).willReturn(parameterTypes);
        given(invocation.getArguments()).willReturn(arguments);
        return invocation;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_38_6
#### Test Case Name: `testInvokerNonJsonPojoSerialization`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\CompatibleFilterFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
@@
 void testInvokerNonJsonPojoSerialization() {
-    invocation = mock(RpcInvocation.class);
-    given(invocation.getMethodName()).willReturn("echo");
-    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { String.class });
-    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
+    invocation = MockInvocation.createMockInvocation("echo", new Class<?>[] { String.class }, new Object[] { "hello" });
    invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("hello");
    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    Result filterResult = compatibleFilter.invoke(invoker, invocation);
    assertEquals("hello", filterResult.getValue());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testInvokerNonJsonPojoSerialization() {
    invocation = mock(RpcInvocation.class);
    given(invocation.getMethodName()).willReturn("echo");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { String.class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
    invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("hello");
    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    Result filterResult = compatibleFilter.invoke(invoker, invocation);
    assertEquals("hello", filterResult.getValue());
}
@AfterEach
public void tearDown() {
    Mockito.reset(invocation, invoker);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvocation {
    public static org.apache.dubbo.rpc.Invocation createMockInvocation(String methodName, Class<?>[] parameterTypes, Object[] arguments) {
        org.apache.dubbo.rpc.Invocation invocation = mock(org.apache.dubbo.rpc.Invocation.class);
        given(invocation.getMethodName()).willReturn(methodName);
        given(invocation.getParameterTypes()).willReturn(parameterTypes);
        given(invocation.getArguments()).willReturn(arguments);
        return invocation;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_38_7
#### Test Case Name: `testSetContext`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\ContextFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
@@
 void testSetContext() {
-    invocation = mock(Invocation.class);
-    given(invocation.getMethodName()).willReturn("$enumlength");
-    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Enum.class });
-    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
-    given(invocation.getObjectAttachments()).willReturn(null);
+    invocation = MockInvocation.createMockInvocation("$enumlength", new Class<?>[] { Enum.class }, new Object[] { "hello" });
+    given(invocation.getObjectAttachments()).willReturn(null);
    invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@SuppressWarnings("unchecked")
@Test
void testSetContext() {
    invocation = mock(Invocation.class);
    given(invocation.getMethodName()).willReturn("$enumlength");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Enum.class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
    given(invocation.getObjectAttachments()).willReturn(null);
    invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("High");
    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    contextFilter.invoke(invoker, invocation);
    assertNotNull(RpcContext.getServiceContext().getInvoker());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvocation {
    public static org.apache.dubbo.rpc.Invocation createMockInvocation(String methodName, Class<?>[] parameterTypes, Object[] arguments) {
        org.apache.dubbo.rpc.Invocation invocation = mock(org.apache.dubbo.rpc.Invocation.class);
        given(invocation.getMethodName()).willReturn(methodName);
        given(invocation.getParameterTypes()).willReturn(parameterTypes);
        given(invocation.getArguments()).willReturn(arguments);
        return invocation;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_38_8
#### Test Case Name: `testEcho`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\EchoFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
@@
 void testEcho() {
-    Invocation invocation = mock(RpcInvocation.class);
-    given(invocation.getMethodName()).willReturn("$echo");
-    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Enum.class });
-    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
-    given(invocation.getObjectAttachments()).willReturn(null);
+    Invocation invocation = MockInvocation.createMockInvocation("$echo", new Class<?>[] { Enum.class }, new Object[] { "hello" });
+    given(invocation.getObjectAttachments()).willReturn(null);
     Invoker<DemoService> invoker = mock(Invoker.class);
     given(invoker.isAvailable()).willReturn(true);
     given(invoker.getInterface()).willReturn(DemoService.class);
     AppResponse result = new AppResponse();
     result.setValue("High");
     given(invoker.invoke(invocation)).willReturn(result);
     URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
     given(invoker.getUrl()).willReturn(url);
     Result filterResult = echoFilter.invoke(invoker, invocation);
     assertEquals("hello", filterResult.getValue());
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("unchecked")
@Test
void testEcho() {
    Invocation invocation = mock(RpcInvocation.class);
    given(invocation.getMethodName()).willReturn("$echo");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Enum.class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
    given(invocation.getObjectAttachments()).willReturn(null);
    Invoker<DemoService> invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("High");
    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    Result filterResult = echoFilter.invoke(invoker, invocation);
    assertEquals("hello", filterResult.getValue());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvocation {
    public static org.apache.dubbo.rpc.Invocation createMockInvocation(String methodName, Class<?>[] parameterTypes, Object[] arguments) {
        org.apache.dubbo.rpc.Invocation invocation = mock(org.apache.dubbo.rpc.Invocation.class);
        given(invocation.getMethodName()).willReturn(methodName);
        given(invocation.getParameterTypes()).willReturn(parameterTypes);
        given(invocation.getArguments()).willReturn(arguments);
        return invocation;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_38_9
#### Test Case Name: `testNonEcho`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\EchoFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testNonEcho() {
-    Invocation invocation = mock(Invocation.class);
-    given(invocation.getMethodName()).willReturn("echo");
-    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Enum.class });
-    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
-    given(invocation.getObjectAttachments()).willReturn(null);
+    Invocation invocation = MockInvocation.createMockInvocation("echo", new Class<?>[] { Enum.class }, new Object[] { "hello" });
+    given(invocation.getObjectAttachments()).willReturn(null);
    Invoker<DemoService> invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("High");
    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    Result filterResult = echoFilter.invoke(invoker, invocation);
    assertEquals("High", filterResult.getValue());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("unchecked")
@Test
void testNonEcho() {
    Invocation invocation = mock(Invocation.class);
    given(invocation.getMethodName()).willReturn("echo");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Enum.class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
    given(invocation.getObjectAttachments()).willReturn(null);
    Invoker<DemoService> invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("High");
    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    Result filterResult = echoFilter.invoke(invoker, invocation);
    assertEquals("High", filterResult.getValue());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvocation {
    public static org.apache.dubbo.rpc.Invocation createMockInvocation(String methodName, Class<?>[] parameterTypes, Object[] arguments) {
        org.apache.dubbo.rpc.Invocation invocation = mock(org.apache.dubbo.rpc.Invocation.class);
        given(invocation.getMethodName()).willReturn(methodName);
        given(invocation.getParameterTypes()).willReturn(parameterTypes);
        given(invocation.getArguments()).willReturn(arguments);
        return invocation;
    }
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_39
- **Scope**: class level
- **Mocked Class**: `org.apache.dubbo.rpc.Invocation`
- **Test Case Count**: 6
- **MO Count**: 6

### Reusable Method
```java
public class MockInvocation {
    public static org.apache.dubbo.rpc.Invocation createMockInvocation(String methodNameReturn) {
        org.apache.dubbo.rpc.Invocation invocation = Mockito.mock(org.apache.dubbo.rpc.Invocation.class);
        when(invocation.getMethodName()).thenReturn(methodNameReturn);
        return invocation;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_39_1
#### Test Case Name: `testNoExecuteLimitInvoke`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\ExecuteLimitFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
@@
     when(invoker.getUrl()).thenReturn(URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1"));
-    Invocation invocation = Mockito.mock(Invocation.class);
-    when(invocation.getMethodName()).thenReturn("testNoExecuteLimitInvoke");
+    Invocation invocation = MockInvocation.createMockInvocation("testNoExecuteLimitInvoke");
     Result result = executeLimitFilter.invoke(invoker, invocation);
     Assertions.assertEquals("result", result.getValue());
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testNoExecuteLimitInvoke() {
    Invoker invoker = Mockito.mock(Invoker.class);
    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse("result"));
    when(invoker.getUrl()).thenReturn(URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1"));
    Invocation invocation = Mockito.mock(Invocation.class);
    when(invocation.getMethodName()).thenReturn("testNoExecuteLimitInvoke");
    Result result = executeLimitFilter.invoke(invoker, invocation);
    Assertions.assertEquals("result", result.getValue());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvocation {
    public static org.apache.dubbo.rpc.Invocation createMockInvocation(String methodNameReturn) {
        org.apache.dubbo.rpc.Invocation invocation = Mockito.mock(org.apache.dubbo.rpc.Invocation.class);
        when(invocation.getMethodName()).thenReturn(methodNameReturn);
        return invocation;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_39_2
#### Test Case Name: `testExecuteLimitInvoke`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\ExecuteLimitFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(invoker.getUrl()).thenReturn(URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&executes=10"));
-    Invocation invocation = Mockito.mock(Invocation.class);
-    when(invocation.getMethodName()).thenReturn("testExecuteLimitInvoke");
+    Invocation invocation = MockInvocation.createMockInvocation("testExecuteLimitInvoke");
    Result result = executeLimitFilter.invoke(invoker, invocation);
    Assertions.assertEquals("result", result.getValue());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testExecuteLimitInvoke() {
    Invoker invoker = Mockito.mock(Invoker.class);
    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse("result"));
    when(invoker.getUrl()).thenReturn(URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&executes=10"));
    Invocation invocation = Mockito.mock(Invocation.class);
    when(invocation.getMethodName()).thenReturn("testExecuteLimitInvoke");
    Result result = executeLimitFilter.invoke(invoker, invocation);
    Assertions.assertEquals("result", result.getValue());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvocation {
    public static org.apache.dubbo.rpc.Invocation createMockInvocation(String methodNameReturn) {
        org.apache.dubbo.rpc.Invocation invocation = Mockito.mock(org.apache.dubbo.rpc.Invocation.class);
        when(invocation.getMethodName()).thenReturn(methodNameReturn);
        return invocation;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_39_3
#### Test Case Name: `testExecuteLimitInvokeWithException`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\ExecuteLimitFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    URL url = URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&executes=10");
    when(invoker.getUrl()).thenReturn(url);
-    Invocation invocation = Mockito.mock(Invocation.class);
-    when(invocation.getMethodName()).thenReturn("testExecuteLimitInvokeWitException");
+    Invocation invocation = MockInvocation.createMockInvocation("testExecuteLimitInvokeWitException");
    try {
        executeLimitFilter.invoke(invoker, invocation);
    } catch (Exception e) {
        Assertions.assertTrue(e instanceof RpcException);
        executeLimitFilter.onError(e, invoker, invocation);
    }
    Assertions.assertEquals(1, RpcStatus.getStatus(url, invocation.getMethodName()).getFailed());
    RpcStatus.removeStatus(url, invocation.getMethodName());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testExecuteLimitInvokeWithException() {
    Invoker invoker = Mockito.mock(Invoker.class);
    doThrow(new RpcException()).when(invoker).invoke(any(Invocation.class));
    URL url = URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&executes=10");
    when(invoker.getUrl()).thenReturn(url);
    Invocation invocation = Mockito.mock(Invocation.class);
    when(invocation.getMethodName()).thenReturn("testExecuteLimitInvokeWitException");
    try {
        executeLimitFilter.invoke(invoker, invocation);
    } catch (Exception e) {
        Assertions.assertTrue(e instanceof RpcException);
        executeLimitFilter.onError(e, invoker, invocation);
    }
    Assertions.assertEquals(1, RpcStatus.getStatus(url, invocation.getMethodName()).getFailed());
    RpcStatus.removeStatus(url, invocation.getMethodName());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvocation {
    public static org.apache.dubbo.rpc.Invocation createMockInvocation(String methodNameReturn) {
        org.apache.dubbo.rpc.Invocation invocation = Mockito.mock(org.apache.dubbo.rpc.Invocation.class);
        when(invocation.getMethodName()).thenReturn(methodNameReturn);
        return invocation;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_39_4
#### Test Case Name: `testMoreThanExecuteLimitInvoke`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\ExecuteLimitFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    int maxExecute = 10;
    int totalExecute = 20;
    final AtomicInteger failed = new AtomicInteger(0);
-    final Invocation invocation = Mockito.mock(RpcInvocation.class);
-    when(invocation.getMethodName()).thenReturn("testMoreThanExecuteLimitInvoke");
+    final Invocation invocation = MockInvocation.createMockInvocation("testMoreThanExecuteLimitInvoke");
    URL url = URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&executes=" + maxExecute);
    final Invoker<ExecuteLimitFilter> invoker = new BlockMyInvoker<>(url, 1000);
    final CountDownLatch latchThatWaitsAllThreadStarted = new CountDownLatch(1);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testMoreThanExecuteLimitInvoke() {
    int maxExecute = 10;
    int totalExecute = 20;
    final AtomicInteger failed = new AtomicInteger(0);
    final Invocation invocation = Mockito.mock(RpcInvocation.class);
    when(invocation.getMethodName()).thenReturn("testMoreThanExecuteLimitInvoke");
    URL url = URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&executes=" + maxExecute);
    final Invoker<ExecuteLimitFilter> invoker = new BlockMyInvoker<>(url, 1000);
    final CountDownLatch latchThatWaitsAllThreadStarted = new CountDownLatch(1);
    final CountDownLatch latchThatWaitsAllThreadFinished = new CountDownLatch(totalExecute);
    for (int i = 0; i < totalExecute; i++) {
        Thread thread = new Thread(() -> {
            try {
                latchThatWaitsAllThreadStarted.await();
                executeLimitFilter.invoke(invoker, invocation);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (RpcException expected) {
                failed.incrementAndGet();
            } finally {
                latchThatWaitsAllThreadFinished.countDown();
            }
        });
        thread.start();
    }
    latchThatWaitsAllThreadStarted.countDown();
    try {
        latchThatWaitsAllThreadFinished.await();
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
    Assertions.assertEquals(totalExecute - maxExecute, failed.get());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvocation {
    public static org.apache.dubbo.rpc.Invocation createMockInvocation(String methodNameReturn) {
        org.apache.dubbo.rpc.Invocation invocation = Mockito.mock(org.apache.dubbo.rpc.Invocation.class);
        when(invocation.getMethodName()).thenReturn(methodNameReturn);
        return invocation;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_39_5
#### Test Case Name: `testInvokeWithoutTimeout`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\TimeoutFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(invoker.getUrl()).thenReturn(URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&timeout=" + timeout));
-    Invocation invocation = Mockito.mock(Invocation.class);
-    when(invocation.getMethodName()).thenReturn("testInvokeWithoutTimeout");
+    Invocation invocation = MockInvocation.createMockInvocation("testInvokeWithoutTimeout");
    Result result = timeoutFilter.invoke(invoker, invocation);
    Assertions.assertEquals("result", result.getValue());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testInvokeWithoutTimeout() {
    int timeout = 3000;
    Invoker invoker = Mockito.mock(Invoker.class);
    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse("result"));
    when(invoker.getUrl()).thenReturn(URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&timeout=" + timeout));
    Invocation invocation = Mockito.mock(Invocation.class);
    when(invocation.getMethodName()).thenReturn("testInvokeWithoutTimeout");
    Result result = timeoutFilter.invoke(invoker, invocation);
    Assertions.assertEquals("result", result.getValue());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvocation {
    public static org.apache.dubbo.rpc.Invocation createMockInvocation(String methodNameReturn) {
        org.apache.dubbo.rpc.Invocation invocation = Mockito.mock(org.apache.dubbo.rpc.Invocation.class);
        when(invocation.getMethodName()).thenReturn(methodNameReturn);
        return invocation;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_39_6
#### Test Case Name: `testInvokeWithTimeout`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\TimeoutFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
@@
    Invoker invoker = new BlockMyInvoker(url, (timeout + 100));
-    Invocation invocation = Mockito.mock(RpcInvocation.class);
-    when(invocation.getMethodName()).thenReturn("testInvokeWithTimeout");
+    Invocation invocation = MockInvocation.createMockInvocation("testInvokeWithTimeout");
    Result result = timeoutFilter.invoke(invoker, invocation);
    Assertions.assertEquals("Dubbo", result.getValue());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testInvokeWithTimeout() {
    int timeout = 100;
    URL url = URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&timeout=" + timeout);
    Invoker invoker = new BlockMyInvoker(url, (timeout + 100));
    Invocation invocation = Mockito.mock(RpcInvocation.class);
    when(invocation.getMethodName()).thenReturn("testInvokeWithTimeout");
    Result result = timeoutFilter.invoke(invoker, invocation);
    Assertions.assertEquals("Dubbo", result.getValue());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvocation {
    public static org.apache.dubbo.rpc.Invocation createMockInvocation(String methodNameReturn) {
        org.apache.dubbo.rpc.Invocation invocation = Mockito.mock(org.apache.dubbo.rpc.Invocation.class);
        when(invocation.getMethodName()).thenReturn(methodNameReturn);
        return invocation;
    }
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_40
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.Invocation`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static Invocation createMockInvocation(String requestSignature, String ak, String consumer, long requestTimestamp) {
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getObjectAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(requestSignature);
    when(invocation.getObjectAttachment(Constants.AK_KEY)).thenReturn(ak);
    when(invocation.getObjectAttachment(CommonConstants.CONSUMER)).thenReturn(consumer);
    when(invocation.getObjectAttachment(Constants.REQUEST_TIMESTAMP_KEY)).thenReturn(requestTimestamp);
    return invocation;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_40_1
#### Test Case Name: `testAuthFailedWhenNoAccessKeyPair`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-auth\src\test\java\org\apache\dubbo\auth\filter\ProviderAuthFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Invoker invoker = mock(Invoker.class);
-    Invocation invocation = mock(RpcInvocation.class);
-    when(invocation.getObjectAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn("dubbo");
-    when(invocation.getObjectAttachment(Constants.AK_KEY)).thenReturn("ak");
-    when(invocation.getObjectAttachment(CommonConstants.CONSUMER)).thenReturn("test-consumer");
-    when(invocation.getObjectAttachment(Constants.REQUEST_TIMESTAMP_KEY)).thenReturn(System.currentTimeMillis());
+    Invocation invocation = createMockInvocation(
+        "dubbo",
+        "ak",
+        "test-consumer",
+        System.currentTimeMillis()
+    );
    when(invoker.getUrl()).thenReturn(url);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    Result result = providerAuthFilter.invoke(invoker, invocation);
    assertTrue(result.hasException());
    assertTrue(result.getException() instanceof RpcAuthenticationException);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testAuthFailedWhenNoAccessKeyPair() {
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").addParameter(CommonConstants.APPLICATION_KEY, "test-provider").addParameter(Constants.SERVICE_AUTH, true);
    Invoker invoker = mock(Invoker.class);
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getObjectAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn("dubbo");
    when(invocation.getObjectAttachment(Constants.AK_KEY)).thenReturn("ak");
    when(invocation.getObjectAttachment(CommonConstants.CONSUMER)).thenReturn("test-consumer");
    when(invocation.getObjectAttachment(Constants.REQUEST_TIMESTAMP_KEY)).thenReturn(System.currentTimeMillis());
    when(invoker.getUrl()).thenReturn(url);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    Result result = providerAuthFilter.invoke(invoker, invocation);
    assertTrue(result.hasException());
    assertTrue(result.getException() instanceof RpcAuthenticationException);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invocation createMockInvocation(String requestSignature, String ak, String consumer, long requestTimestamp) {
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getObjectAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(requestSignature);
    when(invocation.getObjectAttachment(Constants.AK_KEY)).thenReturn(ak);
    when(invocation.getObjectAttachment(CommonConstants.CONSUMER)).thenReturn(consumer);
    when(invocation.getObjectAttachment(Constants.REQUEST_TIMESTAMP_KEY)).thenReturn(requestTimestamp);
    return invocation;
}
```
</details>

---
#### Test Case ID #dubbo_Test_40_2
#### Test Case Name: `testAuthFailedWhenParameterError`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-auth\src\test\java\org\apache\dubbo\auth\filter\ProviderAuthFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Invoker invoker = mock(Invoker.class);
-    Invocation invocation = mock(RpcInvocation.class);
-    when(invocation.getObjectAttachment(Constants.AK_KEY)).thenReturn("ak");
-    when(invocation.getObjectAttachment(CommonConstants.CONSUMER)).thenReturn("test-consumer");
-    when(invocation.getObjectAttachment(Constants.REQUEST_TIMESTAMP_KEY)).thenReturn(currentTimeMillis);
+    Invocation invocation = createMockInvocation(sign, "ak", "test-consumer", currentTimeMillis);
    when(invocation.getMethodName()).thenReturn(method);
    Object[] fakeParams = new Object[] { "dubbo1", "dubbo3" };
    when(invocation.getArguments()).thenReturn(fakeParams);
    when(invoker.getUrl()).thenReturn(url);
    String requestString = String.format(Constants.SIGNATURE_STRING_FORMAT, url.getColonSeparatedKey(), invocation.getMethodName(), "sk", currentTimeMillis);
    String sign = SignatureUtils.sign(originalParams, requestString, "sk");
-    when(invocation.getObjectAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(sign);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    Result result = providerAuthFilter.invoke(invoker, invocation);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testAuthFailedWhenParameterError() {
    String service = "org.apache.dubbo.DemoService";
    String method = "test";
    Object[] originalParams = new Object[] { "dubbo1", "dubbo2" };
    long currentTimeMillis = System.currentTimeMillis();
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").setServiceInterface(service).addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk").addParameter(CommonConstants.APPLICATION_KEY, "test-provider").addParameter(Constants.PARAMETER_SIGNATURE_ENABLE_KEY, true).addParameter(Constants.SERVICE_AUTH, true);
    Invoker invoker = mock(Invoker.class);
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getObjectAttachment(Constants.AK_KEY)).thenReturn("ak");
    when(invocation.getObjectAttachment(CommonConstants.CONSUMER)).thenReturn("test-consumer");
    when(invocation.getObjectAttachment(Constants.REQUEST_TIMESTAMP_KEY)).thenReturn(currentTimeMillis);
    when(invocation.getMethodName()).thenReturn(method);
    Object[] fakeParams = new Object[] { "dubbo1", "dubbo3" };
    when(invocation.getArguments()).thenReturn(fakeParams);
    when(invoker.getUrl()).thenReturn(url);
    String requestString = String.format(Constants.SIGNATURE_STRING_FORMAT, url.getColonSeparatedKey(), invocation.getMethodName(), "sk", currentTimeMillis);
    String sign = SignatureUtils.sign(originalParams, requestString, "sk");
    when(invocation.getObjectAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(sign);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    Result result = providerAuthFilter.invoke(invoker, invocation);
    assertTrue(result.hasException());
    assertTrue(result.getException() instanceof RpcAuthenticationException);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invocation createMockInvocation(String requestSignature, String ak, String consumer, long requestTimestamp) {
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getObjectAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(requestSignature);
    when(invocation.getObjectAttachment(Constants.AK_KEY)).thenReturn(ak);
    when(invocation.getObjectAttachment(CommonConstants.CONSUMER)).thenReturn(consumer);
    when(invocation.getObjectAttachment(Constants.REQUEST_TIMESTAMP_KEY)).thenReturn(requestTimestamp);
    return invocation;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_41
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.Invocation`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static Invocation createMockInvocation() {
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(null);
    return invocation;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_41_1
#### Test Case Name: `testAuthFailed`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-auth\src\test\java\org\apache\dubbo\auth\filter\ProviderAuthFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
@@
    Invoker invoker = mock(Invoker.class);
-    Invocation invocation = mock(RpcInvocation.class);
-    when(invocation.getAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(null);
+    Invocation invocation = createMockInvocation();
    when(invoker.getUrl()).thenReturn(url);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    Result result = providerAuthFilter.invoke(invoker, invocation);
    assertTrue(result.hasException());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testAuthFailed() {
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk").addParameter(CommonConstants.APPLICATION_KEY, "test").addParameter(Constants.SERVICE_AUTH, true);
    Invoker invoker = mock(Invoker.class);
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(null);
    when(invoker.getUrl()).thenReturn(url);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    Result result = providerAuthFilter.invoke(invoker, invocation);
    assertTrue(result.hasException());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invocation createMockInvocation() {
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(null);
    return invocation;
}
```
</details>

---
#### Test Case ID #dubbo_Test_41_2
#### Test Case Name: `testAuthFailedWhenNoSignature`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-auth\src\test\java\org\apache\dubbo\auth\filter\ProviderAuthFilterTest.java`)
#### Mock Object Variable Name: `invocation`
<summary>Suggested Diff</summary>

```diff
@@
    Invoker invoker = mock(Invoker.class);
-    Invocation invocation = mock(RpcInvocation.class);
-    when(invocation.getAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(null);
+    Invocation invocation = createMockInvocation();
    when(invoker.getUrl()).thenReturn(url);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    Result result = providerAuthFilter.invoke(invoker, invocation);
    assertTrue(result.hasException());
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testAuthFailedWhenNoSignature() {
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk").addParameter(CommonConstants.APPLICATION_KEY, "test").addParameter(Constants.SERVICE_AUTH, true);
    Invoker invoker = mock(Invoker.class);
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(null);
    when(invoker.getUrl()).thenReturn(url);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    Result result = providerAuthFilter.invoke(invoker, invocation);
    assertTrue(result.hasException());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invocation createMockInvocation() {
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(null);
    return invocation;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_42
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.Invoker`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static Invoker createMockInvoker(URL url) {
    Invoker invoker = mock(Invoker.class);
    given(invoker.getUrl()).willReturn(url);
    return invoker;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_42_1
#### Test Case Name: `testAvailable`(File: `C:\Java_projects\Apache\dubbo\dubbo-monitor\dubbo-monitor-default\src\test\java\org\apache\dubbo\monitor\dubbo\DubboMonitorTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testAvailable() {
-    Invoker invoker = mock(Invoker.class);
+    Invoker invoker = createMockInvoker(URL.valueOf("dubbo://127.0.0.1:7070?interval=20"));
    MonitorService monitorService = mock(MonitorService.class);
+    given(invoker.isAvailable()).willReturn(true);
    DubboMonitor dubboMonitor = new DubboMonitor(invoker, monitorService);
    assertThat(dubboMonitor.isAvailable(), is(true));
    verify(invoker).isAvailable();
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testAvailable() {
    Invoker invoker = mock(Invoker.class);
    MonitorService monitorService = mock(MonitorService.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getUrl()).willReturn(URL.valueOf("dubbo://127.0.0.1:7070?interval=20"));
    DubboMonitor dubboMonitor = new DubboMonitor(invoker, monitorService);
    assertThat(dubboMonitor.isAvailable(), is(true));
    verify(invoker).isAvailable();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker createMockInvoker(URL url) {
    Invoker invoker = mock(Invoker.class);
    given(invoker.getUrl()).willReturn(url);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_42_2
#### Test Case Name: `testSum`(File: `C:\Java_projects\Apache\dubbo\dubbo-monitor\dubbo-monitor-default\src\test\java\org\apache\dubbo\monitor\dubbo\DubboMonitorTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    URL statistics = new URLBuilder(DUBBO_PROTOCOL, "10.20.153.11", 0).addParameter(APPLICATION_KEY, "morgan").addParameter(INTERFACE_KEY, "MemberService").addParameter(METHOD_KEY, "findPerson").addParameter(CONSUMER, "10.20.153.11").addParameter(SUCCESS_KEY, 1).addParameter(FAILURE_KEY, 0).addParameter(ELAPSED_KEY, 3).addParameter(MAX_ELAPSED_KEY, 3).addParameter(CONCURRENT_KEY, 1).addParameter(MAX_CONCURRENT_KEY, 1).build();
-    Invoker invoker = mock(Invoker.class);
+    Invoker invoker = createMockInvoker(URL.valueOf("dubbo://127.0.0.1:7070?interval=20"));
    MonitorService monitorService = mock(MonitorService.class);
-    given(invoker.getUrl()).willReturn(URL.valueOf("dubbo://127.0.0.1:7070?interval=20"));
    DubboMonitor dubboMonitor = new DubboMonitor(invoker, monitorService);
    dubboMonitor.collect(statistics.toSerializableURL());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testSum() {
    URL statistics = new URLBuilder(DUBBO_PROTOCOL, "10.20.153.11", 0).addParameter(APPLICATION_KEY, "morgan").addParameter(INTERFACE_KEY, "MemberService").addParameter(METHOD_KEY, "findPerson").addParameter(CONSUMER, "10.20.153.11").addParameter(SUCCESS_KEY, 1).addParameter(FAILURE_KEY, 0).addParameter(ELAPSED_KEY, 3).addParameter(MAX_ELAPSED_KEY, 3).addParameter(CONCURRENT_KEY, 1).addParameter(MAX_CONCURRENT_KEY, 1).build();
    Invoker invoker = mock(Invoker.class);
    MonitorService monitorService = mock(MonitorService.class);
    given(invoker.getUrl()).willReturn(URL.valueOf("dubbo://127.0.0.1:7070?interval=20"));
    DubboMonitor dubboMonitor = new DubboMonitor(invoker, monitorService);
    dubboMonitor.collect(statistics.toSerializableURL());
    dubboMonitor.collect(statistics.addParameter(SUCCESS_KEY, 3).addParameter(CONCURRENT_KEY, 2).addParameter(INPUT_KEY, 1).addParameter(OUTPUT_KEY, 2).toSerializableURL());
    dubboMonitor.collect(statistics.addParameter(SUCCESS_KEY, 6).addParameter(ELAPSED_KEY, 2).toSerializableURL());
    dubboMonitor.send();
    ArgumentCaptor<URL> summaryCaptor = ArgumentCaptor.forClass(URL.class);
    verify(monitorService, atLeastOnce()).collect(summaryCaptor.capture());
    List<URL> allValues = summaryCaptor.getAllValues();
    assertThat(allValues, not(nullValue()));
    assertThat(allValues, hasItem(new CustomMatcher<URL>("Monitor count should greater than 1") {

        @Override
        public boolean matches(Object item) {
            URL url = (URL) item;
            return Integer.valueOf(url.getParameter(SUCCESS_KEY)) > 1;
        }
    }));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker createMockInvoker(URL url) {
    Invoker invoker = mock(Invoker.class);
    given(invoker.getUrl()).willReturn(url);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_42_3
#### Test Case Name: `testLookUp`(File: `C:\Java_projects\Apache\dubbo\dubbo-monitor\dubbo-monitor-default\src\test\java\org\apache\dubbo\monitor\dubbo\DubboMonitorTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 void testLookUp() {
-    Invoker invoker = mock(Invoker.class);
     MonitorService monitorService = mock(MonitorService.class);
     URL queryUrl = URL.valueOf("dubbo://127.0.0.1:7070?interval=20");
-    given(invoker.getUrl()).willReturn(queryUrl);
+    Invoker invoker = createMockInvoker(queryUrl);
     DubboMonitor dubboMonitor = new DubboMonitor(invoker, monitorService);
     dubboMonitor.lookup(queryUrl);
     verify(monitorService).lookup(queryUrl);
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testLookUp() {
    Invoker invoker = mock(Invoker.class);
    MonitorService monitorService = mock(MonitorService.class);
    URL queryUrl = URL.valueOf("dubbo://127.0.0.1:7070?interval=20");
    given(invoker.getUrl()).willReturn(queryUrl);
    DubboMonitor dubboMonitor = new DubboMonitor(invoker, monitorService);
    dubboMonitor.lookup(queryUrl);
    verify(monitorService).lookup(queryUrl);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker createMockInvoker(URL url) {
    Invoker invoker = mock(Invoker.class);
    given(invoker.getUrl()).willReturn(url);
    return invoker;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_43
- **Scope**: class level
- **Mocked Class**: `org.apache.dubbo.rpc.Invoker`
- **Test Case Count**: 7
- **MO Count**: 29

### Reusable Method
```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_43_1
#### Test Case Name: `testBasic`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker1`
<summary>Suggested Diff</summary>

```diff
--- a/TestClass.java
+++ b/TestClass.java
@@
 void testBasic() throws InterruptedException {
     Invocation invocation = new RpcInvocation();
     LoadBalance loadBalance = new RandomLoadBalance();
     Assertions.assertEquals(5, directory.list(invocation).size());
     Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
-    when(invoker1.isAvailable()).thenReturn(false);
+    invoker1 = MockInvoker.createMockInvoker(false);
     when(invoker2.isAvailable()).thenReturn(false);
     when(invoker3.isAvailable()).thenReturn(false);
     when(invoker4.isAvailable()).thenReturn(false);
     when(invoker5.isAvailable()).thenReturn(false);
     clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
     Assertions.assertEquals(0, directory.list(invocation).size());
-    when(invoker1.isAvailable()).thenReturn(true);
+    invoker1 = MockInvoker.createMockInvoker(true);
     Set<Invoker> invokerSet = new HashSet<>();
     invokerSet.add(invoker1);
     waitRefresh(invokerSet);
     Assertions.assertEquals(1, directory.list(invocation).size());
     Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testBasic() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    Assertions.assertEquals(5, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    when(invoker1.isAvailable()).thenReturn(false);
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    waitRefresh(invokerSet);
    Assertions.assertEquals(1, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    when(invoker2.isAvailable()).thenReturn(true);
    invokerSet.add(invoker2);
    waitRefresh(invokerSet);
    Assertions.assertEquals(2, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    invokerList.remove(invoker5);
    directory.notify(invokerList);
    when(invoker2.isAvailable()).thenReturn(true);
    waitRefresh(invokerSet);
    Assertions.assertEquals(2, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    waitRefresh(invokerSet);
    Assertions.assertEquals(4, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_2
#### Test Case Name: `testRetry`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker1`
<summary>Suggested Diff</summary>

```diff
--- Original.java
+++ Refactored.java
@@
     Assertions.assertEquals(2, directory.list(invocation).size());
-    when(invoker1.isAvailable()).thenReturn(false);
+    invoker1 = MockInvoker.createMockInvoker(false);
     Assertions.assertEquals(invoker2, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.singletonList(invoker2)));
     Assertions.assertEquals(1, directory.list(invocation).size());
-    when(invoker1.isAvailable()).thenReturn(true);
+    invoker1 = MockInvoker.createMockInvoker(true);
     Set<Invoker> invokerSet = new HashSet<>();
     invokerSet.add(invoker1);
     waitRefresh(invokerSet);
     Assertions.assertEquals(2, directory.list(invocation).size());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testRetry() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    invokerList.clear();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    directory.notify(invokerList);
    Assertions.assertEquals(2, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(false);
    Assertions.assertEquals(invoker2, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.singletonList(invoker2)));
    Assertions.assertEquals(1, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    waitRefresh(invokerSet);
    Assertions.assertEquals(2, directory.list(invocation).size());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_3
#### Test Case Name: `testRandomSelect`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker1`
<summary>Suggested Diff</summary>

```diff
@@
+ // Cannot refactor this mock: The reusable helper does not cover all configuration (configInvoker(invoker1)) applied in @BeforeEach; using it would skip important setup and break test behavior.
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testRandomSelect() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    invokerList.add(invoker6);
    invokerList.add(invoker7);
    invokerList.add(invoker8);
    invokerList.add(invoker9);
    invokerList.add(invoker10);
    invokerList.add(invoker11);
    invokerList.add(invoker12);
    invokerList.add(invoker13);
    invokerList.add(invoker14);
    invokerList.add(invoker15);
    directory.notify(invokerList);
    Assertions.assertEquals(15, directory.list(invocation).size());
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    when(invoker6.isAvailable()).thenReturn(false);
    when(invoker7.isAvailable()).thenReturn(false);
    when(invoker8.isAvailable()).thenReturn(false);
    when(invoker9.isAvailable()).thenReturn(false);
    when(invoker10.isAvailable()).thenReturn(false);
    when(invoker11.isAvailable()).thenReturn(false);
    when(invoker12.isAvailable()).thenReturn(false);
    when(invoker13.isAvailable()).thenReturn(false);
    when(invoker14.isAvailable()).thenReturn(false);
    when(invoker15.isAvailable()).thenReturn(false);
    for (int i = 0; i < 15; i++) {
        clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    }
    for (int i = 0; i < 5; i++) {
        Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    }
    when(invoker1.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    when(invoker2.isAvailable()).thenReturn(true);
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    when(invoker5.isAvailable()).thenReturn(true);
    when(invoker6.isAvailable()).thenReturn(true);
    when(invoker7.isAvailable()).thenReturn(true);
    when(invoker8.isAvailable()).thenReturn(true);
    when(invoker9.isAvailable()).thenReturn(true);
    when(invoker10.isAvailable()).thenReturn(true);
    when(invoker11.isAvailable()).thenReturn(true);
    when(invoker12.isAvailable()).thenReturn(true);
    when(invoker13.isAvailable()).thenReturn(true);
    when(invoker14.isAvailable()).thenReturn(true);
    when(invoker15.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    invokerSet.add(invoker2);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    invokerSet.add(invoker5);
    invokerSet.add(invoker6);
    invokerSet.add(invoker7);
    invokerSet.add(invoker8);
    invokerSet.add(invoker9);
    invokerSet.add(invoker10);
    invokerSet.add(invoker11);
    invokerSet.add(invoker12);
    invokerSet.add(invoker13);
    invokerSet.add(invoker14);
    invokerSet.add(invoker15);
    waitRefresh(invokerSet);
    Assertions.assertTrue(directory.list(invocation).size() > 1);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_4
#### Test Case Name: `testBasic`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker2`
<summary>Suggested Diff</summary>

```diff
@@
+ // Cannot refactor this mock: The helper method only stubs isAvailable(), but in @BeforeEach, configInvoker(invoker2) is called, which may apply additional stubbing or configuration. Replacing the mock creation and stubbing with the helper would skip configInvoker(invoker2), potentially breaking test setup or other tests. Thus, refactoring with the provided helper is unsafe.
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testBasic() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    Assertions.assertEquals(5, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    when(invoker1.isAvailable()).thenReturn(false);
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    waitRefresh(invokerSet);
    Assertions.assertEquals(1, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    when(invoker2.isAvailable()).thenReturn(true);
    invokerSet.add(invoker2);
    waitRefresh(invokerSet);
    Assertions.assertEquals(2, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    invokerList.remove(invoker5);
    directory.notify(invokerList);
    when(invoker2.isAvailable()).thenReturn(true);
    waitRefresh(invokerSet);
    Assertions.assertEquals(2, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    waitRefresh(invokerSet);
    Assertions.assertEquals(4, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_5
#### Test Case Name: `testRandomSelect`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker2`
<summary>Suggested Diff</summary>

```diff
@@
+ // Cannot refactor this mock: The reusable helper cannot express the sequence of stubbing invoker2.isAvailable() to false and then to true in the same test method.
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testRandomSelect() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    invokerList.add(invoker6);
    invokerList.add(invoker7);
    invokerList.add(invoker8);
    invokerList.add(invoker9);
    invokerList.add(invoker10);
    invokerList.add(invoker11);
    invokerList.add(invoker12);
    invokerList.add(invoker13);
    invokerList.add(invoker14);
    invokerList.add(invoker15);
    directory.notify(invokerList);
    Assertions.assertEquals(15, directory.list(invocation).size());
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    when(invoker6.isAvailable()).thenReturn(false);
    when(invoker7.isAvailable()).thenReturn(false);
    when(invoker8.isAvailable()).thenReturn(false);
    when(invoker9.isAvailable()).thenReturn(false);
    when(invoker10.isAvailable()).thenReturn(false);
    when(invoker11.isAvailable()).thenReturn(false);
    when(invoker12.isAvailable()).thenReturn(false);
    when(invoker13.isAvailable()).thenReturn(false);
    when(invoker14.isAvailable()).thenReturn(false);
    when(invoker15.isAvailable()).thenReturn(false);
    for (int i = 0; i < 15; i++) {
        clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    }
    for (int i = 0; i < 5; i++) {
        Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    }
    when(invoker1.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    when(invoker2.isAvailable()).thenReturn(true);
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    when(invoker5.isAvailable()).thenReturn(true);
    when(invoker6.isAvailable()).thenReturn(true);
    when(invoker7.isAvailable()).thenReturn(true);
    when(invoker8.isAvailable()).thenReturn(true);
    when(invoker9.isAvailable()).thenReturn(true);
    when(invoker10.isAvailable()).thenReturn(true);
    when(invoker11.isAvailable()).thenReturn(true);
    when(invoker12.isAvailable()).thenReturn(true);
    when(invoker13.isAvailable()).thenReturn(true);
    when(invoker14.isAvailable()).thenReturn(true);
    when(invoker15.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    invokerSet.add(invoker2);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    invokerSet.add(invoker5);
    invokerSet.add(invoker6);
    invokerSet.add(invoker7);
    invokerSet.add(invoker8);
    invokerSet.add(invoker9);
    invokerSet.add(invoker10);
    invokerSet.add(invoker11);
    invokerSet.add(invoker12);
    invokerSet.add(invoker13);
    invokerSet.add(invoker14);
    invokerSet.add(invoker15);
    waitRefresh(invokerSet);
    Assertions.assertTrue(directory.list(invocation).size() > 1);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_6
#### Test Case Name: `testBasic`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker3`
<summary>Suggested Diff</summary>

```diff
@@
     when(invoker2.isAvailable()).thenReturn(false);
-    when(invoker3.isAvailable()).thenReturn(false);
+    invoker3 = MockInvoker.createMockInvoker(false);
     when(invoker4.isAvailable()).thenReturn(false);
     when(invoker5.isAvailable()).thenReturn(false);
     clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
     Assertions.assertEquals(0, directory.list(invocation).size());
     when(invoker1.isAvailable()).thenReturn(true);
     Set<Invoker> invokerSet = new HashSet<>();
     invokerSet.add(invoker1);
     waitRefresh(invokerSet);
     Assertions.assertEquals(1, directory.list(invocation).size());
     Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
     when(invoker2.isAvailable()).thenReturn(true);
     invokerSet.add(invoker2);
     waitRefresh(invokerSet);
     Assertions.assertEquals(2, directory.list(invocation).size());
     Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
     invokerList.remove(invoker5);
     directory.notify(invokerList);
     when(invoker2.isAvailable()).thenReturn(true);
     waitRefresh(invokerSet);
     Assertions.assertEquals(2, directory.list(invocation).size());
     Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
-    when(invoker3.isAvailable()).thenReturn(true);
+    invoker3 = MockInvoker.createMockInvoker(true);
     when(invoker4.isAvailable()).thenReturn(true);
     invokerSet.add(invoker3);
     invokerSet.add(invoker4);
     waitRefresh(invokerSet);
     Assertions.assertEquals(4, directory.list(invocation).size());
     Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testBasic() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    Assertions.assertEquals(5, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    when(invoker1.isAvailable()).thenReturn(false);
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    waitRefresh(invokerSet);
    Assertions.assertEquals(1, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    when(invoker2.isAvailable()).thenReturn(true);
    invokerSet.add(invoker2);
    waitRefresh(invokerSet);
    Assertions.assertEquals(2, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    invokerList.remove(invoker5);
    directory.notify(invokerList);
    when(invoker2.isAvailable()).thenReturn(true);
    waitRefresh(invokerSet);
    Assertions.assertEquals(2, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    waitRefresh(invokerSet);
    Assertions.assertEquals(4, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_7
#### Test Case Name: `testRandomSelect`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker3`
<summary>Suggested Diff</summary>

```diff
@@
     when(invoker2.isAvailable()).thenReturn(false);
-    when(invoker3.isAvailable()).thenReturn(false);
+    invoker3 = MockInvoker.createMockInvoker(false);
     when(invoker4.isAvailable()).thenReturn(false);
     when(invoker5.isAvailable()).thenReturn(false);
@@
     when(invoker1.isAvailable()).thenReturn(true);
     when(invoker2.isAvailable()).thenReturn(true);
-    when(invoker3.isAvailable()).thenReturn(true);
+    invoker3 = MockInvoker.createMockInvoker(true);
     when(invoker4.isAvailable()).thenReturn(true);
     when(invoker5.isAvailable()).thenReturn(true);
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testRandomSelect() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    invokerList.add(invoker6);
    invokerList.add(invoker7);
    invokerList.add(invoker8);
    invokerList.add(invoker9);
    invokerList.add(invoker10);
    invokerList.add(invoker11);
    invokerList.add(invoker12);
    invokerList.add(invoker13);
    invokerList.add(invoker14);
    invokerList.add(invoker15);
    directory.notify(invokerList);
    Assertions.assertEquals(15, directory.list(invocation).size());
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    when(invoker6.isAvailable()).thenReturn(false);
    when(invoker7.isAvailable()).thenReturn(false);
    when(invoker8.isAvailable()).thenReturn(false);
    when(invoker9.isAvailable()).thenReturn(false);
    when(invoker10.isAvailable()).thenReturn(false);
    when(invoker11.isAvailable()).thenReturn(false);
    when(invoker12.isAvailable()).thenReturn(false);
    when(invoker13.isAvailable()).thenReturn(false);
    when(invoker14.isAvailable()).thenReturn(false);
    when(invoker15.isAvailable()).thenReturn(false);
    for (int i = 0; i < 15; i++) {
        clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    }
    for (int i = 0; i < 5; i++) {
        Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    }
    when(invoker1.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    when(invoker2.isAvailable()).thenReturn(true);
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    when(invoker5.isAvailable()).thenReturn(true);
    when(invoker6.isAvailable()).thenReturn(true);
    when(invoker7.isAvailable()).thenReturn(true);
    when(invoker8.isAvailable()).thenReturn(true);
    when(invoker9.isAvailable()).thenReturn(true);
    when(invoker10.isAvailable()).thenReturn(true);
    when(invoker11.isAvailable()).thenReturn(true);
    when(invoker12.isAvailable()).thenReturn(true);
    when(invoker13.isAvailable()).thenReturn(true);
    when(invoker14.isAvailable()).thenReturn(true);
    when(invoker15.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    invokerSet.add(invoker2);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    invokerSet.add(invoker5);
    invokerSet.add(invoker6);
    invokerSet.add(invoker7);
    invokerSet.add(invoker8);
    invokerSet.add(invoker9);
    invokerSet.add(invoker10);
    invokerSet.add(invoker11);
    invokerSet.add(invoker12);
    invokerSet.add(invoker13);
    invokerSet.add(invoker14);
    invokerSet.add(invoker15);
    waitRefresh(invokerSet);
    Assertions.assertTrue(directory.list(invocation).size() > 1);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_8
#### Test Case Name: `testBasic`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker4`
<summary>Suggested Diff</summary>

```diff
--- Original
+++ Refactored
@@
     when(invoker3.isAvailable()).thenReturn(true);
-    when(invoker4.isAvailable()).thenReturn(true);
+    invoker4 = MockInvoker.createMockInvoker(true);
     invokerSet.add(invoker3);
     invokerSet.add(invoker4);
     waitRefresh(invokerSet);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testBasic() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    Assertions.assertEquals(5, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    when(invoker1.isAvailable()).thenReturn(false);
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    waitRefresh(invokerSet);
    Assertions.assertEquals(1, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    when(invoker2.isAvailable()).thenReturn(true);
    invokerSet.add(invoker2);
    waitRefresh(invokerSet);
    Assertions.assertEquals(2, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    invokerList.remove(invoker5);
    directory.notify(invokerList);
    when(invoker2.isAvailable()).thenReturn(true);
    waitRefresh(invokerSet);
    Assertions.assertEquals(2, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    waitRefresh(invokerSet);
    Assertions.assertEquals(4, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_9
#### Test Case Name: `testRandomSelect`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker4`
<summary>Suggested Diff</summary>

```diff
--- a/TestClass.java
+++ b/TestClass.java
@@
     when(invoker2.isAvailable()).thenReturn(false);
     when(invoker3.isAvailable()).thenReturn(false);
-    when(invoker4.isAvailable()).thenReturn(false);
+    invoker4 = MockInvoker.createMockInvoker(false);
     when(invoker5.isAvailable()).thenReturn(false);
     when(invoker6.isAvailable()).thenReturn(false);
     when(invoker7.isAvailable()).thenReturn(false);
     when(invoker8.isAvailable()).thenReturn(false);
     when(invoker9.isAvailable()).thenReturn(false);
     when(invoker10.isAvailable()).thenReturn(false);
     when(invoker11.isAvailable()).thenReturn(false);
     when(invoker12.isAvailable()).thenReturn(false);
     when(invoker13.isAvailable()).thenReturn(false);
     when(invoker14.isAvailable()).thenReturn(false);
     when(invoker15.isAvailable()).thenReturn(false);
     for (int i = 0; i < 15; i++) {
         clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
     }
     for (int i = 0; i < 5; i++) {
         Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
     }
     when(invoker1.isAvailable()).thenReturn(false);
     clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
     Assertions.assertEquals(0, directory.list(invocation).size());
-    when(invoker1.isAvailable()).thenReturn(true);
-    when(invoker2.isAvailable()).thenReturn(true);
-    when(invoker3.isAvailable()).thenReturn(true);
-    when(invoker4.isAvailable()).thenReturn(true);
-    when(invoker5.isAvailable()).thenReturn(true);
-    when(invoker6.isAvailable()).thenReturn(true);
-    when(invoker7.isAvailable()).thenReturn(true);
-    when(invoker8.isAvailable()).thenReturn(true);
-    when(invoker9.isAvailable()).thenReturn(true);
-    when(invoker10.isAvailable()).thenReturn(true);
-    when(invoker11.isAvailable()).thenReturn(true);
-    when(invoker12.isAvailable()).thenReturn(true);
-    when(invoker13.isAvailable()).thenReturn(true);
-    when(invoker14.isAvailable()).thenReturn(true);
-    when(invoker15.isAvailable()).thenReturn(true);
+    when(invoker1.isAvailable()).thenReturn(true);
+    when(invoker2.isAvailable()).thenReturn(true);
+    when(invoker3.isAvailable()).thenReturn(true);
+    invoker4 = MockInvoker.createMockInvoker(true);
+    when(invoker5.isAvailable()).thenReturn(true);
+    when(invoker6.isAvailable()).thenReturn(true);
+    when(invoker7.isAvailable()).thenReturn(true);
+    when(invoker8.isAvailable()).thenReturn(true);
+    when(invoker9.isAvailable()).thenReturn(true);
+    when(invoker10.isAvailable()).thenReturn(true);
+    when(invoker11.isAvailable()).thenReturn(true);
+    when(invoker12.isAvailable()).thenReturn(true);
+    when(invoker13.isAvailable()).thenReturn(true);
+    when(invoker14.isAvailable()).thenReturn(true);
+    when(invoker15.isAvailable()).thenReturn(true);
     Set<Invoker> invokerSet = new HashSet<>();
     invokerSet.add(invoker1);
     invokerSet.add(invoker2);
     invokerSet.add(invoker3);
     invokerSet.add(invoker4);
     invokerSet.add(invoker5);
     invokerSet.add(invoker6);
     invokerSet.add(invoker7);
     invokerSet.add(invoker8);
     invokerSet.add(invoker9);
     invokerSet.add(invoker10);
     invokerSet.add(invoker11);
     invokerSet.add(invoker12);
     invokerSet.add(invoker13);
     invokerSet.add(invoker14);
     invokerSet.add(invoker15);
     waitRefresh(invokerSet);
     Assertions.assertTrue(directory.list(invocation).size() > 1);
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testRandomSelect() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    invokerList.add(invoker6);
    invokerList.add(invoker7);
    invokerList.add(invoker8);
    invokerList.add(invoker9);
    invokerList.add(invoker10);
    invokerList.add(invoker11);
    invokerList.add(invoker12);
    invokerList.add(invoker13);
    invokerList.add(invoker14);
    invokerList.add(invoker15);
    directory.notify(invokerList);
    Assertions.assertEquals(15, directory.list(invocation).size());
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    when(invoker6.isAvailable()).thenReturn(false);
    when(invoker7.isAvailable()).thenReturn(false);
    when(invoker8.isAvailable()).thenReturn(false);
    when(invoker9.isAvailable()).thenReturn(false);
    when(invoker10.isAvailable()).thenReturn(false);
    when(invoker11.isAvailable()).thenReturn(false);
    when(invoker12.isAvailable()).thenReturn(false);
    when(invoker13.isAvailable()).thenReturn(false);
    when(invoker14.isAvailable()).thenReturn(false);
    when(invoker15.isAvailable()).thenReturn(false);
    for (int i = 0; i < 15; i++) {
        clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    }
    for (int i = 0; i < 5; i++) {
        Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    }
    when(invoker1.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    when(invoker2.isAvailable()).thenReturn(true);
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    when(invoker5.isAvailable()).thenReturn(true);
    when(invoker6.isAvailable()).thenReturn(true);
    when(invoker7.isAvailable()).thenReturn(true);
    when(invoker8.isAvailable()).thenReturn(true);
    when(invoker9.isAvailable()).thenReturn(true);
    when(invoker10.isAvailable()).thenReturn(true);
    when(invoker11.isAvailable()).thenReturn(true);
    when(invoker12.isAvailable()).thenReturn(true);
    when(invoker13.isAvailable()).thenReturn(true);
    when(invoker14.isAvailable()).thenReturn(true);
    when(invoker15.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    invokerSet.add(invoker2);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    invokerSet.add(invoker5);
    invokerSet.add(invoker6);
    invokerSet.add(invoker7);
    invokerSet.add(invoker8);
    invokerSet.add(invoker9);
    invokerSet.add(invoker10);
    invokerSet.add(invoker11);
    invokerSet.add(invoker12);
    invokerSet.add(invoker13);
    invokerSet.add(invoker14);
    invokerSet.add(invoker15);
    waitRefresh(invokerSet);
    Assertions.assertTrue(directory.list(invocation).size() > 1);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_10
#### Test Case Name: `testBasic`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker5`
<summary>Suggested Diff</summary>

```diff
+ // Cannot refactor this mock: The reusable helper creates a new mock instance, but the test relies on the original mock instance being present in invokerList and directory. Replacing it would break references and test logic.
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testBasic() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    Assertions.assertEquals(5, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    when(invoker1.isAvailable()).thenReturn(false);
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    waitRefresh(invokerSet);
    Assertions.assertEquals(1, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    when(invoker2.isAvailable()).thenReturn(true);
    invokerSet.add(invoker2);
    waitRefresh(invokerSet);
    Assertions.assertEquals(2, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    invokerList.remove(invoker5);
    directory.notify(invokerList);
    when(invoker2.isAvailable()).thenReturn(true);
    waitRefresh(invokerSet);
    Assertions.assertEquals(2, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    waitRefresh(invokerSet);
    Assertions.assertEquals(4, directory.list(invocation).size());
    Assertions.assertNotNull(clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_11
#### Test Case Name: `testRandomSelect`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker5`
<summary>Suggested Diff</summary>

```diff
@@
     when(invoker3.isAvailable()).thenReturn(false);
     when(invoker4.isAvailable()).thenReturn(false);
-    when(invoker5.isAvailable()).thenReturn(false);
+    invoker5 = MockInvoker.createMockInvoker(false);
     when(invoker6.isAvailable()).thenReturn(false);
     when(invoker7.isAvailable()).thenReturn(false);
@@
     when(invoker3.isAvailable()).thenReturn(true);
     when(invoker4.isAvailable()).thenReturn(true);
-    when(invoker5.isAvailable()).thenReturn(true);
+    invoker5 = MockInvoker.createMockInvoker(true);
     when(invoker6.isAvailable()).thenReturn(true);
     when(invoker7.isAvailable()).thenReturn(true);
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testRandomSelect() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    invokerList.add(invoker6);
    invokerList.add(invoker7);
    invokerList.add(invoker8);
    invokerList.add(invoker9);
    invokerList.add(invoker10);
    invokerList.add(invoker11);
    invokerList.add(invoker12);
    invokerList.add(invoker13);
    invokerList.add(invoker14);
    invokerList.add(invoker15);
    directory.notify(invokerList);
    Assertions.assertEquals(15, directory.list(invocation).size());
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    when(invoker6.isAvailable()).thenReturn(false);
    when(invoker7.isAvailable()).thenReturn(false);
    when(invoker8.isAvailable()).thenReturn(false);
    when(invoker9.isAvailable()).thenReturn(false);
    when(invoker10.isAvailable()).thenReturn(false);
    when(invoker11.isAvailable()).thenReturn(false);
    when(invoker12.isAvailable()).thenReturn(false);
    when(invoker13.isAvailable()).thenReturn(false);
    when(invoker14.isAvailable()).thenReturn(false);
    when(invoker15.isAvailable()).thenReturn(false);
    for (int i = 0; i < 15; i++) {
        clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    }
    for (int i = 0; i < 5; i++) {
        Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    }
    when(invoker1.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    when(invoker2.isAvailable()).thenReturn(true);
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    when(invoker5.isAvailable()).thenReturn(true);
    when(invoker6.isAvailable()).thenReturn(true);
    when(invoker7.isAvailable()).thenReturn(true);
    when(invoker8.isAvailable()).thenReturn(true);
    when(invoker9.isAvailable()).thenReturn(true);
    when(invoker10.isAvailable()).thenReturn(true);
    when(invoker11.isAvailable()).thenReturn(true);
    when(invoker12.isAvailable()).thenReturn(true);
    when(invoker13.isAvailable()).thenReturn(true);
    when(invoker14.isAvailable()).thenReturn(true);
    when(invoker15.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    invokerSet.add(invoker2);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    invokerSet.add(invoker5);
    invokerSet.add(invoker6);
    invokerSet.add(invoker7);
    invokerSet.add(invoker8);
    invokerSet.add(invoker9);
    invokerSet.add(invoker10);
    invokerSet.add(invoker11);
    invokerSet.add(invoker12);
    invokerSet.add(invoker13);
    invokerSet.add(invoker14);
    invokerSet.add(invoker15);
    waitRefresh(invokerSet);
    Assertions.assertTrue(directory.list(invocation).size() > 1);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_12
#### Test Case Name: `testRandomSelect`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker6`
<summary>Suggested Diff</summary>

```diff
@@
     when(invoker5.isAvailable()).thenReturn(false);
-    when(invoker6.isAvailable()).thenReturn(false);
+    invoker6 = MockInvoker.createMockInvoker(false);
     when(invoker7.isAvailable()).thenReturn(false);
     when(invoker8.isAvailable()).thenReturn(false);
@@
     when(invoker5.isAvailable()).thenReturn(true);
-    when(invoker6.isAvailable()).thenReturn(true);
+    invoker6 = MockInvoker.createMockInvoker(true);
     when(invoker7.isAvailable()).thenReturn(true);
     when(invoker8.isAvailable()).thenReturn(true);
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testRandomSelect() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    invokerList.add(invoker6);
    invokerList.add(invoker7);
    invokerList.add(invoker8);
    invokerList.add(invoker9);
    invokerList.add(invoker10);
    invokerList.add(invoker11);
    invokerList.add(invoker12);
    invokerList.add(invoker13);
    invokerList.add(invoker14);
    invokerList.add(invoker15);
    directory.notify(invokerList);
    Assertions.assertEquals(15, directory.list(invocation).size());
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    when(invoker6.isAvailable()).thenReturn(false);
    when(invoker7.isAvailable()).thenReturn(false);
    when(invoker8.isAvailable()).thenReturn(false);
    when(invoker9.isAvailable()).thenReturn(false);
    when(invoker10.isAvailable()).thenReturn(false);
    when(invoker11.isAvailable()).thenReturn(false);
    when(invoker12.isAvailable()).thenReturn(false);
    when(invoker13.isAvailable()).thenReturn(false);
    when(invoker14.isAvailable()).thenReturn(false);
    when(invoker15.isAvailable()).thenReturn(false);
    for (int i = 0; i < 15; i++) {
        clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    }
    for (int i = 0; i < 5; i++) {
        Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    }
    when(invoker1.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    when(invoker2.isAvailable()).thenReturn(true);
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    when(invoker5.isAvailable()).thenReturn(true);
    when(invoker6.isAvailable()).thenReturn(true);
    when(invoker7.isAvailable()).thenReturn(true);
    when(invoker8.isAvailable()).thenReturn(true);
    when(invoker9.isAvailable()).thenReturn(true);
    when(invoker10.isAvailable()).thenReturn(true);
    when(invoker11.isAvailable()).thenReturn(true);
    when(invoker12.isAvailable()).thenReturn(true);
    when(invoker13.isAvailable()).thenReturn(true);
    when(invoker14.isAvailable()).thenReturn(true);
    when(invoker15.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    invokerSet.add(invoker2);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    invokerSet.add(invoker5);
    invokerSet.add(invoker6);
    invokerSet.add(invoker7);
    invokerSet.add(invoker8);
    invokerSet.add(invoker9);
    invokerSet.add(invoker10);
    invokerSet.add(invoker11);
    invokerSet.add(invoker12);
    invokerSet.add(invoker13);
    invokerSet.add(invoker14);
    invokerSet.add(invoker15);
    waitRefresh(invokerSet);
    Assertions.assertTrue(directory.list(invocation).size() > 1);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_13
#### Test Case Name: `testRandomSelect`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker7`
<summary>Suggested Diff</summary>

```diff
@@
     invoker6 = Mockito.mock(Invoker.class);
-    invoker7 = Mockito.mock(Invoker.class);
+    // invoker7 will be initialized in test method as needed
     invoker8 = Mockito.mock(Invoker.class);
     invoker9 = Mockito.mock(Invoker.class);
@@
     configInvoker(invoker6);
-    configInvoker(invoker7);
+    // configInvoker(invoker7) will be called after mock creation in test method
     configInvoker(invoker8);
     configInvoker(invoker9);
@@
    when(invoker5.isAvailable()).thenReturn(false);
    when(invoker6.isAvailable()).thenReturn(false);
-    when(invoker7.isAvailable()).thenReturn(false);
+    invoker7 = MockInvoker.createMockInvoker(false);
+    configInvoker(invoker7);
    when(invoker8.isAvailable()).thenReturn(false);
    when(invoker9.isAvailable()).thenReturn(false);
@@
    when(invoker6.isAvailable()).thenReturn(true);
-    when(invoker7.isAvailable()).thenReturn(true);
+    invoker7 = MockInvoker.createMockInvoker(true);
+    configInvoker(invoker7);
    when(invoker8.isAvailable()).thenReturn(true);
    when(invoker9.isAvailable()).thenReturn(true);
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testRandomSelect() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    invokerList.add(invoker6);
    invokerList.add(invoker7);
    invokerList.add(invoker8);
    invokerList.add(invoker9);
    invokerList.add(invoker10);
    invokerList.add(invoker11);
    invokerList.add(invoker12);
    invokerList.add(invoker13);
    invokerList.add(invoker14);
    invokerList.add(invoker15);
    directory.notify(invokerList);
    Assertions.assertEquals(15, directory.list(invocation).size());
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    when(invoker6.isAvailable()).thenReturn(false);
    when(invoker7.isAvailable()).thenReturn(false);
    when(invoker8.isAvailable()).thenReturn(false);
    when(invoker9.isAvailable()).thenReturn(false);
    when(invoker10.isAvailable()).thenReturn(false);
    when(invoker11.isAvailable()).thenReturn(false);
    when(invoker12.isAvailable()).thenReturn(false);
    when(invoker13.isAvailable()).thenReturn(false);
    when(invoker14.isAvailable()).thenReturn(false);
    when(invoker15.isAvailable()).thenReturn(false);
    for (int i = 0; i < 15; i++) {
        clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    }
    for (int i = 0; i < 5; i++) {
        Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    }
    when(invoker1.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    when(invoker2.isAvailable()).thenReturn(true);
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    when(invoker5.isAvailable()).thenReturn(true);
    when(invoker6.isAvailable()).thenReturn(true);
    when(invoker7.isAvailable()).thenReturn(true);
    when(invoker8.isAvailable()).thenReturn(true);
    when(invoker9.isAvailable()).thenReturn(true);
    when(invoker10.isAvailable()).thenReturn(true);
    when(invoker11.isAvailable()).thenReturn(true);
    when(invoker12.isAvailable()).thenReturn(true);
    when(invoker13.isAvailable()).thenReturn(true);
    when(invoker14.isAvailable()).thenReturn(true);
    when(invoker15.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    invokerSet.add(invoker2);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    invokerSet.add(invoker5);
    invokerSet.add(invoker6);
    invokerSet.add(invoker7);
    invokerSet.add(invoker8);
    invokerSet.add(invoker9);
    invokerSet.add(invoker10);
    invokerSet.add(invoker11);
    invokerSet.add(invoker12);
    invokerSet.add(invoker13);
    invokerSet.add(invoker14);
    invokerSet.add(invoker15);
    waitRefresh(invokerSet);
    Assertions.assertTrue(directory.list(invocation).size() > 1);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_14
#### Test Case Name: `testRandomSelect`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker8`
<summary>Suggested Diff</summary>

```diff
--- a/TestClass.java
+++ b/TestClass.java
@@
-    invoker8 = Mockito.mock(Invoker.class);
+    // invoker8 will be created in the test method using MockInvoker.createMockInvoker
     invoker9 = Mockito.mock(Invoker.class);
@@
-    configInvoker(invoker8);
+    // configInvoker(invoker8) will be handled in the test method after mock creation
     configInvoker(invoker9);
@@
     invokerList.add(invoker6);
     invokerList.add(invoker7);
-    invokerList.add(invoker8);
+    invoker8 = MockInvoker.createMockInvoker(false);
+    configInvoker(invoker8);
+    invokerList.add(invoker8);
     invokerList.add(invoker9);
     invokerList.add(invoker10);
@@
-    when(invoker8.isAvailable()).thenReturn(false);
@@
     when(invoker7.isAvailable()).thenReturn(false);
-    when(invoker8.isAvailable()).thenReturn(false);
     when(invoker9.isAvailable()).thenReturn(false);
@@
     when(invoker7.isAvailable()).thenReturn(true);
-    when(invoker8.isAvailable()).thenReturn(true);
+    invoker8 = MockInvoker.createMockInvoker(true);
+    configInvoker(invoker8);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testRandomSelect() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    invokerList.add(invoker6);
    invokerList.add(invoker7);
    invokerList.add(invoker8);
    invokerList.add(invoker9);
    invokerList.add(invoker10);
    invokerList.add(invoker11);
    invokerList.add(invoker12);
    invokerList.add(invoker13);
    invokerList.add(invoker14);
    invokerList.add(invoker15);
    directory.notify(invokerList);
    Assertions.assertEquals(15, directory.list(invocation).size());
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    when(invoker6.isAvailable()).thenReturn(false);
    when(invoker7.isAvailable()).thenReturn(false);
    when(invoker8.isAvailable()).thenReturn(false);
    when(invoker9.isAvailable()).thenReturn(false);
    when(invoker10.isAvailable()).thenReturn(false);
    when(invoker11.isAvailable()).thenReturn(false);
    when(invoker12.isAvailable()).thenReturn(false);
    when(invoker13.isAvailable()).thenReturn(false);
    when(invoker14.isAvailable()).thenReturn(false);
    when(invoker15.isAvailable()).thenReturn(false);
    for (int i = 0; i < 15; i++) {
        clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    }
    for (int i = 0; i < 5; i++) {
        Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    }
    when(invoker1.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    when(invoker2.isAvailable()).thenReturn(true);
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    when(invoker5.isAvailable()).thenReturn(true);
    when(invoker6.isAvailable()).thenReturn(true);
    when(invoker7.isAvailable()).thenReturn(true);
    when(invoker8.isAvailable()).thenReturn(true);
    when(invoker9.isAvailable()).thenReturn(true);
    when(invoker10.isAvailable()).thenReturn(true);
    when(invoker11.isAvailable()).thenReturn(true);
    when(invoker12.isAvailable()).thenReturn(true);
    when(invoker13.isAvailable()).thenReturn(true);
    when(invoker14.isAvailable()).thenReturn(true);
    when(invoker15.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    invokerSet.add(invoker2);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    invokerSet.add(invoker5);
    invokerSet.add(invoker6);
    invokerSet.add(invoker7);
    invokerSet.add(invoker8);
    invokerSet.add(invoker9);
    invokerSet.add(invoker10);
    invokerSet.add(invoker11);
    invokerSet.add(invoker12);
    invokerSet.add(invoker13);
    invokerSet.add(invoker14);
    invokerSet.add(invoker15);
    waitRefresh(invokerSet);
    Assertions.assertTrue(directory.list(invocation).size() > 1);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_15
#### Test Case Name: `testRandomSelect`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker9`
<summary>Suggested Diff</summary>

```diff
--- a/TestClass.java
+++ b/TestClass.java
@@
    invokerList.add(invoker8);
    invokerList.add(invoker9);
    invokerList.add(invoker10);
    invokerList.add(invoker11);
    invokerList.add(invoker12);
    invokerList.add(invoker13);
    invokerList.add(invoker14);
    invokerList.add(invoker15);
    directory.notify(invokerList);
    Assertions.assertEquals(15, directory.list(invocation).size());
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    when(invoker6.isAvailable()).thenReturn(false);
    when(invoker7.isAvailable()).thenReturn(false);
    when(invoker8.isAvailable()).thenReturn(false);
-    when(invoker9.isAvailable()).thenReturn(false);
+    invoker9 = MockInvoker.createMockInvoker(false);
    when(invoker10.isAvailable()).thenReturn(false);
    when(invoker11.isAvailable()).thenReturn(false);
    when(invoker12.isAvailable()).thenReturn(false);
    when(invoker13.isAvailable()).thenReturn(false);
    when(invoker14.isAvailable()).thenReturn(false);
    when(invoker15.isAvailable()).thenReturn(false);
    for (int i = 0; i < 15; i++) {
        clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    }
    for (int i = 0; i < 5; i++) {
        Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    }
    when(invoker1.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    when(invoker2.isAvailable()).thenReturn(true);
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    when(invoker5.isAvailable()).thenReturn(true);
    when(invoker6.isAvailable()).thenReturn(true);
    when(invoker7.isAvailable()).thenReturn(true);
    when(invoker8.isAvailable()).thenReturn(true);
-    when(invoker9.isAvailable()).thenReturn(true);
+    invoker9 = MockInvoker.createMockInvoker(true);
    when(invoker10.isAvailable()).thenReturn(true);
    when(invoker11.isAvailable()).thenReturn(true);
    when(invoker12.isAvailable()).thenReturn(true);
    when(invoker13.isAvailable()).thenReturn(true);
    when(invoker14.isAvailable()).thenReturn(true);
    when(invoker15.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    invokerSet.add(invoker2);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    invokerSet.add(invoker5);
    invokerSet.add(invoker6);
    invokerSet.add(invoker7);
    invokerSet.add(invoker8);
    invokerSet.add(invoker9);
    invokerSet.add(invoker10);
    invokerSet.add(invoker11);
    invokerSet.add(invoker12);
    invokerSet.add(invoker13);
    invokerSet.add(invoker14);
    invokerSet.add(invoker15);
    waitRefresh(invokerSet);
    Assertions.assertTrue(directory.list(invocation).size() > 1);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testRandomSelect() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    invokerList.add(invoker6);
    invokerList.add(invoker7);
    invokerList.add(invoker8);
    invokerList.add(invoker9);
    invokerList.add(invoker10);
    invokerList.add(invoker11);
    invokerList.add(invoker12);
    invokerList.add(invoker13);
    invokerList.add(invoker14);
    invokerList.add(invoker15);
    directory.notify(invokerList);
    Assertions.assertEquals(15, directory.list(invocation).size());
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    when(invoker6.isAvailable()).thenReturn(false);
    when(invoker7.isAvailable()).thenReturn(false);
    when(invoker8.isAvailable()).thenReturn(false);
    when(invoker9.isAvailable()).thenReturn(false);
    when(invoker10.isAvailable()).thenReturn(false);
    when(invoker11.isAvailable()).thenReturn(false);
    when(invoker12.isAvailable()).thenReturn(false);
    when(invoker13.isAvailable()).thenReturn(false);
    when(invoker14.isAvailable()).thenReturn(false);
    when(invoker15.isAvailable()).thenReturn(false);
    for (int i = 0; i < 15; i++) {
        clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    }
    for (int i = 0; i < 5; i++) {
        Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    }
    when(invoker1.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    when(invoker2.isAvailable()).thenReturn(true);
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    when(invoker5.isAvailable()).thenReturn(true);
    when(invoker6.isAvailable()).thenReturn(true);
    when(invoker7.isAvailable()).thenReturn(true);
    when(invoker8.isAvailable()).thenReturn(true);
    when(invoker9.isAvailable()).thenReturn(true);
    when(invoker10.isAvailable()).thenReturn(true);
    when(invoker11.isAvailable()).thenReturn(true);
    when(invoker12.isAvailable()).thenReturn(true);
    when(invoker13.isAvailable()).thenReturn(true);
    when(invoker14.isAvailable()).thenReturn(true);
    when(invoker15.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    invokerSet.add(invoker2);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    invokerSet.add(invoker5);
    invokerSet.add(invoker6);
    invokerSet.add(invoker7);
    invokerSet.add(invoker8);
    invokerSet.add(invoker9);
    invokerSet.add(invoker10);
    invokerSet.add(invoker11);
    invokerSet.add(invoker12);
    invokerSet.add(invoker13);
    invokerSet.add(invoker14);
    invokerSet.add(invoker15);
    waitRefresh(invokerSet);
    Assertions.assertTrue(directory.list(invocation).size() > 1);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_16
#### Test Case Name: `testRandomSelect`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker10`
<summary>Suggested Diff</summary>

```diff
@@
     when(invoker8.isAvailable()).thenReturn(false);
     when(invoker9.isAvailable()).thenReturn(false);
-    when(invoker10.isAvailable()).thenReturn(false);
+    invoker10 = MockInvoker.createMockInvoker(false);
     when(invoker11.isAvailable()).thenReturn(false);
     when(invoker12.isAvailable()).thenReturn(false);
     when(invoker13.isAvailable()).thenReturn(false);
@@
     when(invoker8.isAvailable()).thenReturn(true);
     when(invoker9.isAvailable()).thenReturn(true);
-    when(invoker10.isAvailable()).thenReturn(true);
+    invoker10 = MockInvoker.createMockInvoker(true);
     when(invoker11.isAvailable()).thenReturn(true);
     when(invoker12.isAvailable()).thenReturn(true);
     when(invoker13.isAvailable()).thenReturn(true);
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testRandomSelect() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    invokerList.add(invoker6);
    invokerList.add(invoker7);
    invokerList.add(invoker8);
    invokerList.add(invoker9);
    invokerList.add(invoker10);
    invokerList.add(invoker11);
    invokerList.add(invoker12);
    invokerList.add(invoker13);
    invokerList.add(invoker14);
    invokerList.add(invoker15);
    directory.notify(invokerList);
    Assertions.assertEquals(15, directory.list(invocation).size());
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    when(invoker6.isAvailable()).thenReturn(false);
    when(invoker7.isAvailable()).thenReturn(false);
    when(invoker8.isAvailable()).thenReturn(false);
    when(invoker9.isAvailable()).thenReturn(false);
    when(invoker10.isAvailable()).thenReturn(false);
    when(invoker11.isAvailable()).thenReturn(false);
    when(invoker12.isAvailable()).thenReturn(false);
    when(invoker13.isAvailable()).thenReturn(false);
    when(invoker14.isAvailable()).thenReturn(false);
    when(invoker15.isAvailable()).thenReturn(false);
    for (int i = 0; i < 15; i++) {
        clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    }
    for (int i = 0; i < 5; i++) {
        Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    }
    when(invoker1.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    when(invoker2.isAvailable()).thenReturn(true);
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    when(invoker5.isAvailable()).thenReturn(true);
    when(invoker6.isAvailable()).thenReturn(true);
    when(invoker7.isAvailable()).thenReturn(true);
    when(invoker8.isAvailable()).thenReturn(true);
    when(invoker9.isAvailable()).thenReturn(true);
    when(invoker10.isAvailable()).thenReturn(true);
    when(invoker11.isAvailable()).thenReturn(true);
    when(invoker12.isAvailable()).thenReturn(true);
    when(invoker13.isAvailable()).thenReturn(true);
    when(invoker14.isAvailable()).thenReturn(true);
    when(invoker15.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    invokerSet.add(invoker2);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    invokerSet.add(invoker5);
    invokerSet.add(invoker6);
    invokerSet.add(invoker7);
    invokerSet.add(invoker8);
    invokerSet.add(invoker9);
    invokerSet.add(invoker10);
    invokerSet.add(invoker11);
    invokerSet.add(invoker12);
    invokerSet.add(invoker13);
    invokerSet.add(invoker14);
    invokerSet.add(invoker15);
    waitRefresh(invokerSet);
    Assertions.assertTrue(directory.list(invocation).size() > 1);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_17
#### Test Case Name: `testRandomSelect`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker11`
<summary>Suggested Diff</summary>

```diff
--- Original
+++ Refactored
@@
-    invoker11 = Mockito.mock(Invoker.class);
+    // invoker11 will be assigned in the test method using MockInvoker.createMockInvoker
     configInvoker(invoker11);
@@
 void testRandomSelect() throws InterruptedException {
     Invocation invocation = new RpcInvocation();
     LoadBalance loadBalance = new RandomLoadBalance();
     invokerList.add(invoker6);
     invokerList.add(invoker7);
     invokerList.add(invoker8);
     invokerList.add(invoker9);
     invokerList.add(invoker10);
-    invokerList.add(invoker11);
+    invoker11 = MockInvoker.createMockInvoker(false);
+    invokerList.add(invoker11);
     invokerList.add(invoker12);
     invokerList.add(invoker13);
     invokerList.add(invoker14);
     invokerList.add(invoker15);
     directory.notify(invokerList);
     Assertions.assertEquals(15, directory.list(invocation).size());
     when(invoker2.isAvailable()).thenReturn(false);
     when(invoker3.isAvailable()).thenReturn(false);
     when(invoker4.isAvailable()).thenReturn(false);
     when(invoker5.isAvailable()).thenReturn(false);
     when(invoker6.isAvailable()).thenReturn(false);
     when(invoker7.isAvailable()).thenReturn(false);
     when(invoker8.isAvailable()).thenReturn(false);
     when(invoker9.isAvailable()).thenReturn(false);
     when(invoker10.isAvailable()).thenReturn(false);
-    when(invoker11.isAvailable()).thenReturn(false);
     when(invoker12.isAvailable()).thenReturn(false);
     when(invoker13.isAvailable()).thenReturn(false);
     when(invoker14.isAvailable()).thenReturn(false);
     when(invoker15.isAvailable()).thenReturn(false);
     for (int i = 0; i < 15; i++) {
         clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
     }
     for (int i = 0; i < 5; i++) {
         Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
     }
     when(invoker1.isAvailable()).thenReturn(false);
     clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
     Assertions.assertEquals(0, directory.list(invocation).size());
     when(invoker1.isAvailable()).thenReturn(true);
     when(invoker2.isAvailable()).thenReturn(true);
     when(invoker3.isAvailable()).thenReturn(true);
     when(invoker4.isAvailable()).thenReturn(true);
     when(invoker5.isAvailable()).thenReturn(true);
     when(invoker6.isAvailable()).thenReturn(true);
     when(invoker7.isAvailable()).thenReturn(true);
     when(invoker8.isAvailable()).thenReturn(true);
     when(invoker9.isAvailable()).thenReturn(true);
     when(invoker10.isAvailable()).thenReturn(true);
-    when(invoker11.isAvailable()).thenReturn(true);
+    invoker11 = MockInvoker.createMockInvoker(true);
     when(invoker12.isAvailable()).thenReturn(true);
     when(invoker13.isAvailable()).thenReturn(true);
     when(invoker14.isAvailable()).thenReturn(true);
     when(invoker15.isAvailable()).thenReturn(true);
     Set<Invoker> invokerSet = new HashSet<>();
     invokerSet.add(invoker1);
     invokerSet.add(invoker2);
     invokerSet.add(invoker3);
     invokerSet.add(invoker4);
     invokerSet.add(invoker5);
     invokerSet.add(invoker6);
     invokerSet.add(invoker7);
     invokerSet.add(invoker8);
     invokerSet.add(invoker9);
     invokerSet.add(invoker10);
     invokerSet.add(invoker11);
     invokerSet.add(invoker12);
     invokerSet.add(invoker13);
     invokerSet.add(invoker14);
     invokerSet.add(invoker15);
     waitRefresh(invokerSet);
     Assertions.assertTrue(directory.list(invocation).size() > 1);
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testRandomSelect() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    invokerList.add(invoker6);
    invokerList.add(invoker7);
    invokerList.add(invoker8);
    invokerList.add(invoker9);
    invokerList.add(invoker10);
    invokerList.add(invoker11);
    invokerList.add(invoker12);
    invokerList.add(invoker13);
    invokerList.add(invoker14);
    invokerList.add(invoker15);
    directory.notify(invokerList);
    Assertions.assertEquals(15, directory.list(invocation).size());
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    when(invoker6.isAvailable()).thenReturn(false);
    when(invoker7.isAvailable()).thenReturn(false);
    when(invoker8.isAvailable()).thenReturn(false);
    when(invoker9.isAvailable()).thenReturn(false);
    when(invoker10.isAvailable()).thenReturn(false);
    when(invoker11.isAvailable()).thenReturn(false);
    when(invoker12.isAvailable()).thenReturn(false);
    when(invoker13.isAvailable()).thenReturn(false);
    when(invoker14.isAvailable()).thenReturn(false);
    when(invoker15.isAvailable()).thenReturn(false);
    for (int i = 0; i < 15; i++) {
        clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    }
    for (int i = 0; i < 5; i++) {
        Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    }
    when(invoker1.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    when(invoker2.isAvailable()).thenReturn(true);
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    when(invoker5.isAvailable()).thenReturn(true);
    when(invoker6.isAvailable()).thenReturn(true);
    when(invoker7.isAvailable()).thenReturn(true);
    when(invoker8.isAvailable()).thenReturn(true);
    when(invoker9.isAvailable()).thenReturn(true);
    when(invoker10.isAvailable()).thenReturn(true);
    when(invoker11.isAvailable()).thenReturn(true);
    when(invoker12.isAvailable()).thenReturn(true);
    when(invoker13.isAvailable()).thenReturn(true);
    when(invoker14.isAvailable()).thenReturn(true);
    when(invoker15.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    invokerSet.add(invoker2);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    invokerSet.add(invoker5);
    invokerSet.add(invoker6);
    invokerSet.add(invoker7);
    invokerSet.add(invoker8);
    invokerSet.add(invoker9);
    invokerSet.add(invoker10);
    invokerSet.add(invoker11);
    invokerSet.add(invoker12);
    invokerSet.add(invoker13);
    invokerSet.add(invoker14);
    invokerSet.add(invoker15);
    waitRefresh(invokerSet);
    Assertions.assertTrue(directory.list(invocation).size() > 1);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_18
#### Test Case Name: `testRandomSelect`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker12`
<summary>Suggested Diff</summary>

```diff
--- a/TestClass.java
+++ b/TestClass.java
@@
     when(invoker10.isAvailable()).thenReturn(false);
     when(invoker11.isAvailable()).thenReturn(false);
-    when(invoker12.isAvailable()).thenReturn(false);
     when(invoker13.isAvailable()).thenReturn(false);
     when(invoker14.isAvailable()).thenReturn(false);
     when(invoker15.isAvailable()).thenReturn(false);
     for (int i = 0; i < 15; i++) {
         clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
     }
     for (int i = 0; i < 5; i++) {
         Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
     }
     when(invoker1.isAvailable()).thenReturn(false);
     clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
     Assertions.assertEquals(0, directory.list(invocation).size());
     when(invoker1.isAvailable()).thenReturn(true);
     when(invoker2.isAvailable()).thenReturn(true);
     when(invoker3.isAvailable()).thenReturn(true);
     when(invoker4.isAvailable()).thenReturn(true);
     when(invoker5.isAvailable()).thenReturn(true);
     when(invoker6.isAvailable()).thenReturn(true);
     when(invoker7.isAvailable()).thenReturn(true);
     when(invoker8.isAvailable()).thenReturn(true);
     when(invoker9.isAvailable()).thenReturn(true);
     when(invoker10.isAvailable()).thenReturn(true);
     when(invoker11.isAvailable()).thenReturn(true);
-    when(invoker12.isAvailable()).thenReturn(true);
+    invoker12 = MockInvoker.createMockInvoker(true);
     when(invoker13.isAvailable()).thenReturn(true);
     when(invoker14.isAvailable()).thenReturn(true);
     when(invoker15.isAvailable()).thenReturn(true);
     Set<Invoker> invokerSet = new HashSet<>();
     invokerSet.add(invoker1);
     invokerSet.add(invoker2);
     invokerSet.add(invoker3);
     invokerSet.add(invoker4);
     invokerSet.add(invoker5);
     invokerSet.add(invoker6);
     invokerSet.add(invoker7);
     invokerSet.add(invoker8);
     invokerSet.add(invoker9);
     invokerSet.add(invoker10);
     invokerSet.add(invoker11);
     invokerSet.add(invoker12);
     invokerSet.add(invoker13);
     invokerSet.add(invoker14);
     invokerSet.add(invoker15);
     waitRefresh(invokerSet);
     Assertions.assertTrue(directory.list(invocation).size() > 1);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testRandomSelect() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    invokerList.add(invoker6);
    invokerList.add(invoker7);
    invokerList.add(invoker8);
    invokerList.add(invoker9);
    invokerList.add(invoker10);
    invokerList.add(invoker11);
    invokerList.add(invoker12);
    invokerList.add(invoker13);
    invokerList.add(invoker14);
    invokerList.add(invoker15);
    directory.notify(invokerList);
    Assertions.assertEquals(15, directory.list(invocation).size());
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    when(invoker6.isAvailable()).thenReturn(false);
    when(invoker7.isAvailable()).thenReturn(false);
    when(invoker8.isAvailable()).thenReturn(false);
    when(invoker9.isAvailable()).thenReturn(false);
    when(invoker10.isAvailable()).thenReturn(false);
    when(invoker11.isAvailable()).thenReturn(false);
    when(invoker12.isAvailable()).thenReturn(false);
    when(invoker13.isAvailable()).thenReturn(false);
    when(invoker14.isAvailable()).thenReturn(false);
    when(invoker15.isAvailable()).thenReturn(false);
    for (int i = 0; i < 15; i++) {
        clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    }
    for (int i = 0; i < 5; i++) {
        Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    }
    when(invoker1.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    when(invoker2.isAvailable()).thenReturn(true);
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    when(invoker5.isAvailable()).thenReturn(true);
    when(invoker6.isAvailable()).thenReturn(true);
    when(invoker7.isAvailable()).thenReturn(true);
    when(invoker8.isAvailable()).thenReturn(true);
    when(invoker9.isAvailable()).thenReturn(true);
    when(invoker10.isAvailable()).thenReturn(true);
    when(invoker11.isAvailable()).thenReturn(true);
    when(invoker12.isAvailable()).thenReturn(true);
    when(invoker13.isAvailable()).thenReturn(true);
    when(invoker14.isAvailable()).thenReturn(true);
    when(invoker15.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    invokerSet.add(invoker2);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    invokerSet.add(invoker5);
    invokerSet.add(invoker6);
    invokerSet.add(invoker7);
    invokerSet.add(invoker8);
    invokerSet.add(invoker9);
    invokerSet.add(invoker10);
    invokerSet.add(invoker11);
    invokerSet.add(invoker12);
    invokerSet.add(invoker13);
    invokerSet.add(invoker14);
    invokerSet.add(invoker15);
    waitRefresh(invokerSet);
    Assertions.assertTrue(directory.list(invocation).size() > 1);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_19
#### Test Case Name: `testRandomSelect`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker13`
<summary>Suggested Diff</summary>

```diff
--- Original
+++ Refactored
@@
     when(invoker12.isAvailable()).thenReturn(false);
-    when(invoker13.isAvailable()).thenReturn(false);
     when(invoker14.isAvailable()).thenReturn(false);
     when(invoker15.isAvailable()).thenReturn(false);
     for (int i = 0; i < 15; i++) {
@@
     when(invoker12.isAvailable()).thenReturn(true);
-    when(invoker13.isAvailable()).thenReturn(true);
+    invoker13 = MockInvoker.createMockInvoker(true);
     when(invoker14.isAvailable()).thenReturn(true);
     when(invoker15.isAvailable()).thenReturn(true);
     Set<Invoker> invokerSet = new HashSet<>();
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testRandomSelect() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    invokerList.add(invoker6);
    invokerList.add(invoker7);
    invokerList.add(invoker8);
    invokerList.add(invoker9);
    invokerList.add(invoker10);
    invokerList.add(invoker11);
    invokerList.add(invoker12);
    invokerList.add(invoker13);
    invokerList.add(invoker14);
    invokerList.add(invoker15);
    directory.notify(invokerList);
    Assertions.assertEquals(15, directory.list(invocation).size());
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    when(invoker6.isAvailable()).thenReturn(false);
    when(invoker7.isAvailable()).thenReturn(false);
    when(invoker8.isAvailable()).thenReturn(false);
    when(invoker9.isAvailable()).thenReturn(false);
    when(invoker10.isAvailable()).thenReturn(false);
    when(invoker11.isAvailable()).thenReturn(false);
    when(invoker12.isAvailable()).thenReturn(false);
    when(invoker13.isAvailable()).thenReturn(false);
    when(invoker14.isAvailable()).thenReturn(false);
    when(invoker15.isAvailable()).thenReturn(false);
    for (int i = 0; i < 15; i++) {
        clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    }
    for (int i = 0; i < 5; i++) {
        Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    }
    when(invoker1.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    when(invoker2.isAvailable()).thenReturn(true);
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    when(invoker5.isAvailable()).thenReturn(true);
    when(invoker6.isAvailable()).thenReturn(true);
    when(invoker7.isAvailable()).thenReturn(true);
    when(invoker8.isAvailable()).thenReturn(true);
    when(invoker9.isAvailable()).thenReturn(true);
    when(invoker10.isAvailable()).thenReturn(true);
    when(invoker11.isAvailable()).thenReturn(true);
    when(invoker12.isAvailable()).thenReturn(true);
    when(invoker13.isAvailable()).thenReturn(true);
    when(invoker14.isAvailable()).thenReturn(true);
    when(invoker15.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    invokerSet.add(invoker2);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    invokerSet.add(invoker5);
    invokerSet.add(invoker6);
    invokerSet.add(invoker7);
    invokerSet.add(invoker8);
    invokerSet.add(invoker9);
    invokerSet.add(invoker10);
    invokerSet.add(invoker11);
    invokerSet.add(invoker12);
    invokerSet.add(invoker13);
    invokerSet.add(invoker14);
    invokerSet.add(invoker15);
    waitRefresh(invokerSet);
    Assertions.assertTrue(directory.list(invocation).size() > 1);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_20
#### Test Case Name: `testRandomSelect`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker14`
<summary>Suggested Diff</summary>

```diff
--- Original.java
+++ Refactored.java
@@
     when(invoker13.isAvailable()).thenReturn(false);
-    when(invoker14.isAvailable()).thenReturn(false);
     when(invoker15.isAvailable()).thenReturn(false);
     for (int i = 0; i < 15; i++) {
         clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
     }
     for (int i = 0; i < 5; i++) {
         Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
     }
     when(invoker1.isAvailable()).thenReturn(false);
     clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
     Assertions.assertEquals(0, directory.list(invocation).size());
     when(invoker1.isAvailable()).thenReturn(true);
     when(invoker2.isAvailable()).thenReturn(true);
     when(invoker3.isAvailable()).thenReturn(true);
     when(invoker4.isAvailable()).thenReturn(true);
     when(invoker5.isAvailable()).thenReturn(true);
     when(invoker6.isAvailable()).thenReturn(true);
     when(invoker7.isAvailable()).thenReturn(true);
     when(invoker8.isAvailable()).thenReturn(true);
     when(invoker9.isAvailable()).thenReturn(true);
     when(invoker10.isAvailable()).thenReturn(true);
     when(invoker11.isAvailable()).thenReturn(true);
     when(invoker12.isAvailable()).thenReturn(true);
     when(invoker13.isAvailable()).thenReturn(true);
-    when(invoker14.isAvailable()).thenReturn(true);
+    when(invoker14.isAvailable()).thenReturn(true); // replaced by helper if needed
     when(invoker15.isAvailable()).thenReturn(true);
     Set<Invoker> invokerSet = new HashSet<>();
     invokerSet.add(invoker1);
     invokerSet.add(invoker2);
     invokerSet.add(invoker3);
     invokerSet.add(invoker4);
     invokerSet.add(invoker5);
     invokerSet.add(invoker6);
     invokerSet.add(invoker7);
     invokerSet.add(invoker8);
     invokerSet.add(invoker9);
     invokerSet.add(invoker10);
     invokerSet.add(invoker11);
     invokerSet.add(invoker12);
     invokerSet.add(invoker13);
     invokerSet.add(invoker14);
     invokerSet.add(invoker15);
     waitRefresh(invokerSet);
     Assertions.assertTrue(directory.list(invocation).size() > 1);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testRandomSelect() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    invokerList.add(invoker6);
    invokerList.add(invoker7);
    invokerList.add(invoker8);
    invokerList.add(invoker9);
    invokerList.add(invoker10);
    invokerList.add(invoker11);
    invokerList.add(invoker12);
    invokerList.add(invoker13);
    invokerList.add(invoker14);
    invokerList.add(invoker15);
    directory.notify(invokerList);
    Assertions.assertEquals(15, directory.list(invocation).size());
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    when(invoker6.isAvailable()).thenReturn(false);
    when(invoker7.isAvailable()).thenReturn(false);
    when(invoker8.isAvailable()).thenReturn(false);
    when(invoker9.isAvailable()).thenReturn(false);
    when(invoker10.isAvailable()).thenReturn(false);
    when(invoker11.isAvailable()).thenReturn(false);
    when(invoker12.isAvailable()).thenReturn(false);
    when(invoker13.isAvailable()).thenReturn(false);
    when(invoker14.isAvailable()).thenReturn(false);
    when(invoker15.isAvailable()).thenReturn(false);
    for (int i = 0; i < 15; i++) {
        clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    }
    for (int i = 0; i < 5; i++) {
        Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    }
    when(invoker1.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    when(invoker2.isAvailable()).thenReturn(true);
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    when(invoker5.isAvailable()).thenReturn(true);
    when(invoker6.isAvailable()).thenReturn(true);
    when(invoker7.isAvailable()).thenReturn(true);
    when(invoker8.isAvailable()).thenReturn(true);
    when(invoker9.isAvailable()).thenReturn(true);
    when(invoker10.isAvailable()).thenReturn(true);
    when(invoker11.isAvailable()).thenReturn(true);
    when(invoker12.isAvailable()).thenReturn(true);
    when(invoker13.isAvailable()).thenReturn(true);
    when(invoker14.isAvailable()).thenReturn(true);
    when(invoker15.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    invokerSet.add(invoker2);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    invokerSet.add(invoker5);
    invokerSet.add(invoker6);
    invokerSet.add(invoker7);
    invokerSet.add(invoker8);
    invokerSet.add(invoker9);
    invokerSet.add(invoker10);
    invokerSet.add(invoker11);
    invokerSet.add(invoker12);
    invokerSet.add(invoker13);
    invokerSet.add(invoker14);
    invokerSet.add(invoker15);
    waitRefresh(invokerSet);
    Assertions.assertTrue(directory.list(invocation).size() > 1);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_21
#### Test Case Name: `testRandomSelect`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\ConnectivityValidationTest.java`)
#### Mock Object Variable Name: `invoker15`
<summary>Suggested Diff</summary>

```diff
@@
     when(invoker14.isAvailable()).thenReturn(false);
-    when(invoker15.isAvailable()).thenReturn(false);
+    invoker15 = MockInvoker.createMockInvoker(false);
     for (int i = 0; i < 15; i++) {
         clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
     }
     for (int i = 0; i < 5; i++) {
         Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
     }
     when(invoker1.isAvailable()).thenReturn(false);
     clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
     Assertions.assertEquals(0, directory.list(invocation).size());
     when(invoker1.isAvailable()).thenReturn(true);
     when(invoker2.isAvailable()).thenReturn(true);
     when(invoker3.isAvailable()).thenReturn(true);
     when(invoker4.isAvailable()).thenReturn(true);
     when(invoker5.isAvailable()).thenReturn(true);
     when(invoker6.isAvailable()).thenReturn(true);
     when(invoker7.isAvailable()).thenReturn(true);
     when(invoker8.isAvailable()).thenReturn(true);
     when(invoker9.isAvailable()).thenReturn(true);
     when(invoker10.isAvailable()).thenReturn(true);
     when(invoker11.isAvailable()).thenReturn(true);
     when(invoker12.isAvailable()).thenReturn(true);
     when(invoker13.isAvailable()).thenReturn(true);
     when(invoker14.isAvailable()).thenReturn(true);
-    when(invoker15.isAvailable()).thenReturn(true);
+    invoker15 = MockInvoker.createMockInvoker(true);
     Set<Invoker> invokerSet = new HashSet<>();
     invokerSet.add(invoker1);
     invokerSet.add(invoker2);
     invokerSet.add(invoker3);
     invokerSet.add(invoker4);
     invokerSet.add(invoker5);
     invokerSet.add(invoker6);
     invokerSet.add(invoker7);
     invokerSet.add(invoker8);
     invokerSet.add(invoker9);
     invokerSet.add(invoker10);
     invokerSet.add(invoker11);
     invokerSet.add(invoker12);
     invokerSet.add(invoker13);
     invokerSet.add(invoker14);
     invokerSet.add(invoker15);
     waitRefresh(invokerSet);
     Assertions.assertTrue(directory.list(invocation).size() > 1);
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setup() {
    ApplicationModel.defaultModel().getBeanFactory().registerBean(MetricsDispatcher.class);
    invoker1 = Mockito.mock(Invoker.class);
    invoker2 = Mockito.mock(Invoker.class);
    invoker3 = Mockito.mock(Invoker.class);
    invoker4 = Mockito.mock(Invoker.class);
    invoker5 = Mockito.mock(Invoker.class);
    invoker6 = Mockito.mock(Invoker.class);
    invoker7 = Mockito.mock(Invoker.class);
    invoker8 = Mockito.mock(Invoker.class);
    invoker9 = Mockito.mock(Invoker.class);
    invoker10 = Mockito.mock(Invoker.class);
    invoker11 = Mockito.mock(Invoker.class);
    invoker12 = Mockito.mock(Invoker.class);
    invoker13 = Mockito.mock(Invoker.class);
    invoker14 = Mockito.mock(Invoker.class);
    invoker15 = Mockito.mock(Invoker.class);
    configInvoker(invoker1);
    configInvoker(invoker2);
    configInvoker(invoker3);
    configInvoker(invoker4);
    configInvoker(invoker5);
    configInvoker(invoker6);
    configInvoker(invoker7);
    configInvoker(invoker8);
    configInvoker(invoker9);
    configInvoker(invoker10);
    configInvoker(invoker11);
    configInvoker(invoker12);
    configInvoker(invoker13);
    configInvoker(invoker14);
    configInvoker(invoker15);
    invokerList = new LinkedList<>();
    invokerList.add(invoker1);
    invokerList.add(invoker2);
    invokerList.add(invoker3);
    invokerList.add(invoker4);
    invokerList.add(invoker5);
    directory = new StaticDirectory(invokerList);
    clusterInvoker = new ConnectivityClusterInvoker(directory);
}
@Test
void testRandomSelect() throws InterruptedException {
    Invocation invocation = new RpcInvocation();
    LoadBalance loadBalance = new RandomLoadBalance();
    invokerList.add(invoker6);
    invokerList.add(invoker7);
    invokerList.add(invoker8);
    invokerList.add(invoker9);
    invokerList.add(invoker10);
    invokerList.add(invoker11);
    invokerList.add(invoker12);
    invokerList.add(invoker13);
    invokerList.add(invoker14);
    invokerList.add(invoker15);
    directory.notify(invokerList);
    Assertions.assertEquals(15, directory.list(invocation).size());
    when(invoker2.isAvailable()).thenReturn(false);
    when(invoker3.isAvailable()).thenReturn(false);
    when(invoker4.isAvailable()).thenReturn(false);
    when(invoker5.isAvailable()).thenReturn(false);
    when(invoker6.isAvailable()).thenReturn(false);
    when(invoker7.isAvailable()).thenReturn(false);
    when(invoker8.isAvailable()).thenReturn(false);
    when(invoker9.isAvailable()).thenReturn(false);
    when(invoker10.isAvailable()).thenReturn(false);
    when(invoker11.isAvailable()).thenReturn(false);
    when(invoker12.isAvailable()).thenReturn(false);
    when(invoker13.isAvailable()).thenReturn(false);
    when(invoker14.isAvailable()).thenReturn(false);
    when(invoker15.isAvailable()).thenReturn(false);
    for (int i = 0; i < 15; i++) {
        clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    }
    for (int i = 0; i < 5; i++) {
        Assertions.assertEquals(invoker1, clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList()));
    }
    when(invoker1.isAvailable()).thenReturn(false);
    clusterInvoker.select(loadBalance, invocation, directory.list(invocation), Collections.emptyList());
    Assertions.assertEquals(0, directory.list(invocation).size());
    when(invoker1.isAvailable()).thenReturn(true);
    when(invoker2.isAvailable()).thenReturn(true);
    when(invoker3.isAvailable()).thenReturn(true);
    when(invoker4.isAvailable()).thenReturn(true);
    when(invoker5.isAvailable()).thenReturn(true);
    when(invoker6.isAvailable()).thenReturn(true);
    when(invoker7.isAvailable()).thenReturn(true);
    when(invoker8.isAvailable()).thenReturn(true);
    when(invoker9.isAvailable()).thenReturn(true);
    when(invoker10.isAvailable()).thenReturn(true);
    when(invoker11.isAvailable()).thenReturn(true);
    when(invoker12.isAvailable()).thenReturn(true);
    when(invoker13.isAvailable()).thenReturn(true);
    when(invoker14.isAvailable()).thenReturn(true);
    when(invoker15.isAvailable()).thenReturn(true);
    Set<Invoker> invokerSet = new HashSet<>();
    invokerSet.add(invoker1);
    invokerSet.add(invoker2);
    invokerSet.add(invoker3);
    invokerSet.add(invoker4);
    invokerSet.add(invoker5);
    invokerSet.add(invoker6);
    invokerSet.add(invoker7);
    invokerSet.add(invoker8);
    invokerSet.add(invoker9);
    invokerSet.add(invoker10);
    invokerSet.add(invoker11);
    invokerSet.add(invoker12);
    invokerSet.add(invoker13);
    invokerSet.add(invoker14);
    invokerSet.add(invoker15);
    waitRefresh(invokerSet);
    Assertions.assertTrue(directory.list(invocation).size() > 1);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_22
#### Test Case Name: `testAddMenu`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\MergeableClusterInvokerTest.java`)
#### Mock Object Variable Name: `firstInvoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    given(invocation.getObjectAttachments()).willReturn(new HashMap<>());
    given(invocation.getInvoker()).willReturn(firstInvoker);
-    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
-    given(firstInvoker.getInterface()).willReturn(MenuService.class);
-    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
-    given(firstInvoker.isAvailable()).willReturn(true);
+    firstInvoker = MockInvoker.createMockInvoker(true);
+    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
+    given(firstInvoker.getInterface()).willReturn(MenuService.class);
+    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testAddMenu() {
    String menu = "first";
    List<String> menuItems = new ArrayList<String>() {

        {
            add("1");
            add("2");
        }
    };
    given(invocation.getMethodName()).willReturn("addMenu");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { String.class, List.class });
    given(invocation.getArguments()).willReturn(new Object[] { menu, menuItems });
    given(invocation.getObjectAttachments()).willReturn(new HashMap<>());
    given(invocation.getInvoker()).willReturn(firstInvoker);
    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
    given(firstInvoker.getInterface()).willReturn(MenuService.class);
    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(firstInvoker.isAvailable()).willReturn(true);
    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
    given(secondInvoker.getInterface()).willReturn(MenuService.class);
    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(secondInvoker.isAvailable()).willReturn(true);
    given(directory.list(invocation)).willReturn(new ArrayList() {

        {
            add(firstInvoker);
            add(secondInvoker);
        }
    });
    given(directory.getUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getInterface()).willReturn(MenuService.class);
    mergeableClusterInvoker = new MergeableClusterInvoker<MenuService>(directory);
    Result result = mergeableClusterInvoker.invoke(invocation);
    Assertions.assertNull(result.getValue());
}
@BeforeEach
public void setUp() throws Exception {
    directory = mock(Directory.class);
    firstInvoker = mock(Invoker.class);
    secondInvoker = mock(Invoker.class);
    invocation = mock(RpcInvocation.class);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_23
#### Test Case Name: `testInvokerToNoInvokerAvailableException`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\MergeableClusterInvokerTest.java`)
#### Mock Object Variable Name: `firstInvoker`
<summary>Suggested Diff</summary>

```diff
--- a/TestClass.java
+++ b/TestClass.java
@@
    given(invocation.getObjectAttachments()).willReturn(new HashMap<>());
    given(invocation.getInvoker()).willReturn(firstInvoker);
-    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
-    given(firstInvoker.getInterface()).willReturn(MenuService.class);
-    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
-    given(firstInvoker.isAvailable()).willReturn(true);
-    given(firstInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NO_INVOKER_AVAILABLE_AFTER_FILTER));
+    firstInvoker = MockInvoker.createMockInvoker(true);
+    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
+    given(firstInvoker.getInterface()).willReturn(MenuService.class);
+    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
+    given(firstInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NO_INVOKER_AVAILABLE_AFTER_FILTER));
    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testInvokerToNoInvokerAvailableException() {
    String menu = "first";
    List<String> menuItems = new ArrayList<String>() {

        {
            add("1");
            add("2");
        }
    };
    given(invocation.getMethodName()).willReturn("addMenu");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { String.class, List.class });
    given(invocation.getArguments()).willReturn(new Object[] { menu, menuItems });
    given(invocation.getObjectAttachments()).willReturn(new HashMap<>());
    given(invocation.getInvoker()).willReturn(firstInvoker);
    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
    given(firstInvoker.getInterface()).willReturn(MenuService.class);
    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(firstInvoker.isAvailable()).willReturn(true);
    given(firstInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NO_INVOKER_AVAILABLE_AFTER_FILTER));
    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
    given(secondInvoker.getInterface()).willReturn(MenuService.class);
    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(secondInvoker.isAvailable()).willReturn(true);
    given(secondInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NO_INVOKER_AVAILABLE_AFTER_FILTER));
    given(directory.list(invocation)).willReturn(new ArrayList() {

        {
            add(firstInvoker);
            add(secondInvoker);
        }
    });
    given(directory.getUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getInterface()).willReturn(MenuService.class);
    mergeableClusterInvoker = new MergeableClusterInvoker<MenuService>(directory);
    // invoke
    try {
        Result result = mergeableClusterInvoker.invoke(invocation);
        fail();
        Assertions.assertNull(result.getValue());
    } catch (RpcException expected) {
        assertEquals(expected.getCode(), RpcException.NO_INVOKER_AVAILABLE_AFTER_FILTER);
    }
}
@BeforeEach
public void setUp() throws Exception {
    directory = mock(Directory.class);
    firstInvoker = mock(Invoker.class);
    secondInvoker = mock(Invoker.class);
    invocation = mock(RpcInvocation.class);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_24
#### Test Case Name: `testInvokerToException`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\MergeableClusterInvokerTest.java`)
#### Mock Object Variable Name: `firstInvoker`
<summary>Suggested Diff</summary>

```diff
--- a/TestClass.java
+++ b/TestClass.java
@@
    given(invocation.getObjectAttachments()).willReturn(new HashMap<>());
    given(invocation.getInvoker()).willReturn(firstInvoker);
-    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
-    given(firstInvoker.getInterface()).willReturn(MenuService.class);
-    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
-    given(firstInvoker.isAvailable()).willReturn(true);
-    given(firstInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NETWORK_EXCEPTION));
+    firstInvoker = MockInvoker.createMockInvoker(true);
+    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
+    given(firstInvoker.getInterface()).willReturn(MenuService.class);
+    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
+    given(firstInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NETWORK_EXCEPTION));
    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setUp() throws Exception {
    directory = mock(Directory.class);
    firstInvoker = mock(Invoker.class);
    secondInvoker = mock(Invoker.class);
    invocation = mock(RpcInvocation.class);
}
/**
 * test when network exception
 */
@Test
void testInvokerToException() {
    String menu = "first";
    List<String> menuItems = new ArrayList<String>() {

        {
            add("1");
            add("2");
        }
    };
    given(invocation.getMethodName()).willReturn("addMenu");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { String.class, List.class });
    given(invocation.getArguments()).willReturn(new Object[] { menu, menuItems });
    given(invocation.getObjectAttachments()).willReturn(new HashMap<>());
    given(invocation.getInvoker()).willReturn(firstInvoker);
    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
    given(firstInvoker.getInterface()).willReturn(MenuService.class);
    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(firstInvoker.isAvailable()).willReturn(true);
    given(firstInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NETWORK_EXCEPTION));
    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
    given(secondInvoker.getInterface()).willReturn(MenuService.class);
    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(secondInvoker.isAvailable()).willReturn(true);
    given(secondInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NETWORK_EXCEPTION));
    given(directory.list(invocation)).willReturn(new ArrayList() {

        {
            add(firstInvoker);
            add(secondInvoker);
        }
    });
    given(directory.getUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getInterface()).willReturn(MenuService.class);
    mergeableClusterInvoker = new MergeableClusterInvoker<MenuService>(directory);
    // invoke
    try {
        Result result = mergeableClusterInvoker.invoke(invocation);
        fail();
        Assertions.assertNull(result.getValue());
    } catch (RpcException expected) {
        assertEquals(expected.getCode(), RpcException.NETWORK_EXCEPTION);
    }
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_25
#### Test Case Name: `testGetMenuResultHasException`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\MergeableClusterInvokerTest.java`)
#### Mock Object Variable Name: `firstInvoker`
<summary>Suggested Diff</summary>

```diff
@@
     given(invocation.getParameterTypes()).willReturn(new Class<?>[] {});
     given(invocation.getArguments()).willReturn(new Object[] {});
     given(invocation.getObjectAttachments()).willReturn(new HashMap<>());
     given(invocation.getInvoker()).willReturn(firstInvoker);
-    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
-    given(firstInvoker.getInterface()).willReturn(MenuService.class);
-    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
-    given(firstInvoker.isAvailable()).willReturn(true);
+    firstInvoker = MockInvoker.createMockInvoker(true);
+    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
+    given(firstInvoker.getInterface()).willReturn(MenuService.class);
+    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
     given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
     given(secondInvoker.getInterface()).willReturn(MenuService.class);
     given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
     given(secondInvoker.isAvailable()).willReturn(true);
     given(directory.list(invocation)).willReturn(new ArrayList() {

```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setUp() throws Exception {
    directory = mock(Directory.class);
    firstInvoker = mock(Invoker.class);
    secondInvoker = mock(Invoker.class);
    invocation = mock(RpcInvocation.class);
}
@Test
void testGetMenuResultHasException() {
    // setup
    url = url.addParameter(MERGER_KEY, ".merge");
    given(invocation.getMethodName()).willReturn("getMenu");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] {});
    given(invocation.getArguments()).willReturn(new Object[] {});
    given(invocation.getObjectAttachments()).willReturn(new HashMap<>());
    given(invocation.getInvoker()).willReturn(firstInvoker);
    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
    given(firstInvoker.getInterface()).willReturn(MenuService.class);
    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(firstInvoker.isAvailable()).willReturn(true);
    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
    given(secondInvoker.getInterface()).willReturn(MenuService.class);
    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(secondInvoker.isAvailable()).willReturn(true);
    given(directory.list(invocation)).willReturn(new ArrayList() {

        {
            add(firstInvoker);
            add(secondInvoker);
        }
    });
    given(directory.getUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getInterface()).willReturn(MenuService.class);
    mergeableClusterInvoker = new MergeableClusterInvoker<MenuService>(directory);
    // invoke
    try {
        Result result = mergeableClusterInvoker.invoke(invocation);
        fail();
        Assertions.assertNull(result.getValue());
    } catch (RpcException expected) {
        Assertions.assertTrue(expected.getMessage().contains("Failed to invoke service"));
    }
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_26
#### Test Case Name: `testAddMenu`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\MergeableClusterInvokerTest.java`)
#### Mock Object Variable Name: `secondInvoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
    given(firstInvoker.getInterface()).willReturn(MenuService.class);
    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(firstInvoker.isAvailable()).willReturn(true);
-    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
-    given(secondInvoker.getInterface()).willReturn(MenuService.class);
-    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
-    given(secondInvoker.isAvailable()).willReturn(true);
+    secondInvoker = MockInvoker.createMockInvoker(true);
+    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
+    given(secondInvoker.getInterface()).willReturn(MenuService.class);
+    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(directory.list(invocation)).willReturn(new ArrayList() {

```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testAddMenu() {
    String menu = "first";
    List<String> menuItems = new ArrayList<String>() {

        {
            add("1");
            add("2");
        }
    };
    given(invocation.getMethodName()).willReturn("addMenu");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { String.class, List.class });
    given(invocation.getArguments()).willReturn(new Object[] { menu, menuItems });
    given(invocation.getObjectAttachments()).willReturn(new HashMap<>());
    given(invocation.getInvoker()).willReturn(firstInvoker);
    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
    given(firstInvoker.getInterface()).willReturn(MenuService.class);
    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(firstInvoker.isAvailable()).willReturn(true);
    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
    given(secondInvoker.getInterface()).willReturn(MenuService.class);
    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(secondInvoker.isAvailable()).willReturn(true);
    given(directory.list(invocation)).willReturn(new ArrayList() {

        {
            add(firstInvoker);
            add(secondInvoker);
        }
    });
    given(directory.getUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getInterface()).willReturn(MenuService.class);
    mergeableClusterInvoker = new MergeableClusterInvoker<MenuService>(directory);
    Result result = mergeableClusterInvoker.invoke(invocation);
    Assertions.assertNull(result.getValue());
}
@BeforeEach
public void setUp() throws Exception {
    directory = mock(Directory.class);
    firstInvoker = mock(Invoker.class);
    secondInvoker = mock(Invoker.class);
    invocation = mock(RpcInvocation.class);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_27
#### Test Case Name: `testInvokerToNoInvokerAvailableException`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\MergeableClusterInvokerTest.java`)
#### Mock Object Variable Name: `secondInvoker`
<summary>Suggested Diff</summary>

```diff
--- a/TestClass.java
+++ b/TestClass.java
@@
    given(firstInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NO_INVOKER_AVAILABLE_AFTER_FILTER));
-    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
-    given(secondInvoker.getInterface()).willReturn(MenuService.class);
-    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
-    given(secondInvoker.isAvailable()).willReturn(true);
-    given(secondInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NO_INVOKER_AVAILABLE_AFTER_FILTER));
+    secondInvoker = MockInvoker.createMockInvoker(true);
+    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
+    given(secondInvoker.getInterface()).willReturn(MenuService.class);
+    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
+    given(secondInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NO_INVOKER_AVAILABLE_AFTER_FILTER));
    given(directory.list(invocation)).willReturn(new ArrayList() {
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testInvokerToNoInvokerAvailableException() {
    String menu = "first";
    List<String> menuItems = new ArrayList<String>() {

        {
            add("1");
            add("2");
        }
    };
    given(invocation.getMethodName()).willReturn("addMenu");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { String.class, List.class });
    given(invocation.getArguments()).willReturn(new Object[] { menu, menuItems });
    given(invocation.getObjectAttachments()).willReturn(new HashMap<>());
    given(invocation.getInvoker()).willReturn(firstInvoker);
    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
    given(firstInvoker.getInterface()).willReturn(MenuService.class);
    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(firstInvoker.isAvailable()).willReturn(true);
    given(firstInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NO_INVOKER_AVAILABLE_AFTER_FILTER));
    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
    given(secondInvoker.getInterface()).willReturn(MenuService.class);
    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(secondInvoker.isAvailable()).willReturn(true);
    given(secondInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NO_INVOKER_AVAILABLE_AFTER_FILTER));
    given(directory.list(invocation)).willReturn(new ArrayList() {

        {
            add(firstInvoker);
            add(secondInvoker);
        }
    });
    given(directory.getUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getInterface()).willReturn(MenuService.class);
    mergeableClusterInvoker = new MergeableClusterInvoker<MenuService>(directory);
    // invoke
    try {
        Result result = mergeableClusterInvoker.invoke(invocation);
        fail();
        Assertions.assertNull(result.getValue());
    } catch (RpcException expected) {
        assertEquals(expected.getCode(), RpcException.NO_INVOKER_AVAILABLE_AFTER_FILTER);
    }
}
@BeforeEach
public void setUp() throws Exception {
    directory = mock(Directory.class);
    firstInvoker = mock(Invoker.class);
    secondInvoker = mock(Invoker.class);
    invocation = mock(RpcInvocation.class);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_28
#### Test Case Name: `testInvokerToException`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\MergeableClusterInvokerTest.java`)
#### Mock Object Variable Name: `secondInvoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(firstInvoker.isAvailable()).willReturn(true);
    given(firstInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NETWORK_EXCEPTION));
-    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
-    given(secondInvoker.getInterface()).willReturn(MenuService.class);
-    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
-    given(secondInvoker.isAvailable()).willReturn(true);
-    given(secondInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NETWORK_EXCEPTION));
+    secondInvoker = MockInvoker.createMockInvoker(true);
+    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
+    given(secondInvoker.getInterface()).willReturn(MenuService.class);
+    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
+    given(secondInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NETWORK_EXCEPTION));
    given(directory.list(invocation)).willReturn(new ArrayList() {

```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setUp() throws Exception {
    directory = mock(Directory.class);
    firstInvoker = mock(Invoker.class);
    secondInvoker = mock(Invoker.class);
    invocation = mock(RpcInvocation.class);
}
/**
 * test when network exception
 */
@Test
void testInvokerToException() {
    String menu = "first";
    List<String> menuItems = new ArrayList<String>() {

        {
            add("1");
            add("2");
        }
    };
    given(invocation.getMethodName()).willReturn("addMenu");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { String.class, List.class });
    given(invocation.getArguments()).willReturn(new Object[] { menu, menuItems });
    given(invocation.getObjectAttachments()).willReturn(new HashMap<>());
    given(invocation.getInvoker()).willReturn(firstInvoker);
    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
    given(firstInvoker.getInterface()).willReturn(MenuService.class);
    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(firstInvoker.isAvailable()).willReturn(true);
    given(firstInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NETWORK_EXCEPTION));
    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
    given(secondInvoker.getInterface()).willReturn(MenuService.class);
    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(secondInvoker.isAvailable()).willReturn(true);
    given(secondInvoker.invoke(invocation)).willThrow(new RpcException(RpcException.NETWORK_EXCEPTION));
    given(directory.list(invocation)).willReturn(new ArrayList() {

        {
            add(firstInvoker);
            add(secondInvoker);
        }
    });
    given(directory.getUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getInterface()).willReturn(MenuService.class);
    mergeableClusterInvoker = new MergeableClusterInvoker<MenuService>(directory);
    // invoke
    try {
        Result result = mergeableClusterInvoker.invoke(invocation);
        fail();
        Assertions.assertNull(result.getValue());
    } catch (RpcException expected) {
        assertEquals(expected.getCode(), RpcException.NETWORK_EXCEPTION);
    }
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_43_29
#### Test Case Name: `testGetMenuResultHasException`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\MergeableClusterInvokerTest.java`)
#### Mock Object Variable Name: `secondInvoker`
<summary>Suggested Diff</summary>

```diff
--- a/TestClass.java
+++ b/TestClass.java
@@
     given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
     given(firstInvoker.getInterface()).willReturn(MenuService.class);
     given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
     given(firstInvoker.isAvailable()).willReturn(true);
-    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
-    given(secondInvoker.getInterface()).willReturn(MenuService.class);
-    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
-    given(secondInvoker.isAvailable()).willReturn(true);
+    secondInvoker = MockInvoker.createMockInvoker(true);
+    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
+    given(secondInvoker.getInterface()).willReturn(MenuService.class);
+    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
     given(directory.list(invocation)).willReturn(new ArrayList() {

```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setUp() throws Exception {
    directory = mock(Directory.class);
    firstInvoker = mock(Invoker.class);
    secondInvoker = mock(Invoker.class);
    invocation = mock(RpcInvocation.class);
}
@Test
void testGetMenuResultHasException() {
    // setup
    url = url.addParameter(MERGER_KEY, ".merge");
    given(invocation.getMethodName()).willReturn("getMenu");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] {});
    given(invocation.getArguments()).willReturn(new Object[] {});
    given(invocation.getObjectAttachments()).willReturn(new HashMap<>());
    given(invocation.getInvoker()).willReturn(firstInvoker);
    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
    given(firstInvoker.getInterface()).willReturn(MenuService.class);
    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(firstInvoker.isAvailable()).willReturn(true);
    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
    given(secondInvoker.getInterface()).willReturn(MenuService.class);
    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(secondInvoker.isAvailable()).willReturn(true);
    given(directory.list(invocation)).willReturn(new ArrayList() {

        {
            add(firstInvoker);
            add(secondInvoker);
        }
    });
    given(directory.getUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getInterface()).willReturn(MenuService.class);
    mergeableClusterInvoker = new MergeableClusterInvoker<MenuService>(directory);
    // invoke
    try {
        Result result = mergeableClusterInvoker.invoke(invocation);
        fail();
        Assertions.assertNull(result.getValue());
    } catch (RpcException expected) {
        Assertions.assertTrue(expected.getMessage().contains("Failed to invoke service"));
    }
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker and stubs isAvailable() to return the given value.
     *
     * @param isAvailableReturn the value to return from isAvailable()
     * @return the configured mock Invoker
     */
    public static Invoker createMockInvoker(boolean isAvailableReturn) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.isAvailable()).thenReturn(isAvailableReturn);
        return invoker;
    }
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_44
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.Invoker`
- **Test Case Count**: 1
- **MO Count**: 2

### Reusable Method
```java
private static Invoker createMockInvoker(URL url, Invocation invocation, AppResponse appResponse) {
    Invoker invoker = mock(Invoker.class);
    given(invoker.getInterface()).willReturn(MenuService.class);
    given(invoker.getUrl()).willReturn(url);
    given(invoker.invoke(invocation)).willReturn(appResponse);
    return invoker;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_44_1
#### Test Case Name: `testDestroy`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\MergeableClusterInvokerTest.java`)
#### Mock Object Variable Name: `secondInvoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
     given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
     given(firstInvoker.getInterface()).willReturn(MenuService.class);
     given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
-    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
-    given(secondInvoker.getInterface()).willReturn(MenuService.class);
-    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
+    secondInvoker = createMockInvoker(url.addParameter(GROUP_KEY, "second"), invocation, new AppResponse());
     given(directory.list(invocation)).willReturn(new ArrayList() {

```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testDestroy() {
    given(invocation.getMethodName()).willReturn("getMenu");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] {});
    given(invocation.getArguments()).willReturn(new Object[] {});
    given(invocation.getObjectAttachments()).willReturn(new HashMap<>());
    given(invocation.getInvoker()).willReturn(firstInvoker);
    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
    given(firstInvoker.getInterface()).willReturn(MenuService.class);
    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
    given(secondInvoker.getInterface()).willReturn(MenuService.class);
    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(directory.list(invocation)).willReturn(new ArrayList() {

        {
            add(firstInvoker);
            add(secondInvoker);
        }
    });
    given(directory.getUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getInterface()).willReturn(MenuService.class);
    mergeableClusterInvoker = new MergeableClusterInvoker<MenuService>(directory);
    mergeableClusterInvoker.destroy();
    assertFalse(firstInvoker.isAvailable());
    assertFalse(secondInvoker.isAvailable());
}
@BeforeEach
public void setUp() throws Exception {
    directory = mock(Directory.class);
    firstInvoker = mock(Invoker.class);
    secondInvoker = mock(Invoker.class);
    invocation = mock(RpcInvocation.class);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker createMockInvoker(URL url, Invocation invocation, AppResponse appResponse) {
    Invoker invoker = mock(Invoker.class);
    given(invoker.getInterface()).willReturn(MenuService.class);
    given(invoker.getUrl()).willReturn(url);
    given(invoker.invoke(invocation)).willReturn(appResponse);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_44_2
#### Test Case Name: `testDestroy`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\MergeableClusterInvokerTest.java`)
#### Mock Object Variable Name: `firstInvoker`
<summary>Suggested Diff</summary>

```diff
--- a/TestClass.java
+++ b/TestClass.java
@@
    given(invocation.getObjectAttachments()).willReturn(new HashMap<>());
    given(invocation.getInvoker()).willReturn(firstInvoker);
-    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
-    given(firstInvoker.getInterface()).willReturn(MenuService.class);
-    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
+    firstInvoker = createMockInvoker(url.addParameter(GROUP_KEY, "first"), invocation, new AppResponse());
    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
    given(secondInvoker.getInterface()).willReturn(MenuService.class);
    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(directory.list(invocation)).willReturn(new ArrayList() {

```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testDestroy() {
    given(invocation.getMethodName()).willReturn("getMenu");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] {});
    given(invocation.getArguments()).willReturn(new Object[] {});
    given(invocation.getObjectAttachments()).willReturn(new HashMap<>());
    given(invocation.getInvoker()).willReturn(firstInvoker);
    given(firstInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "first"));
    given(firstInvoker.getInterface()).willReturn(MenuService.class);
    given(firstInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(secondInvoker.getUrl()).willReturn(url.addParameter(GROUP_KEY, "second"));
    given(secondInvoker.getInterface()).willReturn(MenuService.class);
    given(secondInvoker.invoke(invocation)).willReturn(new AppResponse());
    given(directory.list(invocation)).willReturn(new ArrayList() {

        {
            add(firstInvoker);
            add(secondInvoker);
        }
    });
    given(directory.getUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getConsumerUrl()).willReturn(url);
    given(directory.getInterface()).willReturn(MenuService.class);
    mergeableClusterInvoker = new MergeableClusterInvoker<MenuService>(directory);
    mergeableClusterInvoker.destroy();
    assertFalse(firstInvoker.isAvailable());
    assertFalse(secondInvoker.isAvailable());
}
@BeforeEach
public void setUp() throws Exception {
    directory = mock(Directory.class);
    firstInvoker = mock(Invoker.class);
    secondInvoker = mock(Invoker.class);
    invocation = mock(RpcInvocation.class);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker createMockInvoker(URL url, Invocation invocation, AppResponse appResponse) {
    Invoker invoker = mock(Invoker.class);
    given(invoker.getInterface()).willReturn(MenuService.class);
    given(invoker.getUrl()).willReturn(url);
    given(invoker.invoke(invocation)).willReturn(appResponse);
    return invoker;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_45
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.Invoker`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static Invoker<Object> createMockInvoker(URL url) {
    Invoker<Object> invoker = Mockito.mock(Invoker.class);
    when(invoker.getUrl()).thenReturn(url);
    return invoker;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_45_1
#### Test Case Name: `testRoutePathMatch`(File: `C:\Java_projects\Apache\dubbo\dubbo-xds\src\test\java\org\apache\dubbo\rpc\cluster\router\xds\XdsRouteTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Invocation invocation = Mockito.mock(Invocation.class);
-    Invoker invoker = Mockito.mock(Invoker.class);
-    URL url1 = Mockito.mock(URL.class);
-    when(invoker.getUrl()).thenReturn(url1);
+    URL url1 = Mockito.mock(URL.class);
+    Invoker<Object> invoker = createMockInvoker(url1);
    when(url1.getPath()).thenReturn("DemoInterface");
    when(invocation.getInvoker()).thenReturn(invoker);
    when(invocation.getMethodName()).thenReturn("call");
    Set<Endpoint> endpoints = new HashSet<>();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testRoutePathMatch() {
    XdsRouter<Object> xdsRouter = new XdsRouter<>(url, rdsRouteRuleManager, edsEndpointManager, true);
    String appName = "app1";
    String cluster1 = "cluster-test1";
    Invoker<Object> invoker1 = createInvoker(appName, "1.1.1.1:20880");
    BitList<Invoker<Object>> invokers = new BitList<>(Arrays.asList(invoker1, createInvoker(appName, "2.2.2.2:20880")));
    xdsRouter.notify(invokers);
    String path = "/DemoInterface/call";
    VirtualHost virtualHost = VirtualHost.newBuilder().addDomains(appName).addRoutes(Route.newBuilder().setName("route-test").setMatch(RouteMatch.newBuilder().setPath(path).build()).setRoute(RouteAction.newBuilder().setCluster(cluster1).build()).build()).build();
    RdsVirtualHostListener hostListener = new RdsVirtualHostListener(appName, rdsRouteRuleManager);
    hostListener.parseVirtualHost(virtualHost);
    Invocation invocation = Mockito.mock(Invocation.class);
    Invoker invoker = Mockito.mock(Invoker.class);
    URL url1 = Mockito.mock(URL.class);
    when(invoker.getUrl()).thenReturn(url1);
    when(url1.getPath()).thenReturn("DemoInterface");
    when(invocation.getInvoker()).thenReturn(invoker);
    when(invocation.getMethodName()).thenReturn("call");
    Set<Endpoint> endpoints = new HashSet<>();
    Endpoint endpoint1 = new Endpoint();
    endpoint1.setAddress("1.1.1.1");
    endpoint1.setPortValue(20880);
    endpoints.add(endpoint1);
    edsEndpointManager.notifyEndpointChange(cluster1, endpoints);
    BitList<Invoker<Object>> routes = xdsRouter.route(invokers.clone(), null, invocation, false, null);
    assertEquals(1, routes.size());
    assertEquals(invoker1, routes.get(0));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker<Object> createMockInvoker(URL url) {
    Invoker<Object> invoker = Mockito.mock(Invoker.class);
    when(invoker.getUrl()).thenReturn(url);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_45_2
#### Test Case Name: `testRouteMultiApp`(File: `C:\Java_projects\Apache\dubbo\dubbo-xds\src\test\java\org\apache\dubbo\rpc\cluster\router\xds\XdsRouteTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Invocation invocation = Mockito.mock(Invocation.class);
-    Invoker invoker = Mockito.mock(Invoker.class);
-    URL url1 = Mockito.mock(URL.class);
-    when(invoker.getUrl()).thenReturn(url1);
+    URL url1 = Mockito.mock(URL.class);
+    Invoker<Object> invoker = createMockInvoker(url1);
    when(url1.getPath()).thenReturn("DemoInterface");
    when(invocation.getInvoker()).thenReturn(invoker);
    when(invocation.getMethodName()).thenReturn("call");
    Set<Endpoint> endpoints = new HashSet<>();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
public void testRouteMultiApp() {
    XdsRouter<Object> xdsRouter = new XdsRouter<>(url, rdsRouteRuleManager, edsEndpointManager, true);
    String appName1 = "app1";
    String appName2 = "app2";
    String cluster1 = "cluster-test1";
    Invoker<Object> invoker1 = createInvoker(appName2, "1.1.1.1:20880");
    Invoker<Object> invoker2 = createInvoker(appName1, "2.2.2.2:20880");
    BitList<Invoker<Object>> invokers = new BitList<>(Arrays.asList(invoker1, invoker2));
    xdsRouter.notify(invokers);
    assertEquals(xdsRouter.getSubscribeApplications().size(), 2);
    String path = "/DemoInterface/call";
    VirtualHost virtualHost = VirtualHost.newBuilder().addDomains(appName2).addRoutes(Route.newBuilder().setName("route-test").setMatch(RouteMatch.newBuilder().setPath(path).build()).setRoute(RouteAction.newBuilder().setCluster(cluster1).build()).build()).build();
    RdsVirtualHostListener hostListener = new RdsVirtualHostListener(appName2, rdsRouteRuleManager);
    hostListener.parseVirtualHost(virtualHost);
    Invocation invocation = Mockito.mock(Invocation.class);
    Invoker invoker = Mockito.mock(Invoker.class);
    URL url1 = Mockito.mock(URL.class);
    when(invoker.getUrl()).thenReturn(url1);
    when(url1.getPath()).thenReturn("DemoInterface");
    when(invocation.getInvoker()).thenReturn(invoker);
    when(invocation.getMethodName()).thenReturn("call");
    Set<Endpoint> endpoints = new HashSet<>();
    Endpoint endpoint1 = new Endpoint();
    endpoint1.setAddress("1.1.1.1");
    endpoint1.setPortValue(20880);
    endpoints.add(endpoint1);
    edsEndpointManager.notifyEndpointChange(cluster1, endpoints);
    BitList<Invoker<Object>> routes = xdsRouter.route(invokers.clone(), null, invocation, false, null);
    assertEquals(1, routes.size());
    assertEquals(invoker1, routes.get(0));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker<Object> createMockInvoker(URL url) {
    Invoker<Object> invoker = Mockito.mock(Invoker.class);
    when(invoker.getUrl()).thenReturn(url);
    return invoker;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_46
- **Scope**: class level
- **Mocked Class**: `org.apache.dubbo.rpc.Invoker`
- **Test Case Count**: 11
- **MO Count**: 11

### Reusable Method
```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with shared stubbing for getInterface() and getUrl().
     *
     * @param url the URL to be returned by getUrl()
     * @return a configured mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        given(invoker.getInterface()).willReturn(DemoService.class);
        given(invoker.getUrl()).willReturn(url);
        return invoker;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_46_1
#### Test Case Name: `testInvokerGeneric`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\CompatibleFilterFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
    invocation = mock(RpcInvocation.class);
    given(invocation.getMethodName()).willReturn("$enumlength");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Enum.class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
-    invoker = mock(Invoker.class);
-    given(invoker.isAvailable()).willReturn(true);
-    given(invoker.getInterface()).willReturn(DemoService.class);
+    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
+    invoker = MockInvoker.createMockInvoker(url);
+    given(invoker.isAvailable()).willReturn(true);
    AppResponse result = new AppResponse();
    result.setValue("High");
-    given(invoker.invoke(invocation)).willReturn(result);
-    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
-    given(invoker.getUrl()).willReturn(url);
+    given(invoker.invoke(invocation)).willReturn(result);
    Result filterResult = compatibleFilter.invoke(invoker, invocation);
    assertEquals(filterResult, result);
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testInvokerGeneric() {
    invocation = mock(RpcInvocation.class);
    given(invocation.getMethodName()).willReturn("$enumlength");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Enum.class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
    invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("High");
    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    Result filterResult = compatibleFilter.invoke(invoker, invocation);
    assertEquals(filterResult, result);
}
@AfterEach
public void tearDown() {
    Mockito.reset(invocation, invoker);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with shared stubbing for getInterface() and getUrl().
     *
     * @param url the URL to be returned by getUrl()
     * @return a configured mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        given(invoker.getInterface()).willReturn(DemoService.class);
        given(invoker.getUrl()).willReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_46_2
#### Test Case Name: `testResultHasException`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\CompatibleFilterFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
    invocation = mock(RpcInvocation.class);
    given(invocation.getMethodName()).willReturn("enumlength");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Enum.class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
-    invoker = mock(Invoker.class);
-    given(invoker.isAvailable()).willReturn(true);
-    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setException(new RuntimeException());
    result.setValue("High");
-    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
-    given(invoker.getUrl()).willReturn(url);
+    invoker = MockInvoker.createMockInvoker(url);
+    given(invoker.isAvailable()).willReturn(true);
+    given(invoker.invoke(invocation)).willReturn(result);
    Result filterResult = compatibleFilter.invoke(invoker, invocation);
    assertEquals(filterResult, result);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testResultHasException() {
    invocation = mock(RpcInvocation.class);
    given(invocation.getMethodName()).willReturn("enumlength");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Enum.class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
    invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setException(new RuntimeException());
    result.setValue("High");
    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    Result filterResult = compatibleFilter.invoke(invoker, invocation);
    assertEquals(filterResult, result);
}
@AfterEach
public void tearDown() {
    Mockito.reset(invocation, invoker);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with shared stubbing for getInterface() and getUrl().
     *
     * @param url the URL to be returned by getUrl()
     * @return a configured mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        given(invoker.getInterface()).willReturn(DemoService.class);
        given(invoker.getUrl()).willReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_46_3
#### Test Case Name: `testInvokerJsonPojoSerialization`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\CompatibleFilterFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Type[].class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
-    invoker = mock(Invoker.class);
-    given(invoker.isAvailable()).willReturn(true);
-    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("High");
    AsyncRpcResult defaultAsyncResult = AsyncRpcResult.newDefaultAsyncResult(result, invocation);
-    given(invoker.invoke(invocation)).willReturn(defaultAsyncResult);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1&serialization=json");
-    given(invoker.getUrl()).willReturn(url);
+    invoker = MockInvoker.createMockInvoker(url);
+    given(invoker.isAvailable()).willReturn(true);
+    given(invoker.invoke(invocation)).willReturn(defaultAsyncResult);
    Result asyncResult = compatibleFilter.invoke(invoker, invocation);
    AppResponse appResponse = (AppResponse) asyncResult.get();
    compatibleFilter.onResponse(appResponse, invoker, invocation);
    assertEquals(Type.High, appResponse.getValue());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testInvokerJsonPojoSerialization() throws Exception {
    invocation = mock(RpcInvocation.class);
    given(invocation.getMethodName()).willReturn("enumlength");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Type[].class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
    invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("High");
    AsyncRpcResult defaultAsyncResult = AsyncRpcResult.newDefaultAsyncResult(result, invocation);
    given(invoker.invoke(invocation)).willReturn(defaultAsyncResult);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1&serialization=json");
    given(invoker.getUrl()).willReturn(url);
    Result asyncResult = compatibleFilter.invoke(invoker, invocation);
    AppResponse appResponse = (AppResponse) asyncResult.get();
    compatibleFilter.onResponse(appResponse, invoker, invocation);
    assertEquals(Type.High, appResponse.getValue());
}
@AfterEach
public void tearDown() {
    Mockito.reset(invocation, invoker);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with shared stubbing for getInterface() and getUrl().
     *
     * @param url the URL to be returned by getUrl()
     * @return a configured mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        given(invoker.getInterface()).willReturn(DemoService.class);
        given(invoker.getUrl()).willReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_46_4
#### Test Case Name: `testInvokerNonJsonEnumSerialization`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\CompatibleFilterFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Type[].class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
-    invoker = mock(Invoker.class);
-    given(invoker.isAvailable()).willReturn(true);
-    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("High");
    AsyncRpcResult defaultAsyncResult = AsyncRpcResult.newDefaultAsyncResult(result, invocation);
-    given(invoker.invoke(invocation)).willReturn(defaultAsyncResult);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
-    given(invoker.getUrl()).willReturn(url);
+    invoker = MockInvoker.createMockInvoker(url);
+    given(invoker.isAvailable()).willReturn(true);
+    given(invoker.invoke(invocation)).willReturn(defaultAsyncResult);
    Result asyncResult = compatibleFilter.invoke(invoker, invocation);
    AppResponse appResponse = (AppResponse) asyncResult.get();
    compatibleFilter.onResponse(appResponse, invoker, invocation);
    assertEquals(Type.High, appResponse.getValue());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testInvokerNonJsonEnumSerialization() throws Exception {
    invocation = mock(RpcInvocation.class);
    given(invocation.getMethodName()).willReturn("enumlength");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { Type[].class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
    invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("High");
    AsyncRpcResult defaultAsyncResult = AsyncRpcResult.newDefaultAsyncResult(result, invocation);
    given(invoker.invoke(invocation)).willReturn(defaultAsyncResult);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    Result asyncResult = compatibleFilter.invoke(invoker, invocation);
    AppResponse appResponse = (AppResponse) asyncResult.get();
    compatibleFilter.onResponse(appResponse, invoker, invocation);
    assertEquals(Type.High, appResponse.getValue());
}
@AfterEach
public void tearDown() {
    Mockito.reset(invocation, invoker);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with shared stubbing for getInterface() and getUrl().
     *
     * @param url the URL to be returned by getUrl()
     * @return a configured mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        given(invoker.getInterface()).willReturn(DemoService.class);
        given(invoker.getUrl()).willReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_46_5
#### Test Case Name: `testInvokerNonJsonNonPojoSerialization`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\CompatibleFilterFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { String.class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
-    invoker = mock(Invoker.class);
-    given(invoker.isAvailable()).willReturn(true);
-    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue(new String[] { "High" });
-    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
-    given(invoker.getUrl()).willReturn(url);
+    invoker = MockInvoker.createMockInvoker(url);
+    given(invoker.isAvailable()).willReturn(true);
+    given(invoker.invoke(invocation)).willReturn(result);
    Result filterResult = compatibleFilter.invoke(invoker, invocation);
    assertArrayEquals(new String[] { "High" }, (String[]) filterResult.getValue());
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testInvokerNonJsonNonPojoSerialization() {
    invocation = mock(RpcInvocation.class);
    given(invocation.getMethodName()).willReturn("echo");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { String.class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
    invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue(new String[] { "High" });
    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    Result filterResult = compatibleFilter.invoke(invoker, invocation);
    assertArrayEquals(new String[] { "High" }, (String[]) filterResult.getValue());
}
@AfterEach
public void tearDown() {
    Mockito.reset(invocation, invoker);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with shared stubbing for getInterface() and getUrl().
     *
     * @param url the URL to be returned by getUrl()
     * @return a configured mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        given(invoker.getInterface()).willReturn(DemoService.class);
        given(invoker.getUrl()).willReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_46_6
#### Test Case Name: `testInvokerNonJsonPojoSerialization`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\CompatibleFilterFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
     given(invocation.getParameterTypes()).willReturn(new Class<?>[] { String.class });
     given(invocation.getArguments()).willReturn(new Object[] { "hello" });
-    invoker = mock(Invoker.class);
-    given(invoker.isAvailable()).willReturn(true);
-    given(invoker.getInterface()).willReturn(DemoService.class);
     AppResponse result = new AppResponse();
     result.setValue("hello");
-    given(invoker.invoke(invocation)).willReturn(result);
     URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
-    given(invoker.getUrl()).willReturn(url);
+    invoker = MockInvoker.createMockInvoker(url);
+    given(invoker.isAvailable()).willReturn(true);
+    given(invoker.invoke(invocation)).willReturn(result);
     Result filterResult = compatibleFilter.invoke(invoker, invocation);
     assertEquals("hello", filterResult.getValue());
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
void testInvokerNonJsonPojoSerialization() {
    invocation = mock(RpcInvocation.class);
    given(invocation.getMethodName()).willReturn("echo");
    given(invocation.getParameterTypes()).willReturn(new Class<?>[] { String.class });
    given(invocation.getArguments()).willReturn(new Object[] { "hello" });
    invoker = mock(Invoker.class);
    given(invoker.isAvailable()).willReturn(true);
    given(invoker.getInterface()).willReturn(DemoService.class);
    AppResponse result = new AppResponse();
    result.setValue("hello");
    given(invoker.invoke(invocation)).willReturn(result);
    URL url = URL.valueOf("test://test:11/test?group=dubbo&version=1.1");
    given(invoker.getUrl()).willReturn(url);
    Result filterResult = compatibleFilter.invoke(invoker, invocation);
    assertEquals("hello", filterResult.getValue());
}
@AfterEach
public void tearDown() {
    Mockito.reset(invocation, invoker);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with shared stubbing for getInterface() and getUrl().
     *
     * @param url the URL to be returned by getUrl()
     * @return a configured mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        given(invoker.getInterface()).willReturn(DemoService.class);
        given(invoker.getUrl()).willReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_46_7
#### Test Case Name: `testInvokeWithDefault`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\GenericFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    URL url = URL.valueOf("test://test:11/org.apache.dubbo.rpc.support.DemoService?" + "accesslog=true&group=dubbo&version=1.1");
-    Invoker invoker = Mockito.mock(Invoker.class);
-    when(invoker.invoke(any(Invocation.class))).thenReturn(AsyncRpcResult.newDefaultAsyncResult(new Person("person", 10), invocation));
-    when(invoker.getUrl()).thenReturn(url);
-    when(invoker.getInterface()).thenReturn(DemoService.class);
+    Invoker invoker = MockInvoker.createMockInvoker(url);
+    when(invoker.invoke(any(Invocation.class))).thenReturn(AsyncRpcResult.newDefaultAsyncResult(new Person("person", 10), invocation));
    Result asyncResult = genericFilter.invoke(invoker, invocation);
    AppResponse appResponse = (AppResponse) asyncResult.get();
    genericFilter.onResponse(appResponse, invoker, invocation);
    Assertions.assertEquals(HashMap.class, appResponse.getValue().getClass());
    Assertions.assertEquals(10, ((HashMap) appResponse.getValue()).get("age"));
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testInvokeWithDefault() throws Exception {
    Method genericInvoke = GenericService.class.getMethods()[0];
    Map<String, Object> person = new HashMap<String, Object>();
    person.put("name", "dubbo");
    person.put("age", 10);
    RpcInvocation invocation = new RpcInvocation($INVOKE, GenericService.class.getName(), "", genericInvoke.getParameterTypes(), new Object[] { "getPerson", new String[] { Person.class.getCanonicalName() }, new Object[] { person } });
    URL url = URL.valueOf("test://test:11/org.apache.dubbo.rpc.support.DemoService?" + "accesslog=true&group=dubbo&version=1.1");
    Invoker invoker = Mockito.mock(Invoker.class);
    when(invoker.invoke(any(Invocation.class))).thenReturn(AsyncRpcResult.newDefaultAsyncResult(new Person("person", 10), invocation));
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(DemoService.class);
    Result asyncResult = genericFilter.invoke(invoker, invocation);
    AppResponse appResponse = (AppResponse) asyncResult.get();
    genericFilter.onResponse(appResponse, invoker, invocation);
    Assertions.assertEquals(HashMap.class, appResponse.getValue().getClass());
    Assertions.assertEquals(10, ((HashMap) appResponse.getValue()).get("age"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with shared stubbing for getInterface() and getUrl().
     *
     * @param url the URL to be returned by getUrl()
     * @return a configured mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        given(invoker.getInterface()).willReturn(DemoService.class);
        given(invoker.getUrl()).willReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_46_8
#### Test Case Name: `testInvokeWithMethodNamtNot$Invoke`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\GenericFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    URL url = URL.valueOf("test://test:11/org.apache.dubbo.rpc.support.DemoService?" + "accesslog=true&group=dubbo&version=1.1");
-    Invoker invoker = Mockito.mock(Invoker.class);
-    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse(new Person("person", 10)));
-    when(invoker.getUrl()).thenReturn(url);
-    when(invoker.getInterface()).thenReturn(DemoService.class);
+    Invoker invoker = MockInvoker.createMockInvoker(url);
+    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse(new Person("person", 10)));
    Result result = genericFilter.invoke(invoker, invocation);
    Assertions.assertEquals(Person.class, result.getValue().getClass());
    Assertions.assertEquals(10, ((Person) (result.getValue())).getAge());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testInvokeWithMethodNamtNot$Invoke() {
    Method genericInvoke = GenericService.class.getMethods()[0];
    Map<String, Object> person = new HashMap<String, Object>();
    person.put("name", "dubbo");
    person.put("age", 10);
    RpcInvocation invocation = new RpcInvocation("sayHi", GenericService.class.getName(), "", genericInvoke.getParameterTypes(), new Object[] { "getPerson", new String[] { Person.class.getCanonicalName() }, new Object[] { person } });
    URL url = URL.valueOf("test://test:11/org.apache.dubbo.rpc.support.DemoService?" + "accesslog=true&group=dubbo&version=1.1");
    Invoker invoker = Mockito.mock(Invoker.class);
    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse(new Person("person", 10)));
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(DemoService.class);
    Result result = genericFilter.invoke(invoker, invocation);
    Assertions.assertEquals(Person.class, result.getValue().getClass());
    Assertions.assertEquals(10, ((Person) (result.getValue())).getAge());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with shared stubbing for getInterface() and getUrl().
     *
     * @param url the URL to be returned by getUrl()
     * @return a configured mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        given(invoker.getInterface()).willReturn(DemoService.class);
        given(invoker.getUrl()).willReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_46_9
#### Test Case Name: `testInvokeWithMethodArgumentSizeIsNot3`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\GenericFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    URL url = URL.valueOf("test://test:11/org.apache.dubbo.rpc.support.DemoService?" + "accesslog=true&group=dubbo&version=1.1");
-    Invoker invoker = Mockito.mock(Invoker.class);
-    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse(new Person("person", 10)));
-    when(invoker.getUrl()).thenReturn(url);
-    when(invoker.getInterface()).thenReturn(DemoService.class);
+    Invoker invoker = MockInvoker.createMockInvoker(url);
+    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse(new Person("person", 10)));
    Result result = genericFilter.invoke(invoker, invocation);
    Assertions.assertEquals(Person.class, result.getValue().getClass());
    Assertions.assertEquals(10, ((Person) (result.getValue())).getAge());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testInvokeWithMethodArgumentSizeIsNot3() {
    Method genericInvoke = GenericService.class.getMethods()[0];
    Map<String, Object> person = new HashMap<String, Object>();
    person.put("name", "dubbo");
    person.put("age", 10);
    RpcInvocation invocation = new RpcInvocation($INVOKE, GenericService.class.getName(), "", genericInvoke.getParameterTypes(), new Object[] { "getPerson", new String[] { Person.class.getCanonicalName() } });
    URL url = URL.valueOf("test://test:11/org.apache.dubbo.rpc.support.DemoService?" + "accesslog=true&group=dubbo&version=1.1");
    Invoker invoker = Mockito.mock(Invoker.class);
    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse(new Person("person", 10)));
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(DemoService.class);
    Result result = genericFilter.invoke(invoker, invocation);
    Assertions.assertEquals(Person.class, result.getValue().getClass());
    Assertions.assertEquals(10, ((Person) (result.getValue())).getAge());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with shared stubbing for getInterface() and getUrl().
     *
     * @param url the URL to be returned by getUrl()
     * @return a configured mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        given(invoker.getInterface()).willReturn(DemoService.class);
        given(invoker.getUrl()).willReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_46_10
#### Test Case Name: `testInvoke`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\GenericImplFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    URL url = URL.valueOf("test://test:11/org.apache.dubbo.rpc.support.DemoService?" + "accesslog=true&group=dubbo&version=1.1&generic=true");
-    Invoker invoker = Mockito.mock(Invoker.class);
    Map<String, Object> person = new HashMap<String, Object>();
    person.put("name", "dubbo");
    person.put("age", 10);
    AppResponse mockRpcResult = new AppResponse(person);
+    Invoker invoker = MockInvoker.createMockInvoker(url);
    when(invoker.invoke(any(Invocation.class))).thenReturn(AsyncRpcResult.newDefaultAsyncResult(mockRpcResult, invocation));
-    when(invoker.getUrl()).thenReturn(url);
-    when(invoker.getInterface()).thenReturn(DemoService.class);
    Result asyncResult = genericImplFilter.invoke(invoker, invocation);
    Result result = asyncResult.get();
    genericImplFilter.onResponse(result, invoker, invocation);
    Assertions.assertEquals(Person.class, result.getValue().getClass());
    Assertions.assertEquals(10, ((Person) result.getValue()).getAge());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testInvoke() throws Exception {
    RpcInvocation invocation = new RpcInvocation("getPerson", "org.apache.dubbo.rpc.support.DemoService", "org.apache.dubbo.rpc.support.DemoService:dubbo", new Class[] { Person.class }, new Object[] { new Person("dubbo", 10) });
    URL url = URL.valueOf("test://test:11/org.apache.dubbo.rpc.support.DemoService?" + "accesslog=true&group=dubbo&version=1.1&generic=true");
    Invoker invoker = Mockito.mock(Invoker.class);
    Map<String, Object> person = new HashMap<String, Object>();
    person.put("name", "dubbo");
    person.put("age", 10);
    AppResponse mockRpcResult = new AppResponse(person);
    when(invoker.invoke(any(Invocation.class))).thenReturn(AsyncRpcResult.newDefaultAsyncResult(mockRpcResult, invocation));
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(DemoService.class);
    Result asyncResult = genericImplFilter.invoke(invoker, invocation);
    Result result = asyncResult.get();
    genericImplFilter.onResponse(result, invoker, invocation);
    Assertions.assertEquals(Person.class, result.getValue().getClass());
    Assertions.assertEquals(10, ((Person) result.getValue()).getAge());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with shared stubbing for getInterface() and getUrl().
     *
     * @param url the URL to be returned by getUrl()
     * @return a configured mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        given(invoker.getInterface()).willReturn(DemoService.class);
        given(invoker.getUrl()).willReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_46_11
#### Test Case Name: `testInvokeWithException`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\GenericImplFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    URL url = URL.valueOf("test://test:11/org.apache.dubbo.rpc.support.DemoService?" + "accesslog=true&group=dubbo&version=1.1&generic=true");
-    Invoker invoker = Mockito.mock(Invoker.class);
    AppResponse mockRpcResult = new AppResponse(new GenericException(new RuntimeException("failed")));
+    Invoker invoker = MockInvoker.createMockInvoker(url);
    when(invoker.invoke(any(Invocation.class))).thenReturn(AsyncRpcResult.newDefaultAsyncResult(mockRpcResult, invocation));
-    when(invoker.getUrl()).thenReturn(url);
-    when(invoker.getInterface()).thenReturn(DemoService.class);
    Result asyncResult = genericImplFilter.invoke(invoker, invocation);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testInvokeWithException() throws Exception {
    RpcInvocation invocation = new RpcInvocation("getPerson", "org.apache.dubbo.rpc.support.DemoService", "org.apache.dubbo.rpc.support.DemoService:dubbo", new Class[] { Person.class }, new Object[] { new Person("dubbo", 10) });
    URL url = URL.valueOf("test://test:11/org.apache.dubbo.rpc.support.DemoService?" + "accesslog=true&group=dubbo&version=1.1&generic=true");
    Invoker invoker = Mockito.mock(Invoker.class);
    AppResponse mockRpcResult = new AppResponse(new GenericException(new RuntimeException("failed")));
    when(invoker.invoke(any(Invocation.class))).thenReturn(AsyncRpcResult.newDefaultAsyncResult(mockRpcResult, invocation));
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(DemoService.class);
    Result asyncResult = genericImplFilter.invoke(invoker, invocation);
    Result result = asyncResult.get();
    genericImplFilter.onResponse(result, invoker, invocation);
    Assertions.assertEquals(RuntimeException.class, result.getException().getClass());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with shared stubbing for getInterface() and getUrl().
     *
     * @param url the URL to be returned by getUrl()
     * @return a configured mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        given(invoker.getInterface()).willReturn(DemoService.class);
        given(invoker.getUrl()).willReturn(url);
        return invoker;
    }
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_47
- **Scope**: class level
- **Mocked Class**: `org.apache.dubbo.rpc.Invoker`
- **Test Case Count**: 6
- **MO Count**: 6

### Reusable Method
```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with getUrl() stubbed to return the provided URL.
     *
     * @param url the URL to return from getUrl()
     * @return a mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_47_1
#### Test Case Name: `testInvokeWithToken`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\TokenFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
 void testInvokeWithToken() throws Exception {
     String token = "token";
-    Invoker invoker = Mockito.mock(Invoker.class);
     URL url = URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&token=" + token);
-    when(invoker.getUrl()).thenReturn(url);
+    Invoker invoker = MockInvoker.createMockInvoker(url);
     when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse("result"));
     Invocation invocation = Mockito.mock(Invocation.class);
     when(invocation.getObjectAttachmentWithoutConvert(TOKEN_KEY)).thenReturn(token);
     Result result = tokenFilter.invoke(invoker, invocation);
     Assertions.assertEquals("result", result.getValue());
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testInvokeWithToken() throws Exception {
    String token = "token";
    Invoker invoker = Mockito.mock(Invoker.class);
    URL url = URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&token=" + token);
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse("result"));
    Invocation invocation = Mockito.mock(Invocation.class);
    when(invocation.getObjectAttachmentWithoutConvert(TOKEN_KEY)).thenReturn(token);
    Result result = tokenFilter.invoke(invoker, invocation);
    Assertions.assertEquals("result", result.getValue());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with getUrl() stubbed to return the provided URL.
     *
     * @param url the URL to return from getUrl()
     * @return a mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_47_2
#### Test Case Name: `testNoExecuteLimitInvoke`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\ExecuteLimitFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testNoExecuteLimitInvoke() {
-    Invoker invoker = Mockito.mock(Invoker.class);
-    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse("result"));
-    when(invoker.getUrl()).thenReturn(URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1"));
+    Invoker invoker = MockInvoker.createMockInvoker(URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1"));
+    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse("result"));
    Invocation invocation = Mockito.mock(Invocation.class);
    when(invocation.getMethodName()).thenReturn("testNoExecuteLimitInvoke");
    Result result = executeLimitFilter.invoke(invoker, invocation);
    Assertions.assertEquals("result", result.getValue());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testNoExecuteLimitInvoke() {
    Invoker invoker = Mockito.mock(Invoker.class);
    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse("result"));
    when(invoker.getUrl()).thenReturn(URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1"));
    Invocation invocation = Mockito.mock(Invocation.class);
    when(invocation.getMethodName()).thenReturn("testNoExecuteLimitInvoke");
    Result result = executeLimitFilter.invoke(invoker, invocation);
    Assertions.assertEquals("result", result.getValue());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with getUrl() stubbed to return the provided URL.
     *
     * @param url the URL to return from getUrl()
     * @return a mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_47_3
#### Test Case Name: `testExecuteLimitInvoke`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\ExecuteLimitFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testExecuteLimitInvoke() {
-    Invoker invoker = Mockito.mock(Invoker.class);
-    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse("result"));
-    when(invoker.getUrl()).thenReturn(URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&executes=10"));
+    Invoker invoker = MockInvoker.createMockInvoker(URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&executes=10"));
+    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse("result"));
    Invocation invocation = Mockito.mock(Invocation.class);
    when(invocation.getMethodName()).thenReturn("testExecuteLimitInvoke");
    Result result = executeLimitFilter.invoke(invoker, invocation);
    Assertions.assertEquals("result", result.getValue());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testExecuteLimitInvoke() {
    Invoker invoker = Mockito.mock(Invoker.class);
    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse("result"));
    when(invoker.getUrl()).thenReturn(URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&executes=10"));
    Invocation invocation = Mockito.mock(Invocation.class);
    when(invocation.getMethodName()).thenReturn("testExecuteLimitInvoke");
    Result result = executeLimitFilter.invoke(invoker, invocation);
    Assertions.assertEquals("result", result.getValue());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with getUrl() stubbed to return the provided URL.
     *
     * @param url the URL to return from getUrl()
     * @return a mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_47_4
#### Test Case Name: `testExecuteLimitInvokeWithException`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\ExecuteLimitFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testExecuteLimitInvokeWithException() {
-    Invoker invoker = Mockito.mock(Invoker.class);
-    doThrow(new RpcException()).when(invoker).invoke(any(Invocation.class));
    URL url = URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&executes=10");
-    when(invoker.getUrl()).thenReturn(url);
+    Invoker invoker = MockInvoker.createMockInvoker(url);
+    doThrow(new RpcException()).when(invoker).invoke(any(Invocation.class));
    Invocation invocation = Mockito.mock(Invocation.class);
    when(invocation.getMethodName()).thenReturn("testExecuteLimitInvokeWitException");
    try {
        executeLimitFilter.invoke(invoker, invocation);
    } catch (Exception e) {
        Assertions.assertTrue(e instanceof RpcException);
        executeLimitFilter.onError(e, invoker, invocation);
    }
    Assertions.assertEquals(1, RpcStatus.getStatus(url, invocation.getMethodName()).getFailed());
    RpcStatus.removeStatus(url, invocation.getMethodName());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testExecuteLimitInvokeWithException() {
    Invoker invoker = Mockito.mock(Invoker.class);
    doThrow(new RpcException()).when(invoker).invoke(any(Invocation.class));
    URL url = URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&executes=10");
    when(invoker.getUrl()).thenReturn(url);
    Invocation invocation = Mockito.mock(Invocation.class);
    when(invocation.getMethodName()).thenReturn("testExecuteLimitInvokeWitException");
    try {
        executeLimitFilter.invoke(invoker, invocation);
    } catch (Exception e) {
        Assertions.assertTrue(e instanceof RpcException);
        executeLimitFilter.onError(e, invoker, invocation);
    }
    Assertions.assertEquals(1, RpcStatus.getStatus(url, invocation.getMethodName()).getFailed());
    RpcStatus.removeStatus(url, invocation.getMethodName());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with getUrl() stubbed to return the provided URL.
     *
     * @param url the URL to return from getUrl()
     * @return a mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_47_5
#### Test Case Name: `testInvokeWith$Invoke`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\GenericImplFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    URL url = URL.valueOf("test://test:11/org.apache.dubbo.rpc.support.DemoService?" + "accesslog=true&group=dubbo&version=1.1&generic=true");
-    Invoker invoker = Mockito.mock(Invoker.class);
-    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse(new Person("person", 10)));
-    when(invoker.getUrl()).thenReturn(url);
+    Invoker invoker = MockInvoker.createMockInvoker(url);
+    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse(new Person("person", 10)));
    genericImplFilter.invoke(invoker, invocation);
    Assertions.assertEquals("true", invocation.getAttachment(GENERIC_KEY));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testInvokeWith$Invoke() throws Exception {
    Method genericInvoke = GenericService.class.getMethods()[0];
    Map<String, Object> person = new HashMap<String, Object>();
    person.put("name", "dubbo");
    person.put("age", 10);
    RpcInvocation invocation = new RpcInvocation($INVOKE, GenericService.class.getName(), "org.apache.dubbo.rpc.support.DemoService:dubbo", genericInvoke.getParameterTypes(), new Object[] { "getPerson", new String[] { Person.class.getCanonicalName() }, new Object[] { person } });
    URL url = URL.valueOf("test://test:11/org.apache.dubbo.rpc.support.DemoService?" + "accesslog=true&group=dubbo&version=1.1&generic=true");
    Invoker invoker = Mockito.mock(Invoker.class);
    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse(new Person("person", 10)));
    when(invoker.getUrl()).thenReturn(url);
    genericImplFilter.invoke(invoker, invocation);
    Assertions.assertEquals("true", invocation.getAttachment(GENERIC_KEY));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with getUrl() stubbed to return the provided URL.
     *
     * @param url the URL to return from getUrl()
     * @return a mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_47_6
#### Test Case Name: `testInvokeWithoutTimeout`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\filter\TimeoutFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testInvokeWithoutTimeout() {
    int timeout = 3000;
-    Invoker invoker = Mockito.mock(Invoker.class);
-    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse("result"));
-    when(invoker.getUrl()).thenReturn(URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&timeout=" + timeout));
+    Invoker invoker = MockInvoker.createMockInvoker(URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&timeout=" + timeout));
+    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse("result"));
    Invocation invocation = Mockito.mock(Invocation.class);
    when(invocation.getMethodName()).thenReturn("testInvokeWithoutTimeout");
    Result result = timeoutFilter.invoke(invoker, invocation);
    Assertions.assertEquals("result", result.getValue());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testInvokeWithoutTimeout() {
    int timeout = 3000;
    Invoker invoker = Mockito.mock(Invoker.class);
    when(invoker.invoke(any(Invocation.class))).thenReturn(new AppResponse("result"));
    when(invoker.getUrl()).thenReturn(URL.valueOf("test://test:11/test?accesslog=true&group=dubbo&version=1.1&timeout=" + timeout));
    Invocation invocation = Mockito.mock(Invocation.class);
    when(invocation.getMethodName()).thenReturn("testInvokeWithoutTimeout");
    Result result = timeoutFilter.invoke(invoker, invocation);
    Assertions.assertEquals("result", result.getValue());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    /**
     * Creates a mock Invoker with getUrl() stubbed to return the provided URL.
     *
     * @param url the URL to return from getUrl()
     * @return a mock Invoker
     */
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = Mockito.mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_48
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.Invoker`
- **Test Case Count**: 5
- **MO Count**: 5

### Reusable Method
```java
private static Invoker createMockInvoker() {
    Invoker invoker = mock(Invoker.class);
    given(invoker.getUrl()).willReturn(URL.valueOf("test://127.0.0.1:1/org.apache.dubbo.rpc.support.DemoService?interface=org.apache.dubbo.rpc.support.DemoService"));
    return invoker;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_48_1
#### Test Case Name: `testGetReturnType`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\support\RpcUtilsTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
     Class<?> demoServiceClass = DemoService.class;
     String serviceName = demoServiceClass.getName();
-    Invoker invoker = mock(Invoker.class);
-    given(invoker.getUrl()).willReturn(URL.valueOf("test://127.0.0.1:1/org.apache.dubbo.rpc.support.DemoService?interface=org.apache.dubbo.rpc.support.DemoService"));
+    Invoker invoker = createMockInvoker();
     // void sayHello(String name);
     RpcInvocation inv = new RpcInvocation("sayHello", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
     Class<?> returnType = RpcUtils.getReturnType(inv);
     Assertions.assertNull(returnType);
     //String echo(String text);
     RpcInvocation inv1 = new RpcInvocation("echo", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
     Class<?> returnType1 = RpcUtils.getReturnType(inv1);
     Assertions.assertNotNull(returnType1);
     Assertions.assertEquals(String.class, returnType1);
     //int getSize(String[] strs);
     RpcInvocation inv2 = new RpcInvocation("getSize", serviceName, "", new Class<?>[] { String[].class }, null, null, invoker, null);
     Class<?> returnType2 = RpcUtils.getReturnType(inv2);
     Assertions.assertNotNull(returnType2);
     Assertions.assertEquals(int.class, returnType2);
     //Person getPerson(Person person);
     RpcInvocation inv3 = new RpcInvocation("getPerson", serviceName, "", new Class<?>[] { Person.class }, null, null, invoker, null);
     Class<?> returnType3 = RpcUtils.getReturnType(inv3);
     Assertions.assertNotNull(returnType3);
     Assertions.assertEquals(Person.class, returnType3);
     //List<String> testReturnType1(String str);
     RpcInvocation inv4 = new RpcInvocation("testReturnType1", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
     Class<?> returnType4 = RpcUtils.getReturnType(inv4);
     Assertions.assertNotNull(returnType4);
     Assertions.assertEquals(List.class, returnType4);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testGetReturnType() {
    Class<?> demoServiceClass = DemoService.class;
    String serviceName = demoServiceClass.getName();
    Invoker invoker = mock(Invoker.class);
    given(invoker.getUrl()).willReturn(URL.valueOf("test://127.0.0.1:1/org.apache.dubbo.rpc.support.DemoService?interface=org.apache.dubbo.rpc.support.DemoService"));
    // void sayHello(String name);
    RpcInvocation inv = new RpcInvocation("sayHello", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    Class<?> returnType = RpcUtils.getReturnType(inv);
    Assertions.assertNull(returnType);
    //String echo(String text);
    RpcInvocation inv1 = new RpcInvocation("echo", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    Class<?> returnType1 = RpcUtils.getReturnType(inv1);
    Assertions.assertNotNull(returnType1);
    Assertions.assertEquals(String.class, returnType1);
    //int getSize(String[] strs);
    RpcInvocation inv2 = new RpcInvocation("getSize", serviceName, "", new Class<?>[] { String[].class }, null, null, invoker, null);
    Class<?> returnType2 = RpcUtils.getReturnType(inv2);
    Assertions.assertNotNull(returnType2);
    Assertions.assertEquals(int.class, returnType2);
    //Person getPerson(Person person);
    RpcInvocation inv3 = new RpcInvocation("getPerson", serviceName, "", new Class<?>[] { Person.class }, null, null, invoker, null);
    Class<?> returnType3 = RpcUtils.getReturnType(inv3);
    Assertions.assertNotNull(returnType3);
    Assertions.assertEquals(Person.class, returnType3);
    //List<String> testReturnType1(String str);
    RpcInvocation inv4 = new RpcInvocation("testReturnType1", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    Class<?> returnType4 = RpcUtils.getReturnType(inv4);
    Assertions.assertNotNull(returnType4);
    Assertions.assertEquals(List.class, returnType4);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker createMockInvoker() {
    Invoker invoker = mock(Invoker.class);
    given(invoker.getUrl()).willReturn(URL.valueOf("test://127.0.0.1:1/org.apache.dubbo.rpc.support.DemoService?interface=org.apache.dubbo.rpc.support.DemoService"));
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_48_2
#### Test Case Name: `testGetReturnTypesUseCache`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\support\RpcUtilsTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Class<?> demoServiceClass = DemoService.class;
    String serviceName = demoServiceClass.getName();
-    Invoker invoker = mock(Invoker.class);
-    given(invoker.getUrl()).willReturn(URL.valueOf("test://127.0.0.1:1/org.apache.dubbo.rpc.support.DemoService?interface=org.apache.dubbo.rpc.support.DemoService"));
+    Invoker invoker = createMockInvoker();
    RpcInvocation inv = new RpcInvocation("testReturnType", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    Type[] types = RpcUtils.getReturnTypes(inv);
    Assertions.assertNotNull(types);
    Assertions.assertEquals(2, types.length);
    Assertions.assertEquals(String.class, types[0]);
    Assertions.assertEquals(String.class, types[1]);
    Assertions.assertArrayEquals(types, inv.getReturnTypes());
    RpcInvocation inv1 = new RpcInvocation("testReturnType1", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    java.lang.reflect.Type[] types1 = RpcUtils.getReturnTypes(inv1);
    Assertions.assertNotNull(types1);
    Assertions.assertEquals(2, types1.length);
    Assertions.assertEquals(List.class, types1[0]);
    Assertions.assertEquals(demoServiceClass.getMethod("testReturnType1", String.class).getGenericReturnType(), types1[1]);
    Assertions.assertArrayEquals(types1, inv1.getReturnTypes());
    RpcInvocation inv2 = new RpcInvocation("testReturnType2", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    java.lang.reflect.Type[] types2 = RpcUtils.getReturnTypes(inv2);
    Assertions.assertNotNull(types2);
    Assertions.assertEquals(2, types2.length);
    Assertions.assertEquals(String.class, types2[0]);
    Assertions.assertEquals(String.class, types2[1]);
    Assertions.assertArrayEquals(types2, inv2.getReturnTypes());
    RpcInvocation inv3 = new RpcInvocation("testReturnType3", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    java.lang.reflect.Type[] types3 = RpcUtils.getReturnTypes(inv3);
    Assertions.assertNotNull(types3);
    Assertions.assertEquals(2, types3.length);
    Assertions.assertEquals(List.class, types3[0]);
    java.lang.reflect.Type genericReturnType3 = demoServiceClass.getMethod("testReturnType3", String.class).getGenericReturnType();
    Assertions.assertEquals(((ParameterizedType) genericReturnType3).getActualTypeArguments()[0], types3[1]);
    Assertions.assertArrayEquals(types3, inv3.getReturnTypes());
    RpcInvocation inv4 = new RpcInvocation("testReturnType4", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    java.lang.reflect.Type[] types4 = RpcUtils.getReturnTypes(inv4);
    Assertions.assertNotNull(types4);
    Assertions.assertEquals(2, types4.length);
    Assertions.assertNull(types4[0]);
    Assertions.assertNull(types4[1]);
    Assertions.assertArrayEquals(types4, inv4.getReturnTypes());
    RpcInvocation inv5 = new RpcInvocation("testReturnType5", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    java.lang.reflect.Type[] types5 = RpcUtils.getReturnTypes(inv5);
    Assertions.assertNotNull(types5);
    Assertions.assertEquals(2, types5.length);
    Assertions.assertEquals(Map.class, types5[0]);
    java.lang.reflect.Type genericReturnType5 = demoServiceClass.getMethod("testReturnType5", String.class).getGenericReturnType();
    Assertions.assertEquals(((ParameterizedType) genericReturnType5).getActualTypeArguments()[0], types5[1]);
    Assertions.assertArrayEquals(types5, inv5.getReturnTypes());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testGetReturnTypesUseCache() throws Exception {
    Class<?> demoServiceClass = DemoService.class;
    String serviceName = demoServiceClass.getName();
    Invoker invoker = mock(Invoker.class);
    given(invoker.getUrl()).willReturn(URL.valueOf("test://127.0.0.1:1/org.apache.dubbo.rpc.support.DemoService?interface=org.apache.dubbo.rpc.support.DemoService"));
    RpcInvocation inv = new RpcInvocation("testReturnType", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    Type[] types = RpcUtils.getReturnTypes(inv);
    Assertions.assertNotNull(types);
    Assertions.assertEquals(2, types.length);
    Assertions.assertEquals(String.class, types[0]);
    Assertions.assertEquals(String.class, types[1]);
    Assertions.assertArrayEquals(types, inv.getReturnTypes());
    RpcInvocation inv1 = new RpcInvocation("testReturnType1", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    java.lang.reflect.Type[] types1 = RpcUtils.getReturnTypes(inv1);
    Assertions.assertNotNull(types1);
    Assertions.assertEquals(2, types1.length);
    Assertions.assertEquals(List.class, types1[0]);
    Assertions.assertEquals(demoServiceClass.getMethod("testReturnType1", String.class).getGenericReturnType(), types1[1]);
    Assertions.assertArrayEquals(types1, inv1.getReturnTypes());
    RpcInvocation inv2 = new RpcInvocation("testReturnType2", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    java.lang.reflect.Type[] types2 = RpcUtils.getReturnTypes(inv2);
    Assertions.assertNotNull(types2);
    Assertions.assertEquals(2, types2.length);
    Assertions.assertEquals(String.class, types2[0]);
    Assertions.assertEquals(String.class, types2[1]);
    Assertions.assertArrayEquals(types2, inv2.getReturnTypes());
    RpcInvocation inv3 = new RpcInvocation("testReturnType3", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    java.lang.reflect.Type[] types3 = RpcUtils.getReturnTypes(inv3);
    Assertions.assertNotNull(types3);
    Assertions.assertEquals(2, types3.length);
    Assertions.assertEquals(List.class, types3[0]);
    java.lang.reflect.Type genericReturnType3 = demoServiceClass.getMethod("testReturnType3", String.class).getGenericReturnType();
    Assertions.assertEquals(((ParameterizedType) genericReturnType3).getActualTypeArguments()[0], types3[1]);
    Assertions.assertArrayEquals(types3, inv3.getReturnTypes());
    RpcInvocation inv4 = new RpcInvocation("testReturnType4", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    java.lang.reflect.Type[] types4 = RpcUtils.getReturnTypes(inv4);
    Assertions.assertNotNull(types4);
    Assertions.assertEquals(2, types4.length);
    Assertions.assertNull(types4[0]);
    Assertions.assertNull(types4[1]);
    Assertions.assertArrayEquals(types4, inv4.getReturnTypes());
    RpcInvocation inv5 = new RpcInvocation("testReturnType5", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    java.lang.reflect.Type[] types5 = RpcUtils.getReturnTypes(inv5);
    Assertions.assertNotNull(types5);
    Assertions.assertEquals(2, types5.length);
    Assertions.assertEquals(Map.class, types5[0]);
    java.lang.reflect.Type genericReturnType5 = demoServiceClass.getMethod("testReturnType5", String.class).getGenericReturnType();
    Assertions.assertEquals(((ParameterizedType) genericReturnType5).getActualTypeArguments()[0], types5[1]);
    Assertions.assertArrayEquals(types5, inv5.getReturnTypes());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker createMockInvoker() {
    Invoker invoker = mock(Invoker.class);
    given(invoker.getUrl()).willReturn(URL.valueOf("test://127.0.0.1:1/org.apache.dubbo.rpc.support.DemoService?interface=org.apache.dubbo.rpc.support.DemoService"));
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_48_3
#### Test Case Name: `testGetReturnTypesWithoutCache`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\support\RpcUtilsTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Class<?> demoServiceClass = DemoService.class;
    String serviceName = demoServiceClass.getName();
-    Invoker invoker = mock(Invoker.class);
-    given(invoker.getUrl()).willReturn(URL.valueOf("test://127.0.0.1:1/org.apache.dubbo.rpc.support.DemoService?interface=org.apache.dubbo.rpc.support.DemoService"));
+    Invoker invoker = createMockInvoker();
    RpcInvocation inv = new RpcInvocation("testReturnType", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv.setReturnTypes(null);
    Type[] types = RpcUtils.getReturnTypes(inv);
    Assertions.assertNotNull(types);
    Assertions.assertEquals(2, types.length);
    Assertions.assertEquals(String.class, types[0]);
    Assertions.assertEquals(String.class, types[1]);
    RpcInvocation inv1 = new RpcInvocation("testReturnType1", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv1.setReturnTypes(null);
    java.lang.reflect.Type[] types1 = RpcUtils.getReturnTypes(inv1);
    Assertions.assertNotNull(types1);
    Assertions.assertEquals(2, types1.length);
    Assertions.assertEquals(List.class, types1[0]);
    Assertions.assertEquals(demoServiceClass.getMethod("testReturnType1", String.class).getGenericReturnType(), types1[1]);
    RpcInvocation inv2 = new RpcInvocation("testReturnType2", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv2.setReturnTypes(null);
    java.lang.reflect.Type[] types2 = RpcUtils.getReturnTypes(inv2);
    Assertions.assertNotNull(types2);
    Assertions.assertEquals(2, types2.length);
    Assertions.assertEquals(String.class, types2[0]);
    Assertions.assertEquals(String.class, types2[1]);
    RpcInvocation inv3 = new RpcInvocation("testReturnType3", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv3.setReturnTypes(null);
    java.lang.reflect.Type[] types3 = RpcUtils.getReturnTypes(inv3);
    Assertions.assertNotNull(types3);
    Assertions.assertEquals(2, types3.length);
    Assertions.assertEquals(List.class, types3[0]);
    java.lang.reflect.Type genericReturnType3 = demoServiceClass.getMethod("testReturnType3", String.class).getGenericReturnType();
    Assertions.assertEquals(((ParameterizedType) genericReturnType3).getActualTypeArguments()[0], types3[1]);
    RpcInvocation inv4 = new RpcInvocation("testReturnType4", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv4.setReturnTypes(null);
    java.lang.reflect.Type[] types4 = RpcUtils.getReturnTypes(inv4);
    Assertions.assertNotNull(types4);
    Assertions.assertEquals(2, types4.length);
    Assertions.assertNull(types4[0]);
    Assertions.assertNull(types4[1]);
    RpcInvocation inv5 = new RpcInvocation("testReturnType5", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv5.setReturnTypes(null);
    java.lang.reflect.Type[] types5 = RpcUtils.getReturnTypes(inv5);
    Assertions.assertNotNull(types5);
    Assertions.assertEquals(2, types5.length);
    Assertions.assertEquals(Map.class, types5[0]);
    java.lang.reflect.Type genericReturnType5 = demoServiceClass.getMethod("testReturnType5", String.class).getGenericReturnType();
    Assertions.assertEquals(((ParameterizedType) genericReturnType5).getActualTypeArguments()[0], types5[1]);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testGetReturnTypesWithoutCache() throws Exception {
    Class<?> demoServiceClass = DemoService.class;
    String serviceName = demoServiceClass.getName();
    Invoker invoker = mock(Invoker.class);
    given(invoker.getUrl()).willReturn(URL.valueOf("test://127.0.0.1:1/org.apache.dubbo.rpc.support.DemoService?interface=org.apache.dubbo.rpc.support.DemoService"));
    RpcInvocation inv = new RpcInvocation("testReturnType", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv.setReturnTypes(null);
    Type[] types = RpcUtils.getReturnTypes(inv);
    Assertions.assertNotNull(types);
    Assertions.assertEquals(2, types.length);
    Assertions.assertEquals(String.class, types[0]);
    Assertions.assertEquals(String.class, types[1]);
    RpcInvocation inv1 = new RpcInvocation("testReturnType1", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv1.setReturnTypes(null);
    java.lang.reflect.Type[] types1 = RpcUtils.getReturnTypes(inv1);
    Assertions.assertNotNull(types1);
    Assertions.assertEquals(2, types1.length);
    Assertions.assertEquals(List.class, types1[0]);
    Assertions.assertEquals(demoServiceClass.getMethod("testReturnType1", String.class).getGenericReturnType(), types1[1]);
    RpcInvocation inv2 = new RpcInvocation("testReturnType2", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv2.setReturnTypes(null);
    java.lang.reflect.Type[] types2 = RpcUtils.getReturnTypes(inv2);
    Assertions.assertNotNull(types2);
    Assertions.assertEquals(2, types2.length);
    Assertions.assertEquals(String.class, types2[0]);
    Assertions.assertEquals(String.class, types2[1]);
    RpcInvocation inv3 = new RpcInvocation("testReturnType3", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv3.setReturnTypes(null);
    java.lang.reflect.Type[] types3 = RpcUtils.getReturnTypes(inv3);
    Assertions.assertNotNull(types3);
    Assertions.assertEquals(2, types3.length);
    Assertions.assertEquals(List.class, types3[0]);
    java.lang.reflect.Type genericReturnType3 = demoServiceClass.getMethod("testReturnType3", String.class).getGenericReturnType();
    Assertions.assertEquals(((ParameterizedType) genericReturnType3).getActualTypeArguments()[0], types3[1]);
    RpcInvocation inv4 = new RpcInvocation("testReturnType4", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv4.setReturnTypes(null);
    java.lang.reflect.Type[] types4 = RpcUtils.getReturnTypes(inv4);
    Assertions.assertNotNull(types4);
    Assertions.assertEquals(2, types4.length);
    Assertions.assertNull(types4[0]);
    Assertions.assertNull(types4[1]);
    RpcInvocation inv5 = new RpcInvocation("testReturnType5", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv5.setReturnTypes(null);
    java.lang.reflect.Type[] types5 = RpcUtils.getReturnTypes(inv5);
    Assertions.assertNotNull(types5);
    Assertions.assertEquals(2, types5.length);
    Assertions.assertEquals(Map.class, types5[0]);
    java.lang.reflect.Type genericReturnType5 = demoServiceClass.getMethod("testReturnType5", String.class).getGenericReturnType();
    Assertions.assertEquals(((ParameterizedType) genericReturnType5).getActualTypeArguments()[0], types5[1]);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker createMockInvoker() {
    Invoker invoker = mock(Invoker.class);
    given(invoker.getUrl()).willReturn(URL.valueOf("test://127.0.0.1:1/org.apache.dubbo.rpc.support.DemoService?interface=org.apache.dubbo.rpc.support.DemoService"));
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_48_4
#### Test Case Name: `testGetReturnTypesWhenGeneric`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\support\RpcUtilsTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Class<?> demoServiceClass = DemoService.class;
    String serviceName = demoServiceClass.getName();
-    Invoker invoker = mock(Invoker.class);
-    given(invoker.getUrl()).willReturn(URL.valueOf("test://127.0.0.1:1/org.apache.dubbo.rpc.support.DemoService?interface=org.apache.dubbo.rpc.support.DemoService"));
+    Invoker invoker = createMockInvoker();
    RpcInvocation inv = new RpcInvocation("testReturnType", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv.setMethodName($INVOKE);
    Type[] types = RpcUtils.getReturnTypes(inv);
    Assertions.assertNull(types);
    RpcInvocation inv1 = new RpcInvocation("testReturnType1", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv1.setMethodName($INVOKE);
    java.lang.reflect.Type[] types1 = RpcUtils.getReturnTypes(inv1);
    Assertions.assertNull(types1);
    RpcInvocation inv2 = new RpcInvocation("testReturnType2", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv2.setMethodName($INVOKE);
    java.lang.reflect.Type[] types2 = RpcUtils.getReturnTypes(inv2);
    Assertions.assertNull(types2);
    RpcInvocation inv3 = new RpcInvocation("testReturnType3", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv3.setMethodName($INVOKE);
    java.lang.reflect.Type[] types3 = RpcUtils.getReturnTypes(inv3);
    Assertions.assertNull(types3);
    RpcInvocation inv4 = new RpcInvocation("testReturnType4", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv4.setMethodName($INVOKE);
    java.lang.reflect.Type[] types4 = RpcUtils.getReturnTypes(inv4);
    Assertions.assertNull(types4);
    RpcInvocation inv5 = new RpcInvocation("testReturnType5", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv5.setMethodName($INVOKE);
    java.lang.reflect.Type[] types5 = RpcUtils.getReturnTypes(inv5);
    Assertions.assertNull(types5);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testGetReturnTypesWhenGeneric() throws Exception {
    Class<?> demoServiceClass = DemoService.class;
    String serviceName = demoServiceClass.getName();
    Invoker invoker = mock(Invoker.class);
    given(invoker.getUrl()).willReturn(URL.valueOf("test://127.0.0.1:1/org.apache.dubbo.rpc.support.DemoService?interface=org.apache.dubbo.rpc.support.DemoService"));
    RpcInvocation inv = new RpcInvocation("testReturnType", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv.setMethodName($INVOKE);
    Type[] types = RpcUtils.getReturnTypes(inv);
    Assertions.assertNull(types);
    RpcInvocation inv1 = new RpcInvocation("testReturnType1", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv1.setMethodName($INVOKE);
    java.lang.reflect.Type[] types1 = RpcUtils.getReturnTypes(inv1);
    Assertions.assertNull(types1);
    RpcInvocation inv2 = new RpcInvocation("testReturnType2", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv2.setMethodName($INVOKE);
    java.lang.reflect.Type[] types2 = RpcUtils.getReturnTypes(inv2);
    Assertions.assertNull(types2);
    RpcInvocation inv3 = new RpcInvocation("testReturnType3", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv3.setMethodName($INVOKE);
    java.lang.reflect.Type[] types3 = RpcUtils.getReturnTypes(inv3);
    Assertions.assertNull(types3);
    RpcInvocation inv4 = new RpcInvocation("testReturnType4", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv4.setMethodName($INVOKE);
    java.lang.reflect.Type[] types4 = RpcUtils.getReturnTypes(inv4);
    Assertions.assertNull(types4);
    RpcInvocation inv5 = new RpcInvocation("testReturnType5", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    inv5.setMethodName($INVOKE);
    java.lang.reflect.Type[] types5 = RpcUtils.getReturnTypes(inv5);
    Assertions.assertNull(types5);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker createMockInvoker() {
    Invoker invoker = mock(Invoker.class);
    given(invoker.getUrl()).willReturn(URL.valueOf("test://127.0.0.1:1/org.apache.dubbo.rpc.support.DemoService?interface=org.apache.dubbo.rpc.support.DemoService"));
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_48_5
#### Test Case Name: `testIsReturnTypeFuture`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\support\RpcUtilsTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Class<?> demoServiceClass = DemoService.class;
    String serviceName = demoServiceClass.getName();
-    Invoker invoker = mock(Invoker.class);
-    given(invoker.getUrl()).willReturn(URL.valueOf("test://127.0.0.1:1/org.apache.dubbo.rpc.support.DemoService?interface=org.apache.dubbo.rpc.support.DemoService"));
+    Invoker invoker = createMockInvoker();
    RpcInvocation inv = new RpcInvocation("testReturnType", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    Assertions.assertFalse(RpcUtils.isReturnTypeFuture(inv));
    ModuleServiceRepository repository = ApplicationModel.defaultModel().getDefaultModule().getServiceRepository();
    repository.registerService(demoServiceClass);
    inv = new RpcInvocation("testReturnType4", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    Assertions.assertTrue(RpcUtils.isReturnTypeFuture(inv));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testIsReturnTypeFuture() {
    Class<?> demoServiceClass = DemoService.class;
    String serviceName = demoServiceClass.getName();
    Invoker invoker = mock(Invoker.class);
    given(invoker.getUrl()).willReturn(URL.valueOf("test://127.0.0.1:1/org.apache.dubbo.rpc.support.DemoService?interface=org.apache.dubbo.rpc.support.DemoService"));
    RpcInvocation inv = new RpcInvocation("testReturnType", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    Assertions.assertFalse(RpcUtils.isReturnTypeFuture(inv));
    ModuleServiceRepository repository = ApplicationModel.defaultModel().getDefaultModule().getServiceRepository();
    repository.registerService(demoServiceClass);
    inv = new RpcInvocation("testReturnType4", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    Assertions.assertTrue(RpcUtils.isReturnTypeFuture(inv));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker createMockInvoker() {
    Invoker invoker = mock(Invoker.class);
    given(invoker.getUrl()).willReturn(URL.valueOf("test://127.0.0.1:1/org.apache.dubbo.rpc.support.DemoService?interface=org.apache.dubbo.rpc.support.DemoService"));
    return invoker;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_49
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.Invoker`
- **Test Case Count**: 5
- **MO Count**: 5

### Reusable Method
```java
// === Declare in class scope ===
private Invoker invoker;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    invoker = mock(Invoker.class);
}

// === Replace local variable in test with ===
invoker;

```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_49_1
#### Test Case Name: `testGetParameterTypes`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\support\RpcUtilsTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void testGetParameterTypes() {
     Class<?> demoServiceClass = DemoService.class;
     String serviceName = demoServiceClass.getName();
-    Invoker invoker = mock(Invoker.class);
+    // removed local mock; replaced with global field `invoker`
     // void sayHello(String name);
     RpcInvocation inv1 = new RpcInvocation("sayHello", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
     Class<?>[] parameterTypes1 = RpcUtils.getParameterTypes(inv1);
     Assertions.assertNotNull(parameterTypes1);
     Assertions.assertEquals(1, parameterTypes1.length);
     Assertions.assertEquals(String.class, parameterTypes1[0]);
     //long timestamp();
     RpcInvocation inv2 = new RpcInvocation("timestamp", serviceName, "", null, null, null, invoker, null);
     Class<?>[] parameterTypes2 = RpcUtils.getParameterTypes(inv2);
     Assertions.assertEquals(0, parameterTypes2.length);
     //Type enumlength(Type... types);
     RpcInvocation inv3 = new RpcInvocation("enumlength", serviceName, "", new Class<?>[] { Type.class, Type.class }, null, null, invoker, null);
     Class<?>[] parameterTypes3 = RpcUtils.getParameterTypes(inv3);
     Assertions.assertNotNull(parameterTypes3);
     Assertions.assertEquals(2, parameterTypes3.length);
     Assertions.assertEquals(Type.class, parameterTypes3[0]);
     Assertions.assertEquals(Type.class, parameterTypes3[1]);
     //byte getbyte(byte arg);
     RpcInvocation inv4 = new RpcInvocation("getbyte", serviceName, "", new Class<?>[] { byte.class }, null, null, invoker, null);
     Class<?>[] parameterTypes4 = RpcUtils.getParameterTypes(inv4);
     Assertions.assertNotNull(parameterTypes4);
     Assertions.assertEquals(1, parameterTypes4.length);
     Assertions.assertEquals(byte.class, parameterTypes4[0]);
     //void $invoke(String s1, String s2);
     RpcInvocation inv5 = new RpcInvocation("$invoke", serviceName, "", new Class<?>[] { String.class, String[].class }, new Object[] { "method", new String[] { "java.lang.String", "void", "java.lang.Object" } }, null, invoker, null);
     Class<?>[] parameterTypes5 = RpcUtils.getParameterTypes(inv5);
     Assertions.assertNotNull(parameterTypes5);
     Assertions.assertEquals(3, parameterTypes5.length);
     Assertions.assertEquals(String.class, parameterTypes5[0]);
     Assertions.assertEquals(void.class, parameterTypes5[1]);
     Assertions.assertEquals(Object.class, parameterTypes5[2]);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testGetParameterTypes() {
    Class<?> demoServiceClass = DemoService.class;
    String serviceName = demoServiceClass.getName();
    Invoker invoker = mock(Invoker.class);
    // void sayHello(String name);
    RpcInvocation inv1 = new RpcInvocation("sayHello", serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    Class<?>[] parameterTypes1 = RpcUtils.getParameterTypes(inv1);
    Assertions.assertNotNull(parameterTypes1);
    Assertions.assertEquals(1, parameterTypes1.length);
    Assertions.assertEquals(String.class, parameterTypes1[0]);
    //long timestamp();
    RpcInvocation inv2 = new RpcInvocation("timestamp", serviceName, "", null, null, null, invoker, null);
    Class<?>[] parameterTypes2 = RpcUtils.getParameterTypes(inv2);
    Assertions.assertEquals(0, parameterTypes2.length);
    //Type enumlength(Type... types);
    RpcInvocation inv3 = new RpcInvocation("enumlength", serviceName, "", new Class<?>[] { Type.class, Type.class }, null, null, invoker, null);
    Class<?>[] parameterTypes3 = RpcUtils.getParameterTypes(inv3);
    Assertions.assertNotNull(parameterTypes3);
    Assertions.assertEquals(2, parameterTypes3.length);
    Assertions.assertEquals(Type.class, parameterTypes3[0]);
    Assertions.assertEquals(Type.class, parameterTypes3[1]);
    //byte getbyte(byte arg);
    RpcInvocation inv4 = new RpcInvocation("getbyte", serviceName, "", new Class<?>[] { byte.class }, null, null, invoker, null);
    Class<?>[] parameterTypes4 = RpcUtils.getParameterTypes(inv4);
    Assertions.assertNotNull(parameterTypes4);
    Assertions.assertEquals(1, parameterTypes4.length);
    Assertions.assertEquals(byte.class, parameterTypes4[0]);
    //void $invoke(String s1, String s2);
    RpcInvocation inv5 = new RpcInvocation("$invoke", serviceName, "", new Class<?>[] { String.class, String[].class }, new Object[] { "method", new String[] { "java.lang.String", "void", "java.lang.Object" } }, null, invoker, null);
    Class<?>[] parameterTypes5 = RpcUtils.getParameterTypes(inv5);
    Assertions.assertNotNull(parameterTypes5);
    Assertions.assertEquals(3, parameterTypes5.length);
    Assertions.assertEquals(String.class, parameterTypes5[0]);
    Assertions.assertEquals(void.class, parameterTypes5[1]);
    Assertions.assertEquals(Object.class, parameterTypes5[2]);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Invoker invoker;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    invoker = mock(Invoker.class);
}

// === Replace local variable in test with ===
invoker;

```
</details>

---
#### Test Case ID #dubbo_Test_49_2
#### Test Case Name: `testGetMethodName`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\support\RpcUtilsTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
 @ParameterizedTest
 @CsvSource({ "echo", "stringLength", "testReturnType" })
 public void testGetMethodName(String methodName) {
     Class<?> demoServiceClass = DemoService.class;
     String serviceName = demoServiceClass.getName();
-    Invoker invoker = mock(Invoker.class);
+    // removed local mock; replaced with global field `invoker`
     RpcInvocation inv1 = new RpcInvocation(methodName, serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
     String actual = RpcUtils.getMethodName(inv1);
     Assertions.assertNotNull(actual);
     Assertions.assertEquals(methodName, actual);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@ParameterizedTest
@CsvSource({ "echo", "stringLength", "testReturnType" })
public void testGetMethodName(String methodName) {
    Class<?> demoServiceClass = DemoService.class;
    String serviceName = demoServiceClass.getName();
    Invoker invoker = mock(Invoker.class);
    RpcInvocation inv1 = new RpcInvocation(methodName, serviceName, "", new Class<?>[] { String.class }, null, null, invoker, null);
    String actual = RpcUtils.getMethodName(inv1);
    Assertions.assertNotNull(actual);
    Assertions.assertEquals(methodName, actual);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Invoker invoker;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    invoker = mock(Invoker.class);
}

// === Replace local variable in test with ===
invoker;

```
</details>

---
#### Test Case ID #dubbo_Test_49_3
#### Test Case Name: `testGet_$invoke_MethodName`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\support\RpcUtilsTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
 @ParameterizedTest
 @CsvSource({ "hello", "apache", "dubbo" })
 public void testGet_$invoke_MethodName(String method) {
     Class<?> demoServiceClass = DemoService.class;
     String serviceName = demoServiceClass.getName();
-    Invoker invoker = mock(Invoker.class);
+    // removed local mock; replaced with global field `invoker`
     RpcInvocation inv = new RpcInvocation("$invoke", serviceName, "", new Class<?>[] { String.class, String[].class }, new Object[] { method, new String[] { "java.lang.String", "void", "java.lang.Object" } }, null, invoker, null);
     String actual = RpcUtils.getMethodName(inv);
     Assertions.assertNotNull(actual);
     Assertions.assertEquals(method, actual);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@ParameterizedTest
@CsvSource({ "hello", "apache", "dubbo" })
public void testGet_$invoke_MethodName(String method) {
    Class<?> demoServiceClass = DemoService.class;
    String serviceName = demoServiceClass.getName();
    Invoker invoker = mock(Invoker.class);
    RpcInvocation inv = new RpcInvocation("$invoke", serviceName, "", new Class<?>[] { String.class, String[].class }, new Object[] { method, new String[] { "java.lang.String", "void", "java.lang.Object" } }, null, invoker, null);
    String actual = RpcUtils.getMethodName(inv);
    Assertions.assertNotNull(actual);
    Assertions.assertEquals(method, actual);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Invoker invoker;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    invoker = mock(Invoker.class);
}

// === Replace local variable in test with ===
invoker;

```
</details>

---
#### Test Case ID #dubbo_Test_49_4
#### Test Case Name: `testGet_$invoke_Arguments`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\support\RpcUtilsTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void testGet_$invoke_Arguments() {
     Object[] args = new Object[] { "hello", "dubbo", 520 };
     Class<?> demoServiceClass = DemoService.class;
     String serviceName = demoServiceClass.getName();
-    Invoker invoker = mock(Invoker.class);
+    // removed local mock; replaced with global field `invoker`
     RpcInvocation inv = new RpcInvocation("$invoke", serviceName, "", new Class<?>[] { String.class, String[].class, Object[].class }, new Object[] { "method", new String[] {}, args }, null, invoker, null);
     Object[] arguments = RpcUtils.getArguments(inv);
     for (int i = 0; i < args.length; i++) {
         Assertions.assertNotNull(arguments[i]);
         Assertions.assertEquals(args[i].getClass().getName(), arguments[i].getClass().getName());
         Assertions.assertEquals(args[i], arguments[i]);
     }
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testGet_$invoke_Arguments() {
    Object[] args = new Object[] { "hello", "dubbo", 520 };
    Class<?> demoServiceClass = DemoService.class;
    String serviceName = demoServiceClass.getName();
    Invoker invoker = mock(Invoker.class);
    RpcInvocation inv = new RpcInvocation("$invoke", serviceName, "", new Class<?>[] { String.class, String[].class, Object[].class }, new Object[] { "method", new String[] {}, args }, null, invoker, null);
    Object[] arguments = RpcUtils.getArguments(inv);
    for (int i = 0; i < args.length; i++) {
        Assertions.assertNotNull(arguments[i]);
        Assertions.assertEquals(args[i].getClass().getName(), arguments[i].getClass().getName());
        Assertions.assertEquals(args[i], arguments[i]);
    }
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Invoker invoker;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    invoker = mock(Invoker.class);
}

// === Replace local variable in test with ===
invoker;

```
</details>

---
#### Test Case ID #dubbo_Test_49_5
#### Test Case Name: `testIsAsync`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\support\RpcUtilsTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void testIsAsync() {
     Object[] args = new Object[] { "hello", "dubbo", 520 };
     Class<?> demoServiceClass = DemoService.class;
     String serviceName = demoServiceClass.getName();
-    Invoker invoker = mock(Invoker.class);
+    // removed local mock; replaced with global field `invoker`
     URL url = URL.valueOf("test://127.0.0.1:1/org.apache.dubbo.rpc.support.DemoService?interface=org.apache.dubbo.rpc.support.DemoService");
-    RpcInvocation inv = new RpcInvocation("test", serviceName, "", new Class<?>[] { String.class, String[].class, Object[].class }, new Object[] { "method", new String[] {}, args }, null, invoker, null);
+    RpcInvocation inv = new RpcInvocation("test", serviceName, "", new Class<?>[] { String.class, String[].class, Object[].class }, new Object[] { "method", new String[] {}, args }, null, invoker, null);
     Assertions.assertFalse(RpcUtils.isAsync(url, inv));
     inv.setInvokeMode(InvokeMode.ASYNC);
     Assertions.assertTrue(RpcUtils.isAsync(url, inv));
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testIsAsync() {
    Object[] args = new Object[] { "hello", "dubbo", 520 };
    Class<?> demoServiceClass = DemoService.class;
    String serviceName = demoServiceClass.getName();
    Invoker invoker = mock(Invoker.class);
    URL url = URL.valueOf("test://127.0.0.1:1/org.apache.dubbo.rpc.support.DemoService?interface=org.apache.dubbo.rpc.support.DemoService");
    RpcInvocation inv = new RpcInvocation("test", serviceName, "", new Class<?>[] { String.class, String[].class, Object[].class }, new Object[] { "method", new String[] {}, args }, null, invoker, null);
    Assertions.assertFalse(RpcUtils.isAsync(url, inv));
    inv.setInvokeMode(InvokeMode.ASYNC);
    Assertions.assertTrue(RpcUtils.isAsync(url, inv));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Invoker invoker;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    invoker = mock(Invoker.class);
}

// === Replace local variable in test with ===
invoker;

```
</details>

---
## Mock Clone Instance #dubbo_MCI_50
- **Scope**: class level
- **Mocked Class**: `org.apache.dubbo.rpc.Invoker`
- **Test Case Count**: 7
- **MO Count**: 9

### Reusable Method
```java
public class MockInvoker {
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_50_1
#### Test Case Name: `testAuthDisabled`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-auth\src\test\java\org\apache\dubbo\auth\filter\ConsumerSignFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
    URL url = mock(URL.class);
-    Invoker invoker = mock(Invoker.class);
    Invocation invocation = mock(Invocation.class);
-    when(invoker.getUrl()).thenReturn(url);
+    Invoker invoker = MockInvoker.createMockInvoker(url);
    ConsumerSignFilter consumerSignFilter = new ConsumerSignFilter(ApplicationModel.defaultModel());
    consumerSignFilter.invoke(invoker, invocation);
    verify(invocation, never()).setAttachment(eq(Constants.REQUEST_SIGNATURE_KEY), anyString());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testAuthDisabled() {
    URL url = mock(URL.class);
    Invoker invoker = mock(Invoker.class);
    Invocation invocation = mock(Invocation.class);
    when(invoker.getUrl()).thenReturn(url);
    ConsumerSignFilter consumerSignFilter = new ConsumerSignFilter(ApplicationModel.defaultModel());
    consumerSignFilter.invoke(invoker, invocation);
    verify(invocation, never()).setAttachment(eq(Constants.REQUEST_SIGNATURE_KEY), anyString());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_50_2
#### Test Case Name: `testAuthEnabled`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-auth\src\test\java\org\apache\dubbo\auth\filter\ConsumerSignFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
     URL url = URL.valueOf("dubbo://10.10.10.10:2181").addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk").addParameter(CommonConstants.APPLICATION_KEY, "test").addParameter(Constants.SERVICE_AUTH, true);
-    Invoker invoker = mock(Invoker.class);
     Invocation invocation = mock(Invocation.class);
-    when(invoker.getUrl()).thenReturn(url);
+    Invoker invoker = MockInvoker.createMockInvoker(url);
     ConsumerSignFilter consumerSignFilter = new ConsumerSignFilter(ApplicationModel.defaultModel());
     consumerSignFilter.invoke(invoker, invocation);
     verify(invocation, times(1)).setAttachment(eq(Constants.REQUEST_SIGNATURE_KEY), anyString());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testAuthEnabled() {
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk").addParameter(CommonConstants.APPLICATION_KEY, "test").addParameter(Constants.SERVICE_AUTH, true);
    Invoker invoker = mock(Invoker.class);
    Invocation invocation = mock(Invocation.class);
    when(invoker.getUrl()).thenReturn(url);
    ConsumerSignFilter consumerSignFilter = new ConsumerSignFilter(ApplicationModel.defaultModel());
    consumerSignFilter.invoke(invoker, invocation);
    verify(invocation, times(1)).setAttachment(eq(Constants.REQUEST_SIGNATURE_KEY), anyString());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_50_3
#### Test Case Name: `testAuthDisabled`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-auth\src\test\java\org\apache\dubbo\auth\filter\ProviderAuthFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
    URL url = mock(URL.class);
-    Invoker invoker = mock(Invoker.class);
-    Invocation invocation = mock(RpcInvocation.class);
-    when(invoker.getUrl()).thenReturn(url);
+    Invoker invoker = MockInvoker.createMockInvoker(url);
+    Invocation invocation = mock(RpcInvocation.class);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    providerAuthFilter.invoke(invoker, invocation);
    verify(url, never()).getParameter(eq(Constants.AUTHENTICATOR), eq(Constants.DEFAULT_AUTHENTICATOR));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testAuthDisabled() {
    URL url = mock(URL.class);
    Invoker invoker = mock(Invoker.class);
    Invocation invocation = mock(RpcInvocation.class);
    when(invoker.getUrl()).thenReturn(url);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    providerAuthFilter.invoke(invoker, invocation);
    verify(url, never()).getParameter(eq(Constants.AUTHENTICATOR), eq(Constants.DEFAULT_AUTHENTICATOR));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_50_4
#### Test Case Name: `testAuthEnabled`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-auth\src\test\java\org\apache\dubbo\auth\filter\ProviderAuthFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
     URL url = URL.valueOf("dubbo://10.10.10.10:2181").addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk").addParameter(CommonConstants.APPLICATION_KEY, "test").addParameter(Constants.SERVICE_AUTH, true);
-    Invoker invoker = mock(Invoker.class);
     Invocation invocation = mock(RpcInvocation.class);
-    when(invoker.getUrl()).thenReturn(url);
+    Invoker invoker = MockInvoker.createMockInvoker(url);
     ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
     providerAuthFilter.invoke(invoker, invocation);
     verify(invocation, atLeastOnce()).getAttachment(anyString());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testAuthEnabled() {
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk").addParameter(CommonConstants.APPLICATION_KEY, "test").addParameter(Constants.SERVICE_AUTH, true);
    Invoker invoker = mock(Invoker.class);
    Invocation invocation = mock(RpcInvocation.class);
    when(invoker.getUrl()).thenReturn(url);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    providerAuthFilter.invoke(invoker, invocation);
    verify(invocation, atLeastOnce()).getAttachment(anyString());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_50_5
#### Test Case Name: `testAuthFailed`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-auth\src\test\java\org\apache\dubbo\auth\filter\ProviderAuthFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk").addParameter(CommonConstants.APPLICATION_KEY, "test").addParameter(Constants.SERVICE_AUTH, true);
-    Invoker invoker = mock(Invoker.class);
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(null);
-    when(invoker.getUrl()).thenReturn(url);
+    Invoker invoker = MockInvoker.createMockInvoker(url);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    Result result = providerAuthFilter.invoke(invoker, invocation);
    assertTrue(result.hasException());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testAuthFailed() {
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk").addParameter(CommonConstants.APPLICATION_KEY, "test").addParameter(Constants.SERVICE_AUTH, true);
    Invoker invoker = mock(Invoker.class);
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(null);
    when(invoker.getUrl()).thenReturn(url);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    Result result = providerAuthFilter.invoke(invoker, invocation);
    assertTrue(result.hasException());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_50_6
#### Test Case Name: `testAuthFailedWhenNoSignature`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-auth\src\test\java\org\apache\dubbo\auth\filter\ProviderAuthFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk").addParameter(CommonConstants.APPLICATION_KEY, "test").addParameter(Constants.SERVICE_AUTH, true);
-    Invoker invoker = mock(Invoker.class);
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(null);
-    when(invoker.getUrl()).thenReturn(url);
+    Invoker invoker = MockInvoker.createMockInvoker(url);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    Result result = providerAuthFilter.invoke(invoker, invocation);
    assertTrue(result.hasException());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testAuthFailedWhenNoSignature() {
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk").addParameter(CommonConstants.APPLICATION_KEY, "test").addParameter(Constants.SERVICE_AUTH, true);
    Invoker invoker = mock(Invoker.class);
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(null);
    when(invoker.getUrl()).thenReturn(url);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    Result result = providerAuthFilter.invoke(invoker, invocation);
    assertTrue(result.hasException());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_50_7
#### Test Case Name: `testAuthFailedWhenNoAccessKeyPair`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-auth\src\test\java\org\apache\dubbo\auth\filter\ProviderAuthFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").addParameter(CommonConstants.APPLICATION_KEY, "test-provider").addParameter(Constants.SERVICE_AUTH, true);
-    Invoker invoker = mock(Invoker.class);
+    Invoker invoker = MockInvoker.createMockInvoker(url);
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getObjectAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn("dubbo");
    when(invocation.getObjectAttachment(Constants.AK_KEY)).thenReturn("ak");
    when(invocation.getObjectAttachment(CommonConstants.CONSUMER)).thenReturn("test-consumer");
    when(invocation.getObjectAttachment(Constants.REQUEST_TIMESTAMP_KEY)).thenReturn(System.currentTimeMillis());
-    when(invoker.getUrl()).thenReturn(url);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    Result result = providerAuthFilter.invoke(invoker, invocation);
    assertTrue(result.hasException());
    assertTrue(result.getException() instanceof RpcAuthenticationException);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testAuthFailedWhenNoAccessKeyPair() {
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").addParameter(CommonConstants.APPLICATION_KEY, "test-provider").addParameter(Constants.SERVICE_AUTH, true);
    Invoker invoker = mock(Invoker.class);
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getObjectAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn("dubbo");
    when(invocation.getObjectAttachment(Constants.AK_KEY)).thenReturn("ak");
    when(invocation.getObjectAttachment(CommonConstants.CONSUMER)).thenReturn("test-consumer");
    when(invocation.getObjectAttachment(Constants.REQUEST_TIMESTAMP_KEY)).thenReturn(System.currentTimeMillis());
    when(invoker.getUrl()).thenReturn(url);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    Result result = providerAuthFilter.invoke(invoker, invocation);
    assertTrue(result.hasException());
    assertTrue(result.getException() instanceof RpcAuthenticationException);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_50_8
#### Test Case Name: `testAuthFailedWhenParameterError`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-auth\src\test\java\org\apache\dubbo\auth\filter\ProviderAuthFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").setServiceInterface(service).addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk").addParameter(CommonConstants.APPLICATION_KEY, "test-provider").addParameter(Constants.PARAMETER_SIGNATURE_ENABLE_KEY, true).addParameter(Constants.SERVICE_AUTH, true);
-    Invoker invoker = mock(Invoker.class);
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getObjectAttachment(Constants.AK_KEY)).thenReturn("ak");
    when(invocation.getObjectAttachment(CommonConstants.CONSUMER)).thenReturn("test-consumer");
    when(invocation.getObjectAttachment(Constants.REQUEST_TIMESTAMP_KEY)).thenReturn(currentTimeMillis);
    when(invocation.getMethodName()).thenReturn(method);
    Object[] fakeParams = new Object[] { "dubbo1", "dubbo3" };
    when(invocation.getArguments()).thenReturn(fakeParams);
-    when(invoker.getUrl()).thenReturn(url);
+    Invoker invoker = MockInvoker.createMockInvoker(url);
    String requestString = String.format(Constants.SIGNATURE_STRING_FORMAT, url.getColonSeparatedKey(), invocation.getMethodName(), "sk", currentTimeMillis);
    String sign = SignatureUtils.sign(originalParams, requestString, "sk");
    when(invocation.getObjectAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(sign);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    Result result = providerAuthFilter.invoke(invoker, invocation);
    assertTrue(result.hasException());
    assertTrue(result.getException() instanceof RpcAuthenticationException);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testAuthFailedWhenParameterError() {
    String service = "org.apache.dubbo.DemoService";
    String method = "test";
    Object[] originalParams = new Object[] { "dubbo1", "dubbo2" };
    long currentTimeMillis = System.currentTimeMillis();
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").setServiceInterface(service).addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk").addParameter(CommonConstants.APPLICATION_KEY, "test-provider").addParameter(Constants.PARAMETER_SIGNATURE_ENABLE_KEY, true).addParameter(Constants.SERVICE_AUTH, true);
    Invoker invoker = mock(Invoker.class);
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getObjectAttachment(Constants.AK_KEY)).thenReturn("ak");
    when(invocation.getObjectAttachment(CommonConstants.CONSUMER)).thenReturn("test-consumer");
    when(invocation.getObjectAttachment(Constants.REQUEST_TIMESTAMP_KEY)).thenReturn(currentTimeMillis);
    when(invocation.getMethodName()).thenReturn(method);
    Object[] fakeParams = new Object[] { "dubbo1", "dubbo3" };
    when(invocation.getArguments()).thenReturn(fakeParams);
    when(invoker.getUrl()).thenReturn(url);
    String requestString = String.format(Constants.SIGNATURE_STRING_FORMAT, url.getColonSeparatedKey(), invocation.getMethodName(), "sk", currentTimeMillis);
    String sign = SignatureUtils.sign(originalParams, requestString, "sk");
    when(invocation.getObjectAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(sign);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    Result result = providerAuthFilter.invoke(invoker, invocation);
    assertTrue(result.hasException());
    assertTrue(result.getException() instanceof RpcAuthenticationException);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_50_9
#### Test Case Name: `testAuthSuccessfully`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-auth\src\test\java\org\apache\dubbo\auth\filter\ProviderAuthFilterTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    long currentTimeMillis = System.currentTimeMillis();
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").setServiceInterface(service).addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk").addParameter(CommonConstants.APPLICATION_KEY, "test-provider").addParameter(Constants.SERVICE_AUTH, true);
-    Invoker invoker = mock(Invoker.class);
+    Invoker invoker = MockInvoker.createMockInvoker(url);
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getAttachment(Constants.AK_KEY)).thenReturn("ak");
    when(invocation.getAttachment(CommonConstants.CONSUMER)).thenReturn("test-consumer");
    when(invocation.getAttachment(Constants.REQUEST_TIMESTAMP_KEY)).thenReturn(String.valueOf(currentTimeMillis));
    when(invocation.getMethodName()).thenReturn(method);
-    when(invoker.getUrl()).thenReturn(url);
    String requestString = String.format(Constants.SIGNATURE_STRING_FORMAT, url.getColonSeparatedKey(), invocation.getMethodName(), "sk", currentTimeMillis);
    String sign = SignatureUtils.sign(requestString, "sk");
    when(invocation.getAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(sign);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    Result result = providerAuthFilter.invoke(invoker, invocation);
    assertNull(result);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testAuthSuccessfully() {
    String service = "org.apache.dubbo.DemoService";
    String method = "test";
    long currentTimeMillis = System.currentTimeMillis();
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").setServiceInterface(service).addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk").addParameter(CommonConstants.APPLICATION_KEY, "test-provider").addParameter(Constants.SERVICE_AUTH, true);
    Invoker invoker = mock(Invoker.class);
    Invocation invocation = mock(RpcInvocation.class);
    when(invocation.getAttachment(Constants.AK_KEY)).thenReturn("ak");
    when(invocation.getAttachment(CommonConstants.CONSUMER)).thenReturn("test-consumer");
    when(invocation.getAttachment(Constants.REQUEST_TIMESTAMP_KEY)).thenReturn(String.valueOf(currentTimeMillis));
    when(invocation.getMethodName()).thenReturn(method);
    when(invoker.getUrl()).thenReturn(url);
    String requestString = String.format(Constants.SIGNATURE_STRING_FORMAT, url.getColonSeparatedKey(), invocation.getMethodName(), "sk", currentTimeMillis);
    String sign = SignatureUtils.sign(requestString, "sk");
    when(invocation.getAttachment(Constants.REQUEST_SIGNATURE_KEY)).thenReturn(sign);
    ProviderAuthFilter providerAuthFilter = new ProviderAuthFilter(ApplicationModel.defaultModel());
    Result result = providerAuthFilter.invoke(invoker, invocation);
    assertNull(result);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockInvoker {
    public static Invoker createMockInvoker(URL url) {
        Invoker invoker = mock(Invoker.class);
        when(invoker.getUrl()).thenReturn(url);
        return invoker;
    }
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_51
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.Invoker`
- **Test Case Count**: 2
- **MO Count**: 3

### Reusable Method
```java
private static Invoker createMockInvokerWithUrl(URL url) {
    Invoker invoker = mock(Invoker.class, Mockito.withSettings().stubOnly());
    given(invoker.getUrl()).willReturn(url);
    return invoker;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_51_1
#### Test Case Name: `testGetWeight`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\loadbalance\AbstractLoadBalanceTest.java`)
#### Mock Object Variable Name: `invoker1`
<summary>Suggested Diff</summary>

```diff
@@
    invocation.setMethodName("say");
-    Invoker invoker1 = mock(Invoker.class, Mockito.withSettings().stubOnly());
    URL url1 = new ServiceConfigURL("", "", 0, "DemoService", new HashMap<>());
    url1 = url1.addParameter(TIMESTAMP_KEY, System.currentTimeMillis() - Integer.MAX_VALUE - 1);
-    given(invoker1.getUrl()).willReturn(url1);
+    Invoker invoker1 = createMockInvokerWithUrl(url1);
    Invoker invoker2 = mock(Invoker.class, Mockito.withSettings().stubOnly());
    URL url2 = new ServiceConfigURL("", "", 0, "DemoService", new HashMap<>());
    url2 = url2.addParameter(TIMESTAMP_KEY, System.currentTimeMillis() - 10 * 60 * 1000L - 1);
    given(invoker2.getUrl()).willReturn(url2);
    Assertions.assertEquals(balance.getWeight(invoker1, invocation), balance.getWeight(invoker2, invocation));
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testGetWeight() {
    RpcInvocation invocation = new RpcInvocation();
    invocation.setMethodName("say");
    Invoker invoker1 = mock(Invoker.class, Mockito.withSettings().stubOnly());
    URL url1 = new ServiceConfigURL("", "", 0, "DemoService", new HashMap<>());
    url1 = url1.addParameter(TIMESTAMP_KEY, System.currentTimeMillis() - Integer.MAX_VALUE - 1);
    given(invoker1.getUrl()).willReturn(url1);
    Invoker invoker2 = mock(Invoker.class, Mockito.withSettings().stubOnly());
    URL url2 = new ServiceConfigURL("", "", 0, "DemoService", new HashMap<>());
    url2 = url2.addParameter(TIMESTAMP_KEY, System.currentTimeMillis() - 10 * 60 * 1000L - 1);
    given(invoker2.getUrl()).willReturn(url2);
    Assertions.assertEquals(balance.getWeight(invoker1, invocation), balance.getWeight(invoker2, invocation));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker createMockInvokerWithUrl(URL url) {
    Invoker invoker = mock(Invoker.class, Mockito.withSettings().stubOnly());
    given(invoker.getUrl()).willReturn(url);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_51_2
#### Test Case Name: `testGetWeight`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\loadbalance\AbstractLoadBalanceTest.java`)
#### Mock Object Variable Name: `invoker2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    URL url1 = new ServiceConfigURL("", "", 0, "DemoService", new HashMap<>());
    url1 = url1.addParameter(TIMESTAMP_KEY, System.currentTimeMillis() - Integer.MAX_VALUE - 1);
    given(invoker1.getUrl()).willReturn(url1);
-    Invoker invoker2 = mock(Invoker.class, Mockito.withSettings().stubOnly());
    URL url2 = new ServiceConfigURL("", "", 0, "DemoService", new HashMap<>());
    url2 = url2.addParameter(TIMESTAMP_KEY, System.currentTimeMillis() - 10 * 60 * 1000L - 1);
-    given(invoker2.getUrl()).willReturn(url2);
+    Invoker invoker2 = createMockInvokerWithUrl(url2);
    Assertions.assertEquals(balance.getWeight(invoker1, invocation), balance.getWeight(invoker2, invocation));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testGetWeight() {
    RpcInvocation invocation = new RpcInvocation();
    invocation.setMethodName("say");
    Invoker invoker1 = mock(Invoker.class, Mockito.withSettings().stubOnly());
    URL url1 = new ServiceConfigURL("", "", 0, "DemoService", new HashMap<>());
    url1 = url1.addParameter(TIMESTAMP_KEY, System.currentTimeMillis() - Integer.MAX_VALUE - 1);
    given(invoker1.getUrl()).willReturn(url1);
    Invoker invoker2 = mock(Invoker.class, Mockito.withSettings().stubOnly());
    URL url2 = new ServiceConfigURL("", "", 0, "DemoService", new HashMap<>());
    url2 = url2.addParameter(TIMESTAMP_KEY, System.currentTimeMillis() - 10 * 60 * 1000L - 1);
    given(invoker2.getUrl()).willReturn(url2);
    Assertions.assertEquals(balance.getWeight(invoker1, invocation), balance.getWeight(invoker2, invocation));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker createMockInvokerWithUrl(URL url) {
    Invoker invoker = mock(Invoker.class, Mockito.withSettings().stubOnly());
    given(invoker.getUrl()).willReturn(url);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_51_3
#### Test Case Name: `testGetRegistryWeight`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\loadbalance\AbstractLoadBalanceTest.java`)
#### Mock Object Variable Name: `invoker1`
<summary>Suggested Diff</summary>

```diff
@@
     invocation.setMethodName("say");
-    Invoker invoker1 = mock(Invoker.class, Mockito.withSettings().stubOnly());
     URL url1 = new ServiceConfigURL("", "", 0, "DemoService", new HashMap<>());
-    given(invoker1.getUrl()).willReturn(url1);
+    Invoker invoker1 = createMockInvokerWithUrl(url1);
     ClusterInvoker invoker2 = mock(ClusterInvoker.class, Mockito.withSettings().stubOnly());
     URL url2 = new ServiceConfigURL("", "", 0, "org.apache.dubbo.registry.RegistryService", new HashMap<>());
     url2 = url2.addParameter(WEIGHT_KEY, 20);
     URL registryUrl2 = new ServiceConfigURL("", "", 0, "org.apache.dubbo.registry.RegistryService", new HashMap<>());
     registryUrl2 = registryUrl2.addParameter(WEIGHT_KEY, 30);
     given(invoker2.getUrl()).willReturn(url2);
     given(invoker2.getRegistryUrl()).willReturn(registryUrl2);
     Assertions.assertEquals(100, balance.getWeight(invoker1, invocation));
     Assertions.assertEquals(30, balance.getWeight(invoker2, invocation));
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testGetRegistryWeight() {
    RpcInvocation invocation = new RpcInvocation();
    invocation.setMethodName("say");
    Invoker invoker1 = mock(Invoker.class, Mockito.withSettings().stubOnly());
    URL url1 = new ServiceConfigURL("", "", 0, "DemoService", new HashMap<>());
    given(invoker1.getUrl()).willReturn(url1);
    ClusterInvoker invoker2 = mock(ClusterInvoker.class, Mockito.withSettings().stubOnly());
    URL url2 = new ServiceConfigURL("", "", 0, "org.apache.dubbo.registry.RegistryService", new HashMap<>());
    url2 = url2.addParameter(WEIGHT_KEY, 20);
    URL registryUrl2 = new ServiceConfigURL("", "", 0, "org.apache.dubbo.registry.RegistryService", new HashMap<>());
    registryUrl2 = registryUrl2.addParameter(WEIGHT_KEY, 30);
    given(invoker2.getUrl()).willReturn(url2);
    given(invoker2.getRegistryUrl()).willReturn(registryUrl2);
    Assertions.assertEquals(100, balance.getWeight(invoker1, invocation));
    Assertions.assertEquals(30, balance.getWeight(invoker2, invocation));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker createMockInvokerWithUrl(URL url) {
    Invoker invoker = mock(Invoker.class, Mockito.withSettings().stubOnly());
    given(invoker.getUrl()).willReturn(url);
    return invoker;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_52
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.config.context.ConfigManager`
- **Test Case Count**: 7
- **MO Count**: 7

### Reusable Method
```java
private static ConfigManager createMockConfigManager(ApplicationConfig applicationConfig) {
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    return configManager;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_52_1
#### Test Case Name: `testConsumerUrlWithoutProtocol`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `configManager`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
-    ConfigManager configManager = mock(ConfigManager.class);
-    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
+    ConfigManager configManager = createMockConfigManager(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify the generated consumer url information
 */
@Test
void testConsumerUrlWithoutProtocol() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    // verify that the protocol header of consumerUrl is set to "consumer"
    Assertions.assertEquals("consumer", consumerUrl.getProtocol());
    Assertions.assertEquals(parameters.get(REGISTER_IP_KEY), consumerUrl.getHost());
    Assertions.assertFalse(consumerUrl.getAttributes().containsKey(REFER_KEY));
    Assertions.assertEquals("value1", consumerUrl.getAttribute("key1"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConfigManager createMockConfigManager(ApplicationConfig applicationConfig) {
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    return configManager;
}
```
</details>

---
#### Test Case ID #dubbo_Test_52_2
#### Test Case Name: `testConsumerUrlWithProtocol`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `configManager`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
-    ConfigManager configManager = mock(ConfigManager.class);
-    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
+    ConfigManager configManager = createMockConfigManager(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that when the protocol is configured, the protocol of consumer url is the configured protocol
 */
@Test
void testConsumerUrlWithProtocol() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    parameters.put(PROTOCOL_KEY, "tri");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    // verify that the protocol of consumer url
    Assertions.assertEquals("tri", consumerUrl.getProtocol());
    Assertions.assertEquals(parameters.get(REGISTER_IP_KEY), consumerUrl.getHost());
    Assertions.assertFalse(consumerUrl.getAttributes().containsKey(REFER_KEY));
    Assertions.assertEquals("value1", consumerUrl.getAttribute("key1"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConfigManager createMockConfigManager(ApplicationConfig applicationConfig) {
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    return configManager;
}
```
</details>

---
#### Test Case ID #dubbo_Test_52_3
#### Test Case Name: `testReferWithoutGroup`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `configManager`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
-    ConfigManager configManager = mock(ConfigManager.class);
-    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
+    ConfigManager configManager = createMockConfigManager(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that if multiple groups are not configured, the service reference of the registration center
 * the default is FailoverCluster
 *
 * @see FailoverCluster
 */
@Test
void testReferWithoutGroup() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Invoker<?> invoker = registryProtocol.refer(DemoService.class, url);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    Assertions.assertTrue(((MigrationInvoker<?>) invoker).getCluster() instanceof ScopeClusterWrapper);
    Assertions.assertTrue(((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster() instanceof MockClusterWrapper);
    Assertions.assertTrue(((MockClusterWrapper) ((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster()).getCluster() instanceof FailoverCluster);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConfigManager createMockConfigManager(ApplicationConfig applicationConfig) {
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    return configManager;
}
```
</details>

---
#### Test Case ID #dubbo_Test_52_4
#### Test Case Name: `testReferWithGroup`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `configManager`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
-    ConfigManager configManager = mock(ConfigManager.class);
-    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
+    ConfigManager configManager = createMockConfigManager(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that if multiple groups are configured, the service reference of the registration center
 *
 * @see MergeableCluster
 */
@Test
void testReferWithGroup() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    refer.put(GROUP_KEY, "group1,group2");
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Invoker<?> invoker = registryProtocol.refer(DemoService.class, url);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    Assertions.assertTrue(((MigrationInvoker<?>) invoker).getCluster() instanceof ScopeClusterWrapper);
    Assertions.assertTrue(((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster() instanceof MockClusterWrapper);
    Assertions.assertTrue(((MockClusterWrapper) ((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster()).getCluster() instanceof MergeableCluster);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConfigManager createMockConfigManager(ApplicationConfig applicationConfig) {
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    return configManager;
}
```
</details>

---
#### Test Case ID #dubbo_Test_52_5
#### Test Case Name: `testInterceptInvokerForMigrationRuleListener`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `configManager`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
-    ConfigManager configManager = mock(ConfigManager.class);
-    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
+    ConfigManager configManager = createMockConfigManager(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that the default RegistryProtocolListener will be executed
 *
 * @see MigrationRuleListener
 */
@Test
void testInterceptInvokerForMigrationRuleListener() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    refer.put(GROUP_KEY, "group1,group2");
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    MigrationInvoker<?> clusterInvoker = mock(MigrationInvoker.class);
    Map<String, Object> consumerAttribute = new HashMap<>(url.getAttributes());
    consumerAttribute.remove(REFER_KEY);
    URL consumerUrl = new ServiceConfigURL(parameters.get(PROTOCOL_KEY) == null ? DUBBO : parameters.get(PROTOCOL_KEY), null, null, parameters.get(REGISTER_IP_KEY), 0, url.getPath(), parameters, consumerAttribute);
    url = url.putAttribute(CONSUMER_URL_KEY, consumerUrl);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    registryProtocol.interceptInvoker(clusterInvoker, url, consumerUrl);
    verify(migrationRuleListener, times(1)).onRefer(registryProtocol, clusterInvoker, consumerUrl, url);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConfigManager createMockConfigManager(ApplicationConfig applicationConfig) {
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    return configManager;
}
```
</details>

---
#### Test Case ID #dubbo_Test_52_6
#### Test Case Name: `testInterceptInvokerForCustomRegistryProtocolListener`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `configManager`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
-    ConfigManager configManager = mock(ConfigManager.class);
-    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
+    ConfigManager configManager = createMockConfigManager(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Verify that if registry.protocol.listener is configured,
 * whether the corresponding RegistryProtocolListener will be executed normally
 *
 * @see CountRegistryProtocolListener
 */
@Test
void testInterceptInvokerForCustomRegistryProtocolListener() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    parameters.put(REGISTRY_PROTOCOL_LISTENER_KEY, "count");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    refer.put(GROUP_KEY, "group1,group2");
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    MigrationInvoker<?> clusterInvoker = mock(MigrationInvoker.class);
    Map<String, Object> consumerAttribute = new HashMap<>(url.getAttributes());
    consumerAttribute.remove(REFER_KEY);
    URL consumerUrl = new ServiceConfigURL(parameters.get(PROTOCOL_KEY) == null ? DUBBO : parameters.get(PROTOCOL_KEY), null, null, parameters.get(REGISTER_IP_KEY), 0, url.getPath(), parameters, consumerAttribute);
    url = url.putAttribute(CONSUMER_URL_KEY, consumerUrl);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(new CountRegistryProtocolListener());
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    registryProtocol.interceptInvoker(clusterInvoker, url, consumerUrl);
    Assertions.assertEquals(1, CountRegistryProtocolListener.getReferCounter().get());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConfigManager createMockConfigManager(ApplicationConfig applicationConfig) {
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    return configManager;
}
```
</details>

---
#### Test Case ID #dubbo_Test_52_7
#### Test Case Name: `testRegisterConsumerUrl`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `configManager`
<summary>Suggested Diff</summary>

```diff
@@
     applicationConfig.setName("application1");
-    ConfigManager configManager = mock(ConfigManager.class);
-    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
+    ConfigManager configManager = createMockConfigManager(applicationConfig);
     CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
     when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
     Map<String, String> parameters = new HashMap<>();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify the registered consumer url
 */
@Test
void testRegisterConsumerUrl() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "true");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    Map<String, String> urlParameters = consumerUrl.getParameters();
    URL urlToRegistry = new ServiceConfigURL(urlParameters.get(PROTOCOL_KEY) == null ? CONSUMER : urlParameters.get(PROTOCOL_KEY), urlParameters.remove(REGISTER_IP_KEY), 0, consumerUrl.getPath(), urlParameters);
    URL registeredConsumerUrl = urlToRegistry.addParameters(CATEGORY_KEY, CONSUMERS_CATEGORY, CHECK_KEY, String.valueOf(false)).setScopeModel(moduleModel);
    verify(registry, times(1)).register(registeredConsumerUrl);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConfigManager createMockConfigManager(ApplicationConfig applicationConfig) {
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    return configManager;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_53
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.registry.NotifyListener`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static NotifyListener createMockNotifyListener(URL consumerUrl) {
    NotifyListener notifyListener = mock(NotifyListener.class);
    when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
    return notifyListener;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_53_1
#### Test Case Name: `testSubscribeURLs`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\ServiceDiscoveryRegistryTest.java`)
#### Mock Object Variable Name: `testServiceListener2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    assertEquals(urls, captor.getValue());
    // different interface mapping to the same apps
-    NotifyListener testServiceListener2 = mock(NotifyListener.class);
     URL url2 = URL.valueOf("tri://127.0.0.1/TestService2?interface=TestService2&check=false&protocol=tri");
-    when(testServiceListener2.getConsumerUrl()).thenReturn(url2);
+    NotifyListener testServiceListener2 = createMockNotifyListener(url2);
     serviceDiscoveryRegistry.subscribeURLs(url2, testServiceListener2, multiApps);
     // check instance listeners not changed, methods not called
     assertEquals(2, serviceDiscoveryRegistry.getServiceListeners().size());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Test instance listener registration
 * - one app
 * - multi apps
 * - repeat same multi apps, instance listener shared
 * - protocol included in key
 * - instance listener gets notified
 * - instance listener and service listener rightly mapped
 */
@Test
void testSubscribeURLs() {
    // interface to single app mapping
    Set<String> singleApp = new TreeSet<>();
    singleApp.add(APP_NAME1);
    serviceDiscoveryRegistry.subscribeURLs(url, testServiceListener, singleApp);
    assertEquals(1, serviceDiscoveryRegistry.getServiceListeners().size());
    verify(testServiceListener, times(1)).addServiceListener(instanceListener);
    verify(instanceListener, never()).onEvent(any());
    verify(serviceDiscovery, times(1)).addServiceInstancesChangedListener(instanceListener);
    // interface to multiple apps mapping
    Set<String> multiApps = new TreeSet<>();
    multiApps.add(APP_NAME1);
    multiApps.add(APP_NAME2);
    MockServiceInstancesChangedListener multiAppsInstanceListener = spy(new MockServiceInstancesChangedListener(multiApps, serviceDiscovery));
    doNothing().when(multiAppsInstanceListener).onEvent(any());
    List<URL> urls = new ArrayList<>();
    urls.add(URL.valueOf("dubbo://127.0.0.1:20880/TestService"));
    doReturn(urls).when(multiAppsInstanceListener).getAddresses(any(), any());
    when(serviceDiscovery.createListener(multiApps)).thenReturn(multiAppsInstanceListener);
    when(serviceDiscovery.getInstances(APP_NAME1)).thenReturn(instanceList1);
    when(serviceDiscovery.getInstances(APP_NAME2)).thenReturn(instanceList2);
    serviceDiscoveryRegistry.subscribeURLs(url, testServiceListener, multiApps);
    assertEquals(2, serviceDiscoveryRegistry.getServiceListeners().size());
    assertEquals(instanceListener, serviceDiscoveryRegistry.getServiceListeners().get(toStringKeys(singleApp)));
    assertEquals(multiAppsInstanceListener, serviceDiscoveryRegistry.getServiceListeners().get(toStringKeys(multiApps)));
    verify(testServiceListener, times(1)).addServiceListener(multiAppsInstanceListener);
    verify(multiAppsInstanceListener, times(2)).onEvent(any());
    verify(multiAppsInstanceListener, times(1)).addListenerAndNotify(any(), eq(testServiceListener));
    verify(serviceDiscovery, times(1)).addServiceInstancesChangedListener(multiAppsInstanceListener);
    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);
    verify(testServiceListener).notify(captor.capture());
    assertEquals(urls, captor.getValue());
    // different interface mapping to the same apps
    NotifyListener testServiceListener2 = mock(NotifyListener.class);
    URL url2 = URL.valueOf("tri://127.0.0.1/TestService2?interface=TestService2&check=false&protocol=tri");
    when(testServiceListener2.getConsumerUrl()).thenReturn(url2);
    serviceDiscoveryRegistry.subscribeURLs(url2, testServiceListener2, multiApps);
    // check instance listeners not changed, methods not called
    assertEquals(2, serviceDiscoveryRegistry.getServiceListeners().size());
    assertEquals(multiAppsInstanceListener, serviceDiscoveryRegistry.getServiceListeners().get(toStringKeys(multiApps)));
    verify(multiAppsInstanceListener, times(1)).addListenerAndNotify(any(), eq(testServiceListener));
    // still called once, not executed this time
    verify(serviceDiscovery, times(2)).addServiceInstancesChangedListener(multiAppsInstanceListener);
    // check different protocol
    Map<String, Set<ServiceInstancesChangedListener.NotifyListenerWithKey>> serviceListeners = multiAppsInstanceListener.getServiceListeners();
    assertEquals(2, serviceListeners.size());
    assertEquals(1, serviceListeners.get(url.getServiceKey()).size());
    assertEquals(1, serviceListeners.get(url2.getServiceKey()).size());
    ProtocolServiceKey protocolServiceKey = new ProtocolServiceKey(url2.getServiceInterface(), url2.getVersion(), url2.getGroup(), url2.getParameter(PROTOCOL_KEY, DUBBO));
    assertTrue(serviceListeners.get(url2.getServiceKey()).contains(new ServiceInstancesChangedListener.NotifyListenerWithKey(protocolServiceKey, testServiceListener2)));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static NotifyListener createMockNotifyListener(URL consumerUrl) {
    NotifyListener notifyListener = mock(NotifyListener.class);
    when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
    return notifyListener;
}
```
</details>

---
#### Test Case ID #dubbo_Test_53_2
#### Test Case Name: `testUnsubscribe`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\ServiceDiscoveryRegistryTest.java`)
#### Mock Object Variable Name: `testServiceListener2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    multiApps.add(APP_NAME1);
    multiApps.add(APP_NAME2);
-    NotifyListener testServiceListener2 = mock(NotifyListener.class);
    URL url2 = URL.valueOf("consumer://127.0.0.1/TestService2?interface=TestService1&check=false&protocol=tri");
-    when(testServiceListener2.getConsumerUrl()).thenReturn(url2);
+    NotifyListener testServiceListener2 = createMockNotifyListener(url2);
    serviceDiscoveryRegistry.subscribeURLs(url, testServiceListener, multiApps);
    serviceDiscoveryRegistry.subscribeURLs(url2, testServiceListener2, multiApps);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testUnsubscribe() {
    // do subscribe to prepare for unsubscribe verification
    Set<String> multiApps = new TreeSet<>();
    multiApps.add(APP_NAME1);
    multiApps.add(APP_NAME2);
    NotifyListener testServiceListener2 = mock(NotifyListener.class);
    URL url2 = URL.valueOf("consumer://127.0.0.1/TestService2?interface=TestService1&check=false&protocol=tri");
    when(testServiceListener2.getConsumerUrl()).thenReturn(url2);
    serviceDiscoveryRegistry.subscribeURLs(url, testServiceListener, multiApps);
    serviceDiscoveryRegistry.subscribeURLs(url2, testServiceListener2, multiApps);
    assertEquals(1, serviceDiscoveryRegistry.getServiceListeners().size());
    // do unsubscribe
    when(mapping.getMapping(url2)).thenReturn(multiApps);
    serviceDiscoveryRegistry.doUnsubscribe(url2, testServiceListener2);
    assertEquals(1, serviceDiscoveryRegistry.getServiceListeners().size());
    ServiceInstancesChangedListener instancesChangedListener = serviceDiscoveryRegistry.getServiceListeners().entrySet().iterator().next().getValue();
    assertTrue(instancesChangedListener.hasListeners());
    when(mapping.getMapping(url)).thenReturn(multiApps);
    serviceDiscoveryRegistry.doUnsubscribe(url, testServiceListener);
    assertEquals(0, serviceDiscoveryRegistry.getServiceListeners().size());
    assertFalse(instancesChangedListener.hasListeners());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static NotifyListener createMockNotifyListener(URL consumerUrl) {
    NotifyListener notifyListener = mock(NotifyListener.class);
    when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
    return notifyListener;
}
```
</details>

---
#### Test Case ID #dubbo_Test_53_3
#### Test Case Name: `testSubscribeURLs`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\ServiceDiscoveryRegistryTest.java`)
#### Mock Object Variable Name: `testServiceListener`
<summary>Suggested Diff</summary>

```diff
--- a/TestClass.java
+++ b/TestClass.java
@@
-    private static NotifyListener testServiceListener = mock(NotifyListener.class);
+    private static NotifyListener testServiceListener;
     
@@
-    when(testServiceListener.getConsumerUrl()).thenReturn(url);
+    testServiceListener = createMockNotifyListener(url);
     
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void init() {
    serviceDiscovery = mock(ServiceDiscovery.class);
    instanceListener = spy(new MockServiceInstancesChangedListener(Collections.emptySet(), serviceDiscovery));
    doNothing().when(instanceListener).onEvent(any());
    when(serviceDiscovery.createListener(any())).thenReturn(instanceListener);
    when(serviceDiscovery.getInstances(any())).thenReturn(Collections.emptyList());
    when(serviceDiscovery.getUrl()).thenReturn(url);
    ApplicationModel applicationModel = spy(ApplicationModel.defaultModel());
    when(applicationModel.getDefaultExtension(ServiceNameMapping.class)).thenReturn(mapping);
    registryURL = registryURL.setScopeModel(applicationModel);
    serviceDiscoveryRegistry = new ServiceDiscoveryRegistry(registryURL, serviceDiscovery, mapping);
    when(mapping.getMappingLock(any())).thenReturn(lock);
    when(testServiceListener.getConsumerUrl()).thenReturn(url);
}
/**
 * Test instance listener registration
 * - one app
 * - multi apps
 * - repeat same multi apps, instance listener shared
 * - protocol included in key
 * - instance listener gets notified
 * - instance listener and service listener rightly mapped
 */
@Test
void testSubscribeURLs() {
    // interface to single app mapping
    Set<String> singleApp = new TreeSet<>();
    singleApp.add(APP_NAME1);
    serviceDiscoveryRegistry.subscribeURLs(url, testServiceListener, singleApp);
    assertEquals(1, serviceDiscoveryRegistry.getServiceListeners().size());
    verify(testServiceListener, times(1)).addServiceListener(instanceListener);
    verify(instanceListener, never()).onEvent(any());
    verify(serviceDiscovery, times(1)).addServiceInstancesChangedListener(instanceListener);
    // interface to multiple apps mapping
    Set<String> multiApps = new TreeSet<>();
    multiApps.add(APP_NAME1);
    multiApps.add(APP_NAME2);
    MockServiceInstancesChangedListener multiAppsInstanceListener = spy(new MockServiceInstancesChangedListener(multiApps, serviceDiscovery));
    doNothing().when(multiAppsInstanceListener).onEvent(any());
    List<URL> urls = new ArrayList<>();
    urls.add(URL.valueOf("dubbo://127.0.0.1:20880/TestService"));
    doReturn(urls).when(multiAppsInstanceListener).getAddresses(any(), any());
    when(serviceDiscovery.createListener(multiApps)).thenReturn(multiAppsInstanceListener);
    when(serviceDiscovery.getInstances(APP_NAME1)).thenReturn(instanceList1);
    when(serviceDiscovery.getInstances(APP_NAME2)).thenReturn(instanceList2);
    serviceDiscoveryRegistry.subscribeURLs(url, testServiceListener, multiApps);
    assertEquals(2, serviceDiscoveryRegistry.getServiceListeners().size());
    assertEquals(instanceListener, serviceDiscoveryRegistry.getServiceListeners().get(toStringKeys(singleApp)));
    assertEquals(multiAppsInstanceListener, serviceDiscoveryRegistry.getServiceListeners().get(toStringKeys(multiApps)));
    verify(testServiceListener, times(1)).addServiceListener(multiAppsInstanceListener);
    verify(multiAppsInstanceListener, times(2)).onEvent(any());
    verify(multiAppsInstanceListener, times(1)).addListenerAndNotify(any(), eq(testServiceListener));
    verify(serviceDiscovery, times(1)).addServiceInstancesChangedListener(multiAppsInstanceListener);
    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);
    verify(testServiceListener).notify(captor.capture());
    assertEquals(urls, captor.getValue());
    // different interface mapping to the same apps
    NotifyListener testServiceListener2 = mock(NotifyListener.class);
    URL url2 = URL.valueOf("tri://127.0.0.1/TestService2?interface=TestService2&check=false&protocol=tri");
    when(testServiceListener2.getConsumerUrl()).thenReturn(url2);
    serviceDiscoveryRegistry.subscribeURLs(url2, testServiceListener2, multiApps);
    // check instance listeners not changed, methods not called
    assertEquals(2, serviceDiscoveryRegistry.getServiceListeners().size());
    assertEquals(multiAppsInstanceListener, serviceDiscoveryRegistry.getServiceListeners().get(toStringKeys(multiApps)));
    verify(multiAppsInstanceListener, times(1)).addListenerAndNotify(any(), eq(testServiceListener));
    // still called once, not executed this time
    verify(serviceDiscovery, times(2)).addServiceInstancesChangedListener(multiAppsInstanceListener);
    // check different protocol
    Map<String, Set<ServiceInstancesChangedListener.NotifyListenerWithKey>> serviceListeners = multiAppsInstanceListener.getServiceListeners();
    assertEquals(2, serviceListeners.size());
    assertEquals(1, serviceListeners.get(url.getServiceKey()).size());
    assertEquals(1, serviceListeners.get(url2.getServiceKey()).size());
    ProtocolServiceKey protocolServiceKey = new ProtocolServiceKey(url2.getServiceInterface(), url2.getVersion(), url2.getGroup(), url2.getParameter(PROTOCOL_KEY, DUBBO));
    assertTrue(serviceListeners.get(url2.getServiceKey()).contains(new ServiceInstancesChangedListener.NotifyListenerWithKey(protocolServiceKey, testServiceListener2)));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static NotifyListener createMockNotifyListener(URL consumerUrl) {
    NotifyListener notifyListener = mock(NotifyListener.class);
    when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
    return notifyListener;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_54
- **Scope**: class level
- **Mocked Class**: `org.apache.dubbo.registry.NotifyListener`
- **Test Case Count**: 3
- **MO Count**: 22

### Reusable Method
```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_54_1
#### Test Case Name: `testServiceListenerNotification`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerTest.java`)
#### Mock Object Variable Name: `demoServiceListener`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
-    NotifyListener demoServiceListener = Mockito.mock(NotifyListener.class);
-    when(demoServiceListener.getConsumerUrl()).thenReturn(consumerURL);
+    NotifyListener demoServiceListener = MockNotifyListener.createMockNotifyListener(consumerURL);
    NotifyListener demoService2Listener = Mockito.mock(NotifyListener.class);
    when(demoService2Listener.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
// instance listener -> service listener(Directory)
@Test
@Order(5)
public void testServiceListenerNotification() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    serviceNames.add("app2");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    NotifyListener demoServiceListener = Mockito.mock(NotifyListener.class);
    when(demoServiceListener.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoService2Listener = Mockito.mock(NotifyListener.class);
    when(demoService2Listener.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1Instances);
    listener.onEvent(app1_event);
    // check
    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener, Mockito.times(1)).notify(captor.capture());
    List<URL> notifiedUrls = captor.getValue();
    Assertions.assertEquals(3, notifiedUrls.size());
    ArgumentCaptor<List<URL>> captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener, Mockito.times(1)).notify(captor2.capture());
    List<URL> notifiedUrls2 = captor2.getValue();
    Assertions.assertEquals(0, notifiedUrls2.size());
    // notify app2 instance change
    ServiceInstancesChangedEvent app2_event = new ServiceInstancesChangedEvent("app2", app2Instances);
    listener.onEvent(app2_event);
    // check
    ArgumentCaptor<List<URL>> app2_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener, Mockito.times(2)).notify(app2_captor.capture());
    List<URL> app2_notifiedUrls = app2_captor.getValue();
    Assertions.assertEquals(7, app2_notifiedUrls.size());
    ArgumentCaptor<List<URL>> app2_captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener, Mockito.times(2)).notify(app2_captor2.capture());
    List<URL> app2_notifiedUrls2 = app2_captor2.getValue();
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_2
#### Test Case Name: `testServiceListenerNotification`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerTest.java`)
#### Mock Object Variable Name: `demoService2Listener`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    NotifyListener demoServiceListener = Mockito.mock(NotifyListener.class);
    when(demoServiceListener.getConsumerUrl()).thenReturn(consumerURL);
-    NotifyListener demoService2Listener = Mockito.mock(NotifyListener.class);
-    when(demoService2Listener.getConsumerUrl()).thenReturn(consumerURL2);
+    NotifyListener demoService2Listener = MockNotifyListener.createMockNotifyListener(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
// instance listener -> service listener(Directory)
@Test
@Order(5)
public void testServiceListenerNotification() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    serviceNames.add("app2");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    NotifyListener demoServiceListener = Mockito.mock(NotifyListener.class);
    when(demoServiceListener.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoService2Listener = Mockito.mock(NotifyListener.class);
    when(demoService2Listener.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1Instances);
    listener.onEvent(app1_event);
    // check
    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener, Mockito.times(1)).notify(captor.capture());
    List<URL> notifiedUrls = captor.getValue();
    Assertions.assertEquals(3, notifiedUrls.size());
    ArgumentCaptor<List<URL>> captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener, Mockito.times(1)).notify(captor2.capture());
    List<URL> notifiedUrls2 = captor2.getValue();
    Assertions.assertEquals(0, notifiedUrls2.size());
    // notify app2 instance change
    ServiceInstancesChangedEvent app2_event = new ServiceInstancesChangedEvent("app2", app2Instances);
    listener.onEvent(app2_event);
    // check
    ArgumentCaptor<List<URL>> app2_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener, Mockito.times(2)).notify(app2_captor.capture());
    List<URL> app2_notifiedUrls = app2_captor.getValue();
    Assertions.assertEquals(7, app2_notifiedUrls.size());
    ArgumentCaptor<List<URL>> app2_captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener, Mockito.times(2)).notify(app2_captor2.capture());
    List<URL> app2_notifiedUrls2 = app2_captor2.getValue();
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_3
#### Test Case Name: `testServiceListenerNotification`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerTest.java`)
#### Mock Object Variable Name: `demoService3Listener`
<summary>Suggested Diff</summary>

```diff
@@
     // test service listener still get notified when added after instance notification.
-    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
-    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
+    NotifyListener demoService3Listener = MockNotifyListener.createMockNotifyListener(consumerURL3);
     listener.addListenerAndNotify(consumerURL3, demoService3Listener);
     Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
// instance listener -> service listener(Directory)
@Test
@Order(5)
public void testServiceListenerNotification() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    serviceNames.add("app2");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    NotifyListener demoServiceListener = Mockito.mock(NotifyListener.class);
    when(demoServiceListener.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoService2Listener = Mockito.mock(NotifyListener.class);
    when(demoService2Listener.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1Instances);
    listener.onEvent(app1_event);
    // check
    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener, Mockito.times(1)).notify(captor.capture());
    List<URL> notifiedUrls = captor.getValue();
    Assertions.assertEquals(3, notifiedUrls.size());
    ArgumentCaptor<List<URL>> captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener, Mockito.times(1)).notify(captor2.capture());
    List<URL> notifiedUrls2 = captor2.getValue();
    Assertions.assertEquals(0, notifiedUrls2.size());
    // notify app2 instance change
    ServiceInstancesChangedEvent app2_event = new ServiceInstancesChangedEvent("app2", app2Instances);
    listener.onEvent(app2_event);
    // check
    ArgumentCaptor<List<URL>> app2_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener, Mockito.times(2)).notify(app2_captor.capture());
    List<URL> app2_notifiedUrls = app2_captor.getValue();
    Assertions.assertEquals(7, app2_notifiedUrls.size());
    ArgumentCaptor<List<URL>> app2_captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener, Mockito.times(2)).notify(app2_captor2.capture());
    List<URL> app2_notifiedUrls2 = app2_captor2.getValue();
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_4
#### Test Case Name: `testMultiServiceListenerNotification`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerTest.java`)
#### Mock Object Variable Name: `demoServiceListener1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
-    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
-    when(demoServiceListener1.getConsumerUrl()).thenReturn(consumerURL);
+    NotifyListener demoServiceListener1 = MockNotifyListener.createMockNotifyListener(consumerURL);
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(consumerURL);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@Order(6)
public void testMultiServiceListenerNotification() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    serviceNames.add("app2");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoService2Listener1 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener1.getConsumerUrl()).thenReturn(consumerURL2);
    NotifyListener demoService2Listener2 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener2.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener1);
    listener.addListenerAndNotify(consumerURL, demoServiceListener2);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener1);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener2);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1Instances);
    listener.onEvent(app1_event);
    // check
    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(1)).notify(captor.capture());
    List<URL> notifiedUrls = captor.getValue();
    Assertions.assertEquals(3, notifiedUrls.size());
    ArgumentCaptor<List<URL>> captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(1)).notify(captor2.capture());
    List<URL> notifiedUrls2 = captor2.getValue();
    Assertions.assertEquals(0, notifiedUrls2.size());
    // notify app2 instance change
    ServiceInstancesChangedEvent app2_event = new ServiceInstancesChangedEvent("app2", app2Instances);
    listener.onEvent(app2_event);
    // check
    ArgumentCaptor<List<URL>> app2_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(2)).notify(app2_captor.capture());
    List<URL> app2_notifiedUrls = app2_captor.getValue();
    Assertions.assertEquals(7, app2_notifiedUrls.size());
    ArgumentCaptor<List<URL>> app2_captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(2)).notify(app2_captor2.capture());
    List<URL> app2_notifiedUrls2 = app2_captor2.getValue();
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_5
#### Test Case Name: `testMultiServiceListenerNotification`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerTest.java`)
#### Mock Object Variable Name: `demoServiceListener2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(consumerURL);
-    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
-    when(demoServiceListener2.getConsumerUrl()).thenReturn(consumerURL);
+    NotifyListener demoServiceListener2 = MockNotifyListener.createMockNotifyListener(consumerURL);
    NotifyListener demoService2Listener1 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener1.getConsumerUrl()).thenReturn(consumerURL2);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@Order(6)
public void testMultiServiceListenerNotification() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    serviceNames.add("app2");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoService2Listener1 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener1.getConsumerUrl()).thenReturn(consumerURL2);
    NotifyListener demoService2Listener2 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener2.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener1);
    listener.addListenerAndNotify(consumerURL, demoServiceListener2);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener1);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener2);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1Instances);
    listener.onEvent(app1_event);
    // check
    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(1)).notify(captor.capture());
    List<URL> notifiedUrls = captor.getValue();
    Assertions.assertEquals(3, notifiedUrls.size());
    ArgumentCaptor<List<URL>> captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(1)).notify(captor2.capture());
    List<URL> notifiedUrls2 = captor2.getValue();
    Assertions.assertEquals(0, notifiedUrls2.size());
    // notify app2 instance change
    ServiceInstancesChangedEvent app2_event = new ServiceInstancesChangedEvent("app2", app2Instances);
    listener.onEvent(app2_event);
    // check
    ArgumentCaptor<List<URL>> app2_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(2)).notify(app2_captor.capture());
    List<URL> app2_notifiedUrls = app2_captor.getValue();
    Assertions.assertEquals(7, app2_notifiedUrls.size());
    ArgumentCaptor<List<URL>> app2_captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(2)).notify(app2_captor2.capture());
    List<URL> app2_notifiedUrls2 = app2_captor2.getValue();
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_6
#### Test Case Name: `testMultiServiceListenerNotification`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerTest.java`)
#### Mock Object Variable Name: `demoService2Listener1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(consumerURL);
-    NotifyListener demoService2Listener1 = Mockito.mock(NotifyListener.class);
-    when(demoService2Listener1.getConsumerUrl()).thenReturn(consumerURL2);
+    NotifyListener demoService2Listener1 = MockNotifyListener.createMockNotifyListener(consumerURL2);
    NotifyListener demoService2Listener2 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener2.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener1);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@Order(6)
public void testMultiServiceListenerNotification() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    serviceNames.add("app2");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoService2Listener1 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener1.getConsumerUrl()).thenReturn(consumerURL2);
    NotifyListener demoService2Listener2 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener2.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener1);
    listener.addListenerAndNotify(consumerURL, demoServiceListener2);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener1);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener2);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1Instances);
    listener.onEvent(app1_event);
    // check
    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(1)).notify(captor.capture());
    List<URL> notifiedUrls = captor.getValue();
    Assertions.assertEquals(3, notifiedUrls.size());
    ArgumentCaptor<List<URL>> captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(1)).notify(captor2.capture());
    List<URL> notifiedUrls2 = captor2.getValue();
    Assertions.assertEquals(0, notifiedUrls2.size());
    // notify app2 instance change
    ServiceInstancesChangedEvent app2_event = new ServiceInstancesChangedEvent("app2", app2Instances);
    listener.onEvent(app2_event);
    // check
    ArgumentCaptor<List<URL>> app2_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(2)).notify(app2_captor.capture());
    List<URL> app2_notifiedUrls = app2_captor.getValue();
    Assertions.assertEquals(7, app2_notifiedUrls.size());
    ArgumentCaptor<List<URL>> app2_captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(2)).notify(app2_captor2.capture());
    List<URL> app2_notifiedUrls2 = app2_captor2.getValue();
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_7
#### Test Case Name: `testMultiServiceListenerNotification`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerTest.java`)
#### Mock Object Variable Name: `demoService2Listener2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    NotifyListener demoService2Listener1 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener1.getConsumerUrl()).thenReturn(consumerURL2);
-    NotifyListener demoService2Listener2 = Mockito.mock(NotifyListener.class);
-    when(demoService2Listener2.getConsumerUrl()).thenReturn(consumerURL2);
+    NotifyListener demoService2Listener2 = MockNotifyListener.createMockNotifyListener(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener1);
    listener.addListenerAndNotify(consumerURL, demoServiceListener2);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@Order(6)
public void testMultiServiceListenerNotification() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    serviceNames.add("app2");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoService2Listener1 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener1.getConsumerUrl()).thenReturn(consumerURL2);
    NotifyListener demoService2Listener2 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener2.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener1);
    listener.addListenerAndNotify(consumerURL, demoServiceListener2);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener1);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener2);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1Instances);
    listener.onEvent(app1_event);
    // check
    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(1)).notify(captor.capture());
    List<URL> notifiedUrls = captor.getValue();
    Assertions.assertEquals(3, notifiedUrls.size());
    ArgumentCaptor<List<URL>> captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(1)).notify(captor2.capture());
    List<URL> notifiedUrls2 = captor2.getValue();
    Assertions.assertEquals(0, notifiedUrls2.size());
    // notify app2 instance change
    ServiceInstancesChangedEvent app2_event = new ServiceInstancesChangedEvent("app2", app2Instances);
    listener.onEvent(app2_event);
    // check
    ArgumentCaptor<List<URL>> app2_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(2)).notify(app2_captor.capture());
    List<URL> app2_notifiedUrls = app2_captor.getValue();
    Assertions.assertEquals(7, app2_notifiedUrls.size());
    ArgumentCaptor<List<URL>> app2_captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(2)).notify(app2_captor2.capture());
    List<URL> app2_notifiedUrls2 = app2_captor2.getValue();
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_8
#### Test Case Name: `testMultiServiceListenerNotification`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerTest.java`)
#### Mock Object Variable Name: `demoService3Listener`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
-    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
-    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
+    NotifyListener demoService3Listener = MockNotifyListener.createMockNotifyListener(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@Order(6)
public void testMultiServiceListenerNotification() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    serviceNames.add("app2");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoService2Listener1 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener1.getConsumerUrl()).thenReturn(consumerURL2);
    NotifyListener demoService2Listener2 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener2.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener1);
    listener.addListenerAndNotify(consumerURL, demoServiceListener2);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener1);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener2);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1Instances);
    listener.onEvent(app1_event);
    // check
    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(1)).notify(captor.capture());
    List<URL> notifiedUrls = captor.getValue();
    Assertions.assertEquals(3, notifiedUrls.size());
    ArgumentCaptor<List<URL>> captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(1)).notify(captor2.capture());
    List<URL> notifiedUrls2 = captor2.getValue();
    Assertions.assertEquals(0, notifiedUrls2.size());
    // notify app2 instance change
    ServiceInstancesChangedEvent app2_event = new ServiceInstancesChangedEvent("app2", app2Instances);
    listener.onEvent(app2_event);
    // check
    ArgumentCaptor<List<URL>> app2_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(2)).notify(app2_captor.capture());
    List<URL> app2_notifiedUrls = app2_captor.getValue();
    Assertions.assertEquals(7, app2_notifiedUrls.size());
    ArgumentCaptor<List<URL>> app2_captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(2)).notify(app2_captor2.capture());
    List<URL> app2_notifiedUrls2 = app2_captor2.getValue();
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_9
#### Test Case Name: `testSubscribeMultipleProtocols`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerTest.java`)
#### Mock Object Variable Name: `demoServiceListener1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    // no protocol specified, consume all instances
-    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
-    when(demoServiceListener1.getConsumerUrl()).thenReturn(noProtocolConsumerURL);
+    NotifyListener demoServiceListener1 = MockNotifyListener.createMockNotifyListener(noProtocolConsumerURL);
    listener.addListenerAndNotify(noProtocolConsumerURL, demoServiceListener1);
    // multiple protocols specified
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Test subscribe multiple protocols
 */
@Test
@Order(7)
public void testSubscribeMultipleProtocols() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    // no protocol specified, consume all instances
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(noProtocolConsumerURL);
    listener.addListenerAndNotify(noProtocolConsumerURL, demoServiceListener1);
    // multiple protocols specified
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(multipleProtocolsConsumerURL);
    listener.addListenerAndNotify(multipleProtocolsConsumerURL, demoServiceListener2);
    // one protocol specified
    NotifyListener demoServiceListener3 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener3.getConsumerUrl()).thenReturn(singleProtocolsConsumerURL);
    listener.addListenerAndNotify(singleProtocolsConsumerURL, demoServiceListener3);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1InstancesMultipleProtocols);
    listener.onEvent(app1_event);
    // check instances expose framework supported default protocols(currently dubbo, triple and rest) are notified
    ArgumentCaptor<List<URL>> default_protocol_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(1)).notify(default_protocol_captor.capture());
    List<URL> default_protocol_notifiedUrls = default_protocol_captor.getValue();
    Assertions.assertEquals(4, default_protocol_notifiedUrls.size());
    // check instances expose protocols in consuming list(dubbo and triple) are notified
    ArgumentCaptor<List<URL>> multi_protocols_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener2, Mockito.times(1)).notify(multi_protocols_captor.capture());
    List<URL> multi_protocol_notifiedUrls = multi_protocols_captor.getValue();
    Assertions.assertEquals(4, multi_protocol_notifiedUrls.size());
    // check instances expose protocols in consuming list(only triple) are notified
    ArgumentCaptor<List<URL>> single_protocols_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener3, Mockito.times(1)).notify(single_protocols_captor.capture());
    List<URL> single_protocol_notifiedUrls = single_protocols_captor.getValue();
    Assertions.assertEquals(1, single_protocol_notifiedUrls.size());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_10
#### Test Case Name: `testSubscribeMultipleProtocols`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerTest.java`)
#### Mock Object Variable Name: `demoServiceListener2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    // no protocol specified, consume all instances
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(noProtocolConsumerURL);
    listener.addListenerAndNotify(noProtocolConsumerURL, demoServiceListener1);
    // multiple protocols specified
-    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
-    when(demoServiceListener2.getConsumerUrl()).thenReturn(multipleProtocolsConsumerURL);
+    NotifyListener demoServiceListener2 = MockNotifyListener.createMockNotifyListener(multipleProtocolsConsumerURL);
    listener.addListenerAndNotify(multipleProtocolsConsumerURL, demoServiceListener2);
    // one protocol specified
    NotifyListener demoServiceListener3 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener3.getConsumerUrl()).thenReturn(singleProtocolsConsumerURL);
    listener.addListenerAndNotify(singleProtocolsConsumerURL, demoServiceListener3);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Test subscribe multiple protocols
 */
@Test
@Order(7)
public void testSubscribeMultipleProtocols() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    // no protocol specified, consume all instances
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(noProtocolConsumerURL);
    listener.addListenerAndNotify(noProtocolConsumerURL, demoServiceListener1);
    // multiple protocols specified
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(multipleProtocolsConsumerURL);
    listener.addListenerAndNotify(multipleProtocolsConsumerURL, demoServiceListener2);
    // one protocol specified
    NotifyListener demoServiceListener3 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener3.getConsumerUrl()).thenReturn(singleProtocolsConsumerURL);
    listener.addListenerAndNotify(singleProtocolsConsumerURL, demoServiceListener3);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1InstancesMultipleProtocols);
    listener.onEvent(app1_event);
    // check instances expose framework supported default protocols(currently dubbo, triple and rest) are notified
    ArgumentCaptor<List<URL>> default_protocol_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(1)).notify(default_protocol_captor.capture());
    List<URL> default_protocol_notifiedUrls = default_protocol_captor.getValue();
    Assertions.assertEquals(4, default_protocol_notifiedUrls.size());
    // check instances expose protocols in consuming list(dubbo and triple) are notified
    ArgumentCaptor<List<URL>> multi_protocols_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener2, Mockito.times(1)).notify(multi_protocols_captor.capture());
    List<URL> multi_protocol_notifiedUrls = multi_protocols_captor.getValue();
    Assertions.assertEquals(4, multi_protocol_notifiedUrls.size());
    // check instances expose protocols in consuming list(only triple) are notified
    ArgumentCaptor<List<URL>> single_protocols_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener3, Mockito.times(1)).notify(single_protocols_captor.capture());
    List<URL> single_protocol_notifiedUrls = single_protocols_captor.getValue();
    Assertions.assertEquals(1, single_protocol_notifiedUrls.size());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_11
#### Test Case Name: `testSubscribeMultipleProtocols`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerTest.java`)
#### Mock Object Variable Name: `demoServiceListener3`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    // multiple protocols specified
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(multipleProtocolsConsumerURL);
    listener.addListenerAndNotify(multipleProtocolsConsumerURL, demoServiceListener2);
    // one protocol specified
-    NotifyListener demoServiceListener3 = Mockito.mock(NotifyListener.class);
-    when(demoServiceListener3.getConsumerUrl()).thenReturn(singleProtocolsConsumerURL);
+    NotifyListener demoServiceListener3 = MockNotifyListener.createMockNotifyListener(singleProtocolsConsumerURL);
    listener.addListenerAndNotify(singleProtocolsConsumerURL, demoServiceListener3);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1InstancesMultipleProtocols);
    listener.onEvent(app1_event);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Test subscribe multiple protocols
 */
@Test
@Order(7)
public void testSubscribeMultipleProtocols() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    // no protocol specified, consume all instances
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(noProtocolConsumerURL);
    listener.addListenerAndNotify(noProtocolConsumerURL, demoServiceListener1);
    // multiple protocols specified
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(multipleProtocolsConsumerURL);
    listener.addListenerAndNotify(multipleProtocolsConsumerURL, demoServiceListener2);
    // one protocol specified
    NotifyListener demoServiceListener3 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener3.getConsumerUrl()).thenReturn(singleProtocolsConsumerURL);
    listener.addListenerAndNotify(singleProtocolsConsumerURL, demoServiceListener3);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1InstancesMultipleProtocols);
    listener.onEvent(app1_event);
    // check instances expose framework supported default protocols(currently dubbo, triple and rest) are notified
    ArgumentCaptor<List<URL>> default_protocol_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(1)).notify(default_protocol_captor.capture());
    List<URL> default_protocol_notifiedUrls = default_protocol_captor.getValue();
    Assertions.assertEquals(4, default_protocol_notifiedUrls.size());
    // check instances expose protocols in consuming list(dubbo and triple) are notified
    ArgumentCaptor<List<URL>> multi_protocols_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener2, Mockito.times(1)).notify(multi_protocols_captor.capture());
    List<URL> multi_protocol_notifiedUrls = multi_protocols_captor.getValue();
    Assertions.assertEquals(4, multi_protocol_notifiedUrls.size());
    // check instances expose protocols in consuming list(only triple) are notified
    ArgumentCaptor<List<URL>> single_protocols_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener3, Mockito.times(1)).notify(single_protocols_captor.capture());
    List<URL> single_protocol_notifiedUrls = single_protocols_captor.getValue();
    Assertions.assertEquals(1, single_protocol_notifiedUrls.size());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_12
#### Test Case Name: `testServiceListenerNotification`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerWithoutEmptyProtectTest.java`)
#### Mock Object Variable Name: `demoServiceListener`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
-    NotifyListener demoServiceListener = Mockito.mock(NotifyListener.class);
-    when(demoServiceListener.getConsumerUrl()).thenReturn(consumerURL);
+    NotifyListener demoServiceListener = MockNotifyListener.createMockNotifyListener(consumerURL);
    NotifyListener demoService2Listener = Mockito.mock(NotifyListener.class);
    when(demoService2Listener.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
// instance listener -> service listener(Directory)
@Test
@Order(5)
public void testServiceListenerNotification() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    serviceNames.add("app2");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    NotifyListener demoServiceListener = Mockito.mock(NotifyListener.class);
    when(demoServiceListener.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoService2Listener = Mockito.mock(NotifyListener.class);
    when(demoService2Listener.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1Instances);
    listener.onEvent(app1_event);
    // check
    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener, Mockito.times(1)).notify(captor.capture());
    List<URL> notifiedUrls = captor.getValue();
    Assertions.assertEquals(3, notifiedUrls.size());
    ArgumentCaptor<List<URL>> captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener, Mockito.times(1)).notify(captor2.capture());
    List<URL> notifiedUrls2 = captor2.getValue();
    Assertions.assertEquals(1, notifiedUrls2.size());
    // notify app2 instance change
    ServiceInstancesChangedEvent app2_event = new ServiceInstancesChangedEvent("app2", app2Instances);
    listener.onEvent(app2_event);
    // check
    ArgumentCaptor<List<URL>> app2_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener, Mockito.times(2)).notify(app2_captor.capture());
    List<URL> app2_notifiedUrls = app2_captor.getValue();
    Assertions.assertEquals(7, app2_notifiedUrls.size());
    ArgumentCaptor<List<URL>> app2_captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener, Mockito.times(2)).notify(app2_captor2.capture());
    List<URL> app2_notifiedUrls2 = app2_captor2.getValue();
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_13
#### Test Case Name: `testServiceListenerNotification`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerWithoutEmptyProtectTest.java`)
#### Mock Object Variable Name: `demoService2Listener`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    NotifyListener demoServiceListener = Mockito.mock(NotifyListener.class);
    when(demoServiceListener.getConsumerUrl()).thenReturn(consumerURL);
-    NotifyListener demoService2Listener = Mockito.mock(NotifyListener.class);
-    when(demoService2Listener.getConsumerUrl()).thenReturn(consumerURL2);
+    NotifyListener demoService2Listener = MockNotifyListener.createMockNotifyListener(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
// instance listener -> service listener(Directory)
@Test
@Order(5)
public void testServiceListenerNotification() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    serviceNames.add("app2");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    NotifyListener demoServiceListener = Mockito.mock(NotifyListener.class);
    when(demoServiceListener.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoService2Listener = Mockito.mock(NotifyListener.class);
    when(demoService2Listener.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1Instances);
    listener.onEvent(app1_event);
    // check
    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener, Mockito.times(1)).notify(captor.capture());
    List<URL> notifiedUrls = captor.getValue();
    Assertions.assertEquals(3, notifiedUrls.size());
    ArgumentCaptor<List<URL>> captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener, Mockito.times(1)).notify(captor2.capture());
    List<URL> notifiedUrls2 = captor2.getValue();
    Assertions.assertEquals(1, notifiedUrls2.size());
    // notify app2 instance change
    ServiceInstancesChangedEvent app2_event = new ServiceInstancesChangedEvent("app2", app2Instances);
    listener.onEvent(app2_event);
    // check
    ArgumentCaptor<List<URL>> app2_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener, Mockito.times(2)).notify(app2_captor.capture());
    List<URL> app2_notifiedUrls = app2_captor.getValue();
    Assertions.assertEquals(7, app2_notifiedUrls.size());
    ArgumentCaptor<List<URL>> app2_captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener, Mockito.times(2)).notify(app2_captor2.capture());
    List<URL> app2_notifiedUrls2 = app2_captor2.getValue();
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_14
#### Test Case Name: `testServiceListenerNotification`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerWithoutEmptyProtectTest.java`)
#### Mock Object Variable Name: `demoService3Listener`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
-    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
-    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
+    NotifyListener demoService3Listener = MockNotifyListener.createMockNotifyListener(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
// instance listener -> service listener(Directory)
@Test
@Order(5)
public void testServiceListenerNotification() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    serviceNames.add("app2");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    NotifyListener demoServiceListener = Mockito.mock(NotifyListener.class);
    when(demoServiceListener.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoService2Listener = Mockito.mock(NotifyListener.class);
    when(demoService2Listener.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1Instances);
    listener.onEvent(app1_event);
    // check
    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener, Mockito.times(1)).notify(captor.capture());
    List<URL> notifiedUrls = captor.getValue();
    Assertions.assertEquals(3, notifiedUrls.size());
    ArgumentCaptor<List<URL>> captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener, Mockito.times(1)).notify(captor2.capture());
    List<URL> notifiedUrls2 = captor2.getValue();
    Assertions.assertEquals(1, notifiedUrls2.size());
    // notify app2 instance change
    ServiceInstancesChangedEvent app2_event = new ServiceInstancesChangedEvent("app2", app2Instances);
    listener.onEvent(app2_event);
    // check
    ArgumentCaptor<List<URL>> app2_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener, Mockito.times(2)).notify(app2_captor.capture());
    List<URL> app2_notifiedUrls = app2_captor.getValue();
    Assertions.assertEquals(7, app2_notifiedUrls.size());
    ArgumentCaptor<List<URL>> app2_captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener, Mockito.times(2)).notify(app2_captor2.capture());
    List<URL> app2_notifiedUrls2 = app2_captor2.getValue();
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_15
#### Test Case Name: `testMultiServiceListenerNotification`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerWithoutEmptyProtectTest.java`)
#### Mock Object Variable Name: `demoServiceListener1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
-    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
-    when(demoServiceListener1.getConsumerUrl()).thenReturn(consumerURL);
+    NotifyListener demoServiceListener1 = MockNotifyListener.createMockNotifyListener(consumerURL);
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(consumerURL);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@Order(6)
public void testMultiServiceListenerNotification() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    serviceNames.add("app2");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoService2Listener1 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener1.getConsumerUrl()).thenReturn(consumerURL2);
    NotifyListener demoService2Listener2 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener2.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener1);
    listener.addListenerAndNotify(consumerURL, demoServiceListener2);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener1);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener2);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1Instances);
    listener.onEvent(app1_event);
    // check
    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(1)).notify(captor.capture());
    List<URL> notifiedUrls = captor.getValue();
    Assertions.assertEquals(3, notifiedUrls.size());
    ArgumentCaptor<List<URL>> captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(1)).notify(captor2.capture());
    List<URL> notifiedUrls2 = captor2.getValue();
    Assertions.assertEquals(1, notifiedUrls2.size());
    // notify app2 instance change
    ServiceInstancesChangedEvent app2_event = new ServiceInstancesChangedEvent("app2", app2Instances);
    listener.onEvent(app2_event);
    // check
    ArgumentCaptor<List<URL>> app2_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(2)).notify(app2_captor.capture());
    List<URL> app2_notifiedUrls = app2_captor.getValue();
    Assertions.assertEquals(7, app2_notifiedUrls.size());
    ArgumentCaptor<List<URL>> app2_captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(2)).notify(app2_captor2.capture());
    List<URL> app2_notifiedUrls2 = app2_captor2.getValue();
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_16
#### Test Case Name: `testMultiServiceListenerNotification`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerWithoutEmptyProtectTest.java`)
#### Mock Object Variable Name: `demoServiceListener2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(consumerURL);
-    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
-    when(demoServiceListener2.getConsumerUrl()).thenReturn(consumerURL);
+    NotifyListener demoServiceListener2 = MockNotifyListener.createMockNotifyListener(consumerURL);
    NotifyListener demoService2Listener1 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener1.getConsumerUrl()).thenReturn(consumerURL2);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@Order(6)
public void testMultiServiceListenerNotification() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    serviceNames.add("app2");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoService2Listener1 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener1.getConsumerUrl()).thenReturn(consumerURL2);
    NotifyListener demoService2Listener2 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener2.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener1);
    listener.addListenerAndNotify(consumerURL, demoServiceListener2);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener1);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener2);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1Instances);
    listener.onEvent(app1_event);
    // check
    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(1)).notify(captor.capture());
    List<URL> notifiedUrls = captor.getValue();
    Assertions.assertEquals(3, notifiedUrls.size());
    ArgumentCaptor<List<URL>> captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(1)).notify(captor2.capture());
    List<URL> notifiedUrls2 = captor2.getValue();
    Assertions.assertEquals(1, notifiedUrls2.size());
    // notify app2 instance change
    ServiceInstancesChangedEvent app2_event = new ServiceInstancesChangedEvent("app2", app2Instances);
    listener.onEvent(app2_event);
    // check
    ArgumentCaptor<List<URL>> app2_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(2)).notify(app2_captor.capture());
    List<URL> app2_notifiedUrls = app2_captor.getValue();
    Assertions.assertEquals(7, app2_notifiedUrls.size());
    ArgumentCaptor<List<URL>> app2_captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(2)).notify(app2_captor2.capture());
    List<URL> app2_notifiedUrls2 = app2_captor2.getValue();
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_17
#### Test Case Name: `testMultiServiceListenerNotification`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerWithoutEmptyProtectTest.java`)
#### Mock Object Variable Name: `demoService2Listener1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(consumerURL);
-    NotifyListener demoService2Listener1 = Mockito.mock(NotifyListener.class);
-    when(demoService2Listener1.getConsumerUrl()).thenReturn(consumerURL2);
+    NotifyListener demoService2Listener1 = MockNotifyListener.createMockNotifyListener(consumerURL2);
    NotifyListener demoService2Listener2 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener2.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener1);
    listener.addListenerAndNotify(consumerURL, demoServiceListener2);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener1);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener2);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@Order(6)
public void testMultiServiceListenerNotification() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    serviceNames.add("app2");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoService2Listener1 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener1.getConsumerUrl()).thenReturn(consumerURL2);
    NotifyListener demoService2Listener2 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener2.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener1);
    listener.addListenerAndNotify(consumerURL, demoServiceListener2);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener1);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener2);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1Instances);
    listener.onEvent(app1_event);
    // check
    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(1)).notify(captor.capture());
    List<URL> notifiedUrls = captor.getValue();
    Assertions.assertEquals(3, notifiedUrls.size());
    ArgumentCaptor<List<URL>> captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(1)).notify(captor2.capture());
    List<URL> notifiedUrls2 = captor2.getValue();
    Assertions.assertEquals(1, notifiedUrls2.size());
    // notify app2 instance change
    ServiceInstancesChangedEvent app2_event = new ServiceInstancesChangedEvent("app2", app2Instances);
    listener.onEvent(app2_event);
    // check
    ArgumentCaptor<List<URL>> app2_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(2)).notify(app2_captor.capture());
    List<URL> app2_notifiedUrls = app2_captor.getValue();
    Assertions.assertEquals(7, app2_notifiedUrls.size());
    ArgumentCaptor<List<URL>> app2_captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(2)).notify(app2_captor2.capture());
    List<URL> app2_notifiedUrls2 = app2_captor2.getValue();
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_18
#### Test Case Name: `testMultiServiceListenerNotification`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerWithoutEmptyProtectTest.java`)
#### Mock Object Variable Name: `demoService2Listener2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    NotifyListener demoService2Listener1 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener1.getConsumerUrl()).thenReturn(consumerURL2);
-    NotifyListener demoService2Listener2 = Mockito.mock(NotifyListener.class);
-    when(demoService2Listener2.getConsumerUrl()).thenReturn(consumerURL2);
+    NotifyListener demoService2Listener2 = MockNotifyListener.createMockNotifyListener(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener1);
    listener.addListenerAndNotify(consumerURL, demoServiceListener2);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@Order(6)
public void testMultiServiceListenerNotification() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    serviceNames.add("app2");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoService2Listener1 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener1.getConsumerUrl()).thenReturn(consumerURL2);
    NotifyListener demoService2Listener2 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener2.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener1);
    listener.addListenerAndNotify(consumerURL, demoServiceListener2);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener1);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener2);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1Instances);
    listener.onEvent(app1_event);
    // check
    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(1)).notify(captor.capture());
    List<URL> notifiedUrls = captor.getValue();
    Assertions.assertEquals(3, notifiedUrls.size());
    ArgumentCaptor<List<URL>> captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(1)).notify(captor2.capture());
    List<URL> notifiedUrls2 = captor2.getValue();
    Assertions.assertEquals(1, notifiedUrls2.size());
    // notify app2 instance change
    ServiceInstancesChangedEvent app2_event = new ServiceInstancesChangedEvent("app2", app2Instances);
    listener.onEvent(app2_event);
    // check
    ArgumentCaptor<List<URL>> app2_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(2)).notify(app2_captor.capture());
    List<URL> app2_notifiedUrls = app2_captor.getValue();
    Assertions.assertEquals(7, app2_notifiedUrls.size());
    ArgumentCaptor<List<URL>> app2_captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(2)).notify(app2_captor2.capture());
    List<URL> app2_notifiedUrls2 = app2_captor2.getValue();
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_19
#### Test Case Name: `testMultiServiceListenerNotification`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerWithoutEmptyProtectTest.java`)
#### Mock Object Variable Name: `demoService3Listener`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
-    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
-    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
+    NotifyListener demoService3Listener = MockNotifyListener.createMockNotifyListener(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
@Order(6)
public void testMultiServiceListenerNotification() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    serviceNames.add("app2");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(consumerURL);
    NotifyListener demoService2Listener1 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener1.getConsumerUrl()).thenReturn(consumerURL2);
    NotifyListener demoService2Listener2 = Mockito.mock(NotifyListener.class);
    when(demoService2Listener2.getConsumerUrl()).thenReturn(consumerURL2);
    listener.addListenerAndNotify(consumerURL, demoServiceListener1);
    listener.addListenerAndNotify(consumerURL, demoServiceListener2);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener1);
    listener.addListenerAndNotify(consumerURL2, demoService2Listener2);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1Instances);
    listener.onEvent(app1_event);
    // check
    ArgumentCaptor<List<URL>> captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(1)).notify(captor.capture());
    List<URL> notifiedUrls = captor.getValue();
    Assertions.assertEquals(3, notifiedUrls.size());
    ArgumentCaptor<List<URL>> captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(1)).notify(captor2.capture());
    List<URL> notifiedUrls2 = captor2.getValue();
    Assertions.assertEquals(1, notifiedUrls2.size());
    // notify app2 instance change
    ServiceInstancesChangedEvent app2_event = new ServiceInstancesChangedEvent("app2", app2Instances);
    listener.onEvent(app2_event);
    // check
    ArgumentCaptor<List<URL>> app2_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(2)).notify(app2_captor.capture());
    List<URL> app2_notifiedUrls = app2_captor.getValue();
    Assertions.assertEquals(7, app2_notifiedUrls.size());
    ArgumentCaptor<List<URL>> app2_captor2 = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoService2Listener1, Mockito.times(2)).notify(app2_captor2.capture());
    List<URL> app2_notifiedUrls2 = app2_captor2.getValue();
    Assertions.assertEquals(4, app2_notifiedUrls2.size());
    // test service listener still get notified when added after instance notification.
    NotifyListener demoService3Listener = Mockito.mock(NotifyListener.class);
    when(demoService3Listener.getConsumerUrl()).thenReturn(consumerURL3);
    listener.addListenerAndNotify(consumerURL3, demoService3Listener);
    Mockito.verify(demoService3Listener, Mockito.times(1)).notify(Mockito.anyList());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_20
#### Test Case Name: `testSubscribeMultipleProtocols`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerWithoutEmptyProtectTest.java`)
#### Mock Object Variable Name: `demoServiceListener1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    // no protocol specified, consume all instances
-    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
-    when(demoServiceListener1.getConsumerUrl()).thenReturn(noProtocolConsumerURL);
+    NotifyListener demoServiceListener1 = MockNotifyListener.createMockNotifyListener(noProtocolConsumerURL);
    listener.addListenerAndNotify(noProtocolConsumerURL, demoServiceListener1);
    // multiple protocols specified
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(multipleProtocolsConsumerURL);
    listener.addListenerAndNotify(multipleProtocolsConsumerURL, demoServiceListener2);
    // one protocol specified
    NotifyListener demoServiceListener3 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener3.getConsumerUrl()).thenReturn(singleProtocolsConsumerURL);
    listener.addListenerAndNotify(singleProtocolsConsumerURL, demoServiceListener3);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1InstancesMultipleProtocols);
    listener.onEvent(app1_event);
    // check instances expose framework supported default protocols(currently dubbo, triple and rest) are notified
    ArgumentCaptor<List<URL>> default_protocol_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(1)).notify(default_protocol_captor.capture());
    List<URL> default_protocol_notifiedUrls = default_protocol_captor.getValue();
    Assertions.assertEquals(4, default_protocol_notifiedUrls.size());
    // check instances expose protocols in consuming list(dubbo and triple) are notified
    ArgumentCaptor<List<URL>> multi_protocols_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener2, Mockito.times(1)).notify(multi_protocols_captor.capture());
    List<URL> multi_protocol_notifiedUrls = multi_protocols_captor.getValue();
    Assertions.assertEquals(4, multi_protocol_notifiedUrls.size());
    // check instances expose protocols in consuming list(only triple) are notified
    ArgumentCaptor<List<URL>> single_protocols_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener3, Mockito.times(1)).notify(single_protocols_captor.capture());
    List<URL> single_protocol_notifiedUrls = single_protocols_captor.getValue();
    Assertions.assertEquals(1, single_protocol_notifiedUrls.size());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Test subscribe multiple protocols
 */
@Test
@Order(7)
public void testSubscribeMultipleProtocols() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    // no protocol specified, consume all instances
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(noProtocolConsumerURL);
    listener.addListenerAndNotify(noProtocolConsumerURL, demoServiceListener1);
    // multiple protocols specified
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(multipleProtocolsConsumerURL);
    listener.addListenerAndNotify(multipleProtocolsConsumerURL, demoServiceListener2);
    // one protocol specified
    NotifyListener demoServiceListener3 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener3.getConsumerUrl()).thenReturn(singleProtocolsConsumerURL);
    listener.addListenerAndNotify(singleProtocolsConsumerURL, demoServiceListener3);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1InstancesMultipleProtocols);
    listener.onEvent(app1_event);
    // check instances expose framework supported default protocols(currently dubbo, triple and rest) are notified
    ArgumentCaptor<List<URL>> default_protocol_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(1)).notify(default_protocol_captor.capture());
    List<URL> default_protocol_notifiedUrls = default_protocol_captor.getValue();
    Assertions.assertEquals(4, default_protocol_notifiedUrls.size());
    // check instances expose protocols in consuming list(dubbo and triple) are notified
    ArgumentCaptor<List<URL>> multi_protocols_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener2, Mockito.times(1)).notify(multi_protocols_captor.capture());
    List<URL> multi_protocol_notifiedUrls = multi_protocols_captor.getValue();
    Assertions.assertEquals(4, multi_protocol_notifiedUrls.size());
    // check instances expose protocols in consuming list(only triple) are notified
    ArgumentCaptor<List<URL>> single_protocols_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener3, Mockito.times(1)).notify(single_protocols_captor.capture());
    List<URL> single_protocol_notifiedUrls = single_protocols_captor.getValue();
    Assertions.assertEquals(1, single_protocol_notifiedUrls.size());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_21
#### Test Case Name: `testSubscribeMultipleProtocols`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerWithoutEmptyProtectTest.java`)
#### Mock Object Variable Name: `demoServiceListener2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    // no protocol specified, consume all instances
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(noProtocolConsumerURL);
    listener.addListenerAndNotify(noProtocolConsumerURL, demoServiceListener1);
    // multiple protocols specified
-    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
-    when(demoServiceListener2.getConsumerUrl()).thenReturn(multipleProtocolsConsumerURL);
+    NotifyListener demoServiceListener2 = MockNotifyListener.createMockNotifyListener(multipleProtocolsConsumerURL);
    listener.addListenerAndNotify(multipleProtocolsConsumerURL, demoServiceListener2);
    // one protocol specified
    NotifyListener demoServiceListener3 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener3.getConsumerUrl()).thenReturn(singleProtocolsConsumerURL);
    listener.addListenerAndNotify(singleProtocolsConsumerURL, demoServiceListener3);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Test subscribe multiple protocols
 */
@Test
@Order(7)
public void testSubscribeMultipleProtocols() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    // no protocol specified, consume all instances
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(noProtocolConsumerURL);
    listener.addListenerAndNotify(noProtocolConsumerURL, demoServiceListener1);
    // multiple protocols specified
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(multipleProtocolsConsumerURL);
    listener.addListenerAndNotify(multipleProtocolsConsumerURL, demoServiceListener2);
    // one protocol specified
    NotifyListener demoServiceListener3 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener3.getConsumerUrl()).thenReturn(singleProtocolsConsumerURL);
    listener.addListenerAndNotify(singleProtocolsConsumerURL, demoServiceListener3);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1InstancesMultipleProtocols);
    listener.onEvent(app1_event);
    // check instances expose framework supported default protocols(currently dubbo, triple and rest) are notified
    ArgumentCaptor<List<URL>> default_protocol_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(1)).notify(default_protocol_captor.capture());
    List<URL> default_protocol_notifiedUrls = default_protocol_captor.getValue();
    Assertions.assertEquals(4, default_protocol_notifiedUrls.size());
    // check instances expose protocols in consuming list(dubbo and triple) are notified
    ArgumentCaptor<List<URL>> multi_protocols_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener2, Mockito.times(1)).notify(multi_protocols_captor.capture());
    List<URL> multi_protocol_notifiedUrls = multi_protocols_captor.getValue();
    Assertions.assertEquals(4, multi_protocol_notifiedUrls.size());
    // check instances expose protocols in consuming list(only triple) are notified
    ArgumentCaptor<List<URL>> single_protocols_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener3, Mockito.times(1)).notify(single_protocols_captor.capture());
    List<URL> single_protocol_notifiedUrls = single_protocols_captor.getValue();
    Assertions.assertEquals(1, single_protocol_notifiedUrls.size());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_54_22
#### Test Case Name: `testSubscribeMultipleProtocols`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\event\listener\ServiceInstancesChangedListenerWithoutEmptyProtectTest.java`)
#### Mock Object Variable Name: `demoServiceListener3`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    // multiple protocols specified
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(multipleProtocolsConsumerURL);
    listener.addListenerAndNotify(multipleProtocolsConsumerURL, demoServiceListener2);
    // one protocol specified
-    NotifyListener demoServiceListener3 = Mockito.mock(NotifyListener.class);
-    when(demoServiceListener3.getConsumerUrl()).thenReturn(singleProtocolsConsumerURL);
+    NotifyListener demoServiceListener3 = MockNotifyListener.createMockNotifyListener(singleProtocolsConsumerURL);
    listener.addListenerAndNotify(singleProtocolsConsumerURL, demoServiceListener3);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1InstancesMultipleProtocols);
    listener.onEvent(app1_event);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Test subscribe multiple protocols
 */
@Test
@Order(7)
public void testSubscribeMultipleProtocols() {
    Set<String> serviceNames = new HashSet<>();
    serviceNames.add("app1");
    listener = new ServiceInstancesChangedListener(serviceNames, serviceDiscovery);
    // no protocol specified, consume all instances
    NotifyListener demoServiceListener1 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener1.getConsumerUrl()).thenReturn(noProtocolConsumerURL);
    listener.addListenerAndNotify(noProtocolConsumerURL, demoServiceListener1);
    // multiple protocols specified
    NotifyListener demoServiceListener2 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener2.getConsumerUrl()).thenReturn(multipleProtocolsConsumerURL);
    listener.addListenerAndNotify(multipleProtocolsConsumerURL, demoServiceListener2);
    // one protocol specified
    NotifyListener demoServiceListener3 = Mockito.mock(NotifyListener.class);
    when(demoServiceListener3.getConsumerUrl()).thenReturn(singleProtocolsConsumerURL);
    listener.addListenerAndNotify(singleProtocolsConsumerURL, demoServiceListener3);
    // notify app1 instance change
    ServiceInstancesChangedEvent app1_event = new ServiceInstancesChangedEvent("app1", app1InstancesMultipleProtocols);
    listener.onEvent(app1_event);
    // check instances expose framework supported default protocols(currently dubbo, triple and rest) are notified
    ArgumentCaptor<List<URL>> default_protocol_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener1, Mockito.times(1)).notify(default_protocol_captor.capture());
    List<URL> default_protocol_notifiedUrls = default_protocol_captor.getValue();
    Assertions.assertEquals(4, default_protocol_notifiedUrls.size());
    // check instances expose protocols in consuming list(dubbo and triple) are notified
    ArgumentCaptor<List<URL>> multi_protocols_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener2, Mockito.times(1)).notify(multi_protocols_captor.capture());
    List<URL> multi_protocol_notifiedUrls = multi_protocols_captor.getValue();
    Assertions.assertEquals(4, multi_protocol_notifiedUrls.size());
    // check instances expose protocols in consuming list(only triple) are notified
    ArgumentCaptor<List<URL>> single_protocols_captor = ArgumentCaptor.forClass(List.class);
    Mockito.verify(demoServiceListener3, Mockito.times(1)).notify(single_protocols_captor.capture());
    List<URL> single_protocol_notifiedUrls = single_protocols_captor.getValue();
    Assertions.assertEquals(1, single_protocol_notifiedUrls.size());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockNotifyListener {
    /**
     * Creates a mock NotifyListener with getConsumerUrl() stubbed to return the given URL.
     *
     * @param consumerUrl the URL to return from getConsumerUrl()
     * @return a mock NotifyListener
     */
    public static NotifyListener createMockNotifyListener(URL consumerUrl) {
        NotifyListener notifyListener = Mockito.mock(NotifyListener.class);
        when(notifyListener.getConsumerUrl()).thenReturn(consumerUrl);
        return notifyListener;
    }
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_55
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.registry.NotifyListener`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
// === Declare in class scope ===
private NotifyListener listener;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    listener = mock(NotifyListener.class);
}

// === Replace local variable in test with ===
listener;

```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_55_1
#### Test Case Name: `testSubscribe`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-nacos\src\test\java\org\apache\dubbo\registry\nacos\NacosRegistryTest.java`)
#### Mock Object Variable Name: `listener`
<summary>Suggested Diff</summary>

```diff
@@
     nacosRegistry = new NacosRegistry(this.registryUrl, nacosNamingServiceWrapper);
-    NotifyListener listener = mock(NotifyListener.class);
+    // removed local mock; replaced with global field `listener`
     nacosRegistry.subscribe(serviceUrl, listener);
     Map<URL, Set<NotifyListener>> subscribed = nacosRegistry.getSubscribed();
     Assertions.assertEquals(1, subscribed.size());
     Assertions.assertEquals(1, subscribed.get(serviceUrl).size());
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testSubscribe() {
    NamingService namingService = mock(NacosNamingService.class);
    try {
        String serviceName = "providers:org.apache.dubbo.registry.nacos.NacosService:1.0.0:default";
        String category = this.serviceUrl.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY);
        URL newUrl = this.serviceUrl.addParameter(CATEGORY_KEY, category);
        newUrl = newUrl.addParameter(PROTOCOL_KEY, this.serviceUrl.getProtocol());
        newUrl = newUrl.addParameter(PATH_KEY, this.serviceUrl.getPath());
        String ip = newUrl.getHost();
        int port = newUrl.getPort();
        Instance instance = new Instance();
        instance.setIp(ip);
        instance.setPort(port);
        instance.setMetadata(new HashMap<>(newUrl.getParameters()));
        List<Instance> instances = new ArrayList<>();
        instances.add(instance);
        when(namingService.getAllInstances(serviceName, this.registryUrl.getParameter(GROUP_KEY, Constants.DEFAULT_GROUP))).thenReturn(instances);
    } catch (NacosException e) {
        // ignore
    }
    NacosNamingServiceWrapper nacosNamingServiceWrapper = new NacosNamingServiceWrapper(new NacosConnectionManager(namingService), 0, 0);
    nacosRegistry = new NacosRegistry(this.registryUrl, nacosNamingServiceWrapper);
    NotifyListener listener = mock(NotifyListener.class);
    nacosRegistry.subscribe(serviceUrl, listener);
    Map<URL, Set<NotifyListener>> subscribed = nacosRegistry.getSubscribed();
    Assertions.assertEquals(1, subscribed.size());
    Assertions.assertEquals(1, subscribed.get(serviceUrl).size());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private NotifyListener listener;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    listener = mock(NotifyListener.class);
}

// === Replace local variable in test with ===
listener;

```
</details>

---
#### Test Case ID #dubbo_Test_55_2
#### Test Case Name: `testUnSubscribe`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-nacos\src\test\java\org\apache\dubbo\registry\nacos\NacosRegistryTest.java`)
#### Mock Object Variable Name: `listener`
<summary>Suggested Diff</summary>

```diff
@@
     nacosRegistry = new NacosRegistry(this.registryUrl, nacosNamingServiceWrapper);
-    NotifyListener listener = mock(NotifyListener.class);
+    // removed local mock; replaced with global field `listener`
     nacosRegistry.subscribe(serviceUrl, listener);
     Map<URL, Set<NotifyListener>> subscribed = nacosRegistry.getSubscribed();
     Assertions.assertEquals(1, subscribed.size());
     Assertions.assertEquals(1, subscribed.get(serviceUrl).size());
     nacosRegistry.unsubscribe(serviceUrl, listener);
     subscribed = nacosRegistry.getSubscribed();
     Assertions.assertEquals(1, subscribed.size());
     Assertions.assertEquals(0, subscribed.get(serviceUrl).size());
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testUnSubscribe() {
    NamingService namingService = mock(NacosNamingService.class);
    try {
        String serviceName = "providers:org.apache.dubbo.registry.nacos.NacosService:1.0.0:default";
        String category = this.serviceUrl.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY);
        URL newUrl = this.serviceUrl.addParameter(CATEGORY_KEY, category);
        newUrl = newUrl.addParameter(PROTOCOL_KEY, this.serviceUrl.getProtocol());
        newUrl = newUrl.addParameter(PATH_KEY, this.serviceUrl.getPath());
        String ip = newUrl.getHost();
        int port = newUrl.getPort();
        Instance instance = new Instance();
        instance.setIp(ip);
        instance.setPort(port);
        instance.setMetadata(new HashMap<>(newUrl.getParameters()));
        List<Instance> instances = new ArrayList<>();
        instances.add(instance);
        when(namingService.getAllInstances(serviceName, this.registryUrl.getParameter(GROUP_KEY, Constants.DEFAULT_GROUP))).thenReturn(instances);
    } catch (NacosException e) {
        // ignore
    }
    NacosNamingServiceWrapper nacosNamingServiceWrapper = new NacosNamingServiceWrapper(new NacosConnectionManager(namingService), 0, 0);
    nacosRegistry = new NacosRegistry(this.registryUrl, nacosNamingServiceWrapper);
    NotifyListener listener = mock(NotifyListener.class);
    nacosRegistry.subscribe(serviceUrl, listener);
    Map<URL, Set<NotifyListener>> subscribed = nacosRegistry.getSubscribed();
    Assertions.assertEquals(1, subscribed.size());
    Assertions.assertEquals(1, subscribed.get(serviceUrl).size());
    nacosRegistry.unsubscribe(serviceUrl, listener);
    subscribed = nacosRegistry.getSubscribed();
    Assertions.assertEquals(1, subscribed.size());
    Assertions.assertEquals(0, subscribed.get(serviceUrl).size());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private NotifyListener listener;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    listener = mock(NotifyListener.class);
}

// === Replace local variable in test with ===
listener;

```
</details>

---
#### Test Case ID #dubbo_Test_55_3
#### Test Case Name: `testIsConformRules`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-nacos\src\test\java\org\apache\dubbo\registry\nacos\NacosRegistryTest.java`)
#### Mock Object Variable Name: `listener`
<summary>Suggested Diff</summary>

```diff
@@
     URL serviceUrlWithWildcard = URL.valueOf("nacos://127.0.0.1:3333/" + serviceInterface + "?interface=org.apache.dubbo.registry.nacos.NacosService" + "&notify=false&methods=test1,test2&category=providers&version=*&group=default");
     URL serviceUrlWithOutWildcard = URL.valueOf("nacos://127.0.0.1:3333/" + serviceInterface + "?interface=org.apache.dubbo.registry.nacos.NacosService" + "&notify=false&methods=test1,test2&category=providers&version=1.0.0&group=default");
-    NotifyListener listener = mock(NotifyListener.class);
+    // removed local mock; replaced with global field `listener`
     nacosRegistry.subscribe(serviceUrlWithWildcard, listener);
     nacosRegistry.subscribe(serviceUrlWithOutWildcard, listener);
     Map<URL, Set<NotifyListener>> subscribed = nacosRegistry.getSubscribed();
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testIsConformRules() {
    NamingService namingService = mock(NacosNamingService.class);
    URL serviceUrlWithoutCategory = URL.valueOf("nacos://127.0.0.1:3333/" + serviceInterface + "?interface=" + serviceInterface + "&notify=false&methods=test1,test2&version=1.0.0&group=default");
    try {
        String serviceName = "providers:org.apache.dubbo.registry.nacos.NacosService:1.0.0:default";
        String category = this.serviceUrl.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY);
        URL newUrl = this.serviceUrl.addParameter(CATEGORY_KEY, category);
        newUrl = newUrl.addParameter(PROTOCOL_KEY, this.serviceUrl.getProtocol());
        newUrl = newUrl.addParameter(PATH_KEY, this.serviceUrl.getPath());
        String ip = newUrl.getHost();
        int port = newUrl.getPort();
        Instance instance = new Instance();
        instance.setIp(ip);
        instance.setPort(port);
        instance.setMetadata(new HashMap<>(newUrl.getParameters()));
        List<Instance> instances = new ArrayList<>();
        instances.add(instance);
        when(namingService.getAllInstances(serviceName, this.registryUrl.getParameter(GROUP_KEY, Constants.DEFAULT_GROUP))).thenReturn(instances);
        String serviceNameWithoutVersion = "providers:org.apache.dubbo.registry.nacos.NacosService:default";
        String serviceName1 = "providers:org.apache.dubbo.registry.nacos.NacosService:1.0.0:default";
        List<String> serviceNames = new ArrayList<>();
        serviceNames.add(serviceNameWithoutVersion);
        serviceNames.add(serviceName1);
        ListView<String> result = new ListView<>();
        result.setData(serviceNames);
        when(namingService.getServicesOfServer(1, Integer.MAX_VALUE, registryUrl.getParameter(GROUP_KEY, Constants.DEFAULT_GROUP))).thenReturn(result);
    } catch (NacosException e) {
        // ignore
    }
    NacosNamingServiceWrapper nacosNamingServiceWrapper = new NacosNamingServiceWrapper(new NacosConnectionManager(namingService), 0, 0);
    nacosRegistry = new NacosRegistry(this.registryUrl, nacosNamingServiceWrapper);
    Set<URL> registered;
    nacosRegistry.register(this.serviceUrl);
    nacosRegistry.register(serviceUrlWithoutCategory);
    registered = nacosRegistry.getRegistered();
    Assertions.assertTrue(registered.contains(serviceUrl));
    Assertions.assertTrue(registered.contains(serviceUrlWithoutCategory));
    Assertions.assertEquals(2, registered.size());
    URL serviceUrlWithWildcard = URL.valueOf("nacos://127.0.0.1:3333/" + serviceInterface + "?interface=org.apache.dubbo.registry.nacos.NacosService" + "&notify=false&methods=test1,test2&category=providers&version=*&group=default");
    URL serviceUrlWithOutWildcard = URL.valueOf("nacos://127.0.0.1:3333/" + serviceInterface + "?interface=org.apache.dubbo.registry.nacos.NacosService" + "&notify=false&methods=test1,test2&category=providers&version=1.0.0&group=default");
    NotifyListener listener = mock(NotifyListener.class);
    nacosRegistry.subscribe(serviceUrlWithWildcard, listener);
    nacosRegistry.subscribe(serviceUrlWithOutWildcard, listener);
    Map<URL, Set<NotifyListener>> subscribed = nacosRegistry.getSubscribed();
    Assertions.assertEquals(2, registered.size());
    Assertions.assertEquals(1, subscribed.get(serviceUrlWithOutWildcard).size());
    Assertions.assertEquals(2, registered.size());
    Assertions.assertEquals(1, subscribed.get(serviceUrlWithWildcard).size());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private NotifyListener listener;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    listener = mock(NotifyListener.class);
}

// === Replace local variable in test with ===
listener;

```
</details>

---
## Mock Clone Instance #dubbo_MCI_56
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.Protocol`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static Protocol createMockProtocol(URL url, Invoker<?> invoker) {
    Protocol protocol = mock(Protocol.class);
    when(protocol.refer(DemoService.class, url)).thenReturn(invoker);
    return protocol;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_56_1
#### Test Case Name: `testLoadingListenerForLocalReference`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\protocol\ProtocolListenerWrapperTest.java`)
#### Mock Object Variable Name: `protocolWithoutListener`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    AbstractInvoker<DemoService> invokerWithoutListener = new AbstractInvoker<DemoService>(DemoService.class, urlWithoutListener) {

        @Override
        protected Result doInvoke(Invocation invocation) throws Throwable {
            return null;
        }
    };
-    Protocol protocolWithoutListener = mock(Protocol.class);
-    when(protocolWithoutListener.refer(DemoService.class, urlWithoutListener)).thenReturn(invokerWithoutListener);
+    Protocol protocolWithoutListener = createMockProtocol(urlWithoutListener, invokerWithoutListener);
    ProtocolListenerWrapper protocolListenerWrapperWithoutListener = new ProtocolListenerWrapper(protocolWithoutListener);
    Invoker<?> invoker = protocolListenerWrapperWithoutListener.refer(DemoService.class, urlWithoutListener);
    Assertions.assertTrue(invoker instanceof ListenerInvokerWrapper);
    Assertions.assertEquals(0, ((ListenerInvokerWrapper<?>) invoker).getListeners().size());
    // verify that if the invoker.listener is configured, then load the specified listener
    URL urlWithListener = URL.valueOf("injvm://127.0.0.1/DemoService").addParameter(INTERFACE_KEY, DemoService.class.getName()).addParameter(INVOKER_LISTENER_KEY, "count");
    AbstractInvoker<DemoService> invokerWithListener = new AbstractInvoker<DemoService>(DemoService.class, urlWithListener) {

        @Override
        protected Result doInvoke(Invocation invocation) throws Throwable {
            return null;
        }
    };
    Protocol protocol = mock(Protocol.class);
    when(protocol.refer(DemoService.class, urlWithListener)).thenReturn(invokerWithListener);
    ProtocolListenerWrapper protocolListenerWrapper = new ProtocolListenerWrapper(protocol);
    invoker = protocolListenerWrapper.refer(DemoService.class, urlWithListener);
    Assertions.assertTrue(invoker instanceof ListenerInvokerWrapper);
    Assertions.assertEquals(1, CountInvokerListener.getCounter());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testLoadingListenerForLocalReference() {
    // verify that no listener is loaded by default
    URL urlWithoutListener = URL.valueOf("injvm://127.0.0.1/DemoService").addParameter(INTERFACE_KEY, DemoService.class.getName());
    AbstractInvoker<DemoService> invokerWithoutListener = new AbstractInvoker<DemoService>(DemoService.class, urlWithoutListener) {

        @Override
        protected Result doInvoke(Invocation invocation) throws Throwable {
            return null;
        }
    };
    Protocol protocolWithoutListener = mock(Protocol.class);
    when(protocolWithoutListener.refer(DemoService.class, urlWithoutListener)).thenReturn(invokerWithoutListener);
    ProtocolListenerWrapper protocolListenerWrapperWithoutListener = new ProtocolListenerWrapper(protocolWithoutListener);
    Invoker<?> invoker = protocolListenerWrapperWithoutListener.refer(DemoService.class, urlWithoutListener);
    Assertions.assertTrue(invoker instanceof ListenerInvokerWrapper);
    Assertions.assertEquals(0, ((ListenerInvokerWrapper<?>) invoker).getListeners().size());
    // verify that if the invoker.listener is configured, then load the specified listener
    URL urlWithListener = URL.valueOf("injvm://127.0.0.1/DemoService").addParameter(INTERFACE_KEY, DemoService.class.getName()).addParameter(INVOKER_LISTENER_KEY, "count");
    AbstractInvoker<DemoService> invokerWithListener = new AbstractInvoker<DemoService>(DemoService.class, urlWithListener) {

        @Override
        protected Result doInvoke(Invocation invocation) throws Throwable {
            return null;
        }
    };
    Protocol protocol = mock(Protocol.class);
    when(protocol.refer(DemoService.class, urlWithListener)).thenReturn(invokerWithListener);
    ProtocolListenerWrapper protocolListenerWrapper = new ProtocolListenerWrapper(protocol);
    invoker = protocolListenerWrapper.refer(DemoService.class, urlWithListener);
    Assertions.assertTrue(invoker instanceof ListenerInvokerWrapper);
    Assertions.assertEquals(1, CountInvokerListener.getCounter());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Protocol createMockProtocol(URL url, Invoker<?> invoker) {
    Protocol protocol = mock(Protocol.class);
    when(protocol.refer(DemoService.class, url)).thenReturn(invoker);
    return protocol;
}
```
</details>

---
#### Test Case ID #dubbo_Test_56_2
#### Test Case Name: `testLoadingListenerForRemoteReference`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\protocol\ProtocolListenerWrapperTest.java`)
#### Mock Object Variable Name: `protocolWithoutListener`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    AbstractInvoker<DemoService> invokerWithoutListener = new AbstractInvoker<DemoService>(DemoService.class, urlWithoutListener) {

        @Override
        protected Result doInvoke(Invocation invocation) throws Throwable {
            return null;
        }
    };
-    Protocol protocolWithoutListener = mock(Protocol.class);
-    when(protocolWithoutListener.refer(DemoService.class, urlWithoutListener)).thenReturn(invokerWithoutListener);
+    Protocol protocolWithoutListener = createMockProtocol(urlWithoutListener, invokerWithoutListener);
    ProtocolListenerWrapper protocolListenerWrapperWithoutListener = new ProtocolListenerWrapper(protocolWithoutListener);
    Invoker<?> invoker = protocolListenerWrapperWithoutListener.refer(DemoService.class, urlWithoutListener);
    Assertions.assertTrue(invoker instanceof ListenerInvokerWrapper);
    Assertions.assertEquals(0, ((ListenerInvokerWrapper<?>) invoker).getListeners().size());
    // verify that if the invoker.listener is configured, then load the specified listener
    URL urlWithListener = URL.valueOf("dubbo://127.0.0.1:20880/DemoService").addParameter(INTERFACE_KEY, DemoService.class.getName()).addParameter(INVOKER_LISTENER_KEY, "count");
    AbstractInvoker<DemoService> invokerWithListener = new AbstractInvoker<DemoService>(DemoService.class, urlWithListener) {

        @Override
        protected Result doInvoke(Invocation invocation) throws Throwable {
            return null;
        }
    };
    Protocol protocol = mock(Protocol.class);
    when(protocol.refer(DemoService.class, urlWithListener)).thenReturn(invokerWithListener);
    ProtocolListenerWrapper protocolListenerWrapper = new ProtocolListenerWrapper(protocol);
    invoker = protocolListenerWrapper.refer(DemoService.class, urlWithListener);
    Assertions.assertTrue(invoker instanceof ListenerInvokerWrapper);
    Assertions.assertEquals(1, CountInvokerListener.getCounter());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testLoadingListenerForRemoteReference() {
    // verify that no listener is loaded by default
    URL urlWithoutListener = URL.valueOf("dubbo://127.0.0.1:20880/DemoService").addParameter(INTERFACE_KEY, DemoService.class.getName());
    AbstractInvoker<DemoService> invokerWithoutListener = new AbstractInvoker<DemoService>(DemoService.class, urlWithoutListener) {

        @Override
        protected Result doInvoke(Invocation invocation) throws Throwable {
            return null;
        }
    };
    Protocol protocolWithoutListener = mock(Protocol.class);
    when(protocolWithoutListener.refer(DemoService.class, urlWithoutListener)).thenReturn(invokerWithoutListener);
    ProtocolListenerWrapper protocolListenerWrapperWithoutListener = new ProtocolListenerWrapper(protocolWithoutListener);
    Invoker<?> invoker = protocolListenerWrapperWithoutListener.refer(DemoService.class, urlWithoutListener);
    Assertions.assertTrue(invoker instanceof ListenerInvokerWrapper);
    Assertions.assertEquals(0, ((ListenerInvokerWrapper<?>) invoker).getListeners().size());
    // verify that if the invoker.listener is configured, then load the specified listener
    URL urlWithListener = URL.valueOf("dubbo://127.0.0.1:20880/DemoService").addParameter(INTERFACE_KEY, DemoService.class.getName()).addParameter(INVOKER_LISTENER_KEY, "count");
    AbstractInvoker<DemoService> invokerWithListener = new AbstractInvoker<DemoService>(DemoService.class, urlWithListener) {

        @Override
        protected Result doInvoke(Invocation invocation) throws Throwable {
            return null;
        }
    };
    Protocol protocol = mock(Protocol.class);
    when(protocol.refer(DemoService.class, urlWithListener)).thenReturn(invokerWithListener);
    ProtocolListenerWrapper protocolListenerWrapper = new ProtocolListenerWrapper(protocol);
    invoker = protocolListenerWrapper.refer(DemoService.class, urlWithListener);
    Assertions.assertTrue(invoker instanceof ListenerInvokerWrapper);
    Assertions.assertEquals(1, CountInvokerListener.getCounter());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Protocol createMockProtocol(URL url, Invoker<?> invoker) {
    Protocol protocol = mock(Protocol.class);
    when(protocol.refer(DemoService.class, url)).thenReturn(invoker);
    return protocol;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_57
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.Protocol`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static Protocol createMockProtocol(URL urlWithListener, Invoker<DemoService> invokerWithListener) {
    Protocol protocol = mock(Protocol.class);
    when(protocol.refer(DemoService.class, urlWithListener)).thenReturn(invokerWithListener);
    return protocol;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_57_1
#### Test Case Name: `testLoadingListenerForLocalReference`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\protocol\ProtocolListenerWrapperTest.java`)
#### Mock Object Variable Name: `protocol`
<summary>Suggested Diff</summary>

```diff
@@
    AbstractInvoker<DemoService> invokerWithListener = new AbstractInvoker<DemoService>(DemoService.class, urlWithListener) {

        @Override
        protected Result doInvoke(Invocation invocation) throws Throwable {
            return null;
        }
    };
-    Protocol protocol = mock(Protocol.class);
-    when(protocol.refer(DemoService.class, urlWithListener)).thenReturn(invokerWithListener);
+    Protocol protocol = createMockProtocol(urlWithListener, invokerWithListener);
    ProtocolListenerWrapper protocolListenerWrapper = new ProtocolListenerWrapper(protocol);
    invoker = protocolListenerWrapper.refer(DemoService.class, urlWithListener);
    Assertions.assertTrue(invoker instanceof ListenerInvokerWrapper);
    Assertions.assertEquals(1, CountInvokerListener.getCounter());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testLoadingListenerForLocalReference() {
    // verify that no listener is loaded by default
    URL urlWithoutListener = URL.valueOf("injvm://127.0.0.1/DemoService").addParameter(INTERFACE_KEY, DemoService.class.getName());
    AbstractInvoker<DemoService> invokerWithoutListener = new AbstractInvoker<DemoService>(DemoService.class, urlWithoutListener) {

        @Override
        protected Result doInvoke(Invocation invocation) throws Throwable {
            return null;
        }
    };
    Protocol protocolWithoutListener = mock(Protocol.class);
    when(protocolWithoutListener.refer(DemoService.class, urlWithoutListener)).thenReturn(invokerWithoutListener);
    ProtocolListenerWrapper protocolListenerWrapperWithoutListener = new ProtocolListenerWrapper(protocolWithoutListener);
    Invoker<?> invoker = protocolListenerWrapperWithoutListener.refer(DemoService.class, urlWithoutListener);
    Assertions.assertTrue(invoker instanceof ListenerInvokerWrapper);
    Assertions.assertEquals(0, ((ListenerInvokerWrapper<?>) invoker).getListeners().size());
    // verify that if the invoker.listener is configured, then load the specified listener
    URL urlWithListener = URL.valueOf("injvm://127.0.0.1/DemoService").addParameter(INTERFACE_KEY, DemoService.class.getName()).addParameter(INVOKER_LISTENER_KEY, "count");
    AbstractInvoker<DemoService> invokerWithListener = new AbstractInvoker<DemoService>(DemoService.class, urlWithListener) {

        @Override
        protected Result doInvoke(Invocation invocation) throws Throwable {
            return null;
        }
    };
    Protocol protocol = mock(Protocol.class);
    when(protocol.refer(DemoService.class, urlWithListener)).thenReturn(invokerWithListener);
    ProtocolListenerWrapper protocolListenerWrapper = new ProtocolListenerWrapper(protocol);
    invoker = protocolListenerWrapper.refer(DemoService.class, urlWithListener);
    Assertions.assertTrue(invoker instanceof ListenerInvokerWrapper);
    Assertions.assertEquals(1, CountInvokerListener.getCounter());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Protocol createMockProtocol(URL urlWithListener, Invoker<DemoService> invokerWithListener) {
    Protocol protocol = mock(Protocol.class);
    when(protocol.refer(DemoService.class, urlWithListener)).thenReturn(invokerWithListener);
    return protocol;
}
```
</details>

---
#### Test Case ID #dubbo_Test_57_2
#### Test Case Name: `testLoadingListenerForRemoteReference`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-api\src\test\java\org\apache\dubbo\rpc\protocol\ProtocolListenerWrapperTest.java`)
#### Mock Object Variable Name: `protocol`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    AbstractInvoker<DemoService> invokerWithListener = new AbstractInvoker<DemoService>(DemoService.class, urlWithListener) {

        @Override
        protected Result doInvoke(Invocation invocation) throws Throwable {
            return null;
        }
    };
-    Protocol protocol = mock(Protocol.class);
-    when(protocol.refer(DemoService.class, urlWithListener)).thenReturn(invokerWithListener);
+    Protocol protocol = createMockProtocol(urlWithListener, invokerWithListener);
    ProtocolListenerWrapper protocolListenerWrapper = new ProtocolListenerWrapper(protocol);
    invoker = protocolListenerWrapper.refer(DemoService.class, urlWithListener);
    Assertions.assertTrue(invoker instanceof ListenerInvokerWrapper);
    Assertions.assertEquals(1, CountInvokerListener.getCounter());
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testLoadingListenerForRemoteReference() {
    // verify that no listener is loaded by default
    URL urlWithoutListener = URL.valueOf("dubbo://127.0.0.1:20880/DemoService").addParameter(INTERFACE_KEY, DemoService.class.getName());
    AbstractInvoker<DemoService> invokerWithoutListener = new AbstractInvoker<DemoService>(DemoService.class, urlWithoutListener) {

        @Override
        protected Result doInvoke(Invocation invocation) throws Throwable {
            return null;
        }
    };
    Protocol protocolWithoutListener = mock(Protocol.class);
    when(protocolWithoutListener.refer(DemoService.class, urlWithoutListener)).thenReturn(invokerWithoutListener);
    ProtocolListenerWrapper protocolListenerWrapperWithoutListener = new ProtocolListenerWrapper(protocolWithoutListener);
    Invoker<?> invoker = protocolListenerWrapperWithoutListener.refer(DemoService.class, urlWithoutListener);
    Assertions.assertTrue(invoker instanceof ListenerInvokerWrapper);
    Assertions.assertEquals(0, ((ListenerInvokerWrapper<?>) invoker).getListeners().size());
    // verify that if the invoker.listener is configured, then load the specified listener
    URL urlWithListener = URL.valueOf("dubbo://127.0.0.1:20880/DemoService").addParameter(INTERFACE_KEY, DemoService.class.getName()).addParameter(INVOKER_LISTENER_KEY, "count");
    AbstractInvoker<DemoService> invokerWithListener = new AbstractInvoker<DemoService>(DemoService.class, urlWithListener) {

        @Override
        protected Result doInvoke(Invocation invocation) throws Throwable {
            return null;
        }
    };
    Protocol protocol = mock(Protocol.class);
    when(protocol.refer(DemoService.class, urlWithListener)).thenReturn(invokerWithListener);
    ProtocolListenerWrapper protocolListenerWrapper = new ProtocolListenerWrapper(protocol);
    invoker = protocolListenerWrapper.refer(DemoService.class, urlWithListener);
    Assertions.assertTrue(invoker instanceof ListenerInvokerWrapper);
    Assertions.assertEquals(1, CountInvokerListener.getCounter());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Protocol createMockProtocol(URL urlWithListener, Invoker<DemoService> invokerWithListener) {
    Protocol protocol = mock(Protocol.class);
    when(protocol.refer(DemoService.class, urlWithListener)).thenReturn(invokerWithListener);
    return protocol;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_58
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.common.extension.ExtensionLoader<org.apache.dubbo.registry.integration.RegistryProtocolListener>`
- **Test Case Count**: 4
- **MO Count**: 4

### Reusable Method
```java
private static ExtensionLoader<RegistryProtocolListener> createMockExtensionLoader(URL url, String registryProtocolListenerKey, List<RegistryProtocolListener> registryProtocolListeners) {
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, registryProtocolListenerKey)).thenReturn(registryProtocolListeners);
    return extensionLoaderMock;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_58_1
#### Test Case Name: `testConsumerUrlWithoutProtocol`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `extensionLoaderMock`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
-    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
-    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
-    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
+    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = createMockExtensionLoader(url, REGISTRY_PROTOCOL_LISTENER_KEY, registryProtocolListeners);
+    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    url = url.setScopeModel(moduleModel);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify the generated consumer url information
 */
@Test
void testConsumerUrlWithoutProtocol() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    // verify that the protocol header of consumerUrl is set to "consumer"
    Assertions.assertEquals("consumer", consumerUrl.getProtocol());
    Assertions.assertEquals(parameters.get(REGISTER_IP_KEY), consumerUrl.getHost());
    Assertions.assertFalse(consumerUrl.getAttributes().containsKey(REFER_KEY));
    Assertions.assertEquals("value1", consumerUrl.getAttribute("key1"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ExtensionLoader<RegistryProtocolListener> createMockExtensionLoader(URL url, String registryProtocolListenerKey, List<RegistryProtocolListener> registryProtocolListeners) {
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, registryProtocolListenerKey)).thenReturn(registryProtocolListeners);
    return extensionLoaderMock;
}
```
</details>

---
#### Test Case ID #dubbo_Test_58_2
#### Test Case Name: `testConsumerUrlWithProtocol`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `extensionLoaderMock`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
-    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
-    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
-    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
+    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = createMockExtensionLoader(url, REGISTRY_PROTOCOL_LISTENER_KEY, registryProtocolListeners);
+    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that when the protocol is configured, the protocol of consumer url is the configured protocol
 */
@Test
void testConsumerUrlWithProtocol() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    parameters.put(PROTOCOL_KEY, "tri");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    // verify that the protocol of consumer url
    Assertions.assertEquals("tri", consumerUrl.getProtocol());
    Assertions.assertEquals(parameters.get(REGISTER_IP_KEY), consumerUrl.getHost());
    Assertions.assertFalse(consumerUrl.getAttributes().containsKey(REFER_KEY));
    Assertions.assertEquals("value1", consumerUrl.getAttribute("key1"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ExtensionLoader<RegistryProtocolListener> createMockExtensionLoader(URL url, String registryProtocolListenerKey, List<RegistryProtocolListener> registryProtocolListeners) {
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, registryProtocolListenerKey)).thenReturn(registryProtocolListeners);
    return extensionLoaderMock;
}
```
</details>

---
#### Test Case ID #dubbo_Test_58_3
#### Test Case Name: `testInterceptInvokerForMigrationRuleListener`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `extensionLoaderMock`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
-    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
-    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
-    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
+    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = createMockExtensionLoader(url, REGISTRY_PROTOCOL_LISTENER_KEY, registryProtocolListeners);
+    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    url = url.setScopeModel(moduleModel);
    registryProtocol.interceptInvoker(clusterInvoker, url, consumerUrl);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that the default RegistryProtocolListener will be executed
 *
 * @see MigrationRuleListener
 */
@Test
void testInterceptInvokerForMigrationRuleListener() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    refer.put(GROUP_KEY, "group1,group2");
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    MigrationInvoker<?> clusterInvoker = mock(MigrationInvoker.class);
    Map<String, Object> consumerAttribute = new HashMap<>(url.getAttributes());
    consumerAttribute.remove(REFER_KEY);
    URL consumerUrl = new ServiceConfigURL(parameters.get(PROTOCOL_KEY) == null ? DUBBO : parameters.get(PROTOCOL_KEY), null, null, parameters.get(REGISTER_IP_KEY), 0, url.getPath(), parameters, consumerAttribute);
    url = url.putAttribute(CONSUMER_URL_KEY, consumerUrl);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    registryProtocol.interceptInvoker(clusterInvoker, url, consumerUrl);
    verify(migrationRuleListener, times(1)).onRefer(registryProtocol, clusterInvoker, consumerUrl, url);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ExtensionLoader<RegistryProtocolListener> createMockExtensionLoader(URL url, String registryProtocolListenerKey, List<RegistryProtocolListener> registryProtocolListeners) {
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, registryProtocolListenerKey)).thenReturn(registryProtocolListeners);
    return extensionLoaderMock;
}
```
</details>

---
#### Test Case ID #dubbo_Test_58_4
#### Test Case Name: `testInterceptInvokerForCustomRegistryProtocolListener`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `extensionLoaderMock`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
-    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
+    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = createMockExtensionLoader(url, REGISTRY_PROTOCOL_LISTENER_KEY, registryProtocolListeners);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
-    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    registryProtocol.interceptInvoker(clusterInvoker, url, consumerUrl);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Verify that if registry.protocol.listener is configured,
 * whether the corresponding RegistryProtocolListener will be executed normally
 *
 * @see CountRegistryProtocolListener
 */
@Test
void testInterceptInvokerForCustomRegistryProtocolListener() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    parameters.put(REGISTRY_PROTOCOL_LISTENER_KEY, "count");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    refer.put(GROUP_KEY, "group1,group2");
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    MigrationInvoker<?> clusterInvoker = mock(MigrationInvoker.class);
    Map<String, Object> consumerAttribute = new HashMap<>(url.getAttributes());
    consumerAttribute.remove(REFER_KEY);
    URL consumerUrl = new ServiceConfigURL(parameters.get(PROTOCOL_KEY) == null ? DUBBO : parameters.get(PROTOCOL_KEY), null, null, parameters.get(REGISTER_IP_KEY), 0, url.getPath(), parameters, consumerAttribute);
    url = url.putAttribute(CONSUMER_URL_KEY, consumerUrl);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(new CountRegistryProtocolListener());
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    registryProtocol.interceptInvoker(clusterInvoker, url, consumerUrl);
    Assertions.assertEquals(1, CountRegistryProtocolListener.getReferCounter().get());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ExtensionLoader<RegistryProtocolListener> createMockExtensionLoader(URL url, String registryProtocolListenerKey, List<RegistryProtocolListener> registryProtocolListeners) {
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, registryProtocolListenerKey)).thenReturn(registryProtocolListeners);
    return extensionLoaderMock;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_59
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.auth.AccessKeyAuthenticator`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static AccessKeyAuthenticator createMockAccessKeyAuthenticator(Invocation invocation, URL url, AccessKeyPair accessKeyPair, String signatureReturn) {
    AccessKeyAuthenticator helper = mock(AccessKeyAuthenticator.class);
    when(helper.getAccessKeyPair(invocation, url)).thenReturn(accessKeyPair);
    when(helper.getSignature(eq(url), eq(invocation), eq("sk"), anyString())).thenReturn(signatureReturn);
    return helper;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_59_1
#### Test Case Name: `testSignForRequest`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-auth\src\test\java\org\apache\dubbo\auth\AccessKeyAuthenticatorTest.java`)
#### Mock Object Variable Name: `helper`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(CommonConstants.APPLICATION_KEY, "test").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk");
    Invocation invocation = new RpcInvocation();
-    AccessKeyAuthenticator helper = mock(AccessKeyAuthenticator.class);
-    doCallRealMethod().when(helper).sign(invocation, url);
-    when(helper.getSignature(eq(url), eq(invocation), eq("sk"), anyString())).thenReturn("dubbo");
    AccessKeyPair accessKeyPair = mock(AccessKeyPair.class);
    when(accessKeyPair.getSecretKey()).thenReturn("sk");
+    AccessKeyAuthenticator helper = createMockAccessKeyAuthenticator(invocation, url, accessKeyPair, "dubbo");
+    doCallRealMethod().when(helper).sign(invocation, url);
    helper.sign(invocation, url);
    assertEquals(String.valueOf(invocation.getAttachment(CommonConstants.CONSUMER)), url.getApplication());
    assertNotNull(invocation.getAttachments().get(Constants.REQUEST_SIGNATURE_KEY));
    assertEquals(invocation.getAttachments().get(Constants.REQUEST_SIGNATURE_KEY), "dubbo");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testSignForRequest() {
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(CommonConstants.APPLICATION_KEY, "test").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk");
    Invocation invocation = new RpcInvocation();
    AccessKeyAuthenticator helper = mock(AccessKeyAuthenticator.class);
    doCallRealMethod().when(helper).sign(invocation, url);
    when(helper.getSignature(eq(url), eq(invocation), eq("sk"), anyString())).thenReturn("dubbo");
    AccessKeyPair accessKeyPair = mock(AccessKeyPair.class);
    when(accessKeyPair.getSecretKey()).thenReturn("sk");
    when(helper.getAccessKeyPair(invocation, url)).thenReturn(accessKeyPair);
    helper.sign(invocation, url);
    assertEquals(String.valueOf(invocation.getAttachment(CommonConstants.CONSUMER)), url.getApplication());
    assertNotNull(invocation.getAttachments().get(Constants.REQUEST_SIGNATURE_KEY));
    assertEquals(invocation.getAttachments().get(Constants.REQUEST_SIGNATURE_KEY), "dubbo");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AccessKeyAuthenticator createMockAccessKeyAuthenticator(Invocation invocation, URL url, AccessKeyPair accessKeyPair, String signatureReturn) {
    AccessKeyAuthenticator helper = mock(AccessKeyAuthenticator.class);
    when(helper.getAccessKeyPair(invocation, url)).thenReturn(accessKeyPair);
    when(helper.getSignature(eq(url), eq(invocation), eq("sk"), anyString())).thenReturn(signatureReturn);
    return helper;
}
```
</details>

---
#### Test Case ID #dubbo_Test_59_2
#### Test Case Name: `testAuthenticateRequest`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-auth\src\test\java\org\apache\dubbo\auth\AccessKeyAuthenticatorTest.java`)
#### Mock Object Variable Name: `helper`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    invocation.setAttachment(CommonConstants.CONSUMER, "test");
-    AccessKeyAuthenticator helper = mock(AccessKeyAuthenticator.class);
-    doCallRealMethod().when(helper).authenticate(invocation, url);
-    when(helper.getSignature(eq(url), eq(invocation), eq("sk"), anyString())).thenReturn("dubbo");
    AccessKeyPair accessKeyPair = mock(AccessKeyPair.class);
    when(accessKeyPair.getSecretKey()).thenReturn("sk");
-    when(helper.getAccessKeyPair(invocation, url)).thenReturn(accessKeyPair);
+    AccessKeyAuthenticator helper = createMockAccessKeyAuthenticator(invocation, url, accessKeyPair, "dubbo");
+    doCallRealMethod().when(helper).authenticate(invocation, url);
    assertDoesNotThrow(() -> helper.authenticate(invocation, url));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testAuthenticateRequest() throws RpcAuthenticationException {
    URL url = URL.valueOf("dubbo://10.10.10.10:2181").addParameter(Constants.ACCESS_KEY_ID_KEY, "ak").addParameter(CommonConstants.APPLICATION_KEY, "test").addParameter(Constants.SECRET_ACCESS_KEY_KEY, "sk");
    Invocation invocation = new RpcInvocation();
    invocation.setAttachment(Constants.ACCESS_KEY_ID_KEY, "ak");
    invocation.setAttachment(Constants.REQUEST_SIGNATURE_KEY, "dubbo");
    invocation.setAttachment(Constants.REQUEST_TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));
    invocation.setAttachment(CommonConstants.CONSUMER, "test");
    AccessKeyAuthenticator helper = mock(AccessKeyAuthenticator.class);
    doCallRealMethod().when(helper).authenticate(invocation, url);
    when(helper.getSignature(eq(url), eq(invocation), eq("sk"), anyString())).thenReturn("dubbo");
    AccessKeyPair accessKeyPair = mock(AccessKeyPair.class);
    when(accessKeyPair.getSecretKey()).thenReturn("sk");
    when(helper.getAccessKeyPair(invocation, url)).thenReturn(accessKeyPair);
    assertDoesNotThrow(() -> helper.authenticate(invocation, url));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static AccessKeyAuthenticator createMockAccessKeyAuthenticator(Invocation invocation, URL url, AccessKeyPair accessKeyPair, String signatureReturn) {
    AccessKeyAuthenticator helper = mock(AccessKeyAuthenticator.class);
    when(helper.getAccessKeyPair(invocation, url)).thenReturn(accessKeyPair);
    when(helper.getSignature(eq(url), eq(invocation), eq("sk"), anyString())).thenReturn(signatureReturn);
    return helper;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_60
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.common.threadpool.support.eager.EagerThreadPoolExecutor`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static EagerThreadPoolExecutor createMockEagerThreadPoolExecutor(int poolSizeReturn, int activeCountReturn) {
    EagerThreadPoolExecutor executor = mock(EagerThreadPoolExecutor.class);
    Mockito.when(executor.getPoolSize()).thenReturn(poolSizeReturn);
    Mockito.when(executor.getActiveCount()).thenReturn(activeCountReturn);
    return executor;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_60_1
#### Test Case Name: `testOffer2`(File: `C:\Java_projects\Apache\dubbo\dubbo-common\src\test\java\org\apache\dubbo\common\threadpool\support\eager\TaskQueueTest.java`)
#### Mock Object Variable Name: `executor`
<summary>Suggested Diff</summary>

```diff
@@
 void testOffer2() throws Exception {
     TaskQueue<Runnable> queue = new TaskQueue<Runnable>(1);
-    EagerThreadPoolExecutor executor = mock(EagerThreadPoolExecutor.class);
-    Mockito.when(executor.getPoolSize()).thenReturn(2);
-    Mockito.when(executor.getActiveCount()).thenReturn(1);
+    EagerThreadPoolExecutor executor = createMockEagerThreadPoolExecutor(2, 1);
     queue.setExecutor(executor);
     assertThat(queue.offer(mock(Runnable.class)), is(true));
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testOffer2() throws Exception {
    TaskQueue<Runnable> queue = new TaskQueue<Runnable>(1);
    EagerThreadPoolExecutor executor = mock(EagerThreadPoolExecutor.class);
    Mockito.when(executor.getPoolSize()).thenReturn(2);
    Mockito.when(executor.getActiveCount()).thenReturn(1);
    queue.setExecutor(executor);
    assertThat(queue.offer(mock(Runnable.class)), is(true));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static EagerThreadPoolExecutor createMockEagerThreadPoolExecutor(int poolSizeReturn, int activeCountReturn) {
    EagerThreadPoolExecutor executor = mock(EagerThreadPoolExecutor.class);
    Mockito.when(executor.getPoolSize()).thenReturn(poolSizeReturn);
    Mockito.when(executor.getActiveCount()).thenReturn(activeCountReturn);
    return executor;
}
```
</details>

---
#### Test Case ID #dubbo_Test_60_2
#### Test Case Name: `testOffer3`(File: `C:\Java_projects\Apache\dubbo\dubbo-common\src\test\java\org\apache\dubbo\common\threadpool\support\eager\TaskQueueTest.java`)
#### Mock Object Variable Name: `executor`
<summary>Suggested Diff</summary>

```diff
@@
 void testOffer3() throws Exception {
     TaskQueue<Runnable> queue = new TaskQueue<Runnable>(1);
-    EagerThreadPoolExecutor executor = mock(EagerThreadPoolExecutor.class);
-    Mockito.when(executor.getPoolSize()).thenReturn(2);
-    Mockito.when(executor.getActiveCount()).thenReturn(2);
-    Mockito.when(executor.getMaximumPoolSize()).thenReturn(4);
+    EagerThreadPoolExecutor executor = createMockEagerThreadPoolExecutor(2, 2);
+    Mockito.when(executor.getMaximumPoolSize()).thenReturn(4);
     queue.setExecutor(executor);
     assertThat(queue.offer(mock(Runnable.class)), is(false));
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testOffer3() throws Exception {
    TaskQueue<Runnable> queue = new TaskQueue<Runnable>(1);
    EagerThreadPoolExecutor executor = mock(EagerThreadPoolExecutor.class);
    Mockito.when(executor.getPoolSize()).thenReturn(2);
    Mockito.when(executor.getActiveCount()).thenReturn(2);
    Mockito.when(executor.getMaximumPoolSize()).thenReturn(4);
    queue.setExecutor(executor);
    assertThat(queue.offer(mock(Runnable.class)), is(false));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static EagerThreadPoolExecutor createMockEagerThreadPoolExecutor(int poolSizeReturn, int activeCountReturn) {
    EagerThreadPoolExecutor executor = mock(EagerThreadPoolExecutor.class);
    Mockito.when(executor.getPoolSize()).thenReturn(poolSizeReturn);
    Mockito.when(executor.getActiveCount()).thenReturn(activeCountReturn);
    return executor;
}
```
</details>

---
#### Test Case ID #dubbo_Test_60_3
#### Test Case Name: `testOffer4`(File: `C:\Java_projects\Apache\dubbo\dubbo-common\src\test\java\org\apache\dubbo\common\threadpool\support\eager\TaskQueueTest.java`)
#### Mock Object Variable Name: `executor`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    TaskQueue<Runnable> queue = new TaskQueue<Runnable>(1);
-    EagerThreadPoolExecutor executor = mock(EagerThreadPoolExecutor.class);
-    Mockito.when(executor.getPoolSize()).thenReturn(4);
-    Mockito.when(executor.getActiveCount()).thenReturn(4);
-    Mockito.when(executor.getMaximumPoolSize()).thenReturn(4);
+    EagerThreadPoolExecutor executor = createMockEagerThreadPoolExecutor(4, 4);
+    Mockito.when(executor.getMaximumPoolSize()).thenReturn(4);
    queue.setExecutor(executor);
    assertThat(queue.offer(mock(Runnable.class)), is(true));
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testOffer4() throws Exception {
    TaskQueue<Runnable> queue = new TaskQueue<Runnable>(1);
    EagerThreadPoolExecutor executor = mock(EagerThreadPoolExecutor.class);
    Mockito.when(executor.getPoolSize()).thenReturn(4);
    Mockito.when(executor.getActiveCount()).thenReturn(4);
    Mockito.when(executor.getMaximumPoolSize()).thenReturn(4);
    queue.setExecutor(executor);
    assertThat(queue.offer(mock(Runnable.class)), is(true));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static EagerThreadPoolExecutor createMockEagerThreadPoolExecutor(int poolSizeReturn, int activeCountReturn) {
    EagerThreadPoolExecutor executor = mock(EagerThreadPoolExecutor.class);
    Mockito.when(executor.getPoolSize()).thenReturn(poolSizeReturn);
    Mockito.when(executor.getActiveCount()).thenReturn(activeCountReturn);
    return executor;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_61
- **Scope**: class level
- **Mocked Class**: `org.apache.dubbo.rpc.model.ProviderModel`
- **Test Case Count**: 1
- **MO Count**: 2

### Reusable Method
```java
public class MockProviderModel {
    public static ProviderModel createMockProviderModel(ServiceDescriptor serviceDescriptor) {
        ProviderModel providerModel = Mockito.mock(ProviderModel.class);
        when(providerModel.getServiceModel()).thenReturn(serviceDescriptor);
        return providerModel;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_61_1
#### Test Case Name: `doStartCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\protocol\tri\call\ReflectionServerCallTest.java`)
#### Mock Object Variable Name: `providerModel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    TripleServerStream serverStream = Mockito.mock(TripleServerStream.class);
-    ProviderModel providerModel = Mockito.mock(ProviderModel.class);
    Method method = DescriptorService.class.getMethod("sayHello", HelloReply.class);
    MethodDescriptor methodDescriptor = new ReflectionMethodDescriptor(method);
    URL url = Mockito.mock(URL.class);
    when(invoker.getUrl()).thenReturn(url);
    when(url.getServiceModel()).thenReturn(providerModel);
    String service = "testService";
    String methodName = "method";
    try {
        ReflectionAbstractServerCall call = new ReflectionAbstractServerCall(invoker, serverStream, new FrameworkModel(), "", service, methodName, Collections.emptyList(), ImmediateEventExecutor.INSTANCE);
        fail();
    } catch (Exception e) {
        // pass
    }
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(serviceDescriptor.getMethods(anyString())).thenReturn(Collections.singletonList(methodDescriptor));
+    ProviderModel providerModel = MockProviderModel.createMockProviderModel(serviceDescriptor);
    ReflectionAbstractServerCall call2 = new ReflectionAbstractServerCall(invoker, serverStream, new FrameworkModel(), "", service, methodName, Collections.emptyList(), ImmediateEventExecutor.INSTANCE);
    call2.onHeader(Collections.emptyMap());
    call2.onMessage(new byte[0], false);
    call2.onComplete();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void doStartCall() throws NoSuchMethodException {
    Invoker<?> invoker = Mockito.mock(Invoker.class);
    TripleServerStream serverStream = Mockito.mock(TripleServerStream.class);
    ProviderModel providerModel = Mockito.mock(ProviderModel.class);
    Method method = DescriptorService.class.getMethod("sayHello", HelloReply.class);
    MethodDescriptor methodDescriptor = new ReflectionMethodDescriptor(method);
    URL url = Mockito.mock(URL.class);
    when(invoker.getUrl()).thenReturn(url);
    when(url.getServiceModel()).thenReturn(providerModel);
    String service = "testService";
    String methodName = "method";
    try {
        ReflectionAbstractServerCall call = new ReflectionAbstractServerCall(invoker, serverStream, new FrameworkModel(), "", service, methodName, Collections.emptyList(), ImmediateEventExecutor.INSTANCE);
        fail();
    } catch (Exception e) {
        // pass
    }
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(serviceDescriptor.getMethods(anyString())).thenReturn(Collections.singletonList(methodDescriptor));
    when(providerModel.getServiceModel()).thenReturn(serviceDescriptor);
    ReflectionAbstractServerCall call2 = new ReflectionAbstractServerCall(invoker, serverStream, new FrameworkModel(), "", service, methodName, Collections.emptyList(), ImmediateEventExecutor.INSTANCE);
    call2.onHeader(Collections.emptyMap());
    call2.onMessage(new byte[0], false);
    call2.onComplete();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockProviderModel {
    public static ProviderModel createMockProviderModel(ServiceDescriptor serviceDescriptor) {
        ProviderModel providerModel = Mockito.mock(ProviderModel.class);
        when(providerModel.getServiceModel()).thenReturn(serviceDescriptor);
        return providerModel;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_61_2
#### Test Case Name: `doStartCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\protocol\tri\call\StubServerCallTest.java`)
#### Mock Object Variable Name: `providerModel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Invoker<?> invoker = Mockito.mock(Invoker.class);
    TripleServerStream tripleServerStream = Mockito.mock(TripleServerStream.class);
-    ProviderModel providerModel = Mockito.mock(ProviderModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    StubMethodDescriptor methodDescriptor = Mockito.mock(StubMethodDescriptor.class);
    URL url = Mockito.mock(URL.class);
    when(invoker.getUrl()).thenReturn(url);
    when(url.getServiceModel()).thenReturn(providerModel);
+    ProviderModel providerModel = MockProviderModel.createMockProviderModel(serviceDescriptor);
    when(serviceDescriptor.getMethods(anyString())).thenReturn(Collections.singletonList(methodDescriptor));
    when(methodDescriptor.getRpcType()).thenReturn(RpcType.UNARY);
    when(methodDescriptor.parseRequest(any(byte[].class))).thenReturn("test");
    String service = "testService";
    String method = "method";
    StubAbstractServerCall call = new StubAbstractServerCall(invoker, tripleServerStream, new FrameworkModel(), "", service, method, ImmediateEventExecutor.INSTANCE);
    call.onHeader(Collections.emptyMap());
    call.onMessage(new byte[0], false);
    call.onComplete();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void doStartCall() throws IOException, ClassNotFoundException {
    Invoker<?> invoker = Mockito.mock(Invoker.class);
    TripleServerStream tripleServerStream = Mockito.mock(TripleServerStream.class);
    ProviderModel providerModel = Mockito.mock(ProviderModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    StubMethodDescriptor methodDescriptor = Mockito.mock(StubMethodDescriptor.class);
    URL url = Mockito.mock(URL.class);
    when(invoker.getUrl()).thenReturn(url);
    when(url.getServiceModel()).thenReturn(providerModel);
    when(providerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(serviceDescriptor.getMethods(anyString())).thenReturn(Collections.singletonList(methodDescriptor));
    when(methodDescriptor.getRpcType()).thenReturn(RpcType.UNARY);
    when(methodDescriptor.parseRequest(any(byte[].class))).thenReturn("test");
    String service = "testService";
    String method = "method";
    StubAbstractServerCall call = new StubAbstractServerCall(invoker, tripleServerStream, new FrameworkModel(), "", service, method, ImmediateEventExecutor.INSTANCE);
    call.onHeader(Collections.emptyMap());
    call.onMessage(new byte[0], false);
    call.onComplete();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockProviderModel {
    public static ProviderModel createMockProviderModel(ServiceDescriptor serviceDescriptor) {
        ProviderModel providerModel = Mockito.mock(ProviderModel.class);
        when(providerModel.getServiceModel()).thenReturn(serviceDescriptor);
        return providerModel;
    }
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_62
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.Invoker<org.apache.dubbo.rpc.cluster.StickyTest>`
- **Test Case Count**: 1
- **MO Count**: 2

### Reusable Method
```java
private static Invoker<StickyTest> createMockInvoker(URL url, Result result, RpcInvocation invocation) {
    Invoker<StickyTest> invoker = mock(Invoker.class);
    given(invoker.getInterface()).willReturn(StickyTest.class);
    given(invoker.getUrl()).willReturn(url);
    given(invoker.invoke(invocation)).willReturn(result);
    given(invoker.isAvailable()).willReturn(true);
    return invoker;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_62_1
#### Test Case Name: `testSticky`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\StickyTest.java`)
#### Mock Object Variable Name: `invoker1`
<summary>Suggested Diff</summary>

```diff
--- Original.java
+++ Refactored.java
@@
public int testSticky(String methodName, boolean check) {
    if (methodName == null) {
        url = url.addParameter(CLUSTER_STICKY_KEY, String.valueOf(check));
    } else {
        url = url.addParameter(methodName + "." + CLUSTER_STICKY_KEY, String.valueOf(check));
    }
-    given(invoker1.invoke(invocation)).willReturn(result);
-    given(invoker1.isAvailable()).willReturn(true);
-    given(invoker1.getUrl()).willReturn(url.setPort(1));
-    given(invoker1.getInterface()).willReturn(StickyTest.class);
+    invoker1 = createMockInvoker(url.setPort(1), result, invocation);
    given(invoker2.invoke(invocation)).willReturn(result);
    given(invoker2.isAvailable()).willReturn(true);
    given(invoker2.getUrl()).willReturn(url.setPort(2));
    given(invoker2.getInterface()).willReturn(StickyTest.class);
    invocation.setMethodName(methodName);
    int count = 0;
    for (int i = 0; i < runs; i++) {
        Assertions.assertNull(clusterinvoker.invoke(invocation));
        if (invoker1 == clusterinvoker.getSelectedInvoker()) {
            count++;
        }
    }
    return count;
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setUp() throws Exception {
    dic = mock(Directory.class);
    invocation = new RpcInvocation();
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.list(invocation)).willReturn(invokers);
    given(dic.getInterface()).willReturn(StickyTest.class);
    invokers.add(invoker1);
    invokers.add(invoker2);
    clusterinvoker = new StickyClusterInvoker<StickyTest>(dic);
}
public int testSticky(String methodName, boolean check) {
    if (methodName == null) {
        url = url.addParameter(CLUSTER_STICKY_KEY, String.valueOf(check));
    } else {
        url = url.addParameter(methodName + "." + CLUSTER_STICKY_KEY, String.valueOf(check));
    }
    given(invoker1.invoke(invocation)).willReturn(result);
    given(invoker1.isAvailable()).willReturn(true);
    given(invoker1.getUrl()).willReturn(url.setPort(1));
    given(invoker1.getInterface()).willReturn(StickyTest.class);
    given(invoker2.invoke(invocation)).willReturn(result);
    given(invoker2.isAvailable()).willReturn(true);
    given(invoker2.getUrl()).willReturn(url.setPort(2));
    given(invoker2.getInterface()).willReturn(StickyTest.class);
    invocation.setMethodName(methodName);
    int count = 0;
    for (int i = 0; i < runs; i++) {
        Assertions.assertNull(clusterinvoker.invoke(invocation));
        if (invoker1 == clusterinvoker.getSelectedInvoker()) {
            count++;
        }
    }
    return count;
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker<StickyTest> createMockInvoker(URL url, Result result, RpcInvocation invocation) {
    Invoker<StickyTest> invoker = mock(Invoker.class);
    given(invoker.getInterface()).willReturn(StickyTest.class);
    given(invoker.getUrl()).willReturn(url);
    given(invoker.invoke(invocation)).willReturn(result);
    given(invoker.isAvailable()).willReturn(true);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_62_2
#### Test Case Name: `testSticky`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\StickyTest.java`)
#### Mock Object Variable Name: `invoker2`
<summary>Suggested Diff</summary>

```diff
--- Original
+++ Refactored
@@
-private Invoker<StickyTest> invoker2 = mock(Invoker.class);
@@
public int testSticky(String methodName, boolean check) {
    if (methodName == null) {
        url = url.addParameter(CLUSTER_STICKY_KEY, String.valueOf(check));
    } else {
        url = url.addParameter(methodName + "." + CLUSTER_STICKY_KEY, String.valueOf(check));
    }
    given(invoker1.invoke(invocation)).willReturn(result);
    given(invoker1.isAvailable()).willReturn(true);
    given(invoker1.getUrl()).willReturn(url.setPort(1));
    given(invoker1.getInterface()).willReturn(StickyTest.class);
-    given(invoker2.invoke(invocation)).willReturn(result);
-    given(invoker2.isAvailable()).willReturn(true);
-    given(invoker2.getUrl()).willReturn(url.setPort(2));
-    given(invoker2.getInterface()).willReturn(StickyTest.class);
+    invoker2 = createMockInvoker(url.setPort(2), result, invocation);
    invocation.setMethodName(methodName);
    int count = 0;
    for (int i = 0; i < runs; i++) {
        Assertions.assertNull(clusterinvoker.invoke(invocation));
        if (invoker1 == clusterinvoker.getSelectedInvoker()) {
            count++;
        }
    }
    return count;
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@BeforeEach
public void setUp() throws Exception {
    dic = mock(Directory.class);
    invocation = new RpcInvocation();
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.list(invocation)).willReturn(invokers);
    given(dic.getInterface()).willReturn(StickyTest.class);
    invokers.add(invoker1);
    invokers.add(invoker2);
    clusterinvoker = new StickyClusterInvoker<StickyTest>(dic);
}
public int testSticky(String methodName, boolean check) {
    if (methodName == null) {
        url = url.addParameter(CLUSTER_STICKY_KEY, String.valueOf(check));
    } else {
        url = url.addParameter(methodName + "." + CLUSTER_STICKY_KEY, String.valueOf(check));
    }
    given(invoker1.invoke(invocation)).willReturn(result);
    given(invoker1.isAvailable()).willReturn(true);
    given(invoker1.getUrl()).willReturn(url.setPort(1));
    given(invoker1.getInterface()).willReturn(StickyTest.class);
    given(invoker2.invoke(invocation)).willReturn(result);
    given(invoker2.isAvailable()).willReturn(true);
    given(invoker2.getUrl()).willReturn(url.setPort(2));
    given(invoker2.getInterface()).willReturn(StickyTest.class);
    invocation.setMethodName(methodName);
    int count = 0;
    for (int i = 0; i < runs; i++) {
        Assertions.assertNull(clusterinvoker.invoke(invocation));
        if (invoker1 == clusterinvoker.getSelectedInvoker()) {
            count++;
        }
    }
    return count;
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker<StickyTest> createMockInvoker(URL url, Result result, RpcInvocation invocation) {
    Invoker<StickyTest> invoker = mock(Invoker.class);
    given(invoker.getInterface()).willReturn(StickyTest.class);
    given(invoker.getUrl()).willReturn(url);
    given(invoker.invoke(invocation)).willReturn(result);
    given(invoker.isAvailable()).willReturn(true);
    return invoker;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_63
- **Scope**: method level
- **Mocked Class**: `javax.sql.DataSource`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static DataSource createMockDataSource(Connection connection) throws SQLException {
    DataSource dataSource = mock(DataSource.class);
    given(dataSource.getConnection()).willReturn(connection);
    return dataSource;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_63_1
#### Test Case Name: `testWithDatasourceHasNextResult`(File: `C:\Java_projects\Apache\dubbo\dubbo-config\dubbo-config-spring\src\test\java\org\apache\dubbo\config\spring\status\DataSourceStatusCheckerTest.java`)
#### Mock Object Variable Name: `dataSource`
<summary>Suggested Diff</summary>

```diff
@@
     Map<String, DataSource> map = new HashMap<String, DataSource>();
-    DataSource dataSource = mock(DataSource.class);
     Connection connection = mock(Connection.class, Answers.RETURNS_DEEP_STUBS);
-    given(dataSource.getConnection()).willReturn(connection);
+    DataSource dataSource = createMockDataSource(connection);
     given(connection.getMetaData().getTypeInfo().next()).willReturn(true);
     map.put("mockDatabase", dataSource);
     given(applicationContext.getBeansOfType(eq(DataSource.class), anyBoolean(), anyBoolean())).willReturn(map);
     Status status = dataSourceStatusChecker.check();
     assertThat(status.getLevel(), is(Status.Level.OK));
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testWithDatasourceHasNextResult() throws SQLException {
    Map<String, DataSource> map = new HashMap<String, DataSource>();
    DataSource dataSource = mock(DataSource.class);
    Connection connection = mock(Connection.class, Answers.RETURNS_DEEP_STUBS);
    given(dataSource.getConnection()).willReturn(connection);
    given(connection.getMetaData().getTypeInfo().next()).willReturn(true);
    map.put("mockDatabase", dataSource);
    given(applicationContext.getBeansOfType(eq(DataSource.class), anyBoolean(), anyBoolean())).willReturn(map);
    Status status = dataSourceStatusChecker.check();
    assertThat(status.getLevel(), is(Status.Level.OK));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static DataSource createMockDataSource(Connection connection) throws SQLException {
    DataSource dataSource = mock(DataSource.class);
    given(dataSource.getConnection()).willReturn(connection);
    return dataSource;
}
```
</details>

---
#### Test Case ID #dubbo_Test_63_2
#### Test Case Name: `testWithDatasourceNotHasNextResult`(File: `C:\Java_projects\Apache\dubbo\dubbo-config\dubbo-config-spring\src\test\java\org\apache\dubbo\config\spring\status\DataSourceStatusCheckerTest.java`)
#### Mock Object Variable Name: `dataSource`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 void testWithDatasourceNotHasNextResult() throws SQLException {
     Map<String, DataSource> map = new HashMap<String, DataSource>();
-    DataSource dataSource = mock(DataSource.class);
     Connection connection = mock(Connection.class, Answers.RETURNS_DEEP_STUBS);
-    given(dataSource.getConnection()).willReturn(connection);
+    DataSource dataSource = createMockDataSource(connection);
     given(connection.getMetaData().getTypeInfo().next()).willReturn(false);
     map.put("mockDatabase", dataSource);
     given(applicationContext.getBeansOfType(eq(DataSource.class), anyBoolean(), anyBoolean())).willReturn(map);
     Status status = dataSourceStatusChecker.check();
     assertThat(status.getLevel(), is(Status.Level.ERROR));
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testWithDatasourceNotHasNextResult() throws SQLException {
    Map<String, DataSource> map = new HashMap<String, DataSource>();
    DataSource dataSource = mock(DataSource.class);
    Connection connection = mock(Connection.class, Answers.RETURNS_DEEP_STUBS);
    given(dataSource.getConnection()).willReturn(connection);
    given(connection.getMetaData().getTypeInfo().next()).willReturn(false);
    map.put("mockDatabase", dataSource);
    given(applicationContext.getBeansOfType(eq(DataSource.class), anyBoolean(), anyBoolean())).willReturn(map);
    Status status = dataSourceStatusChecker.check();
    assertThat(status.getLevel(), is(Status.Level.ERROR));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static DataSource createMockDataSource(Connection connection) throws SQLException {
    DataSource dataSource = mock(DataSource.class);
    given(dataSource.getConnection()).willReturn(connection);
    return dataSource;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_64
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.registry.integration.DynamicDirectory`
- **Test Case Count**: 2
- **MO Count**: 4

### Reusable Method
```java
private static DynamicDirectory createMockDynamicDirectory(List<Invoker<?>> invokers) {
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(directory.getAllInvokers()).thenReturn((List<Invoker<?>>) invokers);
    return directory;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_64_1
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationInvokerTest.java`)
#### Mock Object Variable Name: `directory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
-    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
+    DynamicDirectory directory = createMockDynamicDirectory(invokers);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
    Mockito.when(invoker.isAvailable()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
-    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("all")
@Test
void test() {
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
    Mockito.when(invoker.isAvailable()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(1)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(2)).invoke(null);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(3)).invoke(null);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(4)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(5)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(3)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(4)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(5)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(6)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(6)).invoke(null);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(7)).invoke(null);
    Assertions.assertNull(migrationInvoker.getInvoker());
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(7)).invoke(null);
    Assertions.assertNull(migrationInvoker.getServiceDiscoveryInvoker());
    ArgumentCaptor<InvokersChangedListener> argument = ArgumentCaptor.forClass(InvokersChangedListener.class);
    Mockito.verify(serviceDiscoveryDirectory, Mockito.atLeastOnce()).setInvokersChangedListener(argument.capture());
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    for (int i = 0; i < 20; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(27)).invoke(null);
    serviceDiscoveryInvokers.remove(1);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(false);
    argument.getAllValues().get(argument.getAllValues().size() - 1).onChange();
    for (int i = 0; i < 20; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(invoker, Mockito.times(27)).invoke(null);
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    argument.getAllValues().get(argument.getAllValues().size() - 1).onChange();
    Mockito.when(migrationRule.getProportion(Mockito.any())).thenReturn(50);
    migrationInvoker.setMigrationRule(migrationRule);
    for (int i = 0; i < 1000; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(serviceDiscoveryInvoker, Mockito.atMost(1026)).invoke(null);
    Mockito.verify(invoker, Mockito.atLeast(28)).invoke(null);
    Mockito.when(migrationRule.getDelay(Mockito.any())).thenReturn(1);
    long currentTimeMillis = System.currentTimeMillis();
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    Assertions.assertTrue(System.currentTimeMillis() - currentTimeMillis >= 2000);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static DynamicDirectory createMockDynamicDirectory(List<Invoker<?>> invokers) {
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(directory.getAllInvokers()).thenReturn((List<Invoker<?>>) invokers);
    return directory;
}
```
</details>

---
#### Test Case ID #dubbo_Test_64_2
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationInvokerTest.java`)
#### Mock Object Variable Name: `serviceDiscoveryDirectory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
-    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
     Mockito.when(invoker.getDirectory()).thenReturn(directory);
     Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
     Mockito.when(invoker.isAvailable()).thenReturn(true);
     Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
     Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
     Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
     List<Invoker<?>> invokers = new LinkedList<>();
     invokers.add(Mockito.mock(Invoker.class));
     invokers.add(Mockito.mock(Invoker.class));
     List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
     serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
     serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
     Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
-    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
+    DynamicDirectory serviceDiscoveryDirectory = createMockDynamicDirectory(serviceDiscoveryInvokers);
     Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
     Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
     URL consumerURL = Mockito.mock(URL.class);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("all")
@Test
void test() {
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
    Mockito.when(invoker.isAvailable()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(1)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(2)).invoke(null);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(3)).invoke(null);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(4)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(5)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(3)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(4)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(5)).invoke(null);
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(2.0f);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(6)).invoke(null);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(6)).invoke(null);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(7)).invoke(null);
    Assertions.assertNull(migrationInvoker.getInvoker());
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToForceInterfaceInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_INTERFACE);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(false);
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.FORCE_APPLICATION);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(7)).invoke(null);
    Assertions.assertNull(migrationInvoker.getServiceDiscoveryInvoker());
    ArgumentCaptor<InvokersChangedListener> argument = ArgumentCaptor.forClass(InvokersChangedListener.class);
    Mockito.verify(serviceDiscoveryDirectory, Mockito.atLeastOnce()).setInvokersChangedListener(argument.capture());
    Mockito.when(migrationRule.getThreshold(Mockito.any())).thenReturn(1.0f);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    for (int i = 0; i < 20; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(27)).invoke(null);
    serviceDiscoveryInvokers.remove(1);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(false);
    argument.getAllValues().get(argument.getAllValues().size() - 1).onChange();
    for (int i = 0; i < 20; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(invoker, Mockito.times(27)).invoke(null);
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    argument.getAllValues().get(argument.getAllValues().size() - 1).onChange();
    Mockito.when(migrationRule.getProportion(Mockito.any())).thenReturn(50);
    migrationInvoker.setMigrationRule(migrationRule);
    for (int i = 0; i < 1000; i++) {
        migrationInvoker.invoke(null);
    }
    Mockito.verify(serviceDiscoveryInvoker, Mockito.atMost(1026)).invoke(null);
    Mockito.verify(invoker, Mockito.atLeast(28)).invoke(null);
    Mockito.when(migrationRule.getDelay(Mockito.any())).thenReturn(1);
    long currentTimeMillis = System.currentTimeMillis();
    migrationInvoker.migrateToForceApplicationInvoker(migrationRule);
    Assertions.assertTrue(System.currentTimeMillis() - currentTimeMillis >= 2000);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static DynamicDirectory createMockDynamicDirectory(List<Invoker<?>> invokers) {
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(directory.getAllInvokers()).thenReturn((List<Invoker<?>>) invokers);
    return directory;
}
```
</details>

---
#### Test Case ID #dubbo_Test_64_3
#### Test Case Name: `testDecide`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationInvokerTest.java`)
#### Mock Object Variable Name: `directory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
-    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
    Mockito.when(invoker.isAvailable()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
+    DynamicDirectory directory = createMockDynamicDirectory(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
-    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("all")
@Test
void testDecide() {
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
    Mockito.when(invoker.isAvailable()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(false);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(1)).invoke(null);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static DynamicDirectory createMockDynamicDirectory(List<Invoker<?>> invokers) {
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(directory.getAllInvokers()).thenReturn((List<Invoker<?>>) invokers);
    return directory;
}
```
</details>

---
#### Test Case ID #dubbo_Test_64_4
#### Test Case Name: `testDecide`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationInvokerTest.java`)
#### Mock Object Variable Name: `serviceDiscoveryDirectory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
-    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
     Mockito.when(invoker.getDirectory()).thenReturn(directory);
     Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
     Mockito.when(invoker.isAvailable()).thenReturn(true);
     Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
     Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
     Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
     List<Invoker<?>> invokers = new LinkedList<>();
     invokers.add(Mockito.mock(Invoker.class));
     invokers.add(Mockito.mock(Invoker.class));
     List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
     serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
     serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
     Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
-    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
+    DynamicDirectory serviceDiscoveryDirectory = createMockDynamicDirectory(serviceDiscoveryInvokers);
     Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
     Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
     URL consumerURL = Mockito.mock(URL.class);
     Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("all")
@Test
void testDecide() {
    RegistryProtocol registryProtocol = Mockito.mock(RegistryProtocol.class);
    ClusterInvoker invoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker serviceDiscoveryInvoker = Mockito.mock(ClusterInvoker.class);
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    DynamicDirectory serviceDiscoveryDirectory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(invoker.getDirectory()).thenReturn(directory);
    Mockito.when(serviceDiscoveryInvoker.getDirectory()).thenReturn(serviceDiscoveryDirectory);
    Mockito.when(invoker.isAvailable()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    Mockito.when(invoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(serviceDiscoveryInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> invokers = new LinkedList<>();
    invokers.add(Mockito.mock(Invoker.class));
    invokers.add(Mockito.mock(Invoker.class));
    List<Invoker<?>> serviceDiscoveryInvokers = new LinkedList<>();
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    serviceDiscoveryInvokers.add(Mockito.mock(Invoker.class));
    Mockito.when(directory.getAllInvokers()).thenReturn(invokers);
    Mockito.when(serviceDiscoveryDirectory.getAllInvokers()).thenReturn(serviceDiscoveryInvokers);
    Mockito.when(registryProtocol.getInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(invoker);
    Mockito.when(registryProtocol.getServiceDiscoveryInvoker(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenReturn(serviceDiscoveryInvoker);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceInterface()).thenReturn("Test");
    Mockito.when(consumerURL.getGroup()).thenReturn("Group");
    Mockito.when(consumerURL.getVersion()).thenReturn("0.0.0");
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Group/Test:0.0.0");
    Mockito.when(consumerURL.getDisplayServiceKey()).thenReturn("Test:0.0.0");
    Mockito.when(consumerURL.getOrDefaultApplicationModel()).thenReturn(ApplicationModel.defaultModel());
    Mockito.when(invoker.getUrl()).thenReturn(consumerURL);
    Mockito.when(serviceDiscoveryInvoker.getUrl()).thenReturn(consumerURL);
    MigrationInvoker<?> migrationInvoker = new MigrationInvoker<>(registryProtocol, null, null, DemoService.class, null, consumerURL);
    MigrationRule migrationRule = Mockito.mock(MigrationRule.class);
    Mockito.when(migrationRule.getForce(Mockito.any())).thenReturn(true);
    migrationInvoker.migrateToApplicationFirstInvoker(migrationRule);
    migrationInvoker.setMigrationStep(MigrationStep.APPLICATION_FIRST);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(1)).invoke(null);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(false);
    migrationInvoker.invoke(null);
    Mockito.verify(invoker, Mockito.times(1)).invoke(null);
    Mockito.when(serviceDiscoveryInvoker.isAvailable()).thenReturn(true);
    migrationInvoker.invoke(null);
    Mockito.verify(serviceDiscoveryInvoker, Mockito.times(2)).invoke(null);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static DynamicDirectory createMockDynamicDirectory(List<Invoker<?>> invokers) {
    DynamicDirectory directory = Mockito.mock(DynamicDirectory.class);
    Mockito.when(directory.getAllInvokers()).thenReturn((List<Invoker<?>>) invokers);
    return directory;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_65
- **Scope**: class level
- **Mocked Class**: `org.apache.dubbo.qos.api.CommandContext`
- **Test Case Count**: 2
- **MO Count**: 4

### Reusable Method
```java
public class MockCommandContext {
    public static CommandContext createMockCommandContext(boolean isHttpReturn) {
        CommandContext commandContext = Mockito.mock(CommandContext.class);
        Mockito.when(commandContext.isHttp()).thenReturn(isHttpReturn);
        return commandContext;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_65_1
#### Test Case Name: `testNotify`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-qos\src\test\java\org\apache\dubbo\qos\command\impl\SerializeCheckStatusTest.java`)
#### Mock Object Variable Name: `commandContext1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SerializeCheckStatus serializeCheckStatus = new SerializeCheckStatus(frameworkModel);
-    CommandContext commandContext1 = Mockito.mock(CommandContext.class);
-    Mockito.when(commandContext1.isHttp()).thenReturn(false);
+    CommandContext commandContext1 = MockCommandContext.createMockCommandContext(false);
    CommandContext commandContext2 = Mockito.mock(CommandContext.class);
    Mockito.when(commandContext2.isHttp()).thenReturn(true);
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext1, null).contains("Test1234"));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testNotify() {
    FrameworkModel frameworkModel = new FrameworkModel();
    SerializeSecurityManager ssm = frameworkModel.getBeanFactory().getBean(SerializeSecurityManager.class);
    SerializeCheckStatus serializeCheckStatus = new SerializeCheckStatus(frameworkModel);
    CommandContext commandContext1 = Mockito.mock(CommandContext.class);
    Mockito.when(commandContext1.isHttp()).thenReturn(false);
    CommandContext commandContext2 = Mockito.mock(CommandContext.class);
    Mockito.when(commandContext2.isHttp()).thenReturn(true);
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext1, null).contains("Test1234"));
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext2, null).contains("Test1234"));
    ssm.addToAllowed("Test1234");
    Assertions.assertTrue(serializeCheckStatus.execute(commandContext1, null).contains("Test1234"));
    Assertions.assertTrue(serializeCheckStatus.execute(commandContext2, null).contains("Test1234"));
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext1, null).contains("Test4321"));
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext2, null).contains("Test4321"));
    ssm.addToDisAllowed("Test4321");
    Assertions.assertTrue(serializeCheckStatus.execute(commandContext1, null).contains("Test4321"));
    Assertions.assertTrue(serializeCheckStatus.execute(commandContext2, null).contains("Test4321"));
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext1, null).contains("CheckSerializable: false"));
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext2, null).contains("\"checkSerializable\":false"));
    ssm.setCheckSerializable(false);
    Assertions.assertTrue(serializeCheckStatus.execute(commandContext1, null).contains("CheckSerializable: false"));
    Assertions.assertTrue(serializeCheckStatus.execute(commandContext2, null).contains("\"checkSerializable\":false"));
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext1, null).contains("CheckStatus: DISABLE"));
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext2, null).contains("\"checkStatus\":\"DISABLE\""));
    ssm.setCheckStatus(org.apache.dubbo.common.utils.SerializeCheckStatus.DISABLE);
    Assertions.assertTrue(serializeCheckStatus.execute(commandContext1, null).contains("CheckStatus: DISABLE"));
    Assertions.assertTrue(serializeCheckStatus.execute(commandContext2, null).contains("\"checkStatus\":\"DISABLE\""));
    frameworkModel.destroy();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockCommandContext {
    public static CommandContext createMockCommandContext(boolean isHttpReturn) {
        CommandContext commandContext = Mockito.mock(CommandContext.class);
        Mockito.when(commandContext.isHttp()).thenReturn(isHttpReturn);
        return commandContext;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_65_2
#### Test Case Name: `testNotify`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-qos\src\test\java\org\apache\dubbo\qos\command\impl\SerializeCheckStatusTest.java`)
#### Mock Object Variable Name: `commandContext2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    CommandContext commandContext1 = Mockito.mock(CommandContext.class);
    Mockito.when(commandContext1.isHttp()).thenReturn(false);
-    CommandContext commandContext2 = Mockito.mock(CommandContext.class);
-    Mockito.when(commandContext2.isHttp()).thenReturn(true);
+    CommandContext commandContext2 = MockCommandContext.createMockCommandContext(true);
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext1, null).contains("Test1234"));
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext2, null).contains("Test1234"));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testNotify() {
    FrameworkModel frameworkModel = new FrameworkModel();
    SerializeSecurityManager ssm = frameworkModel.getBeanFactory().getBean(SerializeSecurityManager.class);
    SerializeCheckStatus serializeCheckStatus = new SerializeCheckStatus(frameworkModel);
    CommandContext commandContext1 = Mockito.mock(CommandContext.class);
    Mockito.when(commandContext1.isHttp()).thenReturn(false);
    CommandContext commandContext2 = Mockito.mock(CommandContext.class);
    Mockito.when(commandContext2.isHttp()).thenReturn(true);
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext1, null).contains("Test1234"));
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext2, null).contains("Test1234"));
    ssm.addToAllowed("Test1234");
    Assertions.assertTrue(serializeCheckStatus.execute(commandContext1, null).contains("Test1234"));
    Assertions.assertTrue(serializeCheckStatus.execute(commandContext2, null).contains("Test1234"));
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext1, null).contains("Test4321"));
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext2, null).contains("Test4321"));
    ssm.addToDisAllowed("Test4321");
    Assertions.assertTrue(serializeCheckStatus.execute(commandContext1, null).contains("Test4321"));
    Assertions.assertTrue(serializeCheckStatus.execute(commandContext2, null).contains("Test4321"));
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext1, null).contains("CheckSerializable: false"));
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext2, null).contains("\"checkSerializable\":false"));
    ssm.setCheckSerializable(false);
    Assertions.assertTrue(serializeCheckStatus.execute(commandContext1, null).contains("CheckSerializable: false"));
    Assertions.assertTrue(serializeCheckStatus.execute(commandContext2, null).contains("\"checkSerializable\":false"));
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext1, null).contains("CheckStatus: DISABLE"));
    Assertions.assertFalse(serializeCheckStatus.execute(commandContext2, null).contains("\"checkStatus\":\"DISABLE\""));
    ssm.setCheckStatus(org.apache.dubbo.common.utils.SerializeCheckStatus.DISABLE);
    Assertions.assertTrue(serializeCheckStatus.execute(commandContext1, null).contains("CheckStatus: DISABLE"));
    Assertions.assertTrue(serializeCheckStatus.execute(commandContext2, null).contains("\"checkStatus\":\"DISABLE\""));
    frameworkModel.destroy();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockCommandContext {
    public static CommandContext createMockCommandContext(boolean isHttpReturn) {
        CommandContext commandContext = Mockito.mock(CommandContext.class);
        Mockito.when(commandContext.isHttp()).thenReturn(isHttpReturn);
        return commandContext;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_65_3
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-qos\src\test\java\org\apache\dubbo\qos\command\impl\SerializeWarnedClassesTest.java`)
#### Mock Object Variable Name: `commandContext1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    SerializeWarnedClasses serializeWarnedClasses = new SerializeWarnedClasses(frameworkModel);
-    CommandContext commandContext1 = Mockito.mock(CommandContext.class);
-    Mockito.when(commandContext1.isHttp()).thenReturn(false);
+    CommandContext commandContext1 = MockCommandContext.createMockCommandContext(false);
    CommandContext commandContext2 = Mockito.mock(CommandContext.class);
    Mockito.when(commandContext2.isHttp()).thenReturn(true);
    Assertions.assertFalse(serializeWarnedClasses.execute(commandContext1, null).contains("Test1234"));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void test() {
    FrameworkModel frameworkModel = new FrameworkModel();
    SerializeSecurityManager ssm = frameworkModel.getBeanFactory().getBean(SerializeSecurityManager.class);
    SerializeWarnedClasses serializeWarnedClasses = new SerializeWarnedClasses(frameworkModel);
    CommandContext commandContext1 = Mockito.mock(CommandContext.class);
    Mockito.when(commandContext1.isHttp()).thenReturn(false);
    CommandContext commandContext2 = Mockito.mock(CommandContext.class);
    Mockito.when(commandContext2.isHttp()).thenReturn(true);
    Assertions.assertFalse(serializeWarnedClasses.execute(commandContext1, null).contains("Test1234"));
    Assertions.assertFalse(serializeWarnedClasses.execute(commandContext2, null).contains("Test1234"));
    ssm.getWarnedClasses().add("Test1234");
    Assertions.assertTrue(serializeWarnedClasses.execute(commandContext1, null).contains("Test1234"));
    Assertions.assertTrue(serializeWarnedClasses.execute(commandContext2, null).contains("Test1234"));
    Assertions.assertFalse(serializeWarnedClasses.execute(commandContext1, null).contains("Test4321"));
    Assertions.assertFalse(serializeWarnedClasses.execute(commandContext2, null).contains("Test4321"));
    ssm.getWarnedClasses().add("Test4321");
    Assertions.assertTrue(serializeWarnedClasses.execute(commandContext1, null).contains("Test4321"));
    Assertions.assertTrue(serializeWarnedClasses.execute(commandContext2, null).contains("Test4321"));
    frameworkModel.destroy();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockCommandContext {
    public static CommandContext createMockCommandContext(boolean isHttpReturn) {
        CommandContext commandContext = Mockito.mock(CommandContext.class);
        Mockito.when(commandContext.isHttp()).thenReturn(isHttpReturn);
        return commandContext;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_65_4
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-plugin\dubbo-qos\src\test\java\org\apache\dubbo\qos\command\impl\SerializeWarnedClassesTest.java`)
#### Mock Object Variable Name: `commandContext2`
<summary>Suggested Diff</summary>

```diff
@@
     CommandContext commandContext1 = Mockito.mock(CommandContext.class);
     Mockito.when(commandContext1.isHttp()).thenReturn(false);
-    CommandContext commandContext2 = Mockito.mock(CommandContext.class);
-    Mockito.when(commandContext2.isHttp()).thenReturn(true);
+    CommandContext commandContext2 = MockCommandContext.createMockCommandContext(true);
     Assertions.assertFalse(serializeWarnedClasses.execute(commandContext1, null).contains("Test1234"));
     Assertions.assertFalse(serializeWarnedClasses.execute(commandContext2, null).contains("Test1234"));
     ssm.getWarnedClasses().add("Test1234");
     Assertions.assertTrue(serializeWarnedClasses.execute(commandContext1, null).contains("Test1234"));
     Assertions.assertTrue(serializeWarnedClasses.execute(commandContext2, null).contains("Test1234"));
     Assertions.assertFalse(serializeWarnedClasses.execute(commandContext1, null).contains("Test4321"));
     Assertions.assertFalse(serializeWarnedClasses.execute(commandContext2, null).contains("Test4321"));
     ssm.getWarnedClasses().add("Test4321");
     Assertions.assertTrue(serializeWarnedClasses.execute(commandContext1, null).contains("Test4321"));
     Assertions.assertTrue(serializeWarnedClasses.execute(commandContext2, null).contains("Test4321"));
     frameworkModel.destroy();
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void test() {
    FrameworkModel frameworkModel = new FrameworkModel();
    SerializeSecurityManager ssm = frameworkModel.getBeanFactory().getBean(SerializeSecurityManager.class);
    SerializeWarnedClasses serializeWarnedClasses = new SerializeWarnedClasses(frameworkModel);
    CommandContext commandContext1 = Mockito.mock(CommandContext.class);
    Mockito.when(commandContext1.isHttp()).thenReturn(false);
    CommandContext commandContext2 = Mockito.mock(CommandContext.class);
    Mockito.when(commandContext2.isHttp()).thenReturn(true);
    Assertions.assertFalse(serializeWarnedClasses.execute(commandContext1, null).contains("Test1234"));
    Assertions.assertFalse(serializeWarnedClasses.execute(commandContext2, null).contains("Test1234"));
    ssm.getWarnedClasses().add("Test1234");
    Assertions.assertTrue(serializeWarnedClasses.execute(commandContext1, null).contains("Test1234"));
    Assertions.assertTrue(serializeWarnedClasses.execute(commandContext2, null).contains("Test1234"));
    Assertions.assertFalse(serializeWarnedClasses.execute(commandContext1, null).contains("Test4321"));
    Assertions.assertFalse(serializeWarnedClasses.execute(commandContext2, null).contains("Test4321"));
    ssm.getWarnedClasses().add("Test4321");
    Assertions.assertTrue(serializeWarnedClasses.execute(commandContext1, null).contains("Test4321"));
    Assertions.assertTrue(serializeWarnedClasses.execute(commandContext2, null).contains("Test4321"));
    frameworkModel.destroy();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockCommandContext {
    public static CommandContext createMockCommandContext(boolean isHttpReturn) {
        CommandContext commandContext = Mockito.mock(CommandContext.class);
        Mockito.when(commandContext.isHttp()).thenReturn(isHttpReturn);
        return commandContext;
    }
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_66
- **Scope**: method level
- **Mocked Class**: `java.util.concurrent.ExecutorService`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static ExecutorService createMockExecutorService() {
    ExecutorService executor = Mockito.mock(ExecutorService.class);
    when(executor.isTerminated()).thenReturn(false, true);
    return executor;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_66_1
#### Test Case Name: `testGracefulShutdown1`(File: `C:\Java_projects\Apache\dubbo\dubbo-common\src\test\java\org\apache\dubbo\common\utils\ExecutorUtilTest.java`)
#### Mock Object Variable Name: `executor`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @Test
 void testGracefulShutdown1() throws Exception {
-    ExecutorService executor = Mockito.mock(ExecutorService.class);
-    when(executor.isTerminated()).thenReturn(false, true);
+    ExecutorService executor = createMockExecutorService();
     when(executor.awaitTermination(20, TimeUnit.MILLISECONDS)).thenReturn(false);
     ExecutorUtil.gracefulShutdown(executor, 20);
     verify(executor).shutdown();
     verify(executor).shutdownNow();
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testGracefulShutdown1() throws Exception {
    ExecutorService executor = Mockito.mock(ExecutorService.class);
    when(executor.isTerminated()).thenReturn(false, true);
    when(executor.awaitTermination(20, TimeUnit.MILLISECONDS)).thenReturn(false);
    ExecutorUtil.gracefulShutdown(executor, 20);
    verify(executor).shutdown();
    verify(executor).shutdownNow();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ExecutorService createMockExecutorService() {
    ExecutorService executor = Mockito.mock(ExecutorService.class);
    when(executor.isTerminated()).thenReturn(false, true);
    return executor;
}
```
</details>

---
#### Test Case ID #dubbo_Test_66_2
#### Test Case Name: `testShutdownNow`(File: `C:\Java_projects\Apache\dubbo\dubbo-common\src\test\java\org\apache\dubbo\common\utils\ExecutorUtilTest.java`)
#### Mock Object Variable Name: `executor`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 void testShutdownNow() throws Exception {
-    ExecutorService executor = Mockito.mock(ExecutorService.class);
-    when(executor.isTerminated()).thenReturn(false, true);
+    ExecutorService executor = createMockExecutorService();
     ExecutorUtil.shutdownNow(executor, 20);
     verify(executor).shutdownNow();
     verify(executor).awaitTermination(20, TimeUnit.MILLISECONDS);
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testShutdownNow() throws Exception {
    ExecutorService executor = Mockito.mock(ExecutorService.class);
    when(executor.isTerminated()).thenReturn(false, true);
    ExecutorUtil.shutdownNow(executor, 20);
    verify(executor).shutdownNow();
    verify(executor).awaitTermination(20, TimeUnit.MILLISECONDS);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ExecutorService createMockExecutorService() {
    ExecutorService executor = Mockito.mock(ExecutorService.class);
    when(executor.isTerminated()).thenReturn(false, true);
    return executor;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_67
- **Scope**: method level
- **Mocked Class**: `Invoker<IGreeter>`
- **Test Case Count**: 5
- **MO Count**: 5

### Reusable Method
```java
private static Invoker<IGreeter> createMockInvoker(URL url) {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    return invoker;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_67_1
#### Test Case Name: `unaryCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void unaryCall() throws Throwable {
-    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
     URL url = Mockito.mock(URL.class);
     ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
     ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
     when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
     when(url.getServiceModel()).thenReturn(consumerModel);
     when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
     when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
+    Invoker<IGreeter> invoker = createMockInvoker(url);
     Result result = Mockito.mock(Result.class);
     when(invoker.invoke(any(Invocation.class))).thenReturn(result);
     String response = "response";
     when(result.recreate()).thenReturn(response);
     MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
     when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
     when(method.getMethodName()).thenReturn("sayHello");
     String request = "request";
     Object ret = StubInvocationUtil.unaryCall(invoker, method, request);
     Assertions.assertEquals(response, ret);
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void unaryCall() throws Throwable {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    when(invoker.invoke(any(Invocation.class))).thenReturn(result);
    String response = "response";
    when(result.recreate()).thenReturn(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    Object ret = StubInvocationUtil.unaryCall(invoker, method, request);
    Assertions.assertEquals(response, ret);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker<IGreeter> createMockInvoker(URL url) {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_67_2
#### Test Case Name: `unaryCall2`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void unaryCall2() throws Throwable {
-    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
     URL url = Mockito.mock(URL.class);
     ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
     ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
     when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
     when(url.getServiceModel()).thenReturn(consumerModel);
     when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
     when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
+    Invoker<IGreeter> invoker = createMockInvoker(url);
     Result result = Mockito.mock(Result.class);
-    when(invoker.getUrl()).thenReturn(url);
-    when(invoker.getInterface()).thenReturn(IGreeter.class);
     when(invoker.invoke(any(Invocation.class))).thenThrow(new RuntimeException("a")).thenThrow(new Error("b"));
     String response = "response";
     when(result.recreate()).thenReturn(response);
     MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
     when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
     when(method.getMethodName()).thenReturn("sayHello");
     String request = "request";
     try {
         StubInvocationUtil.unaryCall(invoker, method, request);
         fail();
     } catch (Throwable t) {
         // pass
     }
     try {
         StubInvocationUtil.unaryCall(invoker, method, request);
         fail();
     } catch (Throwable t) {
         // pass
     }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void unaryCall2() throws Throwable {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    when(invoker.invoke(any(Invocation.class))).thenThrow(new RuntimeException("a")).thenThrow(new Error("b"));
    String response = "response";
    when(result.recreate()).thenReturn(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    try {
        StubInvocationUtil.unaryCall(invoker, method, request);
        fail();
    } catch (Throwable t) {
        // pass
    }
    try {
        StubInvocationUtil.unaryCall(invoker, method, request);
        fail();
    } catch (Throwable t) {
        // pass
    }
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker<IGreeter> createMockInvoker(URL url) {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_67_3
#### Test Case Name: `testUnaryCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
@@
 void testUnaryCall() throws Throwable {
-    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
     URL url = Mockito.mock(URL.class);
     ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
     ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
     when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
     when(url.getServiceModel()).thenReturn(consumerModel);
     when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
     when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
+    Invoker<IGreeter> invoker = createMockInvoker(url);
     Result result = Mockito.mock(Result.class);
     String response = "response";
     when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> result);
     when(result.recreate()).thenReturn(response);
     MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
     when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
     when(method.getMethodName()).thenReturn("sayHello");
     String request = "request";
     CountDownLatch latch = new CountDownLatch(1);
     AtomicReference<Object> atomicReference = new AtomicReference<>();
     StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

         @Override
         public void onNext(Object data) {
             atomicReference.set(data);
         }

         @Override
         public void onError(Throwable throwable) {
         }

         @Override
         public void onCompleted() {
             latch.countDown();
         }
     };
     StubInvocationUtil.unaryCall(invoker, method, request, responseObserver);
     latch.await(1, TimeUnit.SECONDS);
     Assertions.assertEquals(response, atomicReference.get());
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testUnaryCall() throws Throwable {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> result);
    when(result.recreate()).thenReturn(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    CountDownLatch latch = new CountDownLatch(1);
    AtomicReference<Object> atomicReference = new AtomicReference<>();
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            atomicReference.set(data);
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StubInvocationUtil.unaryCall(invoker, method, request, responseObserver);
    latch.await(1, TimeUnit.SECONDS);
    Assertions.assertEquals(response, atomicReference.get());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker<IGreeter> createMockInvoker(URL url) {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_67_4
#### Test Case Name: `biOrClientStreamCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void biOrClientStreamCall() throws InterruptedException {
-    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
+    Invoker<IGreeter> invoker = createMockInvoker(url);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
-    when(invoker.getUrl()).thenReturn(url);
-    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> {
        Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];
        StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[0];
        observer.onNext(response);
        observer.onCompleted();
        when(result.recreate()).then(invocationOnMock1 -> new StreamObserver<Object>() {

            @Override
            public void onNext(Object data) {
                observer.onNext(data);
            }

            @Override
            public void onError(Throwable throwable) {
            }

            @Override
            public void onCompleted() {
                observer.onCompleted();
            }
        });
        return result;
    });
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    CountDownLatch latch = new CountDownLatch(11);
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            latch.countDown();
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StreamObserver<Object> observer = StubInvocationUtil.biOrClientStreamCall(invoker, method, responseObserver);
    for (int i = 0; i < 10; i++) {
        observer.onNext(request);
    }
    observer.onCompleted();
    Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void biOrClientStreamCall() throws InterruptedException {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> {
        Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];
        StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[0];
        observer.onNext(response);
        observer.onCompleted();
        when(result.recreate()).then(invocationOnMock1 -> new StreamObserver<Object>() {

            @Override
            public void onNext(Object data) {
                observer.onNext(data);
            }

            @Override
            public void onError(Throwable throwable) {
            }

            @Override
            public void onCompleted() {
                observer.onCompleted();
            }
        });
        return result;
    });
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    CountDownLatch latch = new CountDownLatch(11);
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            latch.countDown();
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StreamObserver<Object> observer = StubInvocationUtil.biOrClientStreamCall(invoker, method, responseObserver);
    for (int i = 0; i < 10; i++) {
        observer.onNext(request);
    }
    observer.onCompleted();
    Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker<IGreeter> createMockInvoker(URL url) {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    return invoker;
}
```
</details>

---
#### Test Case ID #dubbo_Test_67_5
#### Test Case Name: `serverStreamCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `invoker`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void serverStreamCall() throws InterruptedException {
-    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
+    Invoker<IGreeter> invoker = createMockInvoker(url);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
-    when(invoker.getUrl()).thenReturn(url);
-    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> {
        Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];
        StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[1];
        for (int i = 0; i < 10; i++) {
            observer.onNext(response);
        }
        observer.onCompleted();
        return result;
    });
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    CountDownLatch latch = new CountDownLatch(11);
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            latch.countDown();
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StubInvocationUtil.serverStreamCall(invoker, method, request, responseObserver);
    Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void serverStreamCall() throws InterruptedException {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> {
        Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];
        StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[1];
        for (int i = 0; i < 10; i++) {
            observer.onNext(response);
        }
        observer.onCompleted();
        return result;
    });
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    CountDownLatch latch = new CountDownLatch(11);
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            latch.countDown();
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StubInvocationUtil.serverStreamCall(invoker, method, request, responseObserver);
    Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Invoker<IGreeter> createMockInvoker(URL url) {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    return invoker;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_68
- **Scope**: class level
- **Mocked Class**: `org.apache.dubbo.common.logger.Logger`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
public class MockLogger {
    public static Logger createMockLoggerWithFailingMethods() {
        Logger logger = mock(Logger.class);
        doThrow(new RuntimeException()).when(logger).debug(anyString());
        doThrow(new RuntimeException()).when(logger).debug(any(Throwable.class));
        doThrow(new RuntimeException()).when(logger).error(anyString());
        doThrow(new RuntimeException()).when(logger).error(any(Throwable.class));
        doThrow(new RuntimeException()).when(logger).info(anyString());
        doThrow(new RuntimeException()).when(logger).info(any(Throwable.class));
        doThrow(new RuntimeException()).when(logger).trace(anyString());
        doThrow(new RuntimeException()).when(logger).trace(any(Throwable.class));
        doThrow(new RuntimeException()).when(logger).warn(anyString());
        doThrow(new RuntimeException()).when(logger).warn(any(Throwable.class));
        return logger;
    }
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_68_1
#### Test Case Name: `testFailsafeErrorTypeAwareForLoggingMethod`(File: `C:\Java_projects\Apache\dubbo\dubbo-common\src\test\java\org\apache\dubbo\common\logger\support\FailsafeErrorTypeAwareLoggerTest.java`)
#### Mock Object Variable Name: `failLogger`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testFailsafeErrorTypeAwareForLoggingMethod() {
-    Logger failLogger = mock(Logger.class);
+    Logger failLogger = MockLogger.createMockLoggerWithFailingMethods();
    FailsafeErrorTypeAwareLogger failsafeLogger = new FailsafeErrorTypeAwareLogger(failLogger);
-    doThrow(new RuntimeException()).when(failLogger).error(anyString());
-    doThrow(new RuntimeException()).when(failLogger).warn(anyString());
-    doThrow(new RuntimeException()).when(failLogger).info(anyString());
-    doThrow(new RuntimeException()).when(failLogger).debug(anyString());
-    doThrow(new RuntimeException()).when(failLogger).trace(anyString());
    failsafeLogger.error(REGISTRY_ADDRESS_INVALID, "Registry center", "May be it's offline.", "error");
    failsafeLogger.warn(REGISTRY_ADDRESS_INVALID, "Registry center", "May be it's offline.", "warn");
-    doThrow(new RuntimeException()).when(failLogger).error(any(Throwable.class));
-    doThrow(new RuntimeException()).when(failLogger).warn(any(Throwable.class));
-    doThrow(new RuntimeException()).when(failLogger).info(any(Throwable.class));
-    doThrow(new RuntimeException()).when(failLogger).debug(any(Throwable.class));
-    doThrow(new RuntimeException()).when(failLogger).trace(any(Throwable.class));
    failsafeLogger.error(REGISTRY_ADDRESS_INVALID, "Registry center", "May be it's offline.", "error", new Exception("error"));
    failsafeLogger.warn(REGISTRY_ADDRESS_INVALID, "Registry center", "May be it's offline.", "warn", new Exception("warn"));
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testFailsafeErrorTypeAwareForLoggingMethod() {
    Logger failLogger = mock(Logger.class);
    FailsafeErrorTypeAwareLogger failsafeLogger = new FailsafeErrorTypeAwareLogger(failLogger);
    doThrow(new RuntimeException()).when(failLogger).error(anyString());
    doThrow(new RuntimeException()).when(failLogger).warn(anyString());
    doThrow(new RuntimeException()).when(failLogger).info(anyString());
    doThrow(new RuntimeException()).when(failLogger).debug(anyString());
    doThrow(new RuntimeException()).when(failLogger).trace(anyString());
    failsafeLogger.error(REGISTRY_ADDRESS_INVALID, "Registry center", "May be it's offline.", "error");
    failsafeLogger.warn(REGISTRY_ADDRESS_INVALID, "Registry center", "May be it's offline.", "warn");
    doThrow(new RuntimeException()).when(failLogger).error(any(Throwable.class));
    doThrow(new RuntimeException()).when(failLogger).warn(any(Throwable.class));
    doThrow(new RuntimeException()).when(failLogger).info(any(Throwable.class));
    doThrow(new RuntimeException()).when(failLogger).debug(any(Throwable.class));
    doThrow(new RuntimeException()).when(failLogger).trace(any(Throwable.class));
    failsafeLogger.error(REGISTRY_ADDRESS_INVALID, "Registry center", "May be it's offline.", "error", new Exception("error"));
    failsafeLogger.warn(REGISTRY_ADDRESS_INVALID, "Registry center", "May be it's offline.", "warn", new Exception("warn"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockLogger {
    public static Logger createMockLoggerWithFailingMethods() {
        Logger logger = mock(Logger.class);
        doThrow(new RuntimeException()).when(logger).debug(anyString());
        doThrow(new RuntimeException()).when(logger).debug(any(Throwable.class));
        doThrow(new RuntimeException()).when(logger).error(anyString());
        doThrow(new RuntimeException()).when(logger).error(any(Throwable.class));
        doThrow(new RuntimeException()).when(logger).info(anyString());
        doThrow(new RuntimeException()).when(logger).info(any(Throwable.class));
        doThrow(new RuntimeException()).when(logger).trace(anyString());
        doThrow(new RuntimeException()).when(logger).trace(any(Throwable.class));
        doThrow(new RuntimeException()).when(logger).warn(anyString());
        doThrow(new RuntimeException()).when(logger).warn(any(Throwable.class));
        return logger;
    }
}
```
</details>

---
#### Test Case ID #dubbo_Test_68_2
#### Test Case Name: `testFailSafeForLoggingMethod`(File: `C:\Java_projects\Apache\dubbo\dubbo-common\src\test\java\org\apache\dubbo\common\logger\support\FailsafeLoggerTest.java`)
#### Mock Object Variable Name: `failLogger`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testFailSafeForLoggingMethod() {
-    Logger failLogger = mock(Logger.class);
+    Logger failLogger = MockLogger.createMockLoggerWithFailingMethods();
    FailsafeLogger failsafeLogger = new FailsafeLogger(failLogger);
-    doThrow(new RuntimeException()).when(failLogger).error(anyString());
-    doThrow(new RuntimeException()).when(failLogger).warn(anyString());
-    doThrow(new RuntimeException()).when(failLogger).info(anyString());
-    doThrow(new RuntimeException()).when(failLogger).debug(anyString());
-    doThrow(new RuntimeException()).when(failLogger).trace(anyString());
    failsafeLogger.error("error");
    failsafeLogger.warn("warn");
    failsafeLogger.info("info");
    failsafeLogger.debug("debug");
    failsafeLogger.trace("info");
-    doThrow(new RuntimeException()).when(failLogger).error(any(Throwable.class));
-    doThrow(new RuntimeException()).when(failLogger).warn(any(Throwable.class));
-    doThrow(new RuntimeException()).when(failLogger).info(any(Throwable.class));
-    doThrow(new RuntimeException()).when(failLogger).debug(any(Throwable.class));
-    doThrow(new RuntimeException()).when(failLogger).trace(any(Throwable.class));
    failsafeLogger.error(new Exception("error"));
    failsafeLogger.warn(new Exception("warn"));
    failsafeLogger.info(new Exception("info"));
    failsafeLogger.debug(new Exception("debug"));
    failsafeLogger.trace(new Exception("trace"));
    failsafeLogger.error("error", new Exception("error"));
    failsafeLogger.warn("warn", new Exception("warn"));
    failsafeLogger.info("info", new Exception("info"));
    failsafeLogger.debug("debug", new Exception("debug"));
    failsafeLogger.trace("trace", new Exception("trace"));
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testFailSafeForLoggingMethod() {
    Logger failLogger = mock(Logger.class);
    FailsafeLogger failsafeLogger = new FailsafeLogger(failLogger);
    doThrow(new RuntimeException()).when(failLogger).error(anyString());
    doThrow(new RuntimeException()).when(failLogger).warn(anyString());
    doThrow(new RuntimeException()).when(failLogger).info(anyString());
    doThrow(new RuntimeException()).when(failLogger).debug(anyString());
    doThrow(new RuntimeException()).when(failLogger).trace(anyString());
    failsafeLogger.error("error");
    failsafeLogger.warn("warn");
    failsafeLogger.info("info");
    failsafeLogger.debug("debug");
    failsafeLogger.trace("info");
    doThrow(new RuntimeException()).when(failLogger).error(any(Throwable.class));
    doThrow(new RuntimeException()).when(failLogger).warn(any(Throwable.class));
    doThrow(new RuntimeException()).when(failLogger).info(any(Throwable.class));
    doThrow(new RuntimeException()).when(failLogger).debug(any(Throwable.class));
    doThrow(new RuntimeException()).when(failLogger).trace(any(Throwable.class));
    failsafeLogger.error(new Exception("error"));
    failsafeLogger.warn(new Exception("warn"));
    failsafeLogger.info(new Exception("info"));
    failsafeLogger.debug(new Exception("debug"));
    failsafeLogger.trace(new Exception("trace"));
    failsafeLogger.error("error", new Exception("error"));
    failsafeLogger.warn("warn", new Exception("warn"));
    failsafeLogger.info("info", new Exception("info"));
    failsafeLogger.debug("debug", new Exception("debug"));
    failsafeLogger.trace("trace", new Exception("trace"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
public class MockLogger {
    public static Logger createMockLoggerWithFailingMethods() {
        Logger logger = mock(Logger.class);
        doThrow(new RuntimeException()).when(logger).debug(anyString());
        doThrow(new RuntimeException()).when(logger).debug(any(Throwable.class));
        doThrow(new RuntimeException()).when(logger).error(anyString());
        doThrow(new RuntimeException()).when(logger).error(any(Throwable.class));
        doThrow(new RuntimeException()).when(logger).info(anyString());
        doThrow(new RuntimeException()).when(logger).info(any(Throwable.class));
        doThrow(new RuntimeException()).when(logger).trace(anyString());
        doThrow(new RuntimeException()).when(logger).trace(any(Throwable.class));
        doThrow(new RuntimeException()).when(logger).warn(anyString());
        doThrow(new RuntimeException()).when(logger).warn(any(Throwable.class));
        return logger;
    }
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_69
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.cluster.router.mesh.route.MeshEnvListener`
- **Test Case Count**: 1
- **MO Count**: 2

### Reusable Method
```java
private static MeshEnvListener createMockMeshEnvListener(boolean isEnableReturn) {
    MeshEnvListener meshEnvListener = Mockito.mock(MeshEnvListener.class);
    when(meshEnvListener.isEnable()).thenReturn(isEnableReturn);
    return meshEnvListener;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_69_1
#### Test Case Name: `testRegister3`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\router\mesh\route\MeshRuleManagerTest.java`)
#### Mock Object Variable Name: `meshEnvListener1`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    MeshEnvListenerFactory meshEnvListener1 = Mockito.mock(MeshEnvListenerFactory.class);
    MeshEnvListenerFactory meshEnvListenerFactory2 = Mockito.mock(MeshEnvListenerFactory.class);
-    MeshEnvListener meshEnvListener1 = Mockito.mock(MeshEnvListener.class);
+    MeshEnvListener meshEnvListener1 = createMockMeshEnvListener(false);
    when(meshEnvListenerFactory1.getListener()).thenReturn(meshEnvListener1);
    MeshEnvListener meshEnvListener2 = Mockito.mock(MeshEnvListener.class);
    when(meshEnvListenerFactory2.getListener()).thenReturn(meshEnvListener2);
    envListenerFactories.add(meshEnvListenerFactory1);
    envListenerFactories.add(meshEnvListenerFactory2);
    MeshRuleManager meshRuleManager = new MeshRuleManager(moduleModel);
    MeshRuleListener meshRuleListener1 = new MeshRuleListener() {
@@
        public String ruleSuffix() {
            return "Type1";
        }
    };
-    when(meshEnvListener1.isEnable()).thenReturn(false);
    when(meshEnvListener2.isEnable()).thenReturn(true);
    meshRuleManager.register("dubbo-demo", meshRuleListener1);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    verify(ruleRepository, times(1)).getRule("dubbo-demo.MESHAPPRULE", "dubbo", 5000L);
    MeshAppRuleListener meshAppRuleListener = meshRuleManager.getAppRuleListeners().values().iterator().next();
    verify(ruleRepository, times(1)).addListener("dubbo-demo.MESHAPPRULE", "dubbo", meshAppRuleListener);
    verify(meshEnvListener2, times(1)).onSubscribe("dubbo-demo", meshAppRuleListener);
    meshRuleManager.register("dubbo-demo", meshRuleListener1);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    MeshRuleListener meshRuleListener2 = new MeshRuleListener() {
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testRegister3() {
    MeshEnvListenerFactory meshEnvListenerFactory1 = Mockito.mock(MeshEnvListenerFactory.class);
    MeshEnvListenerFactory meshEnvListenerFactory2 = Mockito.mock(MeshEnvListenerFactory.class);
    MeshEnvListener meshEnvListener1 = Mockito.mock(MeshEnvListener.class);
    when(meshEnvListenerFactory1.getListener()).thenReturn(meshEnvListener1);
    MeshEnvListener meshEnvListener2 = Mockito.mock(MeshEnvListener.class);
    when(meshEnvListenerFactory2.getListener()).thenReturn(meshEnvListener2);
    envListenerFactories.add(meshEnvListenerFactory1);
    envListenerFactories.add(meshEnvListenerFactory2);
    MeshRuleManager meshRuleManager = new MeshRuleManager(moduleModel);
    MeshRuleListener meshRuleListener1 = new MeshRuleListener() {

        @Override
        public void onRuleChange(String appName, List<Map<String, Object>> rules) {
            fail();
        }

        @Override
        public void clearRule(String appName) {
        }

        @Override
        public String ruleSuffix() {
            return "Type1";
        }
    };
    when(meshEnvListener1.isEnable()).thenReturn(false);
    when(meshEnvListener2.isEnable()).thenReturn(true);
    meshRuleManager.register("dubbo-demo", meshRuleListener1);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    verify(ruleRepository, times(1)).getRule("dubbo-demo.MESHAPPRULE", "dubbo", 5000L);
    MeshAppRuleListener meshAppRuleListener = meshRuleManager.getAppRuleListeners().values().iterator().next();
    verify(ruleRepository, times(1)).addListener("dubbo-demo.MESHAPPRULE", "dubbo", meshAppRuleListener);
    verify(meshEnvListener2, times(1)).onSubscribe("dubbo-demo", meshAppRuleListener);
    meshRuleManager.register("dubbo-demo", meshRuleListener1);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    MeshRuleListener meshRuleListener2 = new MeshRuleListener() {

        @Override
        public void onRuleChange(String appName, List<Map<String, Object>> rules) {
            fail();
        }

        @Override
        public void clearRule(String appName) {
        }

        @Override
        public String ruleSuffix() {
            return "Type2";
        }
    };
    meshRuleManager.register("dubbo-demo", meshRuleListener2);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    assertEquals(2, meshAppRuleListener.getMeshRuleDispatcher().getListenerMap().size());
    meshRuleManager.unregister("dubbo-demo", meshRuleListener1);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    assertEquals(1, meshAppRuleListener.getMeshRuleDispatcher().getListenerMap().size());
    meshRuleManager.unregister("dubbo-demo", meshRuleListener2);
    assertEquals(0, meshRuleManager.getAppRuleListeners().size());
    verify(ruleRepository, times(1)).removeListener("dubbo-demo.MESHAPPRULE", "dubbo", meshAppRuleListener);
    verify(meshEnvListener2, times(1)).onUnSubscribe("dubbo-demo");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static MeshEnvListener createMockMeshEnvListener(boolean isEnableReturn) {
    MeshEnvListener meshEnvListener = Mockito.mock(MeshEnvListener.class);
    when(meshEnvListener.isEnable()).thenReturn(isEnableReturn);
    return meshEnvListener;
}
```
</details>

---
#### Test Case ID #dubbo_Test_69_2
#### Test Case Name: `testRegister3`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\router\mesh\route\MeshRuleManagerTest.java`)
#### Mock Object Variable Name: `meshEnvListener2`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    MeshEnvListenerFactory meshEnvListener1 = Mockito.mock(MeshEnvListenerFactory.class);
    MeshEnvListenerFactory meshEnvListener2 = Mockito.mock(MeshEnvListenerFactory.class);
    MeshEnvListener meshEnvListener1 = Mockito.mock(MeshEnvListener.class);
    when(meshEnvListenerFactory1.getListener()).thenReturn(meshEnvListener1);
-    MeshEnvListener meshEnvListener2 = Mockito.mock(MeshEnvListener.class);
-    when(meshEnvListenerFactory2.getListener()).thenReturn(meshEnvListener2);
+    MeshEnvListener meshEnvListener2 = createMockMeshEnvListener(true);
+    when(meshEnvListenerFactory2.getListener()).thenReturn(meshEnvListener2);
    envListenerFactories.add(meshEnvListenerFactory1);
    envListenerFactories.add(meshEnvListenerFactory2);
    MeshRuleManager meshRuleManager = new MeshRuleManager(moduleModel);
    MeshRuleListener meshRuleListener1 = new MeshRuleListener() {
@@
        @Override
        public String ruleSuffix() {
            return "Type1";
        }
    };
    when(meshEnvListener1.isEnable()).thenReturn(false);
-    when(meshEnvListener2.isEnable()).thenReturn(true);
    meshRuleManager.register("dubbo-demo", meshRuleListener1);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    verify(ruleRepository, times(1)).getRule("dubbo-demo.MESHAPPRULE", "dubbo", 5000L);
    MeshAppRuleListener meshAppRuleListener = meshRuleManager.getAppRuleListeners().values().iterator().next();
    verify(ruleRepository, times(1)).addListener("dubbo-demo.MESHAPPRULE", "dubbo", meshAppRuleListener);
    verify(meshEnvListener2, times(1)).onSubscribe("dubbo-demo", meshAppRuleListener);
    meshRuleManager.register("dubbo-demo", meshRuleListener1);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    MeshRuleListener meshRuleListener2 = new MeshRuleListener() {
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testRegister3() {
    MeshEnvListenerFactory meshEnvListenerFactory1 = Mockito.mock(MeshEnvListenerFactory.class);
    MeshEnvListenerFactory meshEnvListenerFactory2 = Mockito.mock(MeshEnvListenerFactory.class);
    MeshEnvListener meshEnvListener1 = Mockito.mock(MeshEnvListener.class);
    when(meshEnvListenerFactory1.getListener()).thenReturn(meshEnvListener1);
    MeshEnvListener meshEnvListener2 = Mockito.mock(MeshEnvListener.class);
    when(meshEnvListenerFactory2.getListener()).thenReturn(meshEnvListener2);
    envListenerFactories.add(meshEnvListenerFactory1);
    envListenerFactories.add(meshEnvListenerFactory2);
    MeshRuleManager meshRuleManager = new MeshRuleManager(moduleModel);
    MeshRuleListener meshRuleListener1 = new MeshRuleListener() {

        @Override
        public void onRuleChange(String appName, List<Map<String, Object>> rules) {
            fail();
        }

        @Override
        public void clearRule(String appName) {
        }

        @Override
        public String ruleSuffix() {
            return "Type1";
        }
    };
    when(meshEnvListener1.isEnable()).thenReturn(false);
    when(meshEnvListener2.isEnable()).thenReturn(true);
    meshRuleManager.register("dubbo-demo", meshRuleListener1);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    verify(ruleRepository, times(1)).getRule("dubbo-demo.MESHAPPRULE", "dubbo", 5000L);
    MeshAppRuleListener meshAppRuleListener = meshRuleManager.getAppRuleListeners().values().iterator().next();
    verify(ruleRepository, times(1)).addListener("dubbo-demo.MESHAPPRULE", "dubbo", meshAppRuleListener);
    verify(meshEnvListener2, times(1)).onSubscribe("dubbo-demo", meshAppRuleListener);
    meshRuleManager.register("dubbo-demo", meshRuleListener1);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    MeshRuleListener meshRuleListener2 = new MeshRuleListener() {

        @Override
        public void onRuleChange(String appName, List<Map<String, Object>> rules) {
            fail();
        }

        @Override
        public void clearRule(String appName) {
        }

        @Override
        public String ruleSuffix() {
            return "Type2";
        }
    };
    meshRuleManager.register("dubbo-demo", meshRuleListener2);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    assertEquals(2, meshAppRuleListener.getMeshRuleDispatcher().getListenerMap().size());
    meshRuleManager.unregister("dubbo-demo", meshRuleListener1);
    assertEquals(1, meshRuleManager.getAppRuleListeners().size());
    assertEquals(1, meshAppRuleListener.getMeshRuleDispatcher().getListenerMap().size());
    meshRuleManager.unregister("dubbo-demo", meshRuleListener2);
    assertEquals(0, meshRuleManager.getAppRuleListeners().size());
    verify(ruleRepository, times(1)).removeListener("dubbo-demo.MESHAPPRULE", "dubbo", meshAppRuleListener);
    verify(meshEnvListener2, times(1)).onUnSubscribe("dubbo-demo");
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static MeshEnvListener createMockMeshEnvListener(boolean isEnableReturn) {
    MeshEnvListener meshEnvListener = Mockito.mock(MeshEnvListener.class);
    when(meshEnvListener.isEnable()).thenReturn(isEnableReturn);
    return meshEnvListener;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_70
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.monitor.MonitorFactory`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static MonitorFactory createMockMonitorFactory(Monitor mockMonitor) {
    MonitorFactory mockMonitorFactory = mock(MonitorFactory.class);
    given(mockMonitorFactory.getMonitor(any(URL.class))).willReturn(mockMonitor);
    return mockMonitorFactory;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_70_1
#### Test Case Name: `testSafeFailForMonitorCollectFail`(File: `C:\Java_projects\Apache\dubbo\dubbo-monitor\dubbo-monitor-api\src\test\java\org\apache\dubbo\monitor\support\MonitorFilterTest.java`)
#### Mock Object Variable Name: `mockMonitorFactory`
<summary>Suggested Diff</summary>

```diff
@@
    MonitorFilter monitorFilter = new MonitorFilter();
-    MonitorFactory mockMonitorFactory = mock(MonitorFactory.class);
    Monitor mockMonitor = mock(Monitor.class);
    Mockito.doThrow(new RuntimeException()).when(mockMonitor).collect(any(URL.class));
+    MonitorFactory mockMonitorFactory = createMockMonitorFactory(mockMonitor);
    monitorFilter.setMonitorFactory(mockMonitorFactory);
-    given(mockMonitorFactory.getMonitor(any(URL.class))).willReturn(mockMonitor);
    Invocation invocation = new RpcInvocation("aaa", MonitorService.class.getName(), "", new Class<?>[0], new Object[0]);
    monitorFilter.invoke(serviceInvoker, invocation);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testSafeFailForMonitorCollectFail() {
    MonitorFilter monitorFilter = new MonitorFilter();
    MonitorFactory mockMonitorFactory = mock(MonitorFactory.class);
    Monitor mockMonitor = mock(Monitor.class);
    Mockito.doThrow(new RuntimeException()).when(mockMonitor).collect(any(URL.class));
    monitorFilter.setMonitorFactory(mockMonitorFactory);
    given(mockMonitorFactory.getMonitor(any(URL.class))).willReturn(mockMonitor);
    Invocation invocation = new RpcInvocation("aaa", MonitorService.class.getName(), "", new Class<?>[0], new Object[0]);
    monitorFilter.invoke(serviceInvoker, invocation);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static MonitorFactory createMockMonitorFactory(Monitor mockMonitor) {
    MonitorFactory mockMonitorFactory = mock(MonitorFactory.class);
    given(mockMonitorFactory.getMonitor(any(URL.class))).willReturn(mockMonitor);
    return mockMonitorFactory;
}
```
</details>

---
#### Test Case ID #dubbo_Test_70_2
#### Test Case Name: `testOnResponseWithoutStartTime`(File: `C:\Java_projects\Apache\dubbo\dubbo-monitor\dubbo-monitor-api\src\test\java\org\apache\dubbo\monitor\support\MonitorFilterTest.java`)
#### Mock Object Variable Name: `mockMonitorFactory`
<summary>Suggested Diff</summary>

```diff
@@
    MonitorFilter monitorFilter = new MonitorFilter();
-    MonitorFactory mockMonitorFactory = mock(MonitorFactory.class);
    Monitor mockMonitor = mock(Monitor.class);
-    monitorFilter.setMonitorFactory(mockMonitorFactory);
-    given(mockMonitorFactory.getMonitor(any(URL.class))).willReturn(mockMonitor);
+    MonitorFactory mockMonitorFactory = createMockMonitorFactory(mockMonitor);
+    monitorFilter.setMonitorFactory(mockMonitorFactory);
    Invocation invocation = new RpcInvocation("aaa", MonitorService.class.getName(), "", new Class<?>[0], new Object[0]);
    Result result = monitorFilter.invoke(serviceInvoker, invocation);
    invocation.getAttributes().remove("monitor_filter_start_time");
    monitorFilter.onResponse(result, serviceInvoker, invocation);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testOnResponseWithoutStartTime() {
    MonitorFilter monitorFilter = new MonitorFilter();
    MonitorFactory mockMonitorFactory = mock(MonitorFactory.class);
    Monitor mockMonitor = mock(Monitor.class);
    monitorFilter.setMonitorFactory(mockMonitorFactory);
    given(mockMonitorFactory.getMonitor(any(URL.class))).willReturn(mockMonitor);
    Invocation invocation = new RpcInvocation("aaa", MonitorService.class.getName(), "", new Class<?>[0], new Object[0]);
    Result result = monitorFilter.invoke(serviceInvoker, invocation);
    invocation.getAttributes().remove("monitor_filter_start_time");
    monitorFilter.onResponse(result, serviceInvoker, invocation);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static MonitorFactory createMockMonitorFactory(Monitor mockMonitor) {
    MonitorFactory mockMonitorFactory = mock(MonitorFactory.class);
    given(mockMonitorFactory.getMonitor(any(URL.class))).willReturn(mockMonitor);
    return mockMonitorFactory;
}
```
</details>

---
#### Test Case ID #dubbo_Test_70_3
#### Test Case Name: `testOnErrorWithoutStartTime`(File: `C:\Java_projects\Apache\dubbo\dubbo-monitor\dubbo-monitor-api\src\test\java\org\apache\dubbo\monitor\support\MonitorFilterTest.java`)
#### Mock Object Variable Name: `mockMonitorFactory`
<summary>Suggested Diff</summary>

```diff
@@
    MonitorFilter monitorFilter = new MonitorFilter();
-    MonitorFactory mockMonitorFactory = mock(MonitorFactory.class);
    Monitor mockMonitor = mock(Monitor.class);
+    MonitorFactory mockMonitorFactory = createMockMonitorFactory(mockMonitor);
    monitorFilter.setMonitorFactory(mockMonitorFactory);
-    given(mockMonitorFactory.getMonitor(any(URL.class))).willReturn(mockMonitor);
    Invocation invocation = new RpcInvocation("aaa", MonitorService.class.getName(), "", new Class<?>[0], new Object[0]);
    Throwable rpcException = new RpcException();
    monitorFilter.onError(rpcException, serviceInvoker, invocation);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testOnErrorWithoutStartTime() {
    MonitorFilter monitorFilter = new MonitorFilter();
    MonitorFactory mockMonitorFactory = mock(MonitorFactory.class);
    Monitor mockMonitor = mock(Monitor.class);
    monitorFilter.setMonitorFactory(mockMonitorFactory);
    given(mockMonitorFactory.getMonitor(any(URL.class))).willReturn(mockMonitor);
    Invocation invocation = new RpcInvocation("aaa", MonitorService.class.getName(), "", new Class<?>[0], new Object[0]);
    Throwable rpcException = new RpcException();
    monitorFilter.onError(rpcException, serviceInvoker, invocation);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static MonitorFactory createMockMonitorFactory(Monitor mockMonitor) {
    MonitorFactory mockMonitorFactory = mock(MonitorFactory.class);
    given(mockMonitorFactory.getMonitor(any(URL.class))).willReturn(mockMonitor);
    return mockMonitorFactory;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_71
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.cluster.Cluster`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
// === Declare in class scope ===
private Cluster cluster;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    cluster = mock(Cluster.class);
}

// === Replace local variable in test with ===
cluster;

```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_71_1
#### Test Case Name: `testConsumerUrlWithoutProtocol`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `cluster`
<summary>Suggested Diff</summary>

```diff
@@
     when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
-    Cluster cluster = mock(Cluster.class);
+    // removed local mock; replaced with global field `cluster`
     Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
     Assertions.assertTrue(invoker instanceof MigrationInvoker);
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify the generated consumer url information
 */
@Test
void testConsumerUrlWithoutProtocol() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    // verify that the protocol header of consumerUrl is set to "consumer"
    Assertions.assertEquals("consumer", consumerUrl.getProtocol());
    Assertions.assertEquals(parameters.get(REGISTER_IP_KEY), consumerUrl.getHost());
    Assertions.assertFalse(consumerUrl.getAttributes().containsKey(REFER_KEY));
    Assertions.assertEquals("value1", consumerUrl.getAttribute("key1"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Cluster cluster;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    cluster = mock(Cluster.class);
}

// === Replace local variable in test with ===
cluster;

```
</details>

---
#### Test Case ID #dubbo_Test_71_2
#### Test Case Name: `testConsumerUrlWithProtocol`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `cluster`
<summary>Suggested Diff</summary>

```diff
@@
     when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
-    Cluster cluster = mock(Cluster.class);
+    // removed local mock; replaced with global field `cluster`
     Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
     Assertions.assertTrue(invoker instanceof MigrationInvoker);
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that when the protocol is configured, the protocol of consumer url is the configured protocol
 */
@Test
void testConsumerUrlWithProtocol() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    parameters.put(PROTOCOL_KEY, "tri");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    // verify that the protocol of consumer url
    Assertions.assertEquals("tri", consumerUrl.getProtocol());
    Assertions.assertEquals(parameters.get(REGISTER_IP_KEY), consumerUrl.getHost());
    Assertions.assertFalse(consumerUrl.getAttributes().containsKey(REFER_KEY));
    Assertions.assertEquals("value1", consumerUrl.getAttribute("key1"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Cluster cluster;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    cluster = mock(Cluster.class);
}

// === Replace local variable in test with ===
cluster;

```
</details>

---
#### Test Case ID #dubbo_Test_71_3
#### Test Case Name: `testRegisterConsumerUrl`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `cluster`
<summary>Suggested Diff</summary>

```diff
@@
     when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
-    Cluster cluster = mock(Cluster.class);
+    // removed local mock; replaced with global field `cluster`
     Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
     Assertions.assertTrue(invoker instanceof MigrationInvoker);
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify the registered consumer url
 */
@Test
void testRegisterConsumerUrl() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "true");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    Map<String, String> urlParameters = consumerUrl.getParameters();
    URL urlToRegistry = new ServiceConfigURL(urlParameters.get(PROTOCOL_KEY) == null ? CONSUMER : urlParameters.get(PROTOCOL_KEY), urlParameters.remove(REGISTER_IP_KEY), 0, consumerUrl.getPath(), urlParameters);
    URL registeredConsumerUrl = urlToRegistry.addParameters(CATEGORY_KEY, CONSUMERS_CATEGORY, CHECK_KEY, String.valueOf(false)).setScopeModel(moduleModel);
    verify(registry, times(1)).register(registeredConsumerUrl);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private Cluster cluster;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    cluster = mock(Cluster.class);
}

// === Replace local variable in test with ===
cluster;

```
</details>

---
## Mock Clone Instance #dubbo_MCI_72
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.model.ConsumerModel`
- **Test Case Count**: 5
- **MO Count**: 5

### Reusable Method
```java
private static ConsumerModel createMockConsumerModel(ServiceDescriptor serviceDescriptor) {
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    return consumerModel;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_72_1
#### Test Case Name: `unaryCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `consumerModel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
-    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
+    ConsumerModel consumerModel = createMockConsumerModel(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void unaryCall() throws Throwable {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    when(invoker.invoke(any(Invocation.class))).thenReturn(result);
    String response = "response";
    when(result.recreate()).thenReturn(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    Object ret = StubInvocationUtil.unaryCall(invoker, method, request);
    Assertions.assertEquals(response, ret);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConsumerModel createMockConsumerModel(ServiceDescriptor serviceDescriptor) {
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    return consumerModel;
}
```
</details>

---
#### Test Case ID #dubbo_Test_72_2
#### Test Case Name: `unaryCall2`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `consumerModel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
-    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
+    ConsumerModel consumerModel = createMockConsumerModel(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void unaryCall2() throws Throwable {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    when(invoker.invoke(any(Invocation.class))).thenThrow(new RuntimeException("a")).thenThrow(new Error("b"));
    String response = "response";
    when(result.recreate()).thenReturn(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    try {
        StubInvocationUtil.unaryCall(invoker, method, request);
        fail();
    } catch (Throwable t) {
        // pass
    }
    try {
        StubInvocationUtil.unaryCall(invoker, method, request);
        fail();
    } catch (Throwable t) {
        // pass
    }
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConsumerModel createMockConsumerModel(ServiceDescriptor serviceDescriptor) {
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    return consumerModel;
}
```
</details>

---
#### Test Case ID #dubbo_Test_72_3
#### Test Case Name: `testUnaryCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `consumerModel`
<summary>Suggested Diff</summary>

```diff
@@
    URL url = Mockito.mock(URL.class);
-    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
-    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
-    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
+    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
+    ConsumerModel consumerModel = createMockConsumerModel(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testUnaryCall() throws Throwable {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> result);
    when(result.recreate()).thenReturn(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    CountDownLatch latch = new CountDownLatch(1);
    AtomicReference<Object> atomicReference = new AtomicReference<>();
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            atomicReference.set(data);
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StubInvocationUtil.unaryCall(invoker, method, request, responseObserver);
    latch.await(1, TimeUnit.SECONDS);
    Assertions.assertEquals(response, atomicReference.get());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConsumerModel createMockConsumerModel(ServiceDescriptor serviceDescriptor) {
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    return consumerModel;
}
```
</details>

---
#### Test Case ID #dubbo_Test_72_4
#### Test Case Name: `biOrClientStreamCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `consumerModel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
-    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
+    ConsumerModel consumerModel = createMockConsumerModel(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void biOrClientStreamCall() throws InterruptedException {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> {
        Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];
        StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[0];
        observer.onNext(response);
        observer.onCompleted();
        when(result.recreate()).then(invocationOnMock1 -> new StreamObserver<Object>() {

            @Override
            public void onNext(Object data) {
                observer.onNext(data);
            }

            @Override
            public void onError(Throwable throwable) {
            }

            @Override
            public void onCompleted() {
                observer.onCompleted();
            }
        });
        return result;
    });
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    CountDownLatch latch = new CountDownLatch(11);
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            latch.countDown();
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StreamObserver<Object> observer = StubInvocationUtil.biOrClientStreamCall(invoker, method, responseObserver);
    for (int i = 0; i < 10; i++) {
        observer.onNext(request);
    }
    observer.onCompleted();
    Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConsumerModel createMockConsumerModel(ServiceDescriptor serviceDescriptor) {
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    return consumerModel;
}
```
</details>

---
#### Test Case ID #dubbo_Test_72_5
#### Test Case Name: `serverStreamCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `consumerModel`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
-    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
+    ConsumerModel consumerModel = createMockConsumerModel(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void serverStreamCall() throws InterruptedException {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> {
        Invocation invocation = (Invocation) invocationOnMock.getArguments()[0];
        StreamObserver<Object> observer = (StreamObserver<Object>) invocation.getArguments()[1];
        for (int i = 0; i < 10; i++) {
            observer.onNext(response);
        }
        observer.onCompleted();
        return result;
    });
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    CountDownLatch latch = new CountDownLatch(11);
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            latch.countDown();
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StubInvocationUtil.serverStreamCall(invoker, method, request, responseObserver);
    Assertions.assertTrue(latch.await(1, TimeUnit.SECONDS));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ConsumerModel createMockConsumerModel(ServiceDescriptor serviceDescriptor) {
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    return consumerModel;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_73
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.Result`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
private static Result createMockResult(String recreateReturn) {
    Result result = Mockito.mock(Result.class);
    when(result.recreate()).thenReturn(recreateReturn);
    return result;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_73_1
#### Test Case Name: `unaryCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `result`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(invoker.getInterface()).thenReturn(IGreeter.class);
-    Result result = Mockito.mock(Result.class);
-    when(invoker.invoke(any(Invocation.class))).thenReturn(result);
    String response = "response";
+    Result result = createMockResult(response);
+    when(invoker.invoke(any(Invocation.class))).thenReturn(result);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    Object ret = StubInvocationUtil.unaryCall(invoker, method, request);
    Assertions.assertEquals(response, ret);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void unaryCall() throws Throwable {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    when(invoker.invoke(any(Invocation.class))).thenReturn(result);
    String response = "response";
    when(result.recreate()).thenReturn(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    Object ret = StubInvocationUtil.unaryCall(invoker, method, request);
    Assertions.assertEquals(response, ret);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Result createMockResult(String recreateReturn) {
    Result result = Mockito.mock(Result.class);
    when(result.recreate()).thenReturn(recreateReturn);
    return result;
}
```
</details>

---
#### Test Case ID #dubbo_Test_73_2
#### Test Case Name: `unaryCall2`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `result`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(invoker.getInterface()).thenReturn(IGreeter.class);
-    Result result = Mockito.mock(Result.class);
-    when(invoker.invoke(any(Invocation.class))).thenThrow(new RuntimeException("a")).thenThrow(new Error("b"));
    String response = "response";
-    when(result.recreate()).thenReturn(response);
+    Result result = createMockResult(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    try {
        StubInvocationUtil.unaryCall(invoker, method, request);
        fail();
    } catch (Throwable t) {
        // pass
    }
    try {
        StubInvocationUtil.unaryCall(invoker, method, request);
        fail();
    } catch (Throwable t) {
        // pass
    }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void unaryCall2() throws Throwable {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    when(invoker.invoke(any(Invocation.class))).thenThrow(new RuntimeException("a")).thenThrow(new Error("b"));
    String response = "response";
    when(result.recreate()).thenReturn(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    try {
        StubInvocationUtil.unaryCall(invoker, method, request);
        fail();
    } catch (Throwable t) {
        // pass
    }
    try {
        StubInvocationUtil.unaryCall(invoker, method, request);
        fail();
    } catch (Throwable t) {
        // pass
    }
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Result createMockResult(String recreateReturn) {
    Result result = Mockito.mock(Result.class);
    when(result.recreate()).thenReturn(recreateReturn);
    return result;
}
```
</details>

---
#### Test Case ID #dubbo_Test_73_3
#### Test Case Name: `testUnaryCall`(File: `C:\Java_projects\Apache\dubbo\dubbo-rpc\dubbo-rpc-triple\src\test\java\org\apache\dubbo\rpc\stub\StubInvocationUtilTest.java`)
#### Mock Object Variable Name: `result`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    when(invoker.getInterface()).thenReturn(IGreeter.class);
-    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> result);
-    when(result.recreate()).thenReturn(response);
+    Result result = createMockResult(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testUnaryCall() throws Throwable {
    Invoker<IGreeter> invoker = Mockito.mock(Invoker.class);
    URL url = Mockito.mock(URL.class);
    ConsumerModel consumerModel = Mockito.mock(ConsumerModel.class);
    ServiceDescriptor serviceDescriptor = Mockito.mock(ServiceDescriptor.class);
    when(consumerModel.getServiceModel()).thenReturn(serviceDescriptor);
    when(url.getServiceModel()).thenReturn(consumerModel);
    when(url.getServiceInterface()).thenReturn(IGreeter.class.getName());
    when(url.getProtocolServiceKey()).thenReturn(IGreeter.class.getName());
    when(invoker.getUrl()).thenReturn(url);
    when(invoker.getInterface()).thenReturn(IGreeter.class);
    Result result = Mockito.mock(Result.class);
    String response = "response";
    when(invoker.invoke(any(Invocation.class))).then(invocationOnMock -> result);
    when(result.recreate()).thenReturn(response);
    MethodDescriptor method = Mockito.mock(MethodDescriptor.class);
    when(method.getParameterClasses()).thenReturn(new Class[] { String.class });
    when(method.getMethodName()).thenReturn("sayHello");
    String request = "request";
    CountDownLatch latch = new CountDownLatch(1);
    AtomicReference<Object> atomicReference = new AtomicReference<>();
    StreamObserver<Object> responseObserver = new StreamObserver<Object>() {

        @Override
        public void onNext(Object data) {
            atomicReference.set(data);
        }

        @Override
        public void onError(Throwable throwable) {
        }

        @Override
        public void onCompleted() {
            latch.countDown();
        }
    };
    StubInvocationUtil.unaryCall(invoker, method, request, responseObserver);
    latch.await(1, TimeUnit.SECONDS);
    Assertions.assertEquals(response, atomicReference.get());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Result createMockResult(String recreateReturn) {
    Result result = Mockito.mock(Result.class);
    when(result.recreate()).thenReturn(recreateReturn);
    return result;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_74
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.config.spring.status.SpringStatusCheckerTest.ApplicationLifeCycle`
- **Test Case Count**: 2
- **MO Count**: 2

### Reusable Method
```java
private static ApplicationLifeCycle createMockApplicationLifeCycle(boolean isRunningReturn) {
    ApplicationLifeCycle applicationLifeCycle = mock(ApplicationLifeCycle.class);
    given(applicationLifeCycle.isRunning()).willReturn(isRunningReturn);
    return applicationLifeCycle;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_74_1
#### Test Case Name: `testWithLifeCycleRunning`(File: `C:\Java_projects\Apache\dubbo\dubbo-config\dubbo-config-spring\src\test\java\org\apache\dubbo\config\spring\status\SpringStatusCheckerTest.java`)
#### Mock Object Variable Name: `applicationLifeCycle`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
void testWithLifeCycleRunning() {
-    ApplicationLifeCycle applicationLifeCycle = mock(ApplicationLifeCycle.class);
-    given(applicationLifeCycle.getConfigLocations()).willReturn(new String[] { "test1", "test2" });
-    given(applicationLifeCycle.isRunning()).willReturn(true);
+    ApplicationLifeCycle applicationLifeCycle = createMockApplicationLifeCycle(true);
+    given(applicationLifeCycle.getConfigLocations()).willReturn(new String[] { "test1", "test2" });
    SpringStatusChecker springStatusChecker = new SpringStatusChecker(applicationLifeCycle);
    Status status = springStatusChecker.check();
    assertThat(status.getLevel(), is(Status.Level.OK));
    assertThat(status.getMessage(), is("test1,test2"));
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testWithLifeCycleRunning() {
    ApplicationLifeCycle applicationLifeCycle = mock(ApplicationLifeCycle.class);
    given(applicationLifeCycle.getConfigLocations()).willReturn(new String[] { "test1", "test2" });
    given(applicationLifeCycle.isRunning()).willReturn(true);
    SpringStatusChecker springStatusChecker = new SpringStatusChecker(applicationLifeCycle);
    Status status = springStatusChecker.check();
    assertThat(status.getLevel(), is(Status.Level.OK));
    assertThat(status.getMessage(), is("test1,test2"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ApplicationLifeCycle createMockApplicationLifeCycle(boolean isRunningReturn) {
    ApplicationLifeCycle applicationLifeCycle = mock(ApplicationLifeCycle.class);
    given(applicationLifeCycle.isRunning()).willReturn(isRunningReturn);
    return applicationLifeCycle;
}
```
</details>

---
#### Test Case ID #dubbo_Test_74_2
#### Test Case Name: `testWithoutLifeCycleRunning`(File: `C:\Java_projects\Apache\dubbo\dubbo-config\dubbo-config-spring\src\test\java\org\apache\dubbo\config\spring\status\SpringStatusCheckerTest.java`)
#### Mock Object Variable Name: `applicationLifeCycle`
<summary>Suggested Diff</summary>

```diff
@@
 void testWithoutLifeCycleRunning() {
-    ApplicationLifeCycle applicationLifeCycle = mock(ApplicationLifeCycle.class);
-    given(applicationLifeCycle.isRunning()).willReturn(false);
+    ApplicationLifeCycle applicationLifeCycle = createMockApplicationLifeCycle(false);
     SpringStatusChecker springStatusChecker = new SpringStatusChecker(applicationLifeCycle);
     Status status = springStatusChecker.check();
     assertThat(status.getLevel(), is(Status.Level.ERROR));
 }
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testWithoutLifeCycleRunning() {
    ApplicationLifeCycle applicationLifeCycle = mock(ApplicationLifeCycle.class);
    given(applicationLifeCycle.isRunning()).willReturn(false);
    SpringStatusChecker springStatusChecker = new SpringStatusChecker(applicationLifeCycle);
    Status status = springStatusChecker.check();
    assertThat(status.getLevel(), is(Status.Level.ERROR));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static ApplicationLifeCycle createMockApplicationLifeCycle(boolean isRunningReturn) {
    ApplicationLifeCycle applicationLifeCycle = mock(ApplicationLifeCycle.class);
    given(applicationLifeCycle.isRunning()).willReturn(isRunningReturn);
    return applicationLifeCycle;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_75
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.registry.RegistryFactory`
- **Test Case Count**: 5
- **MO Count**: 5

### Reusable Method
```java
private static RegistryFactory createMockRegistryFactory(URL url, Registry registry, RegistryProtocol registryProtocol) {
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    return registryFactory;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_75_1
#### Test Case Name: `testConsumerUrlWithoutProtocol`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `registryFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    url = url.setScopeModel(moduleModel);
-    RegistryFactory registryFactory = mock(RegistryFactory.class);
-    Registry registry = mock(Registry.class);
-    RegistryProtocol registryProtocol = new RegistryProtocol();
-    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
-    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
-    registryProtocolListeners.add(migrationRuleListener);
-    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
-    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
-    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
-    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
-    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
-    url = url.setScopeModel(moduleModel);
-    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
+    Registry registry = mock(Registry.class);
+    RegistryProtocol registryProtocol = new RegistryProtocol();
+    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
+    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
+    registryProtocolListeners.add(migrationRuleListener);
+    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
+    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
+    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
+    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
+    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
+    url = url.setScopeModel(moduleModel);
+    RegistryFactory registryFactory = createMockRegistryFactory(url, registry, registryProtocol);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify the generated consumer url information
 */
@Test
void testConsumerUrlWithoutProtocol() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    // verify that the protocol header of consumerUrl is set to "consumer"
    Assertions.assertEquals("consumer", consumerUrl.getProtocol());
    Assertions.assertEquals(parameters.get(REGISTER_IP_KEY), consumerUrl.getHost());
    Assertions.assertFalse(consumerUrl.getAttributes().containsKey(REFER_KEY));
    Assertions.assertEquals("value1", consumerUrl.getAttribute("key1"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static RegistryFactory createMockRegistryFactory(URL url, Registry registry, RegistryProtocol registryProtocol) {
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    return registryFactory;
}
```
</details>

---
#### Test Case ID #dubbo_Test_75_2
#### Test Case Name: `testConsumerUrlWithProtocol`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `registryFactory`
<summary>Suggested Diff</summary>

```diff
@@
    URL url = serviceConfigURL.addAttributes(attributes);
-    RegistryFactory registryFactory = mock(RegistryFactory.class);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
+    RegistryFactory registryFactory = createMockRegistryFactory(url, registry, registryProtocol);
-    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that when the protocol is configured, the protocol of consumer url is the configured protocol
 */
@Test
void testConsumerUrlWithProtocol() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    parameters.put(PROTOCOL_KEY, "tri");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader<RegistryProtocolListener> extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    // verify that the protocol of consumer url
    Assertions.assertEquals("tri", consumerUrl.getProtocol());
    Assertions.assertEquals(parameters.get(REGISTER_IP_KEY), consumerUrl.getHost());
    Assertions.assertFalse(consumerUrl.getAttributes().containsKey(REFER_KEY));
    Assertions.assertEquals("value1", consumerUrl.getAttribute("key1"));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static RegistryFactory createMockRegistryFactory(URL url, Registry registry, RegistryProtocol registryProtocol) {
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    return registryFactory;
}
```
</details>

---
#### Test Case ID #dubbo_Test_75_3
#### Test Case Name: `testReferWithoutGroup`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `registryFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    url = url.setScopeModel(moduleModel);
-    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
-    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
+    RegistryFactory registryFactory = createMockRegistryFactory(url, registry, registryProtocol);
    Invoker<?> invoker = registryProtocol.refer(DemoService.class, url);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    Assertions.assertTrue(((MigrationInvoker<?>) invoker).getCluster() instanceof ScopeClusterWrapper);
    Assertions.assertTrue(((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster() instanceof MockClusterWrapper);
    Assertions.assertTrue(((MockClusterWrapper) ((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster()).getCluster() instanceof FailoverCluster);
}
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that if multiple groups are not configured, the service reference of the registration center
 * the default is FailoverCluster
 *
 * @see FailoverCluster
 */
@Test
void testReferWithoutGroup() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Invoker<?> invoker = registryProtocol.refer(DemoService.class, url);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    Assertions.assertTrue(((MigrationInvoker<?>) invoker).getCluster() instanceof ScopeClusterWrapper);
    Assertions.assertTrue(((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster() instanceof MockClusterWrapper);
    Assertions.assertTrue(((MockClusterWrapper) ((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster()).getCluster() instanceof FailoverCluster);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static RegistryFactory createMockRegistryFactory(URL url, Registry registry, RegistryProtocol registryProtocol) {
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    return registryFactory;
}
```
</details>

---
#### Test Case ID #dubbo_Test_75_4
#### Test Case Name: `testReferWithGroup`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `registryFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    url = url.setScopeModel(moduleModel);
-    RegistryFactory registryFactory = mock(RegistryFactory.class);
-    Registry registry = mock(Registry.class);
+    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
+    RegistryFactory registryFactory = createMockRegistryFactory(url, registry, registryProtocol);
-    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Invoker<?> invoker = registryProtocol.refer(DemoService.class, url);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    Assertions.assertTrue(((MigrationInvoker<?>) invoker).getCluster() instanceof ScopeClusterWrapper);
    Assertions.assertTrue(((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster() instanceof MockClusterWrapper);
    Assertions.assertTrue(((MockClusterWrapper) ((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster()).getCluster() instanceof MergeableCluster);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify that if multiple groups are configured, the service reference of the registration center
 *
 * @see MergeableCluster
 */
@Test
void testReferWithGroup() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "false");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    refer.put(GROUP_KEY, "group1,group2");
    attributes.put(REFER_KEY, refer);
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    MigrationRuleListener migrationRuleListener = mock(MigrationRuleListener.class);
    List<RegistryProtocolListener> registryProtocolListeners = new ArrayList<>();
    registryProtocolListeners.add(migrationRuleListener);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryProtocolListener.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getActivateExtension(url, REGISTRY_PROTOCOL_LISTENER_KEY)).thenReturn(registryProtocolListeners);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Invoker<?> invoker = registryProtocol.refer(DemoService.class, url);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    Assertions.assertTrue(((MigrationInvoker<?>) invoker).getCluster() instanceof ScopeClusterWrapper);
    Assertions.assertTrue(((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster() instanceof MockClusterWrapper);
    Assertions.assertTrue(((MockClusterWrapper) ((ScopeClusterWrapper) ((MigrationInvoker<?>) invoker).getCluster()).getCluster()).getCluster() instanceof MergeableCluster);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static RegistryFactory createMockRegistryFactory(URL url, Registry registry, RegistryProtocol registryProtocol) {
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    return registryFactory;
}
```
</details>

---
#### Test Case ID #dubbo_Test_75_5
#### Test Case Name: `testRegisterConsumerUrl`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\integration\RegistryProtocolTest.java`)
#### Mock Object Variable Name: `registryFactory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    URL url = serviceConfigURL.addAttributes(attributes);
-    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    RegistryProtocol registryProtocol = new RegistryProtocol();
-    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
+    RegistryFactory registryFactory = createMockRegistryFactory(url, registry, registryProtocol);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * verify the registered consumer url
 */
@Test
void testRegisterConsumerUrl() {
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("application1");
    ConfigManager configManager = mock(ConfigManager.class);
    when(configManager.getApplicationOrElseThrow()).thenReturn(applicationConfig);
    CompositeConfiguration compositeConfiguration = mock(CompositeConfiguration.class);
    when(compositeConfiguration.convert(Boolean.class, ENABLE_CONFIGURATION_LISTEN, true)).thenReturn(true);
    Map<String, String> parameters = new HashMap<>();
    parameters.put(INTERFACE_KEY, DemoService.class.getName());
    parameters.put("registry", "zookeeper");
    parameters.put("register", "true");
    parameters.put(REGISTER_IP_KEY, "172.23.236.180");
    Map<String, Object> attributes = new HashMap<>();
    ServiceConfigURL serviceConfigURL = new ServiceConfigURL("registry", "127.0.0.1", 2181, "org.apache.dubbo.registry.RegistryService", parameters);
    Map<String, String> refer = new HashMap<>();
    attributes.put(REFER_KEY, refer);
    attributes.put("key1", "value1");
    URL url = serviceConfigURL.addAttributes(attributes);
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    Registry registry = mock(Registry.class);
    ModuleModel moduleModel = Mockito.spy(ApplicationModel.defaultModel().getDefaultModule());
    moduleModel.getApplicationModel().getApplicationConfigManager().setApplication(new ApplicationConfig("application1"));
    ExtensionLoader extensionLoaderMock = mock(ExtensionLoader.class);
    Mockito.when(moduleModel.getExtensionLoader(RegistryFactory.class)).thenReturn(extensionLoaderMock);
    Mockito.when(extensionLoaderMock.getAdaptiveExtension()).thenReturn(registryFactory);
    url = url.setScopeModel(moduleModel);
    RegistryProtocol registryProtocol = new RegistryProtocol();
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    Cluster cluster = mock(Cluster.class);
    Invoker<?> invoker = registryProtocol.doRefer(cluster, registry, DemoService.class, url, parameters);
    Assertions.assertTrue(invoker instanceof MigrationInvoker);
    URL consumerUrl = ((MigrationInvoker<?>) invoker).getConsumerUrl();
    Assertions.assertTrue((consumerUrl != null));
    Map<String, String> urlParameters = consumerUrl.getParameters();
    URL urlToRegistry = new ServiceConfigURL(urlParameters.get(PROTOCOL_KEY) == null ? CONSUMER : urlParameters.get(PROTOCOL_KEY), urlParameters.remove(REGISTER_IP_KEY), 0, consumerUrl.getPath(), urlParameters);
    URL registeredConsumerUrl = urlToRegistry.addParameters(CATEGORY_KEY, CONSUMERS_CATEGORY, CHECK_KEY, String.valueOf(false)).setScopeModel(moduleModel);
    verify(registry, times(1)).register(registeredConsumerUrl);
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static RegistryFactory createMockRegistryFactory(URL url, Registry registry, RegistryProtocol registryProtocol) {
    RegistryFactory registryFactory = mock(RegistryFactory.class);
    when(registryFactory.getRegistry(registryProtocol.getRegistryUrl(url))).thenReturn(registry);
    return registryFactory;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_76
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.cluster.Directory<org.apache.dubbo.rpc.cluster.support.FailbackClusterInvokerTest>`
- **Test Case Count**: 7
- **MO Count**: 7

### Reusable Method
```java
private static Directory<FailbackClusterInvokerTest> createMockDirectory(URL url) {
    Directory<FailbackClusterInvokerTest> dic = mock(Directory.class);
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
    return dic;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_76_1
#### Test Case Name: `testInvokeWithIllegalRetriesParam`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\FailbackClusterInvokerTest.java`)
#### Mock Object Variable Name: `dic`
<summary>Suggested Diff</summary>

```diff
@@
    URL url = URL.valueOf("test://test:11/test?retries=-1&failbacktasks=2");
-    Directory<FailbackClusterInvokerTest> dic = mock(Directory.class);
-    given(dic.getUrl()).willReturn(url);
-    given(dic.getConsumerUrl()).willReturn(url);
-    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
+    Directory<FailbackClusterInvokerTest> dic = createMockDirectory(url);
    FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<>(dic);
    invoker.invoke(invocation);
    Assertions.assertNull(RpcContext.getServiceContext().getInvoker());
    DubboAppender.clear();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testInvokeWithIllegalRetriesParam() {
    URL url = URL.valueOf("test://test:11/test?retries=-1&failbacktasks=2");
    Directory<FailbackClusterInvokerTest> dic = mock(Directory.class);
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
    FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<>(dic);
    invoker.invoke(invocation);
    Assertions.assertNull(RpcContext.getServiceContext().getInvoker());
    DubboAppender.clear();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Directory<FailbackClusterInvokerTest> createMockDirectory(URL url) {
    Directory<FailbackClusterInvokerTest> dic = mock(Directory.class);
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
    return dic;
}
```
</details>

---
#### Test Case ID #dubbo_Test_76_2
#### Test Case Name: `testInvokeWithIllegalFailbacktasksParam`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\FailbackClusterInvokerTest.java`)
#### Mock Object Variable Name: `dic`
<summary>Suggested Diff</summary>

```diff
@@
    URL url = URL.valueOf("test://test:11/test?retries=2&failbacktasks=-1");
-    Directory<FailbackClusterInvokerTest> dic = mock(Directory.class);
-    given(dic.getUrl()).willReturn(url);
-    given(dic.getConsumerUrl()).willReturn(url);
-    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
+    Directory<FailbackClusterInvokerTest> dic = createMockDirectory(url);
    FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<>(dic);
    invoker.invoke(invocation);
    Assertions.assertNull(RpcContext.getServiceContext().getInvoker());
    DubboAppender.clear();
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@Test
void testInvokeWithIllegalFailbacktasksParam() {
    URL url = URL.valueOf("test://test:11/test?retries=2&failbacktasks=-1");
    Directory<FailbackClusterInvokerTest> dic = mock(Directory.class);
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
    FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<>(dic);
    invoker.invoke(invocation);
    Assertions.assertNull(RpcContext.getServiceContext().getInvoker());
    DubboAppender.clear();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Directory<FailbackClusterInvokerTest> createMockDirectory(URL url) {
    Directory<FailbackClusterInvokerTest> dic = mock(Directory.class);
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
    return dic;
}
```
</details>

---
#### Test Case ID #dubbo_Test_76_3
#### Test Case Name: `testNoInvoke`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\FailbackClusterInvokerTest.java`)
#### Mock Object Variable Name: `dic`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 @Order(3)
 public void testNoInvoke() {
-    dic = mock(Directory.class);
-    given(dic.getUrl()).willReturn(url);
-    given(dic.getConsumerUrl()).willReturn(url);
-    given(dic.list(invocation)).willReturn(null);
-    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
+    dic = createMockDirectory(url);
+    given(dic.list(invocation)).willReturn(null);
     invocation.setMethodName("method1");
     invokers.add(invoker);
     resetInvokerToNoException();
     FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<>(dic);
     LogUtil.start();
     DubboAppender.clear();
     invoker.invoke(invocation);
     assertEquals(1, LogUtil.findMessage("Failback to invoke"));
     LogUtil.stop();
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
@Order(3)
public void testNoInvoke() {
    dic = mock(Directory.class);
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.list(invocation)).willReturn(null);
    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
    invocation.setMethodName("method1");
    invokers.add(invoker);
    resetInvokerToNoException();
    FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<>(dic);
    LogUtil.start();
    DubboAppender.clear();
    invoker.invoke(invocation);
    assertEquals(1, LogUtil.findMessage("Failback to invoke"));
    LogUtil.stop();
}
/**
 * @throws java.lang.Exception
 */
@BeforeEach
public void setUp() throws Exception {
    dic = mock(Directory.class);
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.list(invocation)).willReturn(invokers);
    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
    invocation.setMethodName("method1");
    invokers.add(invoker);
}
@AfterEach
public void tearDown() {
    dic = null;
    invocation = new RpcInvocation();
    invokers.clear();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Directory<FailbackClusterInvokerTest> createMockDirectory(URL url) {
    Directory<FailbackClusterInvokerTest> dic = mock(Directory.class);
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
    return dic;
}
```
</details>

---
#### Test Case ID #dubbo_Test_76_4
#### Test Case Name: `testInvokeRetryTimesWithZeroValue`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\FailbackClusterInvokerTest.java`)
#### Mock Object Variable Name: `dic`
<summary>Suggested Diff</summary>

```diff
@@
 @Test
 @Order(5)
 public void testInvokeRetryTimesWithZeroValue() throws InterruptedException, NoSuchFieldException, IllegalAccessException {
     int retries = 0;
     resetInvokerToException();
-    given(dic.getConsumerUrl()).willReturn(url.addParameter(RETRIES_KEY, retries));
+    dic = createMockDirectory(url);
+    given(dic.getConsumerUrl()).willReturn(url.addParameter(RETRIES_KEY, retries));
     FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<>(dic);
     LogUtil.start();
     DubboAppender.clear();
     invocation.setMethodName("testInvokeRetryTimesWithZeroValue");
     invoker.invoke(invocation);
     CountDownLatch countDown = new CountDownLatch(1);
     countDown.await(getRetryFailedPeriod() * (retries + 1), TimeUnit.SECONDS);
     LogUtil.stop();
     Assertions.assertEquals(0, LogUtil.findMessage(Level.INFO, "Attempt to retry to invoke method " + "testInvokeRetryTimesWithZeroValue"), "No retry messages allowed");
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
@Order(5)
public void testInvokeRetryTimesWithZeroValue() throws InterruptedException, NoSuchFieldException, IllegalAccessException {
    int retries = 0;
    resetInvokerToException();
    given(dic.getConsumerUrl()).willReturn(url.addParameter(RETRIES_KEY, retries));
    FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<>(dic);
    LogUtil.start();
    DubboAppender.clear();
    invocation.setMethodName("testInvokeRetryTimesWithZeroValue");
    invoker.invoke(invocation);
    CountDownLatch countDown = new CountDownLatch(1);
    countDown.await(getRetryFailedPeriod() * (retries + 1), TimeUnit.SECONDS);
    LogUtil.stop();
    Assertions.assertEquals(0, LogUtil.findMessage(Level.INFO, "Attempt to retry to invoke method " + "testInvokeRetryTimesWithZeroValue"), "No retry messages allowed");
}
/**
 * @throws java.lang.Exception
 */
@BeforeEach
public void setUp() throws Exception {
    dic = mock(Directory.class);
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.list(invocation)).willReturn(invokers);
    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
    invocation.setMethodName("method1");
    invokers.add(invoker);
}
@AfterEach
public void tearDown() {
    dic = null;
    invocation = new RpcInvocation();
    invokers.clear();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Directory<FailbackClusterInvokerTest> createMockDirectory(URL url) {
    Directory<FailbackClusterInvokerTest> dic = mock(Directory.class);
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
    return dic;
}
```
</details>

---
#### Test Case ID #dubbo_Test_76_5
#### Test Case Name: `testInvokeRetryTimesWithTwoValue`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\FailbackClusterInvokerTest.java`)
#### Mock Object Variable Name: `dic`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
 @BeforeEach
 public void setUp() throws Exception {
-    dic = mock(Directory.class);
-    given(dic.getUrl()).willReturn(url);
-    given(dic.getConsumerUrl()).willReturn(url);
-    given(dic.list(invocation)).willReturn(invokers);
-    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
+    dic = createMockDirectory(url);
     invocation.setMethodName("method1");
     invokers.add(invoker);
 }

 @Test
 @Order(6)
 public void testInvokeRetryTimesWithTwoValue() throws InterruptedException, NoSuchFieldException, IllegalAccessException {
     int retries = 2;
     resetInvokerToException();
-    given(dic.getConsumerUrl()).willReturn(url.addParameter(RETRIES_KEY, retries));
+    given(dic.getConsumerUrl()).willReturn(url.addParameter(RETRIES_KEY, retries));
     FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<>(dic);
     LogUtil.start();
     DubboAppender.clear();
     invocation.setMethodName("testInvokeRetryTimesWithTwoValue");
     invoker.invoke(invocation);
     CountDownLatch countDown = new CountDownLatch(1);
     countDown.await(getRetryFailedPeriod() * (retries + 1), TimeUnit.SECONDS);
     LogUtil.stop();
     Assertions.assertEquals(2, LogUtil.findMessage(Level.INFO, "Attempt to retry to invoke method " + "testInvokeRetryTimesWithTwoValue"), "Must have two error message ");
 }
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

/**
 * @throws java.lang.Exception
 */
@BeforeEach
public void setUp() throws Exception {
    dic = mock(Directory.class);
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.list(invocation)).willReturn(invokers);
    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
    invocation.setMethodName("method1");
    invokers.add(invoker);
}
@Test
@Order(6)
public void testInvokeRetryTimesWithTwoValue() throws InterruptedException, NoSuchFieldException, IllegalAccessException {
    int retries = 2;
    resetInvokerToException();
    given(dic.getConsumerUrl()).willReturn(url.addParameter(RETRIES_KEY, retries));
    FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<>(dic);
    LogUtil.start();
    DubboAppender.clear();
    invocation.setMethodName("testInvokeRetryTimesWithTwoValue");
    invoker.invoke(invocation);
    CountDownLatch countDown = new CountDownLatch(1);
    countDown.await(getRetryFailedPeriod() * (retries + 1), TimeUnit.SECONDS);
    LogUtil.stop();
    Assertions.assertEquals(2, LogUtil.findMessage(Level.INFO, "Attempt to retry to invoke method " + "testInvokeRetryTimesWithTwoValue"), "Must have two error message ");
}
@AfterEach
public void tearDown() {
    dic = null;
    invocation = new RpcInvocation();
    invokers.clear();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Directory<FailbackClusterInvokerTest> createMockDirectory(URL url) {
    Directory<FailbackClusterInvokerTest> dic = mock(Directory.class);
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
    return dic;
}
```
</details>

---
#### Test Case ID #dubbo_Test_76_6
#### Test Case Name: `testInvokeRetryTimesWithDefaultValue`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\FailbackClusterInvokerTest.java`)
#### Mock Object Variable Name: `dic`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    resetInvokerToException();
-    given(dic.getConsumerUrl()).willReturn(URL.valueOf("test://test:11/test"));
+    dic = createMockDirectory(URL.valueOf("test://test:11/test"));
    FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<>(dic);
    LogUtil.start();
    DubboAppender.clear();
    invocation.setMethodName("testInvokeRetryTimesWithDefaultValue");
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
@Order(7)
public void testInvokeRetryTimesWithDefaultValue() throws InterruptedException, NoSuchFieldException, IllegalAccessException {
    resetInvokerToException();
    given(dic.getConsumerUrl()).willReturn(URL.valueOf("test://test:11/test"));
    FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<>(dic);
    LogUtil.start();
    DubboAppender.clear();
    invocation.setMethodName("testInvokeRetryTimesWithDefaultValue");
    invoker.invoke(invocation);
    CountDownLatch countDown = new CountDownLatch(1);
    countDown.await(getRetryFailedPeriod() * (CommonConstants.DEFAULT_FAILBACK_TIMES + 1), TimeUnit.SECONDS);
    LogUtil.stop();
    Assertions.assertEquals(3, LogUtil.findMessage(Level.INFO, "Attempt to retry to invoke method " + "testInvokeRetryTimesWithDefaultValue"), "Must have three error message ");
}
/**
 * @throws java.lang.Exception
 */
@BeforeEach
public void setUp() throws Exception {
    dic = mock(Directory.class);
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.list(invocation)).willReturn(invokers);
    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
    invocation.setMethodName("method1");
    invokers.add(invoker);
}
@AfterEach
public void tearDown() {
    dic = null;
    invocation = new RpcInvocation();
    invokers.clear();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Directory<FailbackClusterInvokerTest> createMockDirectory(URL url) {
    Directory<FailbackClusterInvokerTest> dic = mock(Directory.class);
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
    return dic;
}
```
</details>

---
#### Test Case ID #dubbo_Test_76_7
#### Test Case Name: `testInvokeRetryTimesWithIllegalValue`(File: `C:\Java_projects\Apache\dubbo\dubbo-cluster\src\test\java\org\apache\dubbo\rpc\cluster\support\FailbackClusterInvokerTest.java`)
#### Mock Object Variable Name: `dic`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
public void setUp() throws Exception {
-    dic = mock(Directory.class);
-    given(dic.getUrl()).willReturn(url);
-    given(dic.getConsumerUrl()).willReturn(url);
-    given(dic.list(invocation)).willReturn(invokers);
-    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
+    dic = createMockDirectory(url);
+    given(dic.list(invocation)).willReturn(invokers);
    invocation.setMethodName("method1");
    invokers.add(invoker);
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java

@Test
@Order(8)
public void testInvokeRetryTimesWithIllegalValue() throws InterruptedException, NoSuchFieldException, IllegalAccessException {
    resetInvokerToException();
    given(dic.getConsumerUrl()).willReturn(url.addParameter(RETRIES_KEY, -100));
    FailbackClusterInvoker<FailbackClusterInvokerTest> invoker = new FailbackClusterInvoker<>(dic);
    LogUtil.start();
    DubboAppender.clear();
    invocation.setMethodName("testInvokeRetryTimesWithIllegalValue");
    invoker.invoke(invocation);
    CountDownLatch countDown = new CountDownLatch(1);
    countDown.await(getRetryFailedPeriod() * (CommonConstants.DEFAULT_FAILBACK_TIMES + 1), TimeUnit.SECONDS);
    LogUtil.stop();
    Assertions.assertEquals(3, LogUtil.findMessage(Level.INFO, "Attempt to retry to invoke method " + "testInvokeRetryTimesWithIllegalValue"), "Must have three error message ");
}
/**
 * @throws java.lang.Exception
 */
@BeforeEach
public void setUp() throws Exception {
    dic = mock(Directory.class);
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.list(invocation)).willReturn(invokers);
    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
    invocation.setMethodName("method1");
    invokers.add(invoker);
}
@AfterEach
public void tearDown() {
    dic = null;
    invocation = new RpcInvocation();
    invokers.clear();
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Directory<FailbackClusterInvokerTest> createMockDirectory(URL url) {
    Directory<FailbackClusterInvokerTest> dic = mock(Directory.class);
    given(dic.getUrl()).willReturn(url);
    given(dic.getConsumerUrl()).willReturn(url);
    given(dic.getInterface()).willReturn(FailbackClusterInvokerTest.class);
    return dic;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_77
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.rpc.cluster.Directory`
- **Test Case Count**: 1
- **MO Count**: 2

### Reusable Method
```java
private static Directory createMockDirectory(List<Invoker<?>> invokerList) {
    Directory directory = Mockito.mock(Directory.class);
    Mockito.when(directory.getAllInvokers()).thenReturn(invokerList);
    return directory;
}
```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_77_1
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\DefaultMigrationAddressComparatorTest.java`)
#### Mock Object Variable Name: `newDirectory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ClusterInvoker newInvoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker oldInvoker = Mockito.mock(ClusterInvoker.class);
-    Directory newDirectory = Mockito.mock(Directory.class);
    Directory oldDirectory = Mockito.mock(Directory.class);
    MigrationRule rule = Mockito.mock(MigrationRule.class);
    URL url = Mockito.mock(URL.class);
    Mockito.when(url.getDisplayServiceKey()).thenReturn("test");
    Mockito.when(newInvoker.getDirectory()).thenReturn(newDirectory);
    Mockito.when(oldInvoker.getDirectory()).thenReturn(oldDirectory);
    Mockito.when(newInvoker.getUrl()).thenReturn(url);
    Mockito.when(oldInvoker.getUrl()).thenReturn(url);
    Mockito.when(newInvoker.hasProxyInvokers()).thenReturn(false);
-    Mockito.when(newDirectory.getAllInvokers()).thenReturn(Collections.emptyList());
+    Directory newDirectory = createMockDirectory(Collections.emptyList());
    Assertions.assertFalse(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(-1, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
    Mockito.when(newInvoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(oldInvoker.hasProxyInvokers()).thenReturn(false);
    Mockito.when(oldDirectory.getAllInvokers()).thenReturn(Collections.emptyList());
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(-1, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
    Mockito.when(oldInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> newInvokerList = new LinkedList<>();
    newInvokerList.add(Mockito.mock(Invoker.class));
    newInvokerList.add(Mockito.mock(Invoker.class));
    newInvokerList.add(Mockito.mock(Invoker.class));
-    Mockito.when(newDirectory.getAllInvokers()).thenReturn(newInvokerList);
+    Mockito.when(newDirectory.getAllInvokers()).thenReturn(newInvokerList);
    List<Invoker<?>> oldInvokerList = new LinkedList<>();
    oldInvokerList.add(Mockito.mock(Invoker.class));
    oldInvokerList.add(Mockito.mock(Invoker.class));
    Mockito.when(oldDirectory.getAllInvokers()).thenReturn(oldInvokerList);
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, null));
    Mockito.when(rule.getThreshold(url)).thenReturn(0.5f);
    newInvokerList.clear();
    newInvokerList.add(Mockito.mock(Invoker.class));
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    newInvokerList.clear();
    // hasProxyInvokers will check if invokers list is empty
    // if hasProxyInvokers return true, comparator will directly because default threshold is 0.0
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, null));
    Assertions.assertFalse(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(2, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("all")
@Test
void test() {
    DefaultMigrationAddressComparator comparator = new DefaultMigrationAddressComparator();
    ClusterInvoker newInvoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker oldInvoker = Mockito.mock(ClusterInvoker.class);
    Directory newDirectory = Mockito.mock(Directory.class);
    Directory oldDirectory = Mockito.mock(Directory.class);
    MigrationRule rule = Mockito.mock(MigrationRule.class);
    URL url = Mockito.mock(URL.class);
    Mockito.when(url.getDisplayServiceKey()).thenReturn("test");
    Mockito.when(newInvoker.getDirectory()).thenReturn(newDirectory);
    Mockito.when(oldInvoker.getDirectory()).thenReturn(oldDirectory);
    Mockito.when(newInvoker.getUrl()).thenReturn(url);
    Mockito.when(oldInvoker.getUrl()).thenReturn(url);
    Mockito.when(newInvoker.hasProxyInvokers()).thenReturn(false);
    Mockito.when(newDirectory.getAllInvokers()).thenReturn(Collections.emptyList());
    Assertions.assertFalse(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(-1, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
    Mockito.when(newInvoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(oldInvoker.hasProxyInvokers()).thenReturn(false);
    Mockito.when(oldDirectory.getAllInvokers()).thenReturn(Collections.emptyList());
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(-1, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
    Mockito.when(oldInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> newInvokerList = new LinkedList<>();
    newInvokerList.add(Mockito.mock(Invoker.class));
    newInvokerList.add(Mockito.mock(Invoker.class));
    newInvokerList.add(Mockito.mock(Invoker.class));
    Mockito.when(newDirectory.getAllInvokers()).thenReturn(newInvokerList);
    List<Invoker<?>> oldInvokerList = new LinkedList<>();
    oldInvokerList.add(Mockito.mock(Invoker.class));
    oldInvokerList.add(Mockito.mock(Invoker.class));
    Mockito.when(oldDirectory.getAllInvokers()).thenReturn(oldInvokerList);
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, null));
    Mockito.when(rule.getThreshold(url)).thenReturn(0.5f);
    newInvokerList.clear();
    newInvokerList.add(Mockito.mock(Invoker.class));
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    newInvokerList.clear();
    // hasProxyInvokers will check if invokers list is empty
    // if hasProxyInvokers return true, comparator will directly because default threshold is 0.0
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, null));
    Assertions.assertFalse(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(2, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Directory createMockDirectory(List<Invoker<?>> invokerList) {
    Directory directory = Mockito.mock(Directory.class);
    Mockito.when(directory.getAllInvokers()).thenReturn(invokerList);
    return directory;
}
```
</details>

---
#### Test Case ID #dubbo_Test_77_2
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\DefaultMigrationAddressComparatorTest.java`)
#### Mock Object Variable Name: `oldDirectory`
<summary>Suggested Diff</summary>

```diff
--- original
+++ refactored
@@
    ClusterInvoker newInvoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker oldInvoker = Mockito.mock(ClusterInvoker.class);
    Directory newDirectory = Mockito.mock(Directory.class);
-    Directory oldDirectory = Mockito.mock(Directory.class);
+    Directory oldDirectory = createMockDirectory(Collections.emptyList());
    MigrationRule rule = Mockito.mock(MigrationRule.class);
    URL url = Mockito.mock(URL.class);
    Mockito.when(url.getDisplayServiceKey()).thenReturn("test");
    Mockito.when(newInvoker.getDirectory()).thenReturn(newDirectory);
    Mockito.when(oldInvoker.getDirectory()).thenReturn(oldDirectory);
    Mockito.when(newInvoker.getUrl()).thenReturn(url);
    Mockito.when(oldInvoker.getUrl()).thenReturn(url);
    Mockito.when(newInvoker.hasProxyInvokers()).thenReturn(false);
    Mockito.when(newDirectory.getAllInvokers()).thenReturn(Collections.emptyList());
    Assertions.assertFalse(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(-1, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
    Mockito.when(newInvoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(oldInvoker.hasProxyInvokers()).thenReturn(false);
-    Mockito.when(oldDirectory.getAllInvokers()).thenReturn(Collections.emptyList());
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(-1, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
    Mockito.when(oldInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> newInvokerList = new LinkedList<>();
    newInvokerList.add(Mockito.mock(Invoker.class));
    newInvokerList.add(Mockito.mock(Invoker.class));
    newInvokerList.add(Mockito.mock(Invoker.class));
    Mockito.when(newDirectory.getAllInvokers()).thenReturn(newInvokerList);
    List<Invoker<?>> oldInvokerList = new LinkedList<>();
    oldInvokerList.add(Mockito.mock(Invoker.class));
    oldInvokerList.add(Mockito.mock(Invoker.class));
-    Mockito.when(oldDirectory.getAllInvokers()).thenReturn(oldInvokerList);
+    Mockito.when(oldDirectory.getAllInvokers()).thenReturn(oldInvokerList);
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, null));
    Mockito.when(rule.getThreshold(url)).thenReturn(0.5f);
    newInvokerList.clear();
    newInvokerList.add(Mockito.mock(Invoker.class));
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    newInvokerList.clear();
    // hasProxyInvokers will check if invokers list is empty
    // if hasProxyInvokers return true, comparator will directly because default threshold is 0.0
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, null));
    Assertions.assertFalse(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(2, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
@@
```

<details><summary>Original Test Code (click to expand)</summary>

```java
@SuppressWarnings("all")
@Test
void test() {
    DefaultMigrationAddressComparator comparator = new DefaultMigrationAddressComparator();
    ClusterInvoker newInvoker = Mockito.mock(ClusterInvoker.class);
    ClusterInvoker oldInvoker = Mockito.mock(ClusterInvoker.class);
    Directory newDirectory = Mockito.mock(Directory.class);
    Directory oldDirectory = Mockito.mock(Directory.class);
    MigrationRule rule = Mockito.mock(MigrationRule.class);
    URL url = Mockito.mock(URL.class);
    Mockito.when(url.getDisplayServiceKey()).thenReturn("test");
    Mockito.when(newInvoker.getDirectory()).thenReturn(newDirectory);
    Mockito.when(oldInvoker.getDirectory()).thenReturn(oldDirectory);
    Mockito.when(newInvoker.getUrl()).thenReturn(url);
    Mockito.when(oldInvoker.getUrl()).thenReturn(url);
    Mockito.when(newInvoker.hasProxyInvokers()).thenReturn(false);
    Mockito.when(newDirectory.getAllInvokers()).thenReturn(Collections.emptyList());
    Assertions.assertFalse(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(-1, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
    Mockito.when(newInvoker.hasProxyInvokers()).thenReturn(true);
    Mockito.when(oldInvoker.hasProxyInvokers()).thenReturn(false);
    Mockito.when(oldDirectory.getAllInvokers()).thenReturn(Collections.emptyList());
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(-1, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
    Mockito.when(oldInvoker.hasProxyInvokers()).thenReturn(true);
    List<Invoker<?>> newInvokerList = new LinkedList<>();
    newInvokerList.add(Mockito.mock(Invoker.class));
    newInvokerList.add(Mockito.mock(Invoker.class));
    newInvokerList.add(Mockito.mock(Invoker.class));
    Mockito.when(newDirectory.getAllInvokers()).thenReturn(newInvokerList);
    List<Invoker<?>> oldInvokerList = new LinkedList<>();
    oldInvokerList.add(Mockito.mock(Invoker.class));
    oldInvokerList.add(Mockito.mock(Invoker.class));
    Mockito.when(oldDirectory.getAllInvokers()).thenReturn(oldInvokerList);
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, null));
    Mockito.when(rule.getThreshold(url)).thenReturn(0.5f);
    newInvokerList.clear();
    newInvokerList.add(Mockito.mock(Invoker.class));
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    newInvokerList.clear();
    // hasProxyInvokers will check if invokers list is empty
    // if hasProxyInvokers return true, comparator will directly because default threshold is 0.0
    Assertions.assertTrue(comparator.shouldMigrate(newInvoker, oldInvoker, null));
    Assertions.assertFalse(comparator.shouldMigrate(newInvoker, oldInvoker, rule));
    Assertions.assertEquals(0, comparator.getAddressSize("test").get(NEW_ADDRESS_SIZE));
    Assertions.assertEquals(2, comparator.getAddressSize("test").get(OLD_ADDRESS_SIZE));
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
private static Directory createMockDirectory(List<Invoker<?>> invokerList) {
    Directory directory = Mockito.mock(Directory.class);
    Mockito.when(directory.getAllInvokers()).thenReturn(invokerList);
    return directory;
}
```
</details>

---
## Mock Clone Instance #dubbo_MCI_78
- **Scope**: method level
- **Mocked Class**: `org.apache.dubbo.registry.client.migration.MigrationInvoker<?>`
- **Test Case Count**: 3
- **MO Count**: 3

### Reusable Method
```java
// === Declare in class scope ===
private MigrationInvoker<?> migrationInvoker;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    migrationInvoker = Mockito.mock(MigrationInvoker.class);
}

// === Replace local variable in test with ===
migrationInvoker;

```

### The refactoring details in each test cases
---
#### Test Case ID #dubbo_Test_78_1
#### Test Case Name: `test`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationRuleListenerTest.java`)
#### Mock Object Variable Name: `migrationInvoker`
<summary>Suggested Diff</summary>

```diff
@@
     MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule()) {
 
         @Override
         public synchronized void process(ConfigChangedEvent event) {
             try {
                 countDownLatch.await();
             } catch (InterruptedException e) {
                 throw new RuntimeException(e);
             }
             super.process(event);
         }
     };
-    MigrationInvoker<?> migrationInvoker = Mockito.mock(MigrationInvoker.class);
+    // removed local mock; replaced with global field `migrationInvoker`
     migrationRuleListener.getHandlers().put(migrationInvoker, handler);
     countDownLatch.countDown();
     await().untilAsserted(() -> {
         Mockito.verify(handler).doMigrate(Mockito.any());
     });
     //        Mockito.verify(handler, Mockito.timeout(5000)).doMigrate(Mockito.any());
     migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);
     Mockito.verify(handler, Mockito.times(2)).doMigrate(Mockito.any());
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Listener started with config center and local rule, no initial remote rule.
 * Check local rule take effect
 */
@Test
void test() {
    DynamicConfiguration dynamicConfiguration = Mockito.mock(DynamicConfiguration.class);
    ApplicationModel.reset();
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setDynamicConfiguration(dynamicConfiguration);
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setLocalMigrationRule(localRule);
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("demo-consumer");
    ApplicationModel.defaultModel().getApplicationConfigManager().setApplication(applicationConfig);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Test");
    Mockito.when(consumerURL.getParameter("timestamp")).thenReturn("1");
    System.setProperty("dubbo.application.migration.delay", "1");
    MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
    CountDownLatch countDownLatch = new CountDownLatch(1);
    MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule()) {

        @Override
        public synchronized void process(ConfigChangedEvent event) {
            try {
                countDownLatch.await();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            super.process(event);
        }
    };
    MigrationInvoker<?> migrationInvoker = Mockito.mock(MigrationInvoker.class);
    migrationRuleListener.getHandlers().put(migrationInvoker, handler);
    countDownLatch.countDown();
    await().untilAsserted(() -> {
        Mockito.verify(handler).doMigrate(Mockito.any());
    });
    //        Mockito.verify(handler, Mockito.timeout(5000)).doMigrate(Mockito.any());
    migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);
    Mockito.verify(handler, Mockito.times(2)).doMigrate(Mockito.any());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MigrationInvoker<?> migrationInvoker;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    migrationInvoker = Mockito.mock(MigrationInvoker.class);
}

// === Replace local variable in test with ===
migrationInvoker;

```
</details>

---
#### Test Case ID #dubbo_Test_78_2
#### Test Case Name: `testWithInitAndNoLocalRule`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationRuleListenerTest.java`)
#### Mock Object Variable Name: `migrationInvoker`
<summary>Suggested Diff</summary>

```diff
@@
     MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule());
-    MigrationInvoker<?> migrationInvoker = Mockito.mock(MigrationInvoker.class);
+    // removed local mock; replaced with global field `migrationInvoker`
     migrationRuleListener.getHandlers().put(migrationInvoker, handler);
     migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);
     // check migration happened after invoker referred
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Test listener started without local rule and config center, INIT should be used and no scheduled task should be started.
 */
@Test
void testWithInitAndNoLocalRule() {
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setDynamicConfiguration(null);
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setLocalMigrationRule("");
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("demo-consumer");
    ApplicationModel.defaultModel().getApplicationConfigManager().setApplication(applicationConfig);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Test");
    Mockito.when(consumerURL.getParameter("timestamp")).thenReturn("1");
    System.setProperty("dubbo.application.migration.delay", "1000");
    MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
    MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule());
    MigrationInvoker<?> migrationInvoker = Mockito.mock(MigrationInvoker.class);
    migrationRuleListener.getHandlers().put(migrationInvoker, handler);
    migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);
    // check migration happened after invoker referred
    Mockito.verify(handler, Mockito.times(1)).doMigrate(MigrationRule.getInitRule());
    // check no delay tasks created for there's no local rule and no config center
    Assertions.assertNull(migrationRuleListener.localRuleMigrationFuture);
    Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);
    Assertions.assertEquals(0, migrationRuleListener.ruleQueue.size());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MigrationInvoker<?> migrationInvoker;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    migrationInvoker = Mockito.mock(MigrationInvoker.class);
}

// === Replace local variable in test with ===
migrationInvoker;

```
</details>

---
#### Test Case ID #dubbo_Test_78_3
#### Test Case Name: `testWithConfigurationListenerAndLocalRule`(File: `C:\Java_projects\Apache\dubbo\dubbo-registry\dubbo-registry-api\src\test\java\org\apache\dubbo\registry\client\migration\MigrationRuleListenerTest.java`)
#### Mock Object Variable Name: `migrationInvoker`
<summary>Suggested Diff</summary>

```diff
@@
     Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);
-    MigrationInvoker<?> migrationInvoker = Mockito.mock(MigrationInvoker.class);
+    // removed local mock; replaced with global field `migrationInvoker`
     MigrationInvoker<?> migrationInvoker2 = Mockito.mock(MigrationInvoker.class);
     // Remote rule will be applied when onRefer gets executed
     migrationRuleListener.getHandlers().put(migrationInvoker, handler);
     migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);
     MigrationRule tmpRemoteRule = migrationRuleListener.getRule();
     ArgumentCaptor<MigrationRule> captor = ArgumentCaptor.forClass(MigrationRule.class);
     Mockito.verify(handler, Mockito.times(1)).doMigrate(captor.capture());
     Assertions.assertEquals(tmpRemoteRule, captor.getValue());
     await().until(() -> migrationRuleListener.localRuleMigrationFuture.isDone());
     Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);
     Assertions.assertEquals(tmpRemoteRule, migrationRuleListener.getRule());
     Mockito.verify(handler, Mockito.times(1)).doMigrate(Mockito.any());
     ArgumentCaptor<MigrationRule> captor2 = ArgumentCaptor.forClass(MigrationRule.class);
     migrationRuleListener.getHandlers().put(migrationInvoker2, handler2);
     migrationRuleListener.onRefer(null, migrationInvoker2, consumerURL2, null);
     Mockito.verify(handler2, Mockito.times(1)).doMigrate(captor2.capture());
     Assertions.assertEquals(tmpRemoteRule, captor2.getValue());
     migrationRuleListener.process(new ConfigChangedEvent("key", "group", dynamicRemoteRule));
     await().until(migrationRuleListener.ruleQueue::isEmpty);
     await().untilAsserted(() -> {
         Mockito.verify(handler, Mockito.times(2)).doMigrate(Mockito.any());
         Mockito.verify(handler2, Mockito.times(2)).doMigrate(Mockito.any());
     });
     Assertions.assertNotNull(migrationRuleListener.ruleMigrationFuture);
     ArgumentCaptor<MigrationRule> captor_event = ArgumentCaptor.forClass(MigrationRule.class);
     Mockito.verify(handler, Mockito.times(2)).doMigrate(captor_event.capture());
     Assertions.assertEquals("APPLICATION_FIRST", captor_event.getValue().getStep().toString());
     Mockito.verify(handler2, Mockito.times(2)).doMigrate(captor_event.capture());
     Assertions.assertEquals("APPLICATION_FIRST", captor_event.getValue().getStep().toString());
```

<details><summary>Original Test Code (click to expand)</summary>

```java
/**
 * Listener with config center initial remote rule and local rule, check
 * 1. initial remote rule other than local rule take effect
 * 2. remote rule change and all invokers gets notified
 */
@Test
void testWithConfigurationListenerAndLocalRule() {
    DynamicConfiguration dynamicConfiguration = Mockito.mock(DynamicConfiguration.class);
    Mockito.doReturn(remoteRule).when(dynamicConfiguration).getConfig(Mockito.anyString(), Mockito.anyString());
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setDynamicConfiguration(dynamicConfiguration);
    ApplicationModel.defaultModel().getDefaultModule().getModelEnvironment().setLocalMigrationRule(localRule);
    ApplicationConfig applicationConfig = new ApplicationConfig();
    applicationConfig.setName("demo-consumer");
    ApplicationModel.defaultModel().getApplicationConfigManager().setApplication(applicationConfig);
    URL consumerURL = Mockito.mock(URL.class);
    Mockito.when(consumerURL.getServiceKey()).thenReturn("Test");
    Mockito.when(consumerURL.getParameter("timestamp")).thenReturn("1");
    URL consumerURL2 = Mockito.mock(URL.class);
    Mockito.when(consumerURL2.getServiceKey()).thenReturn("Test2");
    Mockito.when(consumerURL2.getParameter("timestamp")).thenReturn("2");
    System.setProperty("dubbo.application.migration.delay", "10");
    MigrationRuleHandler<?> handler = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
    MigrationRuleHandler<?> handler2 = Mockito.mock(MigrationRuleHandler.class, Mockito.withSettings().verboseLogging());
    // Both local rule and remote rule are here
    // Local rule with one delayed task started to apply
    MigrationRuleListener migrationRuleListener = new MigrationRuleListener(ApplicationModel.defaultModel().getDefaultModule());
    Assertions.assertNotNull(migrationRuleListener.localRuleMigrationFuture);
    Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);
    MigrationInvoker<?> migrationInvoker = Mockito.mock(MigrationInvoker.class);
    MigrationInvoker<?> migrationInvoker2 = Mockito.mock(MigrationInvoker.class);
    // Remote rule will be applied when onRefer gets executed
    migrationRuleListener.getHandlers().put(migrationInvoker, handler);
    migrationRuleListener.onRefer(null, migrationInvoker, consumerURL, null);
    MigrationRule tmpRemoteRule = migrationRuleListener.getRule();
    ArgumentCaptor<MigrationRule> captor = ArgumentCaptor.forClass(MigrationRule.class);
    Mockito.verify(handler, Mockito.times(1)).doMigrate(captor.capture());
    Assertions.assertEquals(tmpRemoteRule, captor.getValue());
    await().until(() -> migrationRuleListener.localRuleMigrationFuture.isDone());
    Assertions.assertNull(migrationRuleListener.ruleMigrationFuture);
    Assertions.assertEquals(tmpRemoteRule, migrationRuleListener.getRule());
    Mockito.verify(handler, Mockito.times(1)).doMigrate(Mockito.any());
    ArgumentCaptor<MigrationRule> captor2 = ArgumentCaptor.forClass(MigrationRule.class);
    migrationRuleListener.getHandlers().put(migrationInvoker2, handler2);
    migrationRuleListener.onRefer(null, migrationInvoker2, consumerURL2, null);
    Mockito.verify(handler2, Mockito.times(1)).doMigrate(captor2.capture());
    Assertions.assertEquals(tmpRemoteRule, captor2.getValue());
    migrationRuleListener.process(new ConfigChangedEvent("key", "group", dynamicRemoteRule));
    await().until(migrationRuleListener.ruleQueue::isEmpty);
    await().untilAsserted(() -> {
        Mockito.verify(handler, Mockito.times(2)).doMigrate(Mockito.any());
        Mockito.verify(handler2, Mockito.times(2)).doMigrate(Mockito.any());
    });
    Assertions.assertNotNull(migrationRuleListener.ruleMigrationFuture);
    ArgumentCaptor<MigrationRule> captor_event = ArgumentCaptor.forClass(MigrationRule.class);
    Mockito.verify(handler, Mockito.times(2)).doMigrate(captor_event.capture());
    Assertions.assertEquals("APPLICATION_FIRST", captor_event.getValue().getStep().toString());
    Mockito.verify(handler2, Mockito.times(2)).doMigrate(captor_event.capture());
    Assertions.assertEquals("APPLICATION_FIRST", captor_event.getValue().getStep().toString());
}
```
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>

```java
// === Declare in class scope ===
private MigrationInvoker<?> migrationInvoker;

// === Add to @BeforeEach method ===
@BeforeEach
public void setUp() {
    migrationInvoker = Mockito.mock(MigrationInvoker.class);
}

// === Replace local variable in test with ===
migrationInvoker;

```
</details>

---