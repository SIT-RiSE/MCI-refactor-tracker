<!DOCTYPE html>
<html>
<head>
<title>spring-security-Ablation 2-guide.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="ablation-2-a-guide-to-refactoring-mock-clones-in-spring-security">Ablation 2: A guide to Refactoring mock clones in spring-security</h1>
<h2 id="mock-clone-instance-spring-securitymci77">Mock Clone Instance #spring-security_MCI_77</h2>
<ul>
<li><strong>Scope</strong>: method level</li>
<li><strong>Mocked Class</strong>: <code>org.springframework.security.authentication.AuthenticationEventPublisher</code></li>
<li><strong>Test Case Count</strong>: 6</li>
<li><strong>MO Count</strong>: 6</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> AuthenticationEventPublisher publisher;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    publisher = mock(AuthenticationEventPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest771">Test Case ID #spring-security_Test_77_1</h4>
<h4 id="test-case-name-authenticationsucceedswithsupportedtokenandreturnsexpectedobjectfile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationprovidermanagertestsjava">Test Case Name: <code>authenticationSucceedsWithSupportedTokenAndReturnsExpectedObject</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\ProviderManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-publisher">Mock Object Variable Name: <code>publisher</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 void authenticationSucceedsWithSupportedTokenAndReturnsExpectedObject() {
     Authentication a = mock(Authentication.class);
     ProviderManager mgr = new ProviderManager(createProviderWhichReturns(a));
<span class="hljs-deletion">-    AuthenticationEventPublisher publisher = mock(AuthenticationEventPublisher.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `publisher`</span>
     mgr.setAuthenticationEventPublisher(publisher);
     Authentication result = mgr.authenticate(a);
     assertThat(result).isEqualTo(a);
     verify(publisher).publishAuthenticationSuccess(result);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">authenticationSucceedsWithSupportedTokenAndReturnsExpectedObject</span><span class="hljs-params">()</span> </span>{

    Authentication a = mock(Authentication<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    ProviderManager mgr = <span class="hljs-keyword">new</span> ProviderManager(createProviderWhichReturns(a));

    AuthenticationEventPublisher publisher = mock(AuthenticationEventPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    mgr.setAuthenticationEventPublisher(publisher);

    Authentication result = mgr.authenticate(a);

    assertThat(result).isEqualTo(a);

    verify(publisher).publishAuthenticationSuccess(result);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> AuthenticationEventPublisher publisher;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    publisher = mock(AuthenticationEventPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest772">Test Case ID #spring-security_Test_77_2</h4>
<h4 id="test-case-name-authenticationsucceedswhenfirstproviderreturnsnullbutsecondauthenticatesfile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationprovidermanagertestsjava">Test Case Name: <code>authenticationSucceedsWhenFirstProviderReturnsNullButSecondAuthenticates</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\ProviderManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-publisher">Mock Object Variable Name: <code>publisher</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 void authenticationSucceedsWhenFirstProviderReturnsNullButSecondAuthenticates() {
     Authentication a = mock(Authentication.class);
     ProviderManager mgr = new ProviderManager(Arrays.asList(createProviderWhichReturns(null), createProviderWhichReturns(a)));
<span class="hljs-deletion">-    AuthenticationEventPublisher publisher = mock(AuthenticationEventPublisher.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `publisher`</span>
     mgr.setAuthenticationEventPublisher(publisher);
     Authentication result = mgr.authenticate(a);
     assertThat(result).isSameAs(a);
     verify(publisher).publishAuthenticationSuccess(result);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">authenticationSucceedsWhenFirstProviderReturnsNullButSecondAuthenticates</span><span class="hljs-params">()</span> </span>{

    Authentication a = mock(Authentication<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    ProviderManager mgr = <span class="hljs-keyword">new</span> ProviderManager(Arrays.asList(createProviderWhichReturns(<span class="hljs-keyword">null</span>), createProviderWhichReturns(a)));

    AuthenticationEventPublisher publisher = mock(AuthenticationEventPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    mgr.setAuthenticationEventPublisher(publisher);

    Authentication result = mgr.authenticate(a);

    assertThat(result).isSameAs(a);

    verify(publisher).publishAuthenticationSuccess(result);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> AuthenticationEventPublisher publisher;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    publisher = mock(AuthenticationEventPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest773">Test Case ID #spring-security_Test_77_3</h4>
<h4 id="test-case-name-providernotfoundfromparentisignoredfile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationprovidermanagertestsjava">Test Case Name: <code>providerNotFoundFromParentIsIgnored</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\ProviderManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-publisher">Mock Object Variable Name: <code>publisher</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 void providerNotFoundFromParentIsIgnored() {
     final Authentication authReq = mock(Authentication.class);
<span class="hljs-deletion">-    AuthenticationEventPublisher publisher = mock(AuthenticationEventPublisher.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `publisher`</span>
     AuthenticationManager parent = mock(AuthenticationManager.class);
     given(parent.authenticate(authReq)).willThrow(new ProviderNotFoundException(""));
     // Set a provider that throws an exception - this is the exception we expect to be
     // propagated
     ProviderManager mgr = new ProviderManager(List.of(createProviderWhichThrows(new BadCredentialsException(""))), parent);
     mgr.setAuthenticationEventPublisher(publisher);
     assertThatExceptionOfType(BadCredentialsException.class).isThrownBy(() -&gt; mgr.authenticate(authReq)).satisfies((ex) -&gt; verify(publisher).publishAuthenticationFailure(ex, authReq));
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">providerNotFoundFromParentIsIgnored</span><span class="hljs-params">()</span> </span>{

    <span class="hljs-keyword">final</span> Authentication authReq = mock(Authentication<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    AuthenticationEventPublisher publisher = mock(AuthenticationEventPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    AuthenticationManager parent = mock(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(parent.authenticate(authReq)).willThrow(<span class="hljs-keyword">new</span> ProviderNotFoundException(<span class="hljs-string">""</span>));

    <span class="hljs-comment">// Set a provider that throws an exception - this is the exception we expect to be</span>

    <span class="hljs-comment">// propagated</span>

    ProviderManager mgr = <span class="hljs-keyword">new</span> ProviderManager(List.of(createProviderWhichThrows(<span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">""</span>))), parent);

    mgr.setAuthenticationEventPublisher(publisher);

    assertThatExceptionOfType(BadCredentialsException<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">isThrownBy</span>(() -&gt; <span class="hljs-title">mgr</span>.<span class="hljs-title">authenticate</span>(<span class="hljs-title">authReq</span>)).<span class="hljs-title">satisfies</span>((<span class="hljs-title">ex</span>) -&gt; <span class="hljs-title">verify</span>(<span class="hljs-title">publisher</span>).<span class="hljs-title">publishAuthenticationFailure</span>(<span class="hljs-title">ex</span>, <span class="hljs-title">authReq</span>))</span>;

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> AuthenticationEventPublisher publisher;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    publisher = mock(AuthenticationEventPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest774">Test Case ID #spring-security_Test_77_4</h4>
<h4 id="test-case-name-authenticationexceptionfromparentoverridespreviousonesfile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationprovidermanagertestsjava">Test Case Name: <code>authenticationExceptionFromParentOverridesPreviousOnes</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\ProviderManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-publisher">Mock Object Variable Name: <code>publisher</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 void authenticationExceptionFromParentOverridesPreviousOnes() {
     AuthenticationManager parent = mock(AuthenticationManager.class);
     ProviderManager mgr = new ProviderManager(List.of(createProviderWhichThrows(new BadCredentialsException(""))), parent);
     Authentication authReq = mock(Authentication.class);
<span class="hljs-deletion">-    AuthenticationEventPublisher publisher = mock(AuthenticationEventPublisher.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `publisher`</span>
     mgr.setAuthenticationEventPublisher(publisher);
     // Set a provider that throws an exception - this is the exception we expect to be
     // propagated
     BadCredentialsException expected = new BadCredentialsException("I'm the one from the parent");
     given(parent.authenticate(authReq)).willThrow(expected);
     assertThatExceptionOfType(BadCredentialsException.class).isThrownBy(() -&gt; mgr.authenticate(authReq)).isSameAs(expected);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">authenticationExceptionFromParentOverridesPreviousOnes</span><span class="hljs-params">()</span> </span>{

    AuthenticationManager parent = mock(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    ProviderManager mgr = <span class="hljs-keyword">new</span> ProviderManager(List.of(createProviderWhichThrows(<span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">""</span>))), parent);

    Authentication authReq = mock(Authentication<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    AuthenticationEventPublisher publisher = mock(AuthenticationEventPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    mgr.setAuthenticationEventPublisher(publisher);

    <span class="hljs-comment">// Set a provider that throws an exception - this is the exception we expect to be</span>

    <span class="hljs-comment">// propagated</span>

    BadCredentialsException expected = <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"I'm the one from the parent"</span>);

    given(parent.authenticate(authReq)).willThrow(expected);

    assertThatExceptionOfType(BadCredentialsException<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">isThrownBy</span>(() -&gt; <span class="hljs-title">mgr</span>.<span class="hljs-title">authenticate</span>(<span class="hljs-title">authReq</span>)).<span class="hljs-title">isSameAs</span>(<span class="hljs-title">expected</span>)</span>;

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> AuthenticationEventPublisher publisher;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    publisher = mock(AuthenticationEventPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest775">Test Case ID #spring-security_Test_77_5</h4>
<h4 id="test-case-name-statusexceptionispublishedfile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationprovidermanagertestsjava">Test Case Name: <code>statusExceptionIsPublished</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\ProviderManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-publisher">Mock Object Variable Name: <code>publisher</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 void statusExceptionIsPublished() {
     AuthenticationManager parent = mock(AuthenticationManager.class);
     LockedException expected = new LockedException("");
     ProviderManager mgr = new ProviderManager(List.of(createProviderWhichThrows(expected)), parent);
     Authentication authReq = mock(Authentication.class);
<span class="hljs-deletion">-    AuthenticationEventPublisher publisher = mock(AuthenticationEventPublisher.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `publisher`</span>
     mgr.setAuthenticationEventPublisher(publisher);
     assertThatExceptionOfType(LockedException.class).isThrownBy(() -&gt; mgr.authenticate(authReq));
     verify(publisher).publishAuthenticationFailure(expected, authReq);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">statusExceptionIsPublished</span><span class="hljs-params">()</span> </span>{

    AuthenticationManager parent = mock(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    LockedException expected = <span class="hljs-keyword">new</span> LockedException(<span class="hljs-string">""</span>);

    ProviderManager mgr = <span class="hljs-keyword">new</span> ProviderManager(List.of(createProviderWhichThrows(expected)), parent);

    Authentication authReq = mock(Authentication<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    AuthenticationEventPublisher publisher = mock(AuthenticationEventPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    mgr.setAuthenticationEventPublisher(publisher);

    assertThatExceptionOfType(LockedException<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">isThrownBy</span>(() -&gt; <span class="hljs-title">mgr</span>.<span class="hljs-title">authenticate</span>(<span class="hljs-title">authReq</span>))</span>;

    verify(publisher).publishAuthenticationFailure(expected, authReq);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> AuthenticationEventPublisher publisher;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    publisher = mock(AuthenticationEventPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest776">Test Case ID #spring-security_Test_77_6</h4>
<h4 id="test-case-name-authenticatewhenfailsinparentandpublishesthenchilddoesnotpublishfile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationprovidermanagertestsjava">Test Case Name: <code>authenticateWhenFailsInParentAndPublishesThenChildDoesNotPublish</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\ProviderManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-publisher">Mock Object Variable Name: <code>publisher</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 // gh-6281
 @Test
 void authenticateWhenFailsInParentAndPublishesThenChildDoesNotPublish() {
     BadCredentialsException badCredentialsExParent = new BadCredentialsException("Bad Credentials in parent");
     ProviderManager parentMgr = new ProviderManager(createProviderWhichThrows(badCredentialsExParent));
     ProviderManager childMgr = new ProviderManager(List.of(createProviderWhichThrows(new BadCredentialsException("Bad Credentials in child"))), parentMgr);
<span class="hljs-deletion">-    AuthenticationEventPublisher publisher = mock(AuthenticationEventPublisher.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `publisher`</span>
     parentMgr.setAuthenticationEventPublisher(publisher);
     childMgr.setAuthenticationEventPublisher(publisher);
     Authentication authReq = mock(Authentication.class);
     assertThatExceptionOfType(BadCredentialsException.class).isThrownBy(() -&gt; childMgr.authenticate(authReq)).isSameAs(badCredentialsExParent);
     // Parent
     verify(publisher).publishAuthenticationFailure(badCredentialsExParent, authReq);
     // publishes
     // Child should not publish (duplicate event)
     verifyNoMoreInteractions(publisher);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-comment">// gh-6281</span>

<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenFailsInParentAndPublishesThenChildDoesNotPublish</span><span class="hljs-params">()</span> </span>{

    BadCredentialsException badCredentialsExParent = <span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"Bad Credentials in parent"</span>);

    ProviderManager parentMgr = <span class="hljs-keyword">new</span> ProviderManager(createProviderWhichThrows(badCredentialsExParent));

    ProviderManager childMgr = <span class="hljs-keyword">new</span> ProviderManager(List.of(createProviderWhichThrows(<span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">"Bad Credentials in child"</span>))), parentMgr);

    AuthenticationEventPublisher publisher = mock(AuthenticationEventPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    parentMgr.setAuthenticationEventPublisher(publisher);

    childMgr.setAuthenticationEventPublisher(publisher);

    Authentication authReq = mock(Authentication<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    assertThatExceptionOfType(BadCredentialsException<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">isThrownBy</span>(() -&gt; <span class="hljs-title">childMgr</span>.<span class="hljs-title">authenticate</span>(<span class="hljs-title">authReq</span>)).<span class="hljs-title">isSameAs</span>(<span class="hljs-title">badCredentialsExParent</span>)</span>;

    <span class="hljs-comment">// Parent</span>

    verify(publisher).publishAuthenticationFailure(badCredentialsExParent, authReq);

    <span class="hljs-comment">// publishes</span>

    <span class="hljs-comment">// Child should not publish (duplicate event)</span>

    verifyNoMoreInteractions(publisher);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> AuthenticationEventPublisher publisher;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    publisher = mock(AuthenticationEventPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci78">Mock Clone Instance #spring-security_MCI_78</h2>
<ul>
<li><strong>Scope</strong>: method level</li>
<li><strong>Mocked Class</strong>: <code>org.springframework.security.oauth2.core.oidc.user.OidcUser</code></li>
<li><strong>Test Case Count</strong>: 3</li>
<li><strong>MO Count</strong>: 3</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> OidcUser <span class="hljs-title">createMockOidcUser</span><span class="hljs-params">(List&lt;GrantedAuthority&gt; authorities)</span> </span>{
    OidcUser principal = mock(OidcUser<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(principal.getAuthorities()).willAnswer((Answer&lt;List&lt;GrantedAuthority&gt;&gt;) (invocation) -&gt; authorities);
    <span class="hljs-keyword">return</span> principal;
}
</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest781">Test Case ID #spring-security_Test_78_1</h4>
<h4 id="test-case-name-authenticatewhenloginsuccessthenreturnauthenticationfile-cjavaprojectsspringspring-securityoauth2oauth2-clientsrctestjavaorgspringframeworksecurityoauth2clientoidcauthenticationoidcauthorizationcodeauthenticationprovidertestsjava">Test Case Name: <code>authenticateWhenLoginSuccessThenReturnAuthentication</code>(File: <code>C:\Java_projects\Spring\spring-security\oauth2\oauth2-client\src\test\java\org\springframework\security\oauth2\client\oidc\authentication\OidcAuthorizationCodeAuthenticationProviderTests.java</code>)</h4>
<h4 id="mock-object-variable-name-principal">Mock Object Variable Name: <code>principal</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
     this.setUpIdToken(claims);
<span class="hljs-deletion">-    OidcUser principal = mock(OidcUser.class);</span>
     List&lt;GrantedAuthority&gt; authorities = AuthorityUtils.createAuthorityList("ROLE_USER");
<span class="hljs-deletion">-    given(principal.getAuthorities()).willAnswer((Answer&lt;List&lt;GrantedAuthority&gt;&gt;) (invocation) -&gt; authorities);</span>
<span class="hljs-addition">+    OidcUser principal = createMockOidcUser(authorities);</span>
     given(this.userService.loadUser(any())).willReturn(principal);
     OAuth2LoginAuthenticationToken authentication = (OAuth2LoginAuthenticationToken) this.authenticationProvider.authenticate(new OAuth2LoginAuthenticationToken(this.clientRegistration, this.authorizationExchange));
     assertThat(authentication.isAuthenticated()).isTrue();
     assertThat(authentication.getPrincipal()).isEqualTo(principal);
     assertThat(authentication.getCredentials()).isEqualTo("");
     assertThat(authentication.getAuthorities()).isEqualTo(authorities);
     assertThat(authentication.getClientRegistration()).isEqualTo(this.clientRegistration);
     assertThat(authentication.getAuthorizationExchange()).isEqualTo(this.authorizationExchange);
     assertThat(authentication.getAccessToken()).isEqualTo(this.accessTokenResponse.getAccessToken());
     assertThat(authentication.getRefreshToken()).isEqualTo(this.accessTokenResponse.getRefreshToken());
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenLoginSuccessThenReturnAuthentication</span><span class="hljs-params">()</span> </span>{

    Map&lt;String, Object&gt; claims = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

    claims.put(IdTokenClaimNames.ISS, <span class="hljs-string">"https://provider.com"</span>);

    claims.put(IdTokenClaimNames.SUB, <span class="hljs-string">"subject1"</span>);

    claims.put(IdTokenClaimNames.AUD, Arrays.asList(<span class="hljs-string">"client1"</span>, <span class="hljs-string">"client2"</span>));

    claims.put(IdTokenClaimNames.AZP, <span class="hljs-string">"client1"</span>);

    claims.put(IdTokenClaimNames.NONCE, <span class="hljs-keyword">this</span>.nonceHash);

    <span class="hljs-keyword">this</span>.setUpIdToken(claims);

    OidcUser principal = mock(OidcUser<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    List&lt;GrantedAuthority&gt; authorities = AuthorityUtils.createAuthorityList(<span class="hljs-string">"ROLE_USER"</span>);

    given(principal.getAuthorities()).willAnswer((Answer&lt;List&lt;GrantedAuthority&gt;&gt;) (invocation) -&gt; authorities);

    given(<span class="hljs-keyword">this</span>.userService.loadUser(any())).willReturn(principal);

    OAuth2LoginAuthenticationToken authentication = (OAuth2LoginAuthenticationToken) <span class="hljs-keyword">this</span>.authenticationProvider.authenticate(<span class="hljs-keyword">new</span> OAuth2LoginAuthenticationToken(<span class="hljs-keyword">this</span>.clientRegistration, <span class="hljs-keyword">this</span>.authorizationExchange));

    assertThat(authentication.isAuthenticated()).isTrue();

    assertThat(authentication.getPrincipal()).isEqualTo(principal);

    assertThat(authentication.getCredentials()).isEqualTo(<span class="hljs-string">""</span>);

    assertThat(authentication.getAuthorities()).isEqualTo(authorities);

    assertThat(authentication.getClientRegistration()).isEqualTo(<span class="hljs-keyword">this</span>.clientRegistration);

    assertThat(authentication.getAuthorizationExchange()).isEqualTo(<span class="hljs-keyword">this</span>.authorizationExchange);

    assertThat(authentication.getAccessToken()).isEqualTo(<span class="hljs-keyword">this</span>.accessTokenResponse.getAccessToken());

    assertThat(authentication.getRefreshToken()).isEqualTo(<span class="hljs-keyword">this</span>.accessTokenResponse.getRefreshToken());

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> OidcUser <span class="hljs-title">createMockOidcUser</span><span class="hljs-params">(List&lt;GrantedAuthority&gt; authorities)</span> </span>{
    OidcUser principal = mock(OidcUser<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(principal.getAuthorities()).willAnswer((Answer&lt;List&lt;GrantedAuthority&gt;&gt;) (invocation) -&gt; authorities);
    <span class="hljs-keyword">return</span> principal;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest782">Test Case ID #spring-security_Test_78_2</h4>
<h4 id="test-case-name-authenticatewhenauthoritiesmappersetthenreturnmappedauthoritiesfile-cjavaprojectsspringspring-securityoauth2oauth2-clientsrctestjavaorgspringframeworksecurityoauth2clientoidcauthenticationoidcauthorizationcodeauthenticationprovidertestsjava">Test Case Name: <code>authenticateWhenAuthoritiesMapperSetThenReturnMappedAuthorities</code>(File: <code>C:\Java_projects\Spring\spring-security\oauth2\oauth2-client\src\test\java\org\springframework\security\oauth2\client\oidc\authentication\OidcAuthorizationCodeAuthenticationProviderTests.java</code>)</h4>
<h4 id="mock-object-variable-name-principal">Mock Object Variable Name: <code>principal</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
     this.setUpIdToken(claims);
<span class="hljs-deletion">-    OidcUser principal = mock(OidcUser.class);</span>
     List&lt;GrantedAuthority&gt; authorities = AuthorityUtils.createAuthorityList("ROLE_USER");
<span class="hljs-deletion">-    given(principal.getAuthorities()).willAnswer((Answer&lt;List&lt;GrantedAuthority&gt;&gt;) (invocation) -&gt; authorities);</span>
<span class="hljs-addition">+    OidcUser principal = createMockOidcUser(authorities);</span>
     given(this.userService.loadUser(any())).willReturn(principal);
     List&lt;GrantedAuthority&gt; mappedAuthorities = AuthorityUtils.createAuthorityList("ROLE_OIDC_USER");
     GrantedAuthoritiesMapper authoritiesMapper = mock(GrantedAuthoritiesMapper.class);
     given(authoritiesMapper.mapAuthorities(anyCollection())).willAnswer((Answer&lt;List&lt;GrantedAuthority&gt;&gt;) (invocation) -&gt; mappedAuthorities);
     this.authenticationProvider.setAuthoritiesMapper(authoritiesMapper);
     OAuth2LoginAuthenticationToken authentication = (OAuth2LoginAuthenticationToken) this.authenticationProvider.authenticate(new OAuth2LoginAuthenticationToken(this.clientRegistration, this.authorizationExchange));
     assertThat(authentication.getAuthorities()).isEqualTo(mappedAuthorities);
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenAuthoritiesMapperSetThenReturnMappedAuthorities</span><span class="hljs-params">()</span> </span>{

    Map&lt;String, Object&gt; claims = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

    claims.put(IdTokenClaimNames.ISS, <span class="hljs-string">"https://provider.com"</span>);

    claims.put(IdTokenClaimNames.SUB, <span class="hljs-string">"subject1"</span>);

    claims.put(IdTokenClaimNames.AUD, Arrays.asList(<span class="hljs-string">"client1"</span>, <span class="hljs-string">"client2"</span>));

    claims.put(IdTokenClaimNames.AZP, <span class="hljs-string">"client1"</span>);

    claims.put(IdTokenClaimNames.NONCE, <span class="hljs-keyword">this</span>.nonceHash);

    <span class="hljs-keyword">this</span>.setUpIdToken(claims);

    OidcUser principal = mock(OidcUser<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    List&lt;GrantedAuthority&gt; authorities = AuthorityUtils.createAuthorityList(<span class="hljs-string">"ROLE_USER"</span>);

    given(principal.getAuthorities()).willAnswer((Answer&lt;List&lt;GrantedAuthority&gt;&gt;) (invocation) -&gt; authorities);

    given(<span class="hljs-keyword">this</span>.userService.loadUser(any())).willReturn(principal);

    List&lt;GrantedAuthority&gt; mappedAuthorities = AuthorityUtils.createAuthorityList(<span class="hljs-string">"ROLE_OIDC_USER"</span>);

    GrantedAuthoritiesMapper authoritiesMapper = mock(GrantedAuthoritiesMapper<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(authoritiesMapper.mapAuthorities(anyCollection())).willAnswer((Answer&lt;List&lt;GrantedAuthority&gt;&gt;) (invocation) -&gt; mappedAuthorities);

    <span class="hljs-keyword">this</span>.authenticationProvider.setAuthoritiesMapper(authoritiesMapper);

    OAuth2LoginAuthenticationToken authentication = (OAuth2LoginAuthenticationToken) <span class="hljs-keyword">this</span>.authenticationProvider.authenticate(<span class="hljs-keyword">new</span> OAuth2LoginAuthenticationToken(<span class="hljs-keyword">this</span>.clientRegistration, <span class="hljs-keyword">this</span>.authorizationExchange));

    assertThat(authentication.getAuthorities()).isEqualTo(mappedAuthorities);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> OidcUser <span class="hljs-title">createMockOidcUser</span><span class="hljs-params">(List&lt;GrantedAuthority&gt; authorities)</span> </span>{
    OidcUser principal = mock(OidcUser<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(principal.getAuthorities()).willAnswer((Answer&lt;List&lt;GrantedAuthority&gt;&gt;) (invocation) -&gt; authorities);
    <span class="hljs-keyword">return</span> principal;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest783">Test Case ID #spring-security_Test_78_3</h4>
<h4 id="test-case-name-authenticatewhentokensuccessresponsethenadditionalparametersaddedtouserrequestfile-cjavaprojectsspringspring-securityoauth2oauth2-clientsrctestjavaorgspringframeworksecurityoauth2clientoidcauthenticationoidcauthorizationcodeauthenticationprovidertestsjava">Test Case Name: <code>authenticateWhenTokenSuccessResponseThenAdditionalParametersAddedToUserRequest</code>(File: <code>C:\Java_projects\Spring\spring-security\oauth2\oauth2-client\src\test\java\org\springframework\security\oauth2\client\oidc\authentication\OidcAuthorizationCodeAuthenticationProviderTests.java</code>)</h4>
<h4 id="mock-object-variable-name-principal">Mock Object Variable Name: <code>principal</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
     this.setUpIdToken(claims);
<span class="hljs-deletion">-    OidcUser principal = mock(OidcUser.class);</span>
     List&lt;GrantedAuthority&gt; authorities = AuthorityUtils.createAuthorityList("ROLE_USER");
<span class="hljs-deletion">-    given(principal.getAuthorities()).willAnswer((Answer&lt;List&lt;GrantedAuthority&gt;&gt;) (invocation) -&gt; authorities);</span>
<span class="hljs-addition">+    OidcUser principal = createMockOidcUser(authorities);</span>
     ArgumentCaptor&lt;OidcUserRequest&gt; userRequestArgCaptor = ArgumentCaptor.forClass(OidcUserRequest.class);
     given(this.userService.loadUser(userRequestArgCaptor.capture())).willReturn(principal);
     this.authenticationProvider.authenticate(new OAuth2LoginAuthenticationToken(this.clientRegistration, this.authorizationExchange));
     assertThat(userRequestArgCaptor.getValue().getAdditionalParameters()).containsAllEntriesOf(this.accessTokenResponse.getAdditionalParameters());
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-comment">// gh-5368</span>

<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenTokenSuccessResponseThenAdditionalParametersAddedToUserRequest</span><span class="hljs-params">()</span> </span>{

    Map&lt;String, Object&gt; claims = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

    claims.put(IdTokenClaimNames.ISS, <span class="hljs-string">"https://provider.com"</span>);

    claims.put(IdTokenClaimNames.SUB, <span class="hljs-string">"subject1"</span>);

    claims.put(IdTokenClaimNames.AUD, Arrays.asList(<span class="hljs-string">"client1"</span>, <span class="hljs-string">"client2"</span>));

    claims.put(IdTokenClaimNames.AZP, <span class="hljs-string">"client1"</span>);

    claims.put(IdTokenClaimNames.NONCE, <span class="hljs-keyword">this</span>.nonceHash);

    <span class="hljs-keyword">this</span>.setUpIdToken(claims);

    OidcUser principal = mock(OidcUser<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    List&lt;GrantedAuthority&gt; authorities = AuthorityUtils.createAuthorityList(<span class="hljs-string">"ROLE_USER"</span>);

    given(principal.getAuthorities()).willAnswer((Answer&lt;List&lt;GrantedAuthority&gt;&gt;) (invocation) -&gt; authorities);

    ArgumentCaptor&lt;OidcUserRequest&gt; userRequestArgCaptor = ArgumentCaptor.forClass(OidcUserRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(<span class="hljs-keyword">this</span>.userService.loadUser(userRequestArgCaptor.capture())).willReturn(principal);

    <span class="hljs-keyword">this</span>.authenticationProvider.authenticate(<span class="hljs-keyword">new</span> OAuth2LoginAuthenticationToken(<span class="hljs-keyword">this</span>.clientRegistration, <span class="hljs-keyword">this</span>.authorizationExchange));

    assertThat(userRequestArgCaptor.getValue().getAdditionalParameters()).containsAllEntriesOf(<span class="hljs-keyword">this</span>.accessTokenResponse.getAdditionalParameters());

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> OidcUser <span class="hljs-title">createMockOidcUser</span><span class="hljs-params">(List&lt;GrantedAuthority&gt; authorities)</span> </span>{
    OidcUser principal = mock(OidcUser<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(principal.getAuthorities()).willAnswer((Answer&lt;List&lt;GrantedAuthority&gt;&gt;) (invocation) -&gt; authorities);
    <span class="hljs-keyword">return</span> principal;
}
</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci79">Mock Clone Instance #spring-security_MCI_79</h2>
<ul>
<li><strong>Scope</strong>: method level</li>
<li><strong>Mocked Class</strong>: <code>org.springframework.core.convert.converter.Converter&lt;java.lang.Object, java.lang.String&gt;</code></li>
<li><strong>Test Case Count</strong>: 2</li>
<li><strong>MO Count</strong>: 2</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Converter&lt;Object, String&gt; <span class="hljs-title">createClaimConverter</span><span class="hljs-params">(String convertReturnValue)</span> </span>{
    Converter&lt;Object, String&gt; claimConverter = mock(Converter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(claimConverter.convert(any(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>(<span class="hljs-title">convertReturnValue</span>)</span>;
    <span class="hljs-keyword">return</span> claimConverter;
}
</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest791">Test Case ID #spring-security_Test_79_1</h4>
<h4 id="test-case-name-convertwhenusingcustomconverterthenallotherdefaultsarestillusedfile-cjavaprojectsspringspring-securityoauth2oauth2-josesrctestjavaorgspringframeworksecurityoauth2jwtmappedjwtclaimsetconvertertestsjava">Test Case Name: <code>convertWhenUsingCustomConverterThenAllOtherDefaultsAreStillUsed</code>(File: <code>C:\Java_projects\Spring\spring-security\oauth2\oauth2-jose\src\test\java\org\springframework\security\oauth2\jwt\MappedJwtClaimSetConverterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-claimconverter">Mock Object Variable Name: <code>claimConverter</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void convertWhenUsingCustomConverterThenAllOtherDefaultsAreStillUsed() {
<span class="hljs-deletion">-    Converter&lt;Object, String&gt; claimConverter = mock(Converter.class);</span>
<span class="hljs-addition">+    Converter&lt;Object, String&gt; claimConverter = createClaimConverter("1234");</span>
     MappedJwtClaimSetConverter converter = MappedJwtClaimSetConverter.withDefaults(Collections.singletonMap(JwtClaimNames.SUB, claimConverter));
<span class="hljs-deletion">-    given(claimConverter.convert(any(Object.class))).willReturn("1234");</span>
     Map&lt;String, Object&gt; source = new HashMap&lt;&gt;();
     source.put(JwtClaimNames.JTI, 1);
     source.put(JwtClaimNames.AUD, "audience");
     source.put(JwtClaimNames.EXP, Instant.ofEpochSecond(2000000000L));
     source.put(JwtClaimNames.IAT, new Date(1000000000000L));
     source.put(JwtClaimNames.ISS, URI.create("https://any.url"));
     source.put(JwtClaimNames.NBF, "1000000000");
     source.put(JwtClaimNames.SUB, 2345);
     Map&lt;String, Object&gt; target = converter.convert(source);
     assertThat(target).containsEntry(JwtClaimNames.JTI, "1");
     assertThat(target).containsEntry(JwtClaimNames.AUD, Arrays.asList("audience"));
     assertThat(target).containsEntry(JwtClaimNames.EXP, Instant.ofEpochSecond(2000000000L));
     assertThat(target).containsEntry(JwtClaimNames.IAT, Instant.ofEpochSecond(1000000000L));
     assertThat(target).containsEntry(JwtClaimNames.ISS, "https://any.url");
     assertThat(target).containsEntry(JwtClaimNames.NBF, Instant.ofEpochSecond(1000000000L));
     assertThat(target).containsEntry(JwtClaimNames.SUB, "1234");
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">convertWhenUsingCustomConverterThenAllOtherDefaultsAreStillUsed</span><span class="hljs-params">()</span> </span>{

    Converter&lt;Object, String&gt; claimConverter = mock(Converter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    MappedJwtClaimSetConverter converter = MappedJwtClaimSetConverter.withDefaults(Collections.singletonMap(JwtClaimNames.SUB, claimConverter));

    given(claimConverter.convert(any(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>("1234")</span>;

    Map&lt;String, Object&gt; source = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

    source.put(JwtClaimNames.JTI, <span class="hljs-number">1</span>);

    source.put(JwtClaimNames.AUD, <span class="hljs-string">"audience"</span>);

    source.put(JwtClaimNames.EXP, Instant.ofEpochSecond(<span class="hljs-number">2000000000L</span>));

    source.put(JwtClaimNames.IAT, <span class="hljs-keyword">new</span> Date(<span class="hljs-number">1000000000000L</span>));

    source.put(JwtClaimNames.ISS, URI.create(<span class="hljs-string">"https://any.url"</span>));

    source.put(JwtClaimNames.NBF, <span class="hljs-string">"1000000000"</span>);

    source.put(JwtClaimNames.SUB, <span class="hljs-number">2345</span>);

    Map&lt;String, Object&gt; target = converter.convert(source);

    assertThat(target).containsEntry(JwtClaimNames.JTI, <span class="hljs-string">"1"</span>);

    assertThat(target).containsEntry(JwtClaimNames.AUD, Arrays.asList(<span class="hljs-string">"audience"</span>));

    assertThat(target).containsEntry(JwtClaimNames.EXP, Instant.ofEpochSecond(<span class="hljs-number">2000000000L</span>));

    assertThat(target).containsEntry(JwtClaimNames.IAT, Instant.ofEpochSecond(<span class="hljs-number">1000000000L</span>));

    assertThat(target).containsEntry(JwtClaimNames.ISS, <span class="hljs-string">"https://any.url"</span>);

    assertThat(target).containsEntry(JwtClaimNames.NBF, Instant.ofEpochSecond(<span class="hljs-number">1000000000L</span>));

    assertThat(target).containsEntry(JwtClaimNames.SUB, <span class="hljs-string">"1234"</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Converter&lt;Object, String&gt; <span class="hljs-title">createClaimConverter</span><span class="hljs-params">(String convertReturnValue)</span> </span>{
    Converter&lt;Object, String&gt; claimConverter = mock(Converter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(claimConverter.convert(any(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>(<span class="hljs-title">convertReturnValue</span>)</span>;
    <span class="hljs-keyword">return</span> claimConverter;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest792">Test Case ID #spring-security_Test_79_2</h4>
<h4 id="test-case-name-convertwhenusingconstructorthenonlyconvertersinthatmapareusedforconversionfile-cjavaprojectsspringspring-securityoauth2oauth2-josesrctestjavaorgspringframeworksecurityoauth2jwtmappedjwtclaimsetconvertertestsjava">Test Case Name: <code>convertWhenUsingConstructorThenOnlyConvertersInThatMapAreUsedForConversion</code>(File: <code>C:\Java_projects\Spring\spring-security\oauth2\oauth2-jose\src\test\java\org\springframework\security\oauth2\jwt\MappedJwtClaimSetConverterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-claimconverter">Mock Object Variable Name: <code>claimConverter</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void convertWhenUsingConstructorThenOnlyConvertersInThatMapAreUsedForConversion() {
<span class="hljs-deletion">-    Converter&lt;Object, String&gt; claimConverter = mock(Converter.class);</span>
<span class="hljs-addition">+    Converter&lt;Object, String&gt; claimConverter = createClaimConverter("1234");</span>
     MappedJwtClaimSetConverter converter = new MappedJwtClaimSetConverter(Collections.singletonMap(JwtClaimNames.SUB, claimConverter));
<span class="hljs-deletion">-    given(claimConverter.convert(any(Object.class))).willReturn("1234");</span>
     Map&lt;String, Object&gt; source = new HashMap&lt;&gt;();
     source.put(JwtClaimNames.JTI, new Object());
     source.put(JwtClaimNames.AUD, new Object());
     source.put(JwtClaimNames.EXP, Instant.ofEpochSecond(1L));
     source.put(JwtClaimNames.IAT, Instant.ofEpochSecond(1L));
     source.put(JwtClaimNames.ISS, new Object());
     source.put(JwtClaimNames.NBF, new Object());
     source.put(JwtClaimNames.SUB, new Object());
     Map&lt;String, Object&gt; target = converter.convert(source);
     assertThat(target).containsEntry(JwtClaimNames.JTI, source.get(JwtClaimNames.JTI));
     assertThat(target).containsEntry(JwtClaimNames.AUD, source.get(JwtClaimNames.AUD));
     assertThat(target).containsEntry(JwtClaimNames.EXP, source.get(JwtClaimNames.EXP));
     assertThat(target).containsEntry(JwtClaimNames.IAT, source.get(JwtClaimNames.IAT));
     assertThat(target).containsEntry(JwtClaimNames.ISS, source.get(JwtClaimNames.ISS));
     assertThat(target).containsEntry(JwtClaimNames.NBF, source.get(JwtClaimNames.NBF));
     assertThat(target).containsEntry(JwtClaimNames.SUB, "1234");
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">convertWhenUsingConstructorThenOnlyConvertersInThatMapAreUsedForConversion</span><span class="hljs-params">()</span> </span>{

    Converter&lt;Object, String&gt; claimConverter = mock(Converter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    MappedJwtClaimSetConverter converter = <span class="hljs-keyword">new</span> MappedJwtClaimSetConverter(Collections.singletonMap(JwtClaimNames.SUB, claimConverter));

    given(claimConverter.convert(any(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>("1234")</span>;

    Map&lt;String, Object&gt; source = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

    source.put(JwtClaimNames.JTI, <span class="hljs-keyword">new</span> Object());

    source.put(JwtClaimNames.AUD, <span class="hljs-keyword">new</span> Object());

    source.put(JwtClaimNames.EXP, Instant.ofEpochSecond(<span class="hljs-number">1L</span>));

    source.put(JwtClaimNames.IAT, Instant.ofEpochSecond(<span class="hljs-number">1L</span>));

    source.put(JwtClaimNames.ISS, <span class="hljs-keyword">new</span> Object());

    source.put(JwtClaimNames.NBF, <span class="hljs-keyword">new</span> Object());

    source.put(JwtClaimNames.SUB, <span class="hljs-keyword">new</span> Object());

    Map&lt;String, Object&gt; target = converter.convert(source);

    assertThat(target).containsEntry(JwtClaimNames.JTI, source.get(JwtClaimNames.JTI));

    assertThat(target).containsEntry(JwtClaimNames.AUD, source.get(JwtClaimNames.AUD));

    assertThat(target).containsEntry(JwtClaimNames.EXP, source.get(JwtClaimNames.EXP));

    assertThat(target).containsEntry(JwtClaimNames.IAT, source.get(JwtClaimNames.IAT));

    assertThat(target).containsEntry(JwtClaimNames.ISS, source.get(JwtClaimNames.ISS));

    assertThat(target).containsEntry(JwtClaimNames.NBF, source.get(JwtClaimNames.NBF));

    assertThat(target).containsEntry(JwtClaimNames.SUB, <span class="hljs-string">"1234"</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Converter&lt;Object, String&gt; <span class="hljs-title">createClaimConverter</span><span class="hljs-params">(String convertReturnValue)</span> </span>{
    Converter&lt;Object, String&gt; claimConverter = mock(Converter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(claimConverter.convert(any(Object<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>(<span class="hljs-title">convertReturnValue</span>)</span>;
    <span class="hljs-keyword">return</span> claimConverter;
}
</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci80">Mock Clone Instance #spring-security_MCI_80</h2>
<ul>
<li><strong>Scope</strong>: method level</li>
<li><strong>Mocked Class</strong>: <code>org.springframework.security.core.userdetails.UserDetailsService</code></li>
<li><strong>Test Case Count</strong>: 3</li>
<li><strong>MO Count</strong>: 3</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> UserDetailsService <span class="hljs-title">mockUserDetailsService</span><span class="hljs-params">(UserDetails user)</span> </span>{
    UserDetailsService userDetailsService = mock(UserDetailsService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(userDetailsService.loadUserByUsername(any())).willReturn(user);
    <span class="hljs-keyword">return</span> userDetailsService;
}
</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest801">Test Case ID #spring-security_Test_80_1</h4>
<h4 id="test-case-name-authenticatewhensuccessandpasswordmanagerthenupdatesfile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationdaodaoauthenticationprovidertestsjava">Test Case Name: <code>authenticateWhenSuccessAndPasswordManagerThenUpdates</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\dao\DaoAuthenticationProviderTests.java</code>)</h4>
<h4 id="mock-object-variable-name-userdetailsservice">Mock Object Variable Name: <code>userDetailsService</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenSuccessAndPasswordManagerThenUpdates() {
     String password = "password";
     String encodedPassword = "encoded";
     UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated("user", password);
     PasswordEncoder encoder = mock(PasswordEncoder.class);
<span class="hljs-deletion">-    UserDetailsService userDetailsService = mock(UserDetailsService.class);</span>
<span class="hljs-addition">+    UserDetails user = PasswordEncodedUser.user();</span>
<span class="hljs-addition">+    UserDetailsService userDetailsService = mockUserDetailsService(user);</span>
     UserDetailsPasswordService passwordManager = mock(UserDetailsPasswordService.class);
     DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
     provider.setPasswordEncoder(encoder);
     provider.setUserDetailsService(userDetailsService);
     provider.setUserDetailsPasswordService(passwordManager);
<span class="hljs-deletion">-    UserDetails user = PasswordEncodedUser.user();</span>
     given(encoder.matches(any(), any())).willReturn(true);
     given(encoder.upgradeEncoding(any())).willReturn(true);
     given(encoder.encode(any())).willReturn(encodedPassword);
<span class="hljs-deletion">-    given(userDetailsService.loadUserByUsername(any())).willReturn(user);</span>
     given(passwordManager.updatePassword(any(), any())).willReturn(user);
     Authentication result = provider.authenticate(token);
     verify(encoder).encode(password);
     verify(passwordManager).updatePassword(eq(user), eq(encodedPassword));
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenSuccessAndPasswordManagerThenUpdates</span><span class="hljs-params">()</span> </span>{

    String password = <span class="hljs-string">"password"</span>;

    String encodedPassword = <span class="hljs-string">"encoded"</span>;

    UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(<span class="hljs-string">"user"</span>, password);

    PasswordEncoder encoder = mock(PasswordEncoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    UserDetailsService userDetailsService = mock(UserDetailsService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    UserDetailsPasswordService passwordManager = mock(UserDetailsPasswordService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    DaoAuthenticationProvider provider = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();

    provider.setPasswordEncoder(encoder);

    provider.setUserDetailsService(userDetailsService);

    provider.setUserDetailsPasswordService(passwordManager);

    UserDetails user = PasswordEncodedUser.user();

    given(encoder.matches(any(), any())).willReturn(<span class="hljs-keyword">true</span>);

    given(encoder.upgradeEncoding(any())).willReturn(<span class="hljs-keyword">true</span>);

    given(encoder.encode(any())).willReturn(encodedPassword);

    given(userDetailsService.loadUserByUsername(any())).willReturn(user);

    given(passwordManager.updatePassword(any(), any())).willReturn(user);

    Authentication result = provider.authenticate(token);

    verify(encoder).encode(password);

    verify(passwordManager).updatePassword(eq(user), eq(encodedPassword));

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> UserDetailsService <span class="hljs-title">mockUserDetailsService</span><span class="hljs-params">(UserDetails user)</span> </span>{
    UserDetailsService userDetailsService = mock(UserDetailsService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(userDetailsService.loadUserByUsername(any())).willReturn(user);
    <span class="hljs-keyword">return</span> userDetailsService;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest802">Test Case ID #spring-security_Test_80_2</h4>
<h4 id="test-case-name-authenticatewhenbadcredentialsandpasswordmanagerthennoupdatefile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationdaodaoauthenticationprovidertestsjava">Test Case Name: <code>authenticateWhenBadCredentialsAndPasswordManagerThenNoUpdate</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\dao\DaoAuthenticationProviderTests.java</code>)</h4>
<h4 id="mock-object-variable-name-userdetailsservice">Mock Object Variable Name: <code>userDetailsService</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenBadCredentialsAndPasswordManagerThenNoUpdate() {
     UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated("user", "password");
     PasswordEncoder encoder = mock(PasswordEncoder.class);
<span class="hljs-deletion">-    UserDetailsService userDetailsService = mock(UserDetailsService.class);</span>
<span class="hljs-addition">+    UserDetails user = PasswordEncodedUser.user();</span>
<span class="hljs-addition">+    UserDetailsService userDetailsService = mockUserDetailsService(user);</span>
     UserDetailsPasswordService passwordManager = mock(UserDetailsPasswordService.class);
     DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
     provider.setPasswordEncoder(encoder);
     provider.setUserDetailsService(userDetailsService);
     provider.setUserDetailsPasswordService(passwordManager);
<span class="hljs-deletion">-    UserDetails user = PasswordEncodedUser.user();</span>
     given(encoder.matches(any(), any())).willReturn(false);
<span class="hljs-deletion">-    given(userDetailsService.loadUserByUsername(any())).willReturn(user);</span>
     assertThatExceptionOfType(BadCredentialsException.class).isThrownBy(() -&gt; provider.authenticate(token));
     verifyNoMoreInteractions(passwordManager);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenBadCredentialsAndPasswordManagerThenNoUpdate</span><span class="hljs-params">()</span> </span>{

    UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>);

    PasswordEncoder encoder = mock(PasswordEncoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    UserDetailsService userDetailsService = mock(UserDetailsService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    UserDetailsPasswordService passwordManager = mock(UserDetailsPasswordService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    DaoAuthenticationProvider provider = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();

    provider.setPasswordEncoder(encoder);

    provider.setUserDetailsService(userDetailsService);

    provider.setUserDetailsPasswordService(passwordManager);

    UserDetails user = PasswordEncodedUser.user();

    given(encoder.matches(any(), any())).willReturn(<span class="hljs-keyword">false</span>);

    given(userDetailsService.loadUserByUsername(any())).willReturn(user);

    assertThatExceptionOfType(BadCredentialsException<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">isThrownBy</span>(() -&gt; <span class="hljs-title">provider</span>.<span class="hljs-title">authenticate</span>(<span class="hljs-title">token</span>))</span>;

    verifyNoMoreInteractions(passwordManager);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> UserDetailsService <span class="hljs-title">mockUserDetailsService</span><span class="hljs-params">(UserDetails user)</span> </span>{
    UserDetailsService userDetailsService = mock(UserDetailsService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(userDetailsService.loadUserByUsername(any())).willReturn(user);
    <span class="hljs-keyword">return</span> userDetailsService;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest803">Test Case ID #spring-security_Test_80_3</h4>
<h4 id="test-case-name-authenticatewhennotupgradeandpasswordmanagerthennoupdatefile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationdaodaoauthenticationprovidertestsjava">Test Case Name: <code>authenticateWhenNotUpgradeAndPasswordManagerThenNoUpdate</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\dao\DaoAuthenticationProviderTests.java</code>)</h4>
<h4 id="mock-object-variable-name-userdetailsservice">Mock Object Variable Name: <code>userDetailsService</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenNotUpgradeAndPasswordManagerThenNoUpdate() {
     UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated("user", "password");
     PasswordEncoder encoder = mock(PasswordEncoder.class);
<span class="hljs-deletion">-    UserDetailsService userDetailsService = mock(UserDetailsService.class);</span>
<span class="hljs-addition">+    UserDetails user = PasswordEncodedUser.user();</span>
<span class="hljs-addition">+    UserDetailsService userDetailsService = mockUserDetailsService(user);</span>
     UserDetailsPasswordService passwordManager = mock(UserDetailsPasswordService.class);
     DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
     provider.setPasswordEncoder(encoder);
     provider.setUserDetailsService(userDetailsService);
     provider.setUserDetailsPasswordService(passwordManager);
<span class="hljs-deletion">-    UserDetails user = PasswordEncodedUser.user();</span>
     given(encoder.matches(any(), any())).willReturn(true);
     given(encoder.upgradeEncoding(any())).willReturn(false);
<span class="hljs-deletion">-    given(userDetailsService.loadUserByUsername(any())).willReturn(user);</span>
     Authentication result = provider.authenticate(token);
     verifyNoMoreInteractions(passwordManager);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenNotUpgradeAndPasswordManagerThenNoUpdate</span><span class="hljs-params">()</span> </span>{

    UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>);

    PasswordEncoder encoder = mock(PasswordEncoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    UserDetailsService userDetailsService = mock(UserDetailsService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    UserDetailsPasswordService passwordManager = mock(UserDetailsPasswordService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    DaoAuthenticationProvider provider = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();

    provider.setPasswordEncoder(encoder);

    provider.setUserDetailsService(userDetailsService);

    provider.setUserDetailsPasswordService(passwordManager);

    UserDetails user = PasswordEncodedUser.user();

    given(encoder.matches(any(), any())).willReturn(<span class="hljs-keyword">true</span>);

    given(encoder.upgradeEncoding(any())).willReturn(<span class="hljs-keyword">false</span>);

    given(userDetailsService.loadUserByUsername(any())).willReturn(user);

    Authentication result = provider.authenticate(token);

    verifyNoMoreInteractions(passwordManager);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> UserDetailsService <span class="hljs-title">mockUserDetailsService</span><span class="hljs-params">(UserDetails user)</span> </span>{
    UserDetailsService userDetailsService = mock(UserDetailsService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(userDetailsService.loadUserByUsername(any())).willReturn(user);
    <span class="hljs-keyword">return</span> userDetailsService;
}
</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci103">Mock Clone Instance #spring-security_MCI_103</h2>
<ul>
<li><strong>Scope</strong>: method level</li>
<li><strong>Mocked Class</strong>: <code>org.springframework.security.saml2.provider.service.web.Saml2AuthenticationRequestRepository&lt;org.springframework.security.saml2.provider.service.authentication.AbstractSaml2AuthenticationRequest&gt;</code></li>
<li><strong>Test Case Count</strong>: 3</li>
<li><strong>MO Count</strong>: 3</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest1031">Test Case ID #spring-security_Test_103_1</h4>
<h4 id="test-case-name-attemptauthenticationwhensavedauthnrequestthenremovesauthnrequestfile-cjavaprojectsspringspring-securitysaml2saml2-service-providersrctestjavaorgspringframeworksecuritysaml2providerservicewebauthenticationsaml2webssoauthenticationfiltertestsjava">Test Case Name: <code>attemptAuthenticationWhenSavedAuthnRequestThenRemovesAuthnRequest</code>(File: <code>C:\Java_projects\Spring\spring-security\saml2\saml2-service-provider\src\test\java\org\springframework\security\saml2\provider\service\web\authentication\Saml2WebSsoAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-authenticationrequestrepository">Mock Object Variable Name: <code>authenticationRequestRepository</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void attemptAuthenticationWhenSavedAuthnRequestThenRemovesAuthnRequest() {
<span class="hljs-deletion">-    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository.class);</span>
     AuthenticationConverter authenticationConverter = mock(AuthenticationConverter.class);
     given(authenticationConverter.convert(this.request)).willReturn(TestSaml2AuthenticationTokens.token());
     this.filter = new Saml2WebSsoAuthenticationFilter(authenticationConverter, "/some/other/path/{registrationId}");
     this.filter.setAuthenticationManager((authentication) -&gt; null);
     this.request.setRequestURI("/some/other/path/idp-registration-id");
     this.request.setPathInfo("/some/other/path/idp-registration-id");
     this.filter.setAuthenticationRequestRepository(authenticationRequestRepository);
     this.filter.attemptAuthentication(this.request, this.response);
     verify(authenticationRequestRepository).removeAuthenticationRequest(this.request, this.response);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attemptAuthenticationWhenSavedAuthnRequestThenRemovesAuthnRequest</span><span class="hljs-params">()</span> </span>{

    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    AuthenticationConverter authenticationConverter = mock(AuthenticationConverter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(authenticationConverter.convert(<span class="hljs-keyword">this</span>.request)).willReturn(TestSaml2AuthenticationTokens.token());

    <span class="hljs-keyword">this</span>.filter = <span class="hljs-keyword">new</span> Saml2WebSsoAuthenticationFilter(authenticationConverter, <span class="hljs-string">"/some/other/path/{registrationId}"</span>);

    <span class="hljs-keyword">this</span>.filter.setAuthenticationManager((authentication) -&gt; <span class="hljs-keyword">null</span>);

    <span class="hljs-keyword">this</span>.request.setRequestURI(<span class="hljs-string">"/some/other/path/idp-registration-id"</span>);

    <span class="hljs-keyword">this</span>.request.setPathInfo(<span class="hljs-string">"/some/other/path/idp-registration-id"</span>);

    <span class="hljs-keyword">this</span>.filter.setAuthenticationRequestRepository(authenticationRequestRepository);

    <span class="hljs-keyword">this</span>.filter.attemptAuthentication(<span class="hljs-keyword">this</span>.request, <span class="hljs-keyword">this</span>.response);

    verify(authenticationRequestRepository).removeAuthenticationRequest(<span class="hljs-keyword">this</span>.request, <span class="hljs-keyword">this</span>.response);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1032">Test Case ID #spring-security_Test_103_2</h4>
<h4 id="test-case-name-setauthenticationrequestrepositorywhenexpectedauthenticationconvertertypethensetloaderintoconverterfile-cjavaprojectsspringspring-securitysaml2saml2-service-providersrctestjavaorgspringframeworksecuritysaml2providerservicewebauthenticationsaml2webssoauthenticationfiltertestsjava">Test Case Name: <code>setAuthenticationRequestRepositoryWhenExpectedAuthenticationConverterTypeThenSetLoaderIntoConverter</code>(File: <code>C:\Java_projects\Spring\spring-security\saml2\saml2-service-provider\src\test\java\org\springframework\security\saml2\provider\service\web\authentication\Saml2WebSsoAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-authenticationrequestrepository">Mock Object Variable Name: <code>authenticationRequestRepository</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void setAuthenticationRequestRepositoryWhenExpectedAuthenticationConverterTypeThenSetLoaderIntoConverter() {
     Saml2AuthenticationTokenConverter authenticationConverter = mock(Saml2AuthenticationTokenConverter.class);
<span class="hljs-deletion">-    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository.class);</span>
     this.filter = new Saml2WebSsoAuthenticationFilter(authenticationConverter, "/some/other/path/{registrationId}");
     this.filter.setAuthenticationRequestRepository(authenticationRequestRepository);
     verify(authenticationConverter).setAuthenticationRequestRepository(authenticationRequestRepository);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthenticationRequestRepositoryWhenExpectedAuthenticationConverterTypeThenSetLoaderIntoConverter</span><span class="hljs-params">()</span> </span>{

    Saml2AuthenticationTokenConverter authenticationConverter = mock(Saml2AuthenticationTokenConverter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter = <span class="hljs-keyword">new</span> Saml2WebSsoAuthenticationFilter(authenticationConverter, <span class="hljs-string">"/some/other/path/{registrationId}"</span>);

    <span class="hljs-keyword">this</span>.filter.setAuthenticationRequestRepository(authenticationRequestRepository);

    verify(authenticationConverter).setAuthenticationRequestRepository(authenticationRequestRepository);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1033">Test Case ID #spring-security_Test_103_3</h4>
<h4 id="test-case-name-setauthenticationrequestrepositorywhennotexpectedauthenticationconvertertypethendonotsetfile-cjavaprojectsspringspring-securitysaml2saml2-service-providersrctestjavaorgspringframeworksecuritysaml2providerservicewebauthenticationsaml2webssoauthenticationfiltertestsjava">Test Case Name: <code>setAuthenticationRequestRepositoryWhenNotExpectedAuthenticationConverterTypeThenDoNotSet</code>(File: <code>C:\Java_projects\Spring\spring-security\saml2\saml2-service-provider\src\test\java\org\springframework\security\saml2\provider\service\web\authentication\Saml2WebSsoAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-authenticationrequestrepository">Mock Object Variable Name: <code>authenticationRequestRepository</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void setAuthenticationRequestRepositoryWhenNotExpectedAuthenticationConverterTypeThenDoNotSet() {
     AuthenticationConverter authenticationConverter = mock(AuthenticationConverter.class);
<span class="hljs-deletion">-    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository.class);</span>
     this.filter = new Saml2WebSsoAuthenticationFilter(authenticationConverter, "/some/other/path/{registrationId}");
     this.filter.setAuthenticationRequestRepository(authenticationRequestRepository);
     verifyNoInteractions(authenticationConverter);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthenticationRequestRepositoryWhenNotExpectedAuthenticationConverterTypeThenDoNotSet</span><span class="hljs-params">()</span> </span>{

    AuthenticationConverter authenticationConverter = mock(AuthenticationConverter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter = <span class="hljs-keyword">new</span> Saml2WebSsoAuthenticationFilter(authenticationConverter, <span class="hljs-string">"/some/other/path/{registrationId}"</span>);

    <span class="hljs-keyword">this</span>.filter.setAuthenticationRequestRepository(authenticationRequestRepository);

    verifyNoInteractions(authenticationConverter);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci104">Mock Clone Instance #spring-security_MCI_104</h2>
<ul>
<li><strong>Scope</strong>: class level</li>
<li><strong>Mocked Class</strong>: <code>org.springframework.security.saml2.provider.service.web.Saml2AuthenticationRequestRepository&lt;org.springframework.security.saml2.provider.service.authentication.AbstractSaml2AuthenticationRequest&gt;</code></li>
<li><strong>Test Case Count</strong>: 2</li>
<li><strong>MO Count</strong>: 5</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockSaml2AuthenticationRequestRepository</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock Saml2AuthenticationRequestRepository with the given return value for loadAuthenticationRequest.
     *
     * <span class="hljs-doctag">@param</span> authenticationRequest the AbstractSaml2AuthenticationRequest to return from loadAuthenticationRequest
     * <span class="hljs-doctag">@return</span> a mock Saml2AuthenticationRequestRepository
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; <span class="hljs-title">createMockRepository</span><span class="hljs-params">(AbstractSaml2AuthenticationRequest authenticationRequest)</span> </span>{
        Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(authenticationRequestRepository.loadAuthenticationRequest(any(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>(<span class="hljs-title">authenticationRequest</span>)</span>;
        <span class="hljs-keyword">return</span> authenticationRequestRepository;
    }
}
</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest1041">Test Case ID #spring-security_Test_104_1</h4>
<h4 id="test-case-name-convertwhensavedauthenticationrequestthentokenfile-cjavaprojectsspringspring-securitysaml2saml2-service-providersrcopensaml4testjavaorgspringframeworksecuritysaml2providerservicewebopensaml4authenticationtokenconvertertestsjava">Test Case Name: <code>convertWhenSavedAuthenticationRequestThenToken</code>(File: <code>C:\Java_projects\Spring\spring-security\saml2\saml2-service-provider\src\opensaml4Test\java\org\springframework\security\saml2\provider\service\web\OpenSaml4AuthenticationTokenConverterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-authenticationrequestrepository">Mock Object Variable Name: <code>authenticationRequestRepository</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void convertWhenSavedAuthenticationRequestThenToken() {
<span class="hljs-deletion">-    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository.class);</span>
     AbstractSaml2AuthenticationRequest authenticationRequest = mock(AbstractSaml2AuthenticationRequest.class);
     given(authenticationRequest.getRelyingPartyRegistrationId()).willReturn(this.registration.getRegistrationId());
     OpenSaml4AuthenticationTokenConverter converter = new OpenSaml4AuthenticationTokenConverter(this.registrations);
<span class="hljs-deletion">-    converter.setAuthenticationRequestRepository(authenticationRequestRepository);</span>
<span class="hljs-addition">+    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = MockSaml2AuthenticationRequestRepository.createMockRepository(authenticationRequest);</span>
<span class="hljs-addition">+    converter.setAuthenticationRequestRepository(authenticationRequestRepository);</span>
     given(this.registrations.findByRegistrationId(any())).willReturn(this.registration);
<span class="hljs-deletion">-    given(authenticationRequestRepository.loadAuthenticationRequest(any(HttpServletRequest.class))).willReturn(authenticationRequest);</span>
     MockHttpServletRequest request = post("/login/saml2/sso/" + this.registration.getRegistrationId());
     request.setParameter(Saml2ParameterNames.SAML_RESPONSE, Saml2Utils.samlEncode("response".getBytes(StandardCharsets.UTF_8)));
     Saml2AuthenticationToken token = converter.convert(request);
     assertThat(token.getSaml2Response()).isEqualTo("response");
     assertThat(token.getRelyingPartyRegistration().getRegistrationId()).isEqualTo(this.registration.getRegistrationId());
     assertThat(token.getAuthenticationRequest()).isEqualTo(authenticationRequest);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">convertWhenSavedAuthenticationRequestThenToken</span><span class="hljs-params">()</span> </span>{

    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    AbstractSaml2AuthenticationRequest authenticationRequest = mock(AbstractSaml2AuthenticationRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(authenticationRequest.getRelyingPartyRegistrationId()).willReturn(<span class="hljs-keyword">this</span>.registration.getRegistrationId());

    OpenSaml4AuthenticationTokenConverter converter = <span class="hljs-keyword">new</span> OpenSaml4AuthenticationTokenConverter(<span class="hljs-keyword">this</span>.registrations);

    converter.setAuthenticationRequestRepository(authenticationRequestRepository);

    given(<span class="hljs-keyword">this</span>.registrations.findByRegistrationId(any())).willReturn(<span class="hljs-keyword">this</span>.registration);

    given(authenticationRequestRepository.loadAuthenticationRequest(any(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>(<span class="hljs-title">authenticationRequest</span>)</span>;

    MockHttpServletRequest request = post(<span class="hljs-string">"/login/saml2/sso/"</span> + <span class="hljs-keyword">this</span>.registration.getRegistrationId());

    request.setParameter(Saml2ParameterNames.SAML_RESPONSE, Saml2Utils.samlEncode(<span class="hljs-string">"response"</span>.getBytes(StandardCharsets.UTF_8)));

    Saml2AuthenticationToken token = converter.convert(request);

    assertThat(token.getSaml2Response()).isEqualTo(<span class="hljs-string">"response"</span>);

    assertThat(token.getRelyingPartyRegistration().getRegistrationId()).isEqualTo(<span class="hljs-keyword">this</span>.registration.getRegistrationId());

    assertThat(token.getAuthenticationRequest()).isEqualTo(authenticationRequest);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockSaml2AuthenticationRequestRepository</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock Saml2AuthenticationRequestRepository with the given return value for loadAuthenticationRequest.
     *
     * <span class="hljs-doctag">@param</span> authenticationRequest the AbstractSaml2AuthenticationRequest to return from loadAuthenticationRequest
     * <span class="hljs-doctag">@return</span> a mock Saml2AuthenticationRequestRepository
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; <span class="hljs-title">createMockRepository</span><span class="hljs-params">(AbstractSaml2AuthenticationRequest authenticationRequest)</span> </span>{
        Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(authenticationRequestRepository.loadAuthenticationRequest(any(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>(<span class="hljs-title">authenticationRequest</span>)</span>;
        <span class="hljs-keyword">return</span> authenticationRequestRepository;
    }
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1042">Test Case ID #spring-security_Test_104_2</h4>
<h4 id="test-case-name-convertwhensavedauthenticationrequestthentokenfile-cjavaprojectsspringspring-securitysaml2saml2-service-providersrcopensaml4testjavaorgspringframeworksecuritysaml2providerservicewebopensamlauthenticationtokenconvertertestsjava">Test Case Name: <code>convertWhenSavedAuthenticationRequestThenToken</code>(File: <code>C:\Java_projects\Spring\spring-security\saml2\saml2-service-provider\src\opensaml4Test\java\org\springframework\security\saml2\provider\service\web\OpenSamlAuthenticationTokenConverterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-authenticationrequestrepository">Mock Object Variable Name: <code>authenticationRequestRepository</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void convertWhenSavedAuthenticationRequestThenToken() {
<span class="hljs-deletion">-    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository.class);</span>
     AbstractSaml2AuthenticationRequest authenticationRequest = mock(AbstractSaml2AuthenticationRequest.class);
     given(authenticationRequest.getRelyingPartyRegistrationId()).willReturn(this.registration.getRegistrationId());
     OpenSamlAuthenticationTokenConverter converter = new OpenSamlAuthenticationTokenConverter(this.registrations);
<span class="hljs-deletion">-    converter.setAuthenticationRequestRepository(authenticationRequestRepository);</span>
<span class="hljs-addition">+    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = MockSaml2AuthenticationRequestRepository.createMockRepository(authenticationRequest);</span>
<span class="hljs-addition">+    converter.setAuthenticationRequestRepository(authenticationRequestRepository);</span>
     given(this.registrations.findByRegistrationId(any())).willReturn(this.registration);
<span class="hljs-deletion">-    given(authenticationRequestRepository.loadAuthenticationRequest(any(HttpServletRequest.class))).willReturn(authenticationRequest);</span>
     MockHttpServletRequest request = post("/login/saml2/sso/" + this.registration.getRegistrationId());
     request.setParameter(Saml2ParameterNames.SAML_RESPONSE, Saml2Utils.samlEncode("response".getBytes(StandardCharsets.UTF_8)));
     Saml2AuthenticationToken token = converter.convert(request);
     assertThat(token.getSaml2Response()).isEqualTo("response");
     assertThat(token.getRelyingPartyRegistration().getRegistrationId()).isEqualTo(this.registration.getRegistrationId());
     assertThat(token.getAuthenticationRequest()).isEqualTo(authenticationRequest);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">convertWhenSavedAuthenticationRequestThenToken</span><span class="hljs-params">()</span> </span>{

    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    AbstractSaml2AuthenticationRequest authenticationRequest = mock(AbstractSaml2AuthenticationRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(authenticationRequest.getRelyingPartyRegistrationId()).willReturn(<span class="hljs-keyword">this</span>.registration.getRegistrationId());

    OpenSamlAuthenticationTokenConverter converter = <span class="hljs-keyword">new</span> OpenSamlAuthenticationTokenConverter(<span class="hljs-keyword">this</span>.registrations);

    converter.setAuthenticationRequestRepository(authenticationRequestRepository);

    given(<span class="hljs-keyword">this</span>.registrations.findByRegistrationId(any())).willReturn(<span class="hljs-keyword">this</span>.registration);

    given(authenticationRequestRepository.loadAuthenticationRequest(any(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>(<span class="hljs-title">authenticationRequest</span>)</span>;

    MockHttpServletRequest request = post(<span class="hljs-string">"/login/saml2/sso/"</span> + <span class="hljs-keyword">this</span>.registration.getRegistrationId());

    request.setParameter(Saml2ParameterNames.SAML_RESPONSE, Saml2Utils.samlEncode(<span class="hljs-string">"response"</span>.getBytes(StandardCharsets.UTF_8)));

    Saml2AuthenticationToken token = converter.convert(request);

    assertThat(token.getSaml2Response()).isEqualTo(<span class="hljs-string">"response"</span>);

    assertThat(token.getRelyingPartyRegistration().getRegistrationId()).isEqualTo(<span class="hljs-keyword">this</span>.registration.getRegistrationId());

    assertThat(token.getAuthenticationRequest()).isEqualTo(authenticationRequest);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockSaml2AuthenticationRequestRepository</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock Saml2AuthenticationRequestRepository with the given return value for loadAuthenticationRequest.
     *
     * <span class="hljs-doctag">@param</span> authenticationRequest the AbstractSaml2AuthenticationRequest to return from loadAuthenticationRequest
     * <span class="hljs-doctag">@return</span> a mock Saml2AuthenticationRequestRepository
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; <span class="hljs-title">createMockRepository</span><span class="hljs-params">(AbstractSaml2AuthenticationRequest authenticationRequest)</span> </span>{
        Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(authenticationRequestRepository.loadAuthenticationRequest(any(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>(<span class="hljs-title">authenticationRequest</span>)</span>;
        <span class="hljs-keyword">return</span> authenticationRequestRepository;
    }
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1043">Test Case ID #spring-security_Test_104_3</h4>
<h4 id="test-case-name-convertwhensavedauthenticationrequestthentokenfile-cjavaprojectsspringspring-securitysaml2saml2-service-providersrcopensaml5testjavaorgspringframeworksecuritysaml2providerservicewebopensaml5authenticationtokenconvertertestsjava">Test Case Name: <code>convertWhenSavedAuthenticationRequestThenToken</code>(File: <code>C:\Java_projects\Spring\spring-security\saml2\saml2-service-provider\src\opensaml5Test\java\org\springframework\security\saml2\provider\service\web\OpenSaml5AuthenticationTokenConverterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-authenticationrequestrepository">Mock Object Variable Name: <code>authenticationRequestRepository</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void convertWhenSavedAuthenticationRequestThenToken() {
<span class="hljs-deletion">-    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository.class);</span>
     AbstractSaml2AuthenticationRequest authenticationRequest = mock(AbstractSaml2AuthenticationRequest.class);
     given(authenticationRequest.getRelyingPartyRegistrationId()).willReturn(this.registration.getRegistrationId());
     OpenSaml5AuthenticationTokenConverter converter = new OpenSaml5AuthenticationTokenConverter(this.registrations);
<span class="hljs-deletion">-    converter.setAuthenticationRequestRepository(authenticationRequestRepository);</span>
<span class="hljs-addition">+    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = MockSaml2AuthenticationRequestRepository.createMockRepository(authenticationRequest);</span>
<span class="hljs-addition">+    converter.setAuthenticationRequestRepository(authenticationRequestRepository);</span>
     given(this.registrations.findByRegistrationId(any())).willReturn(this.registration);
<span class="hljs-deletion">-    given(authenticationRequestRepository.loadAuthenticationRequest(any(HttpServletRequest.class))).willReturn(authenticationRequest);</span>
     MockHttpServletRequest request = post("/login/saml2/sso/" + this.registration.getRegistrationId());
     request.setParameter(Saml2ParameterNames.SAML_RESPONSE, Saml2Utils.samlEncode("response".getBytes(StandardCharsets.UTF_8)));
     Saml2AuthenticationToken token = converter.convert(request);
     assertThat(token.getSaml2Response()).isEqualTo("response");
     assertThat(token.getRelyingPartyRegistration().getRegistrationId()).isEqualTo(this.registration.getRegistrationId());
     assertThat(token.getAuthenticationRequest()).isEqualTo(authenticationRequest);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">convertWhenSavedAuthenticationRequestThenToken</span><span class="hljs-params">()</span> </span>{

    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    AbstractSaml2AuthenticationRequest authenticationRequest = mock(AbstractSaml2AuthenticationRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(authenticationRequest.getRelyingPartyRegistrationId()).willReturn(<span class="hljs-keyword">this</span>.registration.getRegistrationId());

    OpenSaml5AuthenticationTokenConverter converter = <span class="hljs-keyword">new</span> OpenSaml5AuthenticationTokenConverter(<span class="hljs-keyword">this</span>.registrations);

    converter.setAuthenticationRequestRepository(authenticationRequestRepository);

    given(<span class="hljs-keyword">this</span>.registrations.findByRegistrationId(any())).willReturn(<span class="hljs-keyword">this</span>.registration);

    given(authenticationRequestRepository.loadAuthenticationRequest(any(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>(<span class="hljs-title">authenticationRequest</span>)</span>;

    MockHttpServletRequest request = post(<span class="hljs-string">"/login/saml2/sso/"</span> + <span class="hljs-keyword">this</span>.registration.getRegistrationId());

    request.setParameter(Saml2ParameterNames.SAML_RESPONSE, Saml2Utils.samlEncode(<span class="hljs-string">"response"</span>.getBytes(StandardCharsets.UTF_8)));

    Saml2AuthenticationToken token = converter.convert(request);

    assertThat(token.getSaml2Response()).isEqualTo(<span class="hljs-string">"response"</span>);

    assertThat(token.getRelyingPartyRegistration().getRegistrationId()).isEqualTo(<span class="hljs-keyword">this</span>.registration.getRegistrationId());

    assertThat(token.getAuthenticationRequest()).isEqualTo(authenticationRequest);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockSaml2AuthenticationRequestRepository</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock Saml2AuthenticationRequestRepository with the given return value for loadAuthenticationRequest.
     *
     * <span class="hljs-doctag">@param</span> authenticationRequest the AbstractSaml2AuthenticationRequest to return from loadAuthenticationRequest
     * <span class="hljs-doctag">@return</span> a mock Saml2AuthenticationRequestRepository
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; <span class="hljs-title">createMockRepository</span><span class="hljs-params">(AbstractSaml2AuthenticationRequest authenticationRequest)</span> </span>{
        Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(authenticationRequestRepository.loadAuthenticationRequest(any(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>(<span class="hljs-title">authenticationRequest</span>)</span>;
        <span class="hljs-keyword">return</span> authenticationRequestRepository;
    }
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1044">Test Case ID #spring-security_Test_104_4</h4>
<h4 id="test-case-name-convertwhensavedauthenticationrequestthentokenfile-cjavaprojectsspringspring-securitysaml2saml2-service-providersrctestjavaorgspringframeworksecuritysaml2providerservicewebsaml2authenticationtokenconvertertestsjava">Test Case Name: <code>convertWhenSavedAuthenticationRequestThenToken</code>(File: <code>C:\Java_projects\Spring\spring-security\saml2\saml2-service-provider\src\test\java\org\springframework\security\saml2\provider\service\web\Saml2AuthenticationTokenConverterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-authenticationrequestrepository">Mock Object Variable Name: <code>authenticationRequestRepository</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void convertWhenSavedAuthenticationRequestThenToken() {
<span class="hljs-deletion">-    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository.class);</span>
     AbstractSaml2AuthenticationRequest authenticationRequest = mock(AbstractSaml2AuthenticationRequest.class);
     given(authenticationRequest.getRelyingPartyRegistrationId()).willReturn(this.relyingPartyRegistration.getRegistrationId());
     Saml2AuthenticationTokenConverter converter = new Saml2AuthenticationTokenConverter(this.relyingPartyRegistrationResolver);
<span class="hljs-deletion">-    converter.setAuthenticationRequestRepository(authenticationRequestRepository);</span>
<span class="hljs-addition">+    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = MockSaml2AuthenticationRequestRepository.createMockRepository(authenticationRequest);</span>
<span class="hljs-addition">+    converter.setAuthenticationRequestRepository(authenticationRequestRepository);</span>
     given(this.relyingPartyRegistrationResolver.resolve(any(HttpServletRequest.class), any())).willReturn(this.relyingPartyRegistration);
<span class="hljs-deletion">-    given(authenticationRequestRepository.loadAuthenticationRequest(any(HttpServletRequest.class))).willReturn(authenticationRequest);</span>
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.setParameter(Saml2ParameterNames.SAML_RESPONSE, Saml2Utils.samlEncode("response".getBytes(StandardCharsets.UTF_8)));
     Saml2AuthenticationToken token = converter.convert(request);
     assertThat(token.getSaml2Response()).isEqualTo("response");
     assertThat(token.getRelyingPartyRegistration().getRegistrationId()).isEqualTo(this.relyingPartyRegistration.getRegistrationId());
     assertThat(token.getAuthenticationRequest()).isEqualTo(authenticationRequest);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">convertWhenSavedAuthenticationRequestThenToken</span><span class="hljs-params">()</span> </span>{

    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    AbstractSaml2AuthenticationRequest authenticationRequest = mock(AbstractSaml2AuthenticationRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(authenticationRequest.getRelyingPartyRegistrationId()).willReturn(<span class="hljs-keyword">this</span>.relyingPartyRegistration.getRegistrationId());

    Saml2AuthenticationTokenConverter converter = <span class="hljs-keyword">new</span> Saml2AuthenticationTokenConverter(<span class="hljs-keyword">this</span>.relyingPartyRegistrationResolver);

    converter.setAuthenticationRequestRepository(authenticationRequestRepository);

    given(<span class="hljs-keyword">this</span>.relyingPartyRegistrationResolver.resolve(any(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>())).<span class="hljs-title">willReturn</span>(<span class="hljs-title">this</span>.<span class="hljs-title">relyingPartyRegistration</span>)</span>;

    given(authenticationRequestRepository.loadAuthenticationRequest(any(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>(<span class="hljs-title">authenticationRequest</span>)</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.setParameter(Saml2ParameterNames.SAML_RESPONSE, Saml2Utils.samlEncode(<span class="hljs-string">"response"</span>.getBytes(StandardCharsets.UTF_8)));

    Saml2AuthenticationToken token = converter.convert(request);

    assertThat(token.getSaml2Response()).isEqualTo(<span class="hljs-string">"response"</span>);

    assertThat(token.getRelyingPartyRegistration().getRegistrationId()).isEqualTo(<span class="hljs-keyword">this</span>.relyingPartyRegistration.getRegistrationId());

    assertThat(token.getAuthenticationRequest()).isEqualTo(authenticationRequest);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockSaml2AuthenticationRequestRepository</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock Saml2AuthenticationRequestRepository with the given return value for loadAuthenticationRequest.
     *
     * <span class="hljs-doctag">@param</span> authenticationRequest the AbstractSaml2AuthenticationRequest to return from loadAuthenticationRequest
     * <span class="hljs-doctag">@return</span> a mock Saml2AuthenticationRequestRepository
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; <span class="hljs-title">createMockRepository</span><span class="hljs-params">(AbstractSaml2AuthenticationRequest authenticationRequest)</span> </span>{
        Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(authenticationRequestRepository.loadAuthenticationRequest(any(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>(<span class="hljs-title">authenticationRequest</span>)</span>;
        <span class="hljs-keyword">return</span> authenticationRequestRepository;
    }
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1045">Test Case ID #spring-security_Test_104_5</h4>
<h4 id="test-case-name-convertwhensavedauthenticationrequestthentokenwithrelyingpartyregistrationresolverfile-cjavaprojectsspringspring-securitysaml2saml2-service-providersrctestjavaorgspringframeworksecuritysaml2providerservicewebsaml2authenticationtokenconvertertestsjava">Test Case Name: <code>convertWhenSavedAuthenticationRequestThenTokenWithRelyingPartyRegistrationResolver</code>(File: <code>C:\Java_projects\Spring\spring-security\saml2\saml2-service-provider\src\test\java\org\springframework\security\saml2\provider\service\web\Saml2AuthenticationTokenConverterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-authenticationrequestrepository">Mock Object Variable Name: <code>authenticationRequestRepository</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void convertWhenSavedAuthenticationRequestThenTokenWithRelyingPartyRegistrationResolver(@Mock RelyingPartyRegistrationResolver resolver) {
<span class="hljs-deletion">-    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository.class);</span>
     AbstractSaml2AuthenticationRequest authenticationRequest = mock(AbstractSaml2AuthenticationRequest.class);
     given(authenticationRequest.getRelyingPartyRegistrationId()).willReturn(this.relyingPartyRegistration.getRegistrationId());
     Saml2AuthenticationTokenConverter converter = new Saml2AuthenticationTokenConverter(resolver);
<span class="hljs-deletion">-    converter.setAuthenticationRequestRepository(authenticationRequestRepository);</span>
<span class="hljs-addition">+    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = MockSaml2AuthenticationRequestRepository.createMockRepository(authenticationRequest);</span>
<span class="hljs-addition">+    converter.setAuthenticationRequestRepository(authenticationRequestRepository);</span>
     given(resolver.resolve(any(HttpServletRequest.class), any())).willReturn(this.relyingPartyRegistration);
<span class="hljs-deletion">-    given(authenticationRequestRepository.loadAuthenticationRequest(any(HttpServletRequest.class))).willReturn(authenticationRequest);</span>
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.setParameter(Saml2ParameterNames.SAML_RESPONSE, Saml2Utils.samlEncode("response".getBytes(StandardCharsets.UTF_8)));
     Saml2AuthenticationToken token = converter.convert(request);
     assertThat(token.getSaml2Response()).isEqualTo("response");
     assertThat(token.getRelyingPartyRegistration().getRegistrationId()).isEqualTo(this.relyingPartyRegistration.getRegistrationId());
     assertThat(token.getAuthenticationRequest()).isEqualTo(authenticationRequest);
     verify(resolver).resolve(any(), eq(this.relyingPartyRegistration.getRegistrationId()));
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">convertWhenSavedAuthenticationRequestThenTokenWithRelyingPartyRegistrationResolver</span><span class="hljs-params">(@Mock RelyingPartyRegistrationResolver resolver)</span> </span>{

    Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    AbstractSaml2AuthenticationRequest authenticationRequest = mock(AbstractSaml2AuthenticationRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(authenticationRequest.getRelyingPartyRegistrationId()).willReturn(<span class="hljs-keyword">this</span>.relyingPartyRegistration.getRegistrationId());

    Saml2AuthenticationTokenConverter converter = <span class="hljs-keyword">new</span> Saml2AuthenticationTokenConverter(resolver);

    converter.setAuthenticationRequestRepository(authenticationRequestRepository);

    given(resolver.resolve(any(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>())).<span class="hljs-title">willReturn</span>(<span class="hljs-title">this</span>.<span class="hljs-title">relyingPartyRegistration</span>)</span>;

    given(authenticationRequestRepository.loadAuthenticationRequest(any(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>(<span class="hljs-title">authenticationRequest</span>)</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.setParameter(Saml2ParameterNames.SAML_RESPONSE, Saml2Utils.samlEncode(<span class="hljs-string">"response"</span>.getBytes(StandardCharsets.UTF_8)));

    Saml2AuthenticationToken token = converter.convert(request);

    assertThat(token.getSaml2Response()).isEqualTo(<span class="hljs-string">"response"</span>);

    assertThat(token.getRelyingPartyRegistration().getRegistrationId()).isEqualTo(<span class="hljs-keyword">this</span>.relyingPartyRegistration.getRegistrationId());

    assertThat(token.getAuthenticationRequest()).isEqualTo(authenticationRequest);

    verify(resolver).resolve(any(), eq(<span class="hljs-keyword">this</span>.relyingPartyRegistration.getRegistrationId()));

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockSaml2AuthenticationRequestRepository</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock Saml2AuthenticationRequestRepository with the given return value for loadAuthenticationRequest.
     *
     * <span class="hljs-doctag">@param</span> authenticationRequest the AbstractSaml2AuthenticationRequest to return from loadAuthenticationRequest
     * <span class="hljs-doctag">@return</span> a mock Saml2AuthenticationRequestRepository
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; <span class="hljs-title">createMockRepository</span><span class="hljs-params">(AbstractSaml2AuthenticationRequest authenticationRequest)</span> </span>{
        Saml2AuthenticationRequestRepository&lt;AbstractSaml2AuthenticationRequest&gt; authenticationRequestRepository = mock(Saml2AuthenticationRequestRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(authenticationRequestRepository.loadAuthenticationRequest(any(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>(<span class="hljs-title">authenticationRequest</span>)</span>;
        <span class="hljs-keyword">return</span> authenticationRequestRepository;
    }
}
</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci105">Mock Clone Instance #spring-security_MCI_105</h2>
<ul>
<li><strong>Scope</strong>: method level</li>
<li><strong>Mocked Class</strong>: <code>org.springframework.security.oauth2.server.resource.introspection.ReactiveOpaqueTokenIntrospector</code></li>
<li><strong>Test Case Count</strong>: 3</li>
<li><strong>MO Count</strong>: 3</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ReactiveOpaqueTokenIntrospector <span class="hljs-title">createMockIntrospector</span><span class="hljs-params">(OAuth2AuthenticatedPrincipal principal)</span> </span>{
    ReactiveOpaqueTokenIntrospector introspector = mock(ReactiveOpaqueTokenIntrospector<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(introspector.introspect(any())).willReturn(Mono.just(principal));
    <span class="hljs-keyword">return</span> introspector;
}
</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest1051">Test Case ID #spring-security_Test_105_1</h4>
<h4 id="test-case-name-authenticatewhenactivetokenthenokfile-cjavaprojectsspringspring-securityoauth2oauth2-resource-serversrctestjavaorgspringframeworksecurityoauth2serverresourceauthenticationopaquetokenreactiveauthenticationmanagertestsjava">Test Case Name: <code>authenticateWhenActiveTokenThenOk</code>(File: <code>C:\Java_projects\Spring\spring-security\oauth2\oauth2-resource-server\src\test\java\org\springframework\security\oauth2\server\resource\authentication\OpaqueTokenReactiveAuthenticationManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-introspector">Mock Object Variable Name: <code>introspector</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenActiveTokenThenOk() throws Exception {
     OAuth2AuthenticatedPrincipal authority = TestOAuth2AuthenticatedPrincipals.active((attributes) -&gt; attributes.put("extension_field", "twenty-seven"));
<span class="hljs-deletion">-    ReactiveOpaqueTokenIntrospector introspector = mock(ReactiveOpaqueTokenIntrospector.class);</span>
<span class="hljs-deletion">-    given(introspector.introspect(any())).willReturn(Mono.just(authority));</span>
<span class="hljs-addition">+    ReactiveOpaqueTokenIntrospector introspector = createMockIntrospector(authority);</span>
     OpaqueTokenReactiveAuthenticationManager provider = new OpaqueTokenReactiveAuthenticationManager(introspector);
     Authentication result = provider.authenticate(new BearerTokenAuthenticationToken("token")).block();
     assertThat(result.getPrincipal()).isInstanceOf(OAuth2IntrospectionAuthenticatedPrincipal.class);
     Map&lt;String, Object&gt; attributes = ((OAuth2AuthenticatedPrincipal) result.getPrincipal()).getAttributes();
     // @formatter:off
     assertThat(attributes).isNotNull().containsEntry(OAuth2TokenIntrospectionClaimNames.ACTIVE, true).containsEntry(OAuth2TokenIntrospectionClaimNames.AUD, Arrays.asList("https://protected.example.net/resource")).containsEntry(OAuth2TokenIntrospectionClaimNames.CLIENT_ID, "l238j323ds-23ij4").containsEntry(OAuth2TokenIntrospectionClaimNames.EXP, Instant.ofEpochSecond(1419356238)).containsEntry(OAuth2TokenIntrospectionClaimNames.ISS, new URL("https://server.example.com/")).containsEntry(OAuth2TokenIntrospectionClaimNames.NBF, Instant.ofEpochSecond(29348723984L)).containsEntry(OAuth2TokenIntrospectionClaimNames.SCOPE, Arrays.asList("read", "write", "dolphin")).containsEntry(OAuth2TokenIntrospectionClaimNames.SUB, "Z5O3upPC88QrAjx00dis").containsEntry(OAuth2TokenIntrospectionClaimNames.USERNAME, "jdoe").containsEntry("extension_field", "twenty-seven");
     assertThat(result.getAuthorities()).extracting("authority").containsExactly("SCOPE_read", "SCOPE_write", "SCOPE_dolphin");
     // @formatter:on
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenActiveTokenThenOk</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    OAuth2AuthenticatedPrincipal authority = TestOAuth2AuthenticatedPrincipals.active((attributes) -&gt; attributes.put(<span class="hljs-string">"extension_field"</span>, <span class="hljs-string">"twenty-seven"</span>));

    ReactiveOpaqueTokenIntrospector introspector = mock(ReactiveOpaqueTokenIntrospector<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(introspector.introspect(any())).willReturn(Mono.just(authority));

    OpaqueTokenReactiveAuthenticationManager provider = <span class="hljs-keyword">new</span> OpaqueTokenReactiveAuthenticationManager(introspector);

    Authentication result = provider.authenticate(<span class="hljs-keyword">new</span> BearerTokenAuthenticationToken(<span class="hljs-string">"token"</span>)).block();

    assertThat(result.getPrincipal()).isInstanceOf(OAuth2IntrospectionAuthenticatedPrincipal<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    Map&lt;String, Object&gt; attributes = ((OAuth2AuthenticatedPrincipal) result.getPrincipal()).getAttributes();

    <span class="hljs-comment">// @formatter:off</span>

    assertThat(attributes).isNotNull().containsEntry(OAuth2TokenIntrospectionClaimNames.ACTIVE, <span class="hljs-keyword">true</span>).containsEntry(OAuth2TokenIntrospectionClaimNames.AUD, Arrays.asList(<span class="hljs-string">"https://protected.example.net/resource"</span>)).containsEntry(OAuth2TokenIntrospectionClaimNames.CLIENT_ID, <span class="hljs-string">"l238j323ds-23ij4"</span>).containsEntry(OAuth2TokenIntrospectionClaimNames.EXP, Instant.ofEpochSecond(<span class="hljs-number">1419356238</span>)).containsEntry(OAuth2TokenIntrospectionClaimNames.ISS, <span class="hljs-keyword">new</span> URL(<span class="hljs-string">"https://server.example.com/"</span>)).containsEntry(OAuth2TokenIntrospectionClaimNames.NBF, Instant.ofEpochSecond(<span class="hljs-number">29348723984L</span>)).containsEntry(OAuth2TokenIntrospectionClaimNames.SCOPE, Arrays.asList(<span class="hljs-string">"read"</span>, <span class="hljs-string">"write"</span>, <span class="hljs-string">"dolphin"</span>)).containsEntry(OAuth2TokenIntrospectionClaimNames.SUB, <span class="hljs-string">"Z5O3upPC88QrAjx00dis"</span>).containsEntry(OAuth2TokenIntrospectionClaimNames.USERNAME, <span class="hljs-string">"jdoe"</span>).containsEntry(<span class="hljs-string">"extension_field"</span>, <span class="hljs-string">"twenty-seven"</span>);

    assertThat(result.getAuthorities()).extracting(<span class="hljs-string">"authority"</span>).containsExactly(<span class="hljs-string">"SCOPE_read"</span>, <span class="hljs-string">"SCOPE_write"</span>, <span class="hljs-string">"SCOPE_dolphin"</span>);

    <span class="hljs-comment">// @formatter:on</span>

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ReactiveOpaqueTokenIntrospector <span class="hljs-title">createMockIntrospector</span><span class="hljs-params">(OAuth2AuthenticatedPrincipal principal)</span> </span>{
    ReactiveOpaqueTokenIntrospector introspector = mock(ReactiveOpaqueTokenIntrospector<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(introspector.introspect(any())).willReturn(Mono.just(principal));
    <span class="hljs-keyword">return</span> introspector;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1052">Test Case ID #spring-security_Test_105_2</h4>
<h4 id="test-case-name-authenticatewhenmissingscopeattributethennoauthoritiesfile-cjavaprojectsspringspring-securityoauth2oauth2-resource-serversrctestjavaorgspringframeworksecurityoauth2serverresourceauthenticationopaquetokenreactiveauthenticationmanagertestsjava">Test Case Name: <code>authenticateWhenMissingScopeAttributeThenNoAuthorities</code>(File: <code>C:\Java_projects\Spring\spring-security\oauth2\oauth2-resource-server\src\test\java\org\springframework\security\oauth2\server\resource\authentication\OpaqueTokenReactiveAuthenticationManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-introspector">Mock Object Variable Name: <code>introspector</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenMissingScopeAttributeThenNoAuthorities() {
     OAuth2AuthenticatedPrincipal authority = new OAuth2IntrospectionAuthenticatedPrincipal(Collections.singletonMap("claim", "value"), null);
<span class="hljs-deletion">-    ReactiveOpaqueTokenIntrospector introspector = mock(ReactiveOpaqueTokenIntrospector.class);</span>
<span class="hljs-deletion">-    given(introspector.introspect(any())).willReturn(Mono.just(authority));</span>
<span class="hljs-addition">+    ReactiveOpaqueTokenIntrospector introspector = createMockIntrospector(authority);</span>
     OpaqueTokenReactiveAuthenticationManager provider = new OpaqueTokenReactiveAuthenticationManager(introspector);
     Authentication result = provider.authenticate(new BearerTokenAuthenticationToken("token")).block();
     assertThat(result.getPrincipal()).isInstanceOf(OAuth2IntrospectionAuthenticatedPrincipal.class);
     Map&lt;String, Object&gt; attributes = ((OAuth2AuthenticatedPrincipal) result.getPrincipal()).getAttributes();
     assertThat(attributes).isNotNull().doesNotContainKey(OAuth2TokenIntrospectionClaimNames.SCOPE);
     assertThat(result.getAuthorities()).isEmpty();
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenMissingScopeAttributeThenNoAuthorities</span><span class="hljs-params">()</span> </span>{

    OAuth2AuthenticatedPrincipal authority = <span class="hljs-keyword">new</span> OAuth2IntrospectionAuthenticatedPrincipal(Collections.singletonMap(<span class="hljs-string">"claim"</span>, <span class="hljs-string">"value"</span>), <span class="hljs-keyword">null</span>);

    ReactiveOpaqueTokenIntrospector introspector = mock(ReactiveOpaqueTokenIntrospector<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(introspector.introspect(any())).willReturn(Mono.just(authority));

    OpaqueTokenReactiveAuthenticationManager provider = <span class="hljs-keyword">new</span> OpaqueTokenReactiveAuthenticationManager(introspector);

    Authentication result = provider.authenticate(<span class="hljs-keyword">new</span> BearerTokenAuthenticationToken(<span class="hljs-string">"token"</span>)).block();

    assertThat(result.getPrincipal()).isInstanceOf(OAuth2IntrospectionAuthenticatedPrincipal<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    Map&lt;String, Object&gt; attributes = ((OAuth2AuthenticatedPrincipal) result.getPrincipal()).getAttributes();

    assertThat(attributes).isNotNull().doesNotContainKey(OAuth2TokenIntrospectionClaimNames.SCOPE);

    assertThat(result.getAuthorities()).isEmpty();

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ReactiveOpaqueTokenIntrospector <span class="hljs-title">createMockIntrospector</span><span class="hljs-params">(OAuth2AuthenticatedPrincipal principal)</span> </span>{
    ReactiveOpaqueTokenIntrospector introspector = mock(ReactiveOpaqueTokenIntrospector<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(introspector.introspect(any())).willReturn(Mono.just(principal));
    <span class="hljs-keyword">return</span> introspector;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1053">Test Case ID #spring-security_Test_105_3</h4>
<h4 id="test-case-name-authenticatewhencustomauthenticationconverterthenusesfile-cjavaprojectsspringspring-securityoauth2oauth2-resource-serversrctestjavaorgspringframeworksecurityoauth2serverresourceauthenticationopaquetokenreactiveauthenticationmanagertestsjava">Test Case Name: <code>authenticateWhenCustomAuthenticationConverterThenUses</code>(File: <code>C:\Java_projects\Spring\spring-security\oauth2\oauth2-resource-server\src\test\java\org\springframework\security\oauth2\server\resource\authentication\OpaqueTokenReactiveAuthenticationManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-introspector">Mock Object Variable Name: <code>introspector</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenCustomAuthenticationConverterThenUses() {
<span class="hljs-deletion">-    ReactiveOpaqueTokenIntrospector introspector = mock(ReactiveOpaqueTokenIntrospector.class);</span>
     OAuth2AuthenticatedPrincipal principal = TestOAuth2AuthenticatedPrincipals.active();
<span class="hljs-deletion">-    given(introspector.introspect(any())).willReturn(Mono.just(principal));</span>
<span class="hljs-addition">+    ReactiveOpaqueTokenIntrospector introspector = createMockIntrospector(principal);</span>
     OpaqueTokenReactiveAuthenticationManager provider = new OpaqueTokenReactiveAuthenticationManager(introspector);
     ReactiveOpaqueTokenAuthenticationConverter authenticationConverter = mock(ReactiveOpaqueTokenAuthenticationConverter.class);
     given(authenticationConverter.convert(any(), any(OAuth2AuthenticatedPrincipal.class))).willReturn(Mono.just(new TestingAuthenticationToken(principal, null, Collections.emptyList())));
     provider.setAuthenticationConverter(authenticationConverter);
     Authentication result = provider.authenticate(new BearerTokenAuthenticationToken("token")).block();
     assertThat(result).isNotNull();
     verify(introspector).introspect("token");
     verify(authenticationConverter).convert("token", principal);
     verifyNoMoreInteractions(introspector, authenticationConverter);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenCustomAuthenticationConverterThenUses</span><span class="hljs-params">()</span> </span>{

    ReactiveOpaqueTokenIntrospector introspector = mock(ReactiveOpaqueTokenIntrospector<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    OAuth2AuthenticatedPrincipal principal = TestOAuth2AuthenticatedPrincipals.active();

    given(introspector.introspect(any())).willReturn(Mono.just(principal));

    OpaqueTokenReactiveAuthenticationManager provider = <span class="hljs-keyword">new</span> OpaqueTokenReactiveAuthenticationManager(introspector);

    ReactiveOpaqueTokenAuthenticationConverter authenticationConverter = mock(ReactiveOpaqueTokenAuthenticationConverter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(authenticationConverter.convert(any(), any(OAuth2AuthenticatedPrincipal<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>(<span class="hljs-title">Mono</span>.<span class="hljs-title">just</span>(<span class="hljs-title">new</span> <span class="hljs-title">TestingAuthenticationToken</span>(<span class="hljs-title">principal</span>, <span class="hljs-title">null</span>, <span class="hljs-title">Collections</span>.<span class="hljs-title">emptyList</span>())))</span>;

    provider.setAuthenticationConverter(authenticationConverter);

    Authentication result = provider.authenticate(<span class="hljs-keyword">new</span> BearerTokenAuthenticationToken(<span class="hljs-string">"token"</span>)).block();

    assertThat(result).isNotNull();

    verify(introspector).introspect(<span class="hljs-string">"token"</span>);

    verify(authenticationConverter).convert(<span class="hljs-string">"token"</span>, principal);

    verifyNoMoreInteractions(introspector, authenticationConverter);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ReactiveOpaqueTokenIntrospector <span class="hljs-title">createMockIntrospector</span><span class="hljs-params">(OAuth2AuthenticatedPrincipal principal)</span> </span>{
    ReactiveOpaqueTokenIntrospector introspector = mock(ReactiveOpaqueTokenIntrospector<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(introspector.introspect(any())).willReturn(Mono.just(principal));
    <span class="hljs-keyword">return</span> introspector;
}
</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci106">Mock Clone Instance #spring-security_MCI_106</h2>
<ul>
<li><strong>Scope</strong>: class level</li>
<li><strong>Mocked Class</strong>: <code>org.springframework.web.server.WebFilterChain</code></li>
<li><strong>Test Case Count</strong>: 9</li>
<li><strong>MO Count</strong>: 9</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockWebFilterChain</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock WebFilterChain with the given filter behavior.
     *
     * <span class="hljs-doctag">@param</span> filterReturn the Mono to return when filter(any()) is called
     * <span class="hljs-doctag">@return</span> a mock WebFilterChain
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WebFilterChain <span class="hljs-title">createMockWebFilterChain</span><span class="hljs-params">(Mono&lt;?&gt; filterReturn)</span> </span>{
        WebFilterChain chain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(chain.filter(any())).willReturn(filterReturn);
        <span class="hljs-keyword">return</span> chain;
    }
}

</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest1061">Test Case ID #spring-security_Test_106_1</h4>
<h4 id="test-case-name-decoratewhendefaultsthenobservesfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverobservationwebfilterchaindecoratortestsjava">Test Case Name: <code>decorateWhenDefaultsThenObserves</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\ObservationWebFilterChainDecoratorTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 void decorateWhenDefaultsThenObserves() {
     ObservationHandler&lt;?&gt; handler = mock(ObservationHandler.class);
     given(handler.supportsContext(any())).willReturn(true);
     ObservationRegistry registry = ObservationRegistry.create();
     registry.observationConfig().observationHandler(handler);
     ObservationWebFilterChainDecorator decorator = new ObservationWebFilterChainDecorator(registry);
<span class="hljs-deletion">-    WebFilterChain chain = mock(WebFilterChain.class);</span>
<span class="hljs-deletion">-    given(chain.filter(any())).willReturn(Mono.empty());</span>
<span class="hljs-addition">+    WebFilterChain chain = MockWebFilterChain.createMockWebFilterChain(Mono.empty());</span>
     WebFilterChain decorated = decorator.decorate(chain);
     decorated.filter(MockServerWebExchange.from(MockServerHttpRequest.get("/").build())).block();
     verify(handler).onStart(any());
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decorateWhenDefaultsThenObserves</span><span class="hljs-params">()</span> </span>{

    ObservationHandler&lt;?&gt; handler = mock(ObservationHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(handler.supportsContext(any())).willReturn(<span class="hljs-keyword">true</span>);

    ObservationRegistry registry = ObservationRegistry.create();

    registry.observationConfig().observationHandler(handler);

    ObservationWebFilterChainDecorator decorator = <span class="hljs-keyword">new</span> ObservationWebFilterChainDecorator(registry);

    WebFilterChain chain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(chain.filter(any())).willReturn(Mono.empty());

    WebFilterChain decorated = decorator.decorate(chain);

    decorated.filter(MockServerWebExchange.from(MockServerHttpRequest.get(<span class="hljs-string">"/"</span>).build())).block();

    verify(handler).onStart(any());

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockWebFilterChain</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock WebFilterChain with the given filter behavior.
     *
     * <span class="hljs-doctag">@param</span> filterReturn the Mono to return when filter(any()) is called
     * <span class="hljs-doctag">@return</span> a mock WebFilterChain
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WebFilterChain <span class="hljs-title">createMockWebFilterChain</span><span class="hljs-params">(Mono&lt;?&gt; filterReturn)</span> </span>{
        WebFilterChain chain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(chain.filter(any())).willReturn(filterReturn);
        <span class="hljs-keyword">return</span> chain;
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1062">Test Case ID #spring-security_Test_106_2</h4>
<h4 id="test-case-name-decoratewhennoopthendoesnotobservefile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverobservationwebfilterchaindecoratortestsjava">Test Case Name: <code>decorateWhenNoopThenDoesNotObserve</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\ObservationWebFilterChainDecoratorTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 void decorateWhenNoopThenDoesNotObserve() {
     ObservationHandler&lt;?&gt; handler = mock(ObservationHandler.class);
     given(handler.supportsContext(any())).willReturn(true);
     ObservationRegistry registry = ObservationRegistry.NOOP;
     registry.observationConfig().observationHandler(handler);
     ObservationWebFilterChainDecorator decorator = new ObservationWebFilterChainDecorator(registry);
<span class="hljs-deletion">-    WebFilterChain chain = mock(WebFilterChain.class);</span>
<span class="hljs-deletion">-    given(chain.filter(any())).willReturn(Mono.empty());</span>
<span class="hljs-addition">+    WebFilterChain chain = MockWebFilterChain.createMockWebFilterChain(Mono.empty());</span>
     WebFilterChain decorated = decorator.decorate(chain);
     decorated.filter(MockServerWebExchange.from(MockServerHttpRequest.get("/").build())).block();
     verifyNoInteractions(handler);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decorateWhenNoopThenDoesNotObserve</span><span class="hljs-params">()</span> </span>{

    ObservationHandler&lt;?&gt; handler = mock(ObservationHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(handler.supportsContext(any())).willReturn(<span class="hljs-keyword">true</span>);

    ObservationRegistry registry = ObservationRegistry.NOOP;

    registry.observationConfig().observationHandler(handler);

    ObservationWebFilterChainDecorator decorator = <span class="hljs-keyword">new</span> ObservationWebFilterChainDecorator(registry);

    WebFilterChain chain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(chain.filter(any())).willReturn(Mono.empty());

    WebFilterChain decorated = decorator.decorate(chain);

    decorated.filter(MockServerWebExchange.from(MockServerHttpRequest.get(<span class="hljs-string">"/"</span>).build())).block();

    verifyNoInteractions(handler);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockWebFilterChain</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock WebFilterChain with the given filter behavior.
     *
     * <span class="hljs-doctag">@param</span> filterReturn the Mono to return when filter(any()) is called
     * <span class="hljs-doctag">@return</span> a mock WebFilterChain
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WebFilterChain <span class="hljs-title">createMockWebFilterChain</span><span class="hljs-params">(Mono&lt;?&gt; filterReturn)</span> </span>{
        WebFilterChain chain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(chain.filter(any())).willReturn(filterReturn);
        <span class="hljs-keyword">return</span> chain;
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1063">Test Case ID #spring-security_Test_106_3</h4>
<h4 id="test-case-name-decoratewhenterminatingfilterthenobservesfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverobservationwebfilterchaindecoratortestsjava">Test Case Name: <code>decorateWhenTerminatingFilterThenObserves</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\ObservationWebFilterChainDecoratorTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 void decorateWhenTerminatingFilterThenObserves() {
     AccumulatingObservationHandler handler = new AccumulatingObservationHandler();
     ObservationRegistry registry = ObservationRegistry.create();
     registry.observationConfig().observationHandler(handler);
     ObservationWebFilterChainDecorator decorator = new ObservationWebFilterChainDecorator(registry);
<span class="hljs-deletion">-    WebFilterChain chain = mock(WebFilterChain.class);</span>
<span class="hljs-deletion">-    given(chain.filter(any())).willReturn(Mono.error(() -&gt; new Exception("ack")));</span>
<span class="hljs-addition">+    WebFilterChain chain = MockWebFilterChain.createMockWebFilterChain(Mono.error(() -&gt; new Exception("ack")));</span>
     WebFilterChain decorated = decorator.decorate(chain, List.of(new BasicAuthenticationFilter(), new TerminatingFilter()));
     Observation http = Observation.start("http", registry).contextualName("http");
     try {
         decorated.filter(MockServerWebExchange.from(MockServerHttpRequest.get("/").build())).contextWrite((context) -&gt; context.put(ObservationThreadLocalAccessor.KEY, http)).block();
     } catch (Exception ex) {
         http.error(ex);
     } finally {
         http.stop();
     }
     handler.assertSpanStart(0, "http", null);
     handler.assertSpanStart(1, "spring.security.filterchains", "http");
     handler.assertSpanStop(2, "security filterchain before");
     handler.assertSpanStart(3, "spring.security.filterchains", "http");
     handler.assertSpanStop(4, "security filterchain after");
     handler.assertSpanStop(5, "http");
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decorateWhenTerminatingFilterThenObserves</span><span class="hljs-params">()</span> </span>{

    AccumulatingObservationHandler handler = <span class="hljs-keyword">new</span> AccumulatingObservationHandler();

    ObservationRegistry registry = ObservationRegistry.create();

    registry.observationConfig().observationHandler(handler);

    ObservationWebFilterChainDecorator decorator = <span class="hljs-keyword">new</span> ObservationWebFilterChainDecorator(registry);

    WebFilterChain chain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(chain.filter(any())).willReturn(Mono.error(() -&gt; <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"ack"</span>)));

    WebFilterChain decorated = decorator.decorate(chain, List.of(<span class="hljs-keyword">new</span> BasicAuthenticationFilter(), <span class="hljs-keyword">new</span> TerminatingFilter()));

    Observation http = Observation.start(<span class="hljs-string">"http"</span>, registry).contextualName(<span class="hljs-string">"http"</span>);

    <span class="hljs-keyword">try</span> {

        decorated.filter(MockServerWebExchange.from(MockServerHttpRequest.get(<span class="hljs-string">"/"</span>).build())).contextWrite((context) -&gt; context.put(ObservationThreadLocalAccessor.KEY, http)).block();

    } <span class="hljs-keyword">catch</span> (Exception ex) {

        http.error(ex);

    } <span class="hljs-keyword">finally</span> {

        http.stop();

    }

    handler.assertSpanStart(<span class="hljs-number">0</span>, <span class="hljs-string">"http"</span>, <span class="hljs-keyword">null</span>);

    handler.assertSpanStart(<span class="hljs-number">1</span>, <span class="hljs-string">"spring.security.filterchains"</span>, <span class="hljs-string">"http"</span>);

    handler.assertSpanStop(<span class="hljs-number">2</span>, <span class="hljs-string">"security filterchain before"</span>);

    handler.assertSpanStart(<span class="hljs-number">3</span>, <span class="hljs-string">"spring.security.filterchains"</span>, <span class="hljs-string">"http"</span>);

    handler.assertSpanStop(<span class="hljs-number">4</span>, <span class="hljs-string">"security filterchain after"</span>);

    handler.assertSpanStop(<span class="hljs-number">5</span>, <span class="hljs-string">"http"</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockWebFilterChain</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock WebFilterChain with the given filter behavior.
     *
     * <span class="hljs-doctag">@param</span> filterReturn the Mono to return when filter(any()) is called
     * <span class="hljs-doctag">@return</span> a mock WebFilterChain
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WebFilterChain <span class="hljs-title">createMockWebFilterChain</span><span class="hljs-params">(Mono&lt;?&gt; filterReturn)</span> </span>{
        WebFilterChain chain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(chain.filter(any())).willReturn(filterReturn);
        <span class="hljs-keyword">return</span> chain;
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1064">Test Case ID #spring-security_Test_106_4</h4>
<h4 id="test-case-name-decoratewhenerrorsignalthenstopsobservationfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverobservationwebfilterchaindecoratortestsjava">Test Case Name: <code>decorateWhenErrorSignalThenStopsObservation</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\ObservationWebFilterChainDecoratorTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 void decorateWhenErrorSignalThenStopsObservation() {
     AccumulatingObservationHandler handler = new AccumulatingObservationHandler();
     ObservationRegistry registry = ObservationRegistry.create();
     registry.observationConfig().observationHandler(handler);
     ObservationWebFilterChainDecorator decorator = new ObservationWebFilterChainDecorator(registry);
<span class="hljs-deletion">-    WebFilterChain chain = mock(WebFilterChain.class);</span>
<span class="hljs-deletion">-    given(chain.filter(any())).willReturn(Mono.error(() -&gt; new Exception("ack")));</span>
<span class="hljs-addition">+    WebFilterChain chain = MockWebFilterChain.createMockWebFilterChain(Mono.error(() -&gt; new Exception("ack")));</span>
     WebFilterChain decorated = decorator.decorate(chain, List.of(new BasicAuthenticationFilter()));
     Observation http = Observation.start("http", registry).contextualName("http");
     try {
         decorated.filter(MockServerWebExchange.from(MockServerHttpRequest.get("/").build())).contextWrite((context) -&gt; context.put(ObservationThreadLocalAccessor.KEY, http)).block();
     } catch (Exception ex) {
         http.error(ex);
     } finally {
         http.stop();
     }
     handler.assertSpanStart(0, "http", null);
     handler.assertSpanStart(1, "spring.security.filterchains", "http");
     handler.assertSpanStop(2, "security filterchain before");
     handler.assertSpanStart(3, "secured request", "security filterchain before");
     handler.assertSpanError(4);
     handler.assertSpanStop(5, "secured request");
     handler.assertSpanStart(6, "spring.security.filterchains", "http");
     handler.assertSpanError(7);
     handler.assertSpanStop(8, "security filterchain after");
     handler.assertSpanError(9);
     handler.assertSpanStop(10, "http");
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decorateWhenErrorSignalThenStopsObservation</span><span class="hljs-params">()</span> </span>{

    AccumulatingObservationHandler handler = <span class="hljs-keyword">new</span> AccumulatingObservationHandler();

    ObservationRegistry registry = ObservationRegistry.create();

    registry.observationConfig().observationHandler(handler);

    ObservationWebFilterChainDecorator decorator = <span class="hljs-keyword">new</span> ObservationWebFilterChainDecorator(registry);

    WebFilterChain chain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(chain.filter(any())).willReturn(Mono.error(() -&gt; <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"ack"</span>)));

    WebFilterChain decorated = decorator.decorate(chain, List.of(<span class="hljs-keyword">new</span> BasicAuthenticationFilter()));

    Observation http = Observation.start(<span class="hljs-string">"http"</span>, registry).contextualName(<span class="hljs-string">"http"</span>);

    <span class="hljs-keyword">try</span> {

        decorated.filter(MockServerWebExchange.from(MockServerHttpRequest.get(<span class="hljs-string">"/"</span>).build())).contextWrite((context) -&gt; context.put(ObservationThreadLocalAccessor.KEY, http)).block();

    } <span class="hljs-keyword">catch</span> (Exception ex) {

        http.error(ex);

    } <span class="hljs-keyword">finally</span> {

        http.stop();

    }

    handler.assertSpanStart(<span class="hljs-number">0</span>, <span class="hljs-string">"http"</span>, <span class="hljs-keyword">null</span>);

    handler.assertSpanStart(<span class="hljs-number">1</span>, <span class="hljs-string">"spring.security.filterchains"</span>, <span class="hljs-string">"http"</span>);

    handler.assertSpanStop(<span class="hljs-number">2</span>, <span class="hljs-string">"security filterchain before"</span>);

    handler.assertSpanStart(<span class="hljs-number">3</span>, <span class="hljs-string">"secured request"</span>, <span class="hljs-string">"security filterchain before"</span>);

    handler.assertSpanError(<span class="hljs-number">4</span>);

    handler.assertSpanStop(<span class="hljs-number">5</span>, <span class="hljs-string">"secured request"</span>);

    handler.assertSpanStart(<span class="hljs-number">6</span>, <span class="hljs-string">"spring.security.filterchains"</span>, <span class="hljs-string">"http"</span>);

    handler.assertSpanError(<span class="hljs-number">7</span>);

    handler.assertSpanStop(<span class="hljs-number">8</span>, <span class="hljs-string">"security filterchain after"</span>);

    handler.assertSpanError(<span class="hljs-number">9</span>);

    handler.assertSpanStop(<span class="hljs-number">10</span>, <span class="hljs-string">"http"</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockWebFilterChain</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock WebFilterChain with the given filter behavior.
     *
     * <span class="hljs-doctag">@param</span> filterReturn the Mono to return when filter(any()) is called
     * <span class="hljs-doctag">@return</span> a mock WebFilterChain
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WebFilterChain <span class="hljs-title">createMockWebFilterChain</span><span class="hljs-params">(Mono&lt;?&gt; filterReturn)</span> </span>{
        WebFilterChain chain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(chain.filter(any())).willReturn(filterReturn);
        <span class="hljs-keyword">return</span> chain;
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1065">Test Case ID #spring-security_Test_106_5</h4>
<h4 id="test-case-name-decoratewhencustomafterfilterthenobservesfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverobservationwebfilterchaindecoratortestsjava">Test Case Name: <code>decorateWhenCustomAfterFilterThenObserves</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\ObservationWebFilterChainDecoratorTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 // gh-12849
 @Test
 void decorateWhenCustomAfterFilterThenObserves() {
     AccumulatingObservationHandler handler = new AccumulatingObservationHandler();
     ObservationRegistry registry = ObservationRegistry.create();
     registry.observationConfig().observationHandler(handler);
     ObservationWebFilterChainDecorator decorator = new ObservationWebFilterChainDecorator(registry);
     WebFilter mock = mock(WebFilter.class);
     given(mock.filter(any(), any())).willReturn(Mono.empty());
<span class="hljs-deletion">-    WebFilterChain chain = mock(WebFilterChain.class);</span>
<span class="hljs-deletion">-    given(chain.filter(any())).willReturn(Mono.empty());</span>
<span class="hljs-addition">+    WebFilterChain chain = MockWebFilterChain.createMockWebFilterChain(Mono.empty());</span>
     WebFilterChain decorated = decorator.decorate(chain, List.of((e, c) -&gt; c.filter(e).then(Mono.deferContextual((context) -&gt; {
         Observation parentObservation = context.getOrDefault(ObservationThreadLocalAccessor.KEY, null);
         Observation observation = Observation.createNotStarted("custom", registry).parentObservation(parentObservation).contextualName("custom").start();
         return Mono.just("3").doOnSuccess((v) -&gt; observation.stop()).doOnCancel(observation::stop).doOnError((t) -&gt; {
             observation.error(t);
             observation.stop();
         }).then(Mono.empty());
     }))));
     Observation http = Observation.start("http", registry).contextualName("http");
     try {
         decorated.filter(MockServerWebExchange.from(MockServerHttpRequest.get("/").build())).contextWrite((context) -&gt; context.put(ObservationThreadLocalAccessor.KEY, http)).block();
     } finally {
         http.stop();
     }
     handler.assertSpanStart(0, "http", null);
     handler.assertSpanStart(1, "spring.security.filterchains", "http");
     handler.assertSpanStop(2, "security filterchain before");
     handler.assertSpanStart(3, "secured request", "security filterchain before");
     handler.assertSpanStop(4, "secured request");
     handler.assertSpanStart(5, "spring.security.filterchains", "http");
     handler.assertSpanStart(6, "custom", "spring.security.filterchains");
     handler.assertSpanStop(7, "custom");
     handler.assertSpanStop(8, "security filterchain after");
     handler.assertSpanStop(9, "http");
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-comment">// gh-12849</span>

<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decorateWhenCustomAfterFilterThenObserves</span><span class="hljs-params">()</span> </span>{

    AccumulatingObservationHandler handler = <span class="hljs-keyword">new</span> AccumulatingObservationHandler();

    ObservationRegistry registry = ObservationRegistry.create();

    registry.observationConfig().observationHandler(handler);

    ObservationWebFilterChainDecorator decorator = <span class="hljs-keyword">new</span> ObservationWebFilterChainDecorator(registry);

    WebFilter mock = mock(WebFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(mock.filter(any(), any())).willReturn(Mono.empty());

    WebFilterChain chain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(chain.filter(any())).willReturn(Mono.empty());

    WebFilterChain decorated = decorator.decorate(chain, List.of((e, c) -&gt; c.filter(e).then(Mono.deferContextual((context) -&gt; {

        Observation parentObservation = context.getOrDefault(ObservationThreadLocalAccessor.KEY, <span class="hljs-keyword">null</span>);

        Observation observation = Observation.createNotStarted(<span class="hljs-string">"custom"</span>, registry).parentObservation(parentObservation).contextualName(<span class="hljs-string">"custom"</span>).start();

        <span class="hljs-keyword">return</span> Mono.just(<span class="hljs-string">"3"</span>).doOnSuccess((v) -&gt; observation.stop()).doOnCancel(observation::stop).doOnError((t) -&gt; {

            observation.error(t);

            observation.stop();

        }).then(Mono.empty());

    }))));

    Observation http = Observation.start(<span class="hljs-string">"http"</span>, registry).contextualName(<span class="hljs-string">"http"</span>);

    <span class="hljs-keyword">try</span> {

        decorated.filter(MockServerWebExchange.from(MockServerHttpRequest.get(<span class="hljs-string">"/"</span>).build())).contextWrite((context) -&gt; context.put(ObservationThreadLocalAccessor.KEY, http)).block();

    } <span class="hljs-keyword">finally</span> {

        http.stop();

    }

    handler.assertSpanStart(<span class="hljs-number">0</span>, <span class="hljs-string">"http"</span>, <span class="hljs-keyword">null</span>);

    handler.assertSpanStart(<span class="hljs-number">1</span>, <span class="hljs-string">"spring.security.filterchains"</span>, <span class="hljs-string">"http"</span>);

    handler.assertSpanStop(<span class="hljs-number">2</span>, <span class="hljs-string">"security filterchain before"</span>);

    handler.assertSpanStart(<span class="hljs-number">3</span>, <span class="hljs-string">"secured request"</span>, <span class="hljs-string">"security filterchain before"</span>);

    handler.assertSpanStop(<span class="hljs-number">4</span>, <span class="hljs-string">"secured request"</span>);

    handler.assertSpanStart(<span class="hljs-number">5</span>, <span class="hljs-string">"spring.security.filterchains"</span>, <span class="hljs-string">"http"</span>);

    handler.assertSpanStart(<span class="hljs-number">6</span>, <span class="hljs-string">"custom"</span>, <span class="hljs-string">"spring.security.filterchains"</span>);

    handler.assertSpanStop(<span class="hljs-number">7</span>, <span class="hljs-string">"custom"</span>);

    handler.assertSpanStop(<span class="hljs-number">8</span>, <span class="hljs-string">"security filterchain after"</span>);

    handler.assertSpanStop(<span class="hljs-number">9</span>, <span class="hljs-string">"http"</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockWebFilterChain</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock WebFilterChain with the given filter behavior.
     *
     * <span class="hljs-doctag">@param</span> filterReturn the Mono to return when filter(any()) is called
     * <span class="hljs-doctag">@return</span> a mock WebFilterChain
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WebFilterChain <span class="hljs-title">createMockWebFilterChain</span><span class="hljs-params">(Mono&lt;?&gt; filterReturn)</span> </span>{
        WebFilterChain chain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(chain.filter(any())).willReturn(filterReturn);
        <span class="hljs-keyword">return</span> chain;
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1066">Test Case ID #spring-security_Test_106_6</h4>
<h4 id="test-case-name-decoratefilterswhencompletesthenhasspringsecurityreachedfilternametagfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverobservationwebfilterchaindecoratortestsjava">Test Case Name: <code>decorateFiltersWhenCompletesThenHasSpringSecurityReachedFilterNameTag</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\ObservationWebFilterChainDecoratorTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @ParameterizedTest
 @MethodSource("decorateFiltersWhenCompletesThenHasSpringSecurityReachedFilterNameTagArguments")
 void decorateFiltersWhenCompletesThenHasSpringSecurityReachedFilterNameTag(WebFilter filter, String expectedFilterNameTag) {
     ObservationHandler&lt;Observation.Context&gt; handler = mock(ObservationHandler.class);
     given(handler.supportsContext(any())).willReturn(true);
     ObservationRegistry registry = ObservationRegistry.create();
     registry.observationConfig().observationHandler(handler);
     ObservationWebFilterChainDecorator decorator = new ObservationWebFilterChainDecorator(registry);
<span class="hljs-deletion">-    WebFilterChain chain = mock(WebFilterChain.class);</span>
<span class="hljs-deletion">-    given(chain.filter(any())).willReturn(Mono.empty());</span>
<span class="hljs-addition">+    WebFilterChain chain = MockWebFilterChain.createMockWebFilterChain(Mono.empty());</span>
     WebFilterChain decorated = decorator.decorate(chain, List.of(filter));
     decorated.filter(MockServerWebExchange.from(MockServerHttpRequest.get("/").build())).block();
     ArgumentCaptor&lt;Observation.Context&gt; context = ArgumentCaptor.forClass(Observation.Context.class);
     verify(handler, times(3)).onStop(context.capture());
     assertThat(context.getValue().getLowCardinalityKeyValue("spring.security.reached.filter.name").getValue()).isEqualTo(expectedFilterNameTag);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@ParameterizedTest</span>

<span class="hljs-meta">@MethodSource</span>(<span class="hljs-string">"decorateFiltersWhenCompletesThenHasSpringSecurityReachedFilterNameTagArguments"</span>)

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decorateFiltersWhenCompletesThenHasSpringSecurityReachedFilterNameTag</span><span class="hljs-params">(WebFilter filter, String expectedFilterNameTag)</span> </span>{

    ObservationHandler&lt;Observation.Context&gt; handler = mock(ObservationHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(handler.supportsContext(any())).willReturn(<span class="hljs-keyword">true</span>);

    ObservationRegistry registry = ObservationRegistry.create();

    registry.observationConfig().observationHandler(handler);

    ObservationWebFilterChainDecorator decorator = <span class="hljs-keyword">new</span> ObservationWebFilterChainDecorator(registry);

    WebFilterChain chain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(chain.filter(any())).willReturn(Mono.empty());

    WebFilterChain decorated = decorator.decorate(chain, List.of(filter));

    decorated.filter(MockServerWebExchange.from(MockServerHttpRequest.get(<span class="hljs-string">"/"</span>).build())).block();

    ArgumentCaptor&lt;Observation.Context&gt; context = ArgumentCaptor.forClass(Observation.Context<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    verify(handler, times(<span class="hljs-number">3</span>)).onStop(context.capture());

    assertThat(context.getValue().getLowCardinalityKeyValue(<span class="hljs-string">"spring.security.reached.filter.name"</span>).getValue()).isEqualTo(expectedFilterNameTag);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockWebFilterChain</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock WebFilterChain with the given filter behavior.
     *
     * <span class="hljs-doctag">@param</span> filterReturn the Mono to return when filter(any()) is called
     * <span class="hljs-doctag">@return</span> a mock WebFilterChain
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WebFilterChain <span class="hljs-title">createMockWebFilterChain</span><span class="hljs-params">(Mono&lt;?&gt; filterReturn)</span> </span>{
        WebFilterChain chain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(chain.filter(any())).willReturn(filterReturn);
        <span class="hljs-keyword">return</span> chain;
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1067">Test Case ID #spring-security_Test_106_7</h4>
<h4 id="test-case-name-dofilterwhenmatchesthenobservationregistryobservesfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverwebfilterchainproxytestsjava">Test Case Name: <code>doFilterWhenMatchesThenObservationRegistryObserves</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\WebFilterChainProxyTests.java</code>)</h4>
<h4 id="mock-object-variable-name-mockchain">Mock Object Variable Name: <code>mockChain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void doFilterWhenMatchesThenObservationRegistryObserves() {
     ObservationHandler&lt;Observation.Context&gt; handler = mock(ObservationHandler.class);
     given(handler.supportsContext(any())).willReturn(true);
     ObservationRegistry registry = ObservationRegistry.create();
     registry.observationConfig().observationHandler(handler);
     List&lt;WebFilter&gt; filters = Arrays.asList(new PassthroughWebFilter());
     ServerWebExchangeMatcher match = (exchange) -&gt; MatchResult.match();
     MatcherSecurityWebFilterChain chain = new MatcherSecurityWebFilterChain(match, filters);
     WebFilterChainProxy fcp = new WebFilterChainProxy(chain);
     fcp.setFilterChainDecorator(new ObservationWebFilterChainDecorator(registry));
     WebFilter filter = WebFilterObservation.create(Observation.createNotStarted("wrap", registry)).wrap(fcp);
<span class="hljs-deletion">-    WebFilterChain mockChain = mock(WebFilterChain.class);</span>
<span class="hljs-deletion">-    given(mockChain.filter(any())).willReturn(Mono.empty());</span>
<span class="hljs-addition">+    WebFilterChain mockChain = MockWebFilterChain.createMockWebFilterChain(Mono.empty());</span>
     filter.filter(MockServerWebExchange.from(MockServerHttpRequest.get("/")), mockChain).block();
     ArgumentCaptor&lt;Observation.Context&gt; captor = ArgumentCaptor.forClass(Observation.Context.class);
     verify(handler, times(4)).onStart(captor.capture());
     Iterator&lt;Observation.Context&gt; contexts = captor.getAllValues().iterator();
     assertThat(contexts.next().getName()).isEqualTo("wrap");
     assertFilterChainObservation(contexts.next(), "before", 1);
     assertThat(contexts.next().getName()).isEqualTo(ObservationWebFilterChainDecorator.SECURED_OBSERVATION_NAME);
     assertFilterChainObservation(contexts.next(), "after", 1);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterWhenMatchesThenObservationRegistryObserves</span><span class="hljs-params">()</span> </span>{

    ObservationHandler&lt;Observation.Context&gt; handler = mock(ObservationHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(handler.supportsContext(any())).willReturn(<span class="hljs-keyword">true</span>);

    ObservationRegistry registry = ObservationRegistry.create();

    registry.observationConfig().observationHandler(handler);

    List&lt;WebFilter&gt; filters = Arrays.asList(<span class="hljs-keyword">new</span> PassthroughWebFilter());

    ServerWebExchangeMatcher match = (exchange) -&gt; MatchResult.match();

    MatcherSecurityWebFilterChain chain = <span class="hljs-keyword">new</span> MatcherSecurityWebFilterChain(match, filters);

    WebFilterChainProxy fcp = <span class="hljs-keyword">new</span> WebFilterChainProxy(chain);

    fcp.setFilterChainDecorator(<span class="hljs-keyword">new</span> ObservationWebFilterChainDecorator(registry));

    WebFilter filter = WebFilterObservation.create(Observation.createNotStarted(<span class="hljs-string">"wrap"</span>, registry)).wrap(fcp);

    WebFilterChain mockChain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(mockChain.filter(any())).willReturn(Mono.empty());

    filter.filter(MockServerWebExchange.from(MockServerHttpRequest.get(<span class="hljs-string">"/"</span>)), mockChain).block();

    ArgumentCaptor&lt;Observation.Context&gt; captor = ArgumentCaptor.forClass(Observation.Context<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    verify(handler, times(<span class="hljs-number">4</span>)).onStart(captor.capture());

    Iterator&lt;Observation.Context&gt; contexts = captor.getAllValues().iterator();

    assertThat(contexts.next().getName()).isEqualTo(<span class="hljs-string">"wrap"</span>);

    assertFilterChainObservation(contexts.next(), <span class="hljs-string">"before"</span>, <span class="hljs-number">1</span>);

    assertThat(contexts.next().getName()).isEqualTo(ObservationWebFilterChainDecorator.SECURED_OBSERVATION_NAME);

    assertFilterChainObservation(contexts.next(), <span class="hljs-string">"after"</span>, <span class="hljs-number">1</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockWebFilterChain</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock WebFilterChain with the given filter behavior.
     *
     * <span class="hljs-doctag">@param</span> filterReturn the Mono to return when filter(any()) is called
     * <span class="hljs-doctag">@return</span> a mock WebFilterChain
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WebFilterChain <span class="hljs-title">createMockWebFilterChain</span><span class="hljs-params">(Mono&lt;?&gt; filterReturn)</span> </span>{
        WebFilterChain chain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(chain.filter(any())).willReturn(filterReturn);
        <span class="hljs-keyword">return</span> chain;
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1068">Test Case ID #spring-security_Test_106_8</h4>
<h4 id="test-case-name-dofilterwhenmismatchesthenobservationregistryobservesfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverwebfilterchainproxytestsjava">Test Case Name: <code>doFilterWhenMismatchesThenObservationRegistryObserves</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\WebFilterChainProxyTests.java</code>)</h4>
<h4 id="mock-object-variable-name-mockchain">Mock Object Variable Name: <code>mockChain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void doFilterWhenMismatchesThenObservationRegistryObserves() {
     ObservationHandler&lt;Observation.Context&gt; handler = mock(ObservationHandler.class);
     given(handler.supportsContext(any())).willReturn(true);
     ObservationRegistry registry = ObservationRegistry.create();
     registry.observationConfig().observationHandler(handler);
     List&lt;WebFilter&gt; filters = Arrays.asList(new PassthroughWebFilter());
     ServerWebExchangeMatcher notMatch = (exchange) -&gt; MatchResult.notMatch();
     MatcherSecurityWebFilterChain chain = new MatcherSecurityWebFilterChain(notMatch, filters);
     WebFilterChainProxy fcp = new WebFilterChainProxy(chain);
     fcp.setFilterChainDecorator(new ObservationWebFilterChainDecorator(registry));
     WebFilter filter = WebFilterObservation.create(Observation.createNotStarted("wrap", registry)).wrap(fcp);
<span class="hljs-deletion">-    WebFilterChain mockChain = mock(WebFilterChain.class);</span>
<span class="hljs-deletion">-    given(mockChain.filter(any())).willReturn(Mono.empty());</span>
<span class="hljs-addition">+    WebFilterChain mockChain = MockWebFilterChain.createMockWebFilterChain(Mono.empty());</span>
     filter.filter(MockServerWebExchange.from(MockServerHttpRequest.get("/")), mockChain).block();
     ArgumentCaptor&lt;Observation.Context&gt; captor = ArgumentCaptor.forClass(Observation.Context.class);
     verify(handler, times(2)).onStart(captor.capture());
     Iterator&lt;Observation.Context&gt; contexts = captor.getAllValues().iterator();
     assertThat(contexts.next().getName()).isEqualTo("wrap");
     assertThat(contexts.next().getName()).isEqualTo(ObservationWebFilterChainDecorator.UNSECURED_OBSERVATION_NAME);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterWhenMismatchesThenObservationRegistryObserves</span><span class="hljs-params">()</span> </span>{

    ObservationHandler&lt;Observation.Context&gt; handler = mock(ObservationHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(handler.supportsContext(any())).willReturn(<span class="hljs-keyword">true</span>);

    ObservationRegistry registry = ObservationRegistry.create();

    registry.observationConfig().observationHandler(handler);

    List&lt;WebFilter&gt; filters = Arrays.asList(<span class="hljs-keyword">new</span> PassthroughWebFilter());

    ServerWebExchangeMatcher notMatch = (exchange) -&gt; MatchResult.notMatch();

    MatcherSecurityWebFilterChain chain = <span class="hljs-keyword">new</span> MatcherSecurityWebFilterChain(notMatch, filters);

    WebFilterChainProxy fcp = <span class="hljs-keyword">new</span> WebFilterChainProxy(chain);

    fcp.setFilterChainDecorator(<span class="hljs-keyword">new</span> ObservationWebFilterChainDecorator(registry));

    WebFilter filter = WebFilterObservation.create(Observation.createNotStarted(<span class="hljs-string">"wrap"</span>, registry)).wrap(fcp);

    WebFilterChain mockChain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(mockChain.filter(any())).willReturn(Mono.empty());

    filter.filter(MockServerWebExchange.from(MockServerHttpRequest.get(<span class="hljs-string">"/"</span>)), mockChain).block();

    ArgumentCaptor&lt;Observation.Context&gt; captor = ArgumentCaptor.forClass(Observation.Context<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    verify(handler, times(<span class="hljs-number">2</span>)).onStart(captor.capture());

    Iterator&lt;Observation.Context&gt; contexts = captor.getAllValues().iterator();

    assertThat(contexts.next().getName()).isEqualTo(<span class="hljs-string">"wrap"</span>);

    assertThat(contexts.next().getName()).isEqualTo(ObservationWebFilterChainDecorator.UNSECURED_OBSERVATION_NAME);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockWebFilterChain</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock WebFilterChain with the given filter behavior.
     *
     * <span class="hljs-doctag">@param</span> filterReturn the Mono to return when filter(any()) is called
     * <span class="hljs-doctag">@return</span> a mock WebFilterChain
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WebFilterChain <span class="hljs-title">createMockWebFilterChain</span><span class="hljs-params">(Mono&lt;?&gt; filterReturn)</span> </span>{
        WebFilterChain chain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(chain.filter(any())).willReturn(filterReturn);
        <span class="hljs-keyword">return</span> chain;
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1069">Test Case ID #spring-security_Test_106_9</h4>
<h4 id="test-case-name-dofilterwhenfilterexceptionthenobservationregistryobservesfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverwebfilterchainproxytestsjava">Test Case Name: <code>doFilterWhenFilterExceptionThenObservationRegistryObserves</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\WebFilterChainProxyTests.java</code>)</h4>
<h4 id="mock-object-variable-name-mockchain">Mock Object Variable Name: <code>mockChain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void doFilterWhenFilterExceptionThenObservationRegistryObserves() {
     ObservationHandler&lt;Observation.Context&gt; handler = mock(ObservationHandler.class);
     given(handler.supportsContext(any())).willReturn(true);
     ObservationRegistry registry = ObservationRegistry.create();
     registry.observationConfig().observationHandler(handler);
     WebFilter error = mock(WebFilter.class);
     given(error.filter(any(), any())).willReturn(Mono.error(new IllegalStateException()));
     List&lt;WebFilter&gt; filters = Arrays.asList(error);
     ServerWebExchangeMatcher match = (exchange) -&gt; MatchResult.match();
     MatcherSecurityWebFilterChain chain = new MatcherSecurityWebFilterChain(match, filters);
     WebFilterChainProxy fcp = new WebFilterChainProxy(chain);
     fcp.setFilterChainDecorator(new ObservationWebFilterChainDecorator(registry));
     WebFilter filter = WebFilterObservation.create(Observation.createNotStarted("wrap", registry)).wrap(fcp);
<span class="hljs-deletion">-    WebFilterChain mockChain = mock(WebFilterChain.class);</span>
<span class="hljs-deletion">-    given(mockChain.filter(any())).willReturn(Mono.empty());</span>
<span class="hljs-addition">+    WebFilterChain mockChain = MockWebFilterChain.createMockWebFilterChain(Mono.empty());</span>
     assertThatExceptionOfType(IllegalStateException.class).isThrownBy(() -&gt; filter.filter(MockServerWebExchange.from(MockServerHttpRequest.get("/")), mockChain).block());
     ArgumentCaptor&lt;Observation.Context&gt; captor = ArgumentCaptor.forClass(Observation.Context.class);
     verify(handler, times(2)).onStart(captor.capture());
     verify(handler, atLeastOnce()).onError(any());
     Iterator&lt;Observation.Context&gt; contexts = captor.getAllValues().iterator();
     assertThat(contexts.next().getName()).isEqualTo("wrap");
     assertFilterChainObservation(contexts.next(), "before", 1);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterWhenFilterExceptionThenObservationRegistryObserves</span><span class="hljs-params">()</span> </span>{

    ObservationHandler&lt;Observation.Context&gt; handler = mock(ObservationHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(handler.supportsContext(any())).willReturn(<span class="hljs-keyword">true</span>);

    ObservationRegistry registry = ObservationRegistry.create();

    registry.observationConfig().observationHandler(handler);

    WebFilter error = mock(WebFilter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(error.filter(any(), any())).willReturn(Mono.error(<span class="hljs-keyword">new</span> IllegalStateException()));

    List&lt;WebFilter&gt; filters = Arrays.asList(error);

    ServerWebExchangeMatcher match = (exchange) -&gt; MatchResult.match();

    MatcherSecurityWebFilterChain chain = <span class="hljs-keyword">new</span> MatcherSecurityWebFilterChain(match, filters);

    WebFilterChainProxy fcp = <span class="hljs-keyword">new</span> WebFilterChainProxy(chain);

    fcp.setFilterChainDecorator(<span class="hljs-keyword">new</span> ObservationWebFilterChainDecorator(registry));

    WebFilter filter = WebFilterObservation.create(Observation.createNotStarted(<span class="hljs-string">"wrap"</span>, registry)).wrap(fcp);

    WebFilterChain mockChain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(mockChain.filter(any())).willReturn(Mono.empty());

    assertThatExceptionOfType(IllegalStateException<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">isThrownBy</span>(() -&gt; <span class="hljs-title">filter</span>.<span class="hljs-title">filter</span>(<span class="hljs-title">MockServerWebExchange</span>.<span class="hljs-title">from</span>(<span class="hljs-title">MockServerHttpRequest</span>.<span class="hljs-title">get</span>("/")), <span class="hljs-title">mockChain</span>).<span class="hljs-title">block</span>())</span>;

    ArgumentCaptor&lt;Observation.Context&gt; captor = ArgumentCaptor.forClass(Observation.Context<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    verify(handler, times(<span class="hljs-number">2</span>)).onStart(captor.capture());

    verify(handler, atLeastOnce()).onError(any());

    Iterator&lt;Observation.Context&gt; contexts = captor.getAllValues().iterator();

    assertThat(contexts.next().getName()).isEqualTo(<span class="hljs-string">"wrap"</span>);

    assertFilterChainObservation(contexts.next(), <span class="hljs-string">"before"</span>, <span class="hljs-number">1</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockWebFilterChain</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock WebFilterChain with the given filter behavior.
     *
     * <span class="hljs-doctag">@param</span> filterReturn the Mono to return when filter(any()) is called
     * <span class="hljs-doctag">@return</span> a mock WebFilterChain
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WebFilterChain <span class="hljs-title">createMockWebFilterChain</span><span class="hljs-params">(Mono&lt;?&gt; filterReturn)</span> </span>{
        WebFilterChain chain = mock(WebFilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(chain.filter(any())).willReturn(filterReturn);
        <span class="hljs-keyword">return</span> chain;
    }
}

</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci151">Mock Clone Instance #spring-security_MCI_151</h2>
<ul>
<li><strong>Scope</strong>: method level</li>
<li><strong>Mocked Class</strong>: <code>org.springframework.security.web.server.util.matcher.ServerWebExchangeMatcher</code></li>
<li><strong>Test Case Count</strong>: 3</li>
<li><strong>MO Count</strong>: 4</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ServerWebExchangeMatcher <span class="hljs-title">createMockMatcher</span><span class="hljs-params">(MatchResult matchResult, ServerWebExchange exchange)</span> </span>{
    ServerWebExchangeMatcher matcher = mock(ServerWebExchangeMatcher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(matcher.matches(exchange)).willReturn(matchResult);
    <span class="hljs-keyword">return</span> matcher;
}
</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest1511">Test Case ID #spring-security_Test_151_1</h4>
<h4 id="test-case-name-handlewhennothingmatchesthenonlydefaulthandlerinvokedfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverauthorizationserverwebexchangedelegatingserveraccessdeniedhandlertestsjava">Test Case Name: <code>handleWhenNothingMatchesThenOnlyDefaultHandlerInvoked</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\authorization\ServerWebExchangeDelegatingServerAccessDeniedHandlerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-matcher">Mock Object Variable Name: <code>matcher</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void handleWhenNothingMatchesThenOnlyDefaultHandlerInvoked() {
     ServerAccessDeniedHandler handler = mock(ServerAccessDeniedHandler.class);
<span class="hljs-deletion">-    ServerWebExchangeMatcher matcher = mock(ServerWebExchangeMatcher.class);</span>
<span class="hljs-deletion">-    given(matcher.matches(this.exchange)).willReturn(MatchResult.notMatch());</span>
<span class="hljs-addition">+    ServerWebExchangeMatcher matcher = createMockMatcher(MatchResult.notMatch(), this.exchange);</span>
     given(handler.handle(this.exchange, null)).willReturn(Mono.empty());
     given(this.accessDeniedHandler.handle(this.exchange, null)).willReturn(Mono.empty());
     this.entries.add(new DelegateEntry(matcher, handler));
     this.delegator = new ServerWebExchangeDelegatingServerAccessDeniedHandler(this.entries);
     this.delegator.setDefaultAccessDeniedHandler(this.accessDeniedHandler);
     this.delegator.handle(this.exchange, null).block();
     verify(this.accessDeniedHandler).handle(this.exchange, null);
     verify(handler, never()).handle(this.exchange, null);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleWhenNothingMatchesThenOnlyDefaultHandlerInvoked</span><span class="hljs-params">()</span> </span>{

    ServerAccessDeniedHandler handler = mock(ServerAccessDeniedHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    ServerWebExchangeMatcher matcher = mock(ServerWebExchangeMatcher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(matcher.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(MatchResult.notMatch());

    given(handler.handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>)).willReturn(Mono.empty());

    given(<span class="hljs-keyword">this</span>.accessDeniedHandler.handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>)).willReturn(Mono.empty());

    <span class="hljs-keyword">this</span>.entries.add(<span class="hljs-keyword">new</span> DelegateEntry(matcher, handler));

    <span class="hljs-keyword">this</span>.delegator = <span class="hljs-keyword">new</span> ServerWebExchangeDelegatingServerAccessDeniedHandler(<span class="hljs-keyword">this</span>.entries);

    <span class="hljs-keyword">this</span>.delegator.setDefaultAccessDeniedHandler(<span class="hljs-keyword">this</span>.accessDeniedHandler);

    <span class="hljs-keyword">this</span>.delegator.handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>).block();

    verify(<span class="hljs-keyword">this</span>.accessDeniedHandler).handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>);

    verify(handler, never()).handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ServerWebExchangeMatcher <span class="hljs-title">createMockMatcher</span><span class="hljs-params">(MatchResult matchResult, ServerWebExchange exchange)</span> </span>{
    ServerWebExchangeMatcher matcher = mock(ServerWebExchangeMatcher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(matcher.matches(exchange)).willReturn(matchResult);
    <span class="hljs-keyword">return</span> matcher;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1512">Test Case ID #spring-security_Test_151_2</h4>
<h4 id="test-case-name-handlewhenfirstmatchesthenonlyfirstinvokedfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverauthorizationserverwebexchangedelegatingserveraccessdeniedhandlertestsjava">Test Case Name: <code>handleWhenFirstMatchesThenOnlyFirstInvoked</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\authorization\ServerWebExchangeDelegatingServerAccessDeniedHandlerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-firstmatcher">Mock Object Variable Name: <code>firstMatcher</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void handleWhenFirstMatchesThenOnlyFirstInvoked() {
     ServerAccessDeniedHandler firstHandler = mock(ServerAccessDeniedHandler.class);
<span class="hljs-deletion">-    ServerWebExchangeMatcher firstMatcher = mock(ServerWebExchangeMatcher.class);</span>
<span class="hljs-addition">+    ServerWebExchangeMatcher firstMatcher = createMockMatcher(MatchResult.match(), this.exchange);</span>
     ServerAccessDeniedHandler secondHandler = mock(ServerAccessDeniedHandler.class);
     ServerWebExchangeMatcher secondMatcher = mock(ServerWebExchangeMatcher.class);
<span class="hljs-deletion">-    given(firstMatcher.matches(this.exchange)).willReturn(MatchResult.match());</span>
     given(firstHandler.handle(this.exchange, null)).willReturn(Mono.empty());
     given(secondHandler.handle(this.exchange, null)).willReturn(Mono.empty());
     this.entries.add(new DelegateEntry(firstMatcher, firstHandler));
     this.entries.add(new DelegateEntry(secondMatcher, secondHandler));
     this.delegator = new ServerWebExchangeDelegatingServerAccessDeniedHandler(this.entries);
     this.delegator.setDefaultAccessDeniedHandler(this.accessDeniedHandler);
     this.delegator.handle(this.exchange, null).block();
     verify(firstHandler).handle(this.exchange, null);
     verify(secondHandler, never()).handle(this.exchange, null);
     verify(this.accessDeniedHandler, never()).handle(this.exchange, null);
     verify(secondMatcher, never()).matches(this.exchange);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleWhenFirstMatchesThenOnlyFirstInvoked</span><span class="hljs-params">()</span> </span>{

    ServerAccessDeniedHandler firstHandler = mock(ServerAccessDeniedHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    ServerWebExchangeMatcher firstMatcher = mock(ServerWebExchangeMatcher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    ServerAccessDeniedHandler secondHandler = mock(ServerAccessDeniedHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    ServerWebExchangeMatcher secondMatcher = mock(ServerWebExchangeMatcher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(firstMatcher.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(MatchResult.match());

    given(firstHandler.handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>)).willReturn(Mono.empty());

    given(secondHandler.handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>)).willReturn(Mono.empty());

    <span class="hljs-keyword">this</span>.entries.add(<span class="hljs-keyword">new</span> DelegateEntry(firstMatcher, firstHandler));

    <span class="hljs-keyword">this</span>.entries.add(<span class="hljs-keyword">new</span> DelegateEntry(secondMatcher, secondHandler));

    <span class="hljs-keyword">this</span>.delegator = <span class="hljs-keyword">new</span> ServerWebExchangeDelegatingServerAccessDeniedHandler(<span class="hljs-keyword">this</span>.entries);

    <span class="hljs-keyword">this</span>.delegator.setDefaultAccessDeniedHandler(<span class="hljs-keyword">this</span>.accessDeniedHandler);

    <span class="hljs-keyword">this</span>.delegator.handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>).block();

    verify(firstHandler).handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>);

    verify(secondHandler, never()).handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>);

    verify(<span class="hljs-keyword">this</span>.accessDeniedHandler, never()).handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>);

    verify(secondMatcher, never()).matches(<span class="hljs-keyword">this</span>.exchange);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ServerWebExchangeMatcher <span class="hljs-title">createMockMatcher</span><span class="hljs-params">(MatchResult matchResult, ServerWebExchange exchange)</span> </span>{
    ServerWebExchangeMatcher matcher = mock(ServerWebExchangeMatcher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(matcher.matches(exchange)).willReturn(matchResult);
    <span class="hljs-keyword">return</span> matcher;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1513">Test Case ID #spring-security_Test_151_3</h4>
<h4 id="test-case-name-handlewhensecondmatchesthenonlysecondinvokedfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverauthorizationserverwebexchangedelegatingserveraccessdeniedhandlertestsjava">Test Case Name: <code>handleWhenSecondMatchesThenOnlySecondInvoked</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\authorization\ServerWebExchangeDelegatingServerAccessDeniedHandlerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-firstmatcher">Mock Object Variable Name: <code>firstMatcher</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void handleWhenSecondMatchesThenOnlySecondInvoked() {
     ServerAccessDeniedHandler firstHandler = mock(ServerAccessDeniedHandler.class);
     ServerWebExchangeMatcher firstMatcher = mock(ServerWebExchangeMatcher.class);
     ServerAccessDeniedHandler secondHandler = mock(ServerAccessDeniedHandler.class);
<span class="hljs-deletion">-    ServerWebExchangeMatcher secondMatcher = mock(ServerWebExchangeMatcher.class);</span>
<span class="hljs-addition">+    ServerWebExchangeMatcher secondMatcher = createMockMatcher(MatchResult.match(), this.exchange);</span>
     given(firstMatcher.matches(this.exchange)).willReturn(MatchResult.notMatch());
<span class="hljs-deletion">-    given(secondMatcher.matches(this.exchange)).willReturn(MatchResult.match());</span>
     given(firstHandler.handle(this.exchange, null)).willReturn(Mono.empty());
     given(secondHandler.handle(this.exchange, null)).willReturn(Mono.empty());
     this.entries.add(new DelegateEntry(firstMatcher, firstHandler));
     this.entries.add(new DelegateEntry(secondMatcher, secondHandler));
     this.delegator = new ServerWebExchangeDelegatingServerAccessDeniedHandler(this.entries);
     this.delegator.handle(this.exchange, null).block();
     verify(secondHandler).handle(this.exchange, null);
     verify(firstHandler, never()).handle(this.exchange, null);
     verify(this.accessDeniedHandler, never()).handle(this.exchange, null);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleWhenSecondMatchesThenOnlySecondInvoked</span><span class="hljs-params">()</span> </span>{

    ServerAccessDeniedHandler firstHandler = mock(ServerAccessDeniedHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    ServerWebExchangeMatcher firstMatcher = mock(ServerWebExchangeMatcher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    ServerAccessDeniedHandler secondHandler = mock(ServerAccessDeniedHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    ServerWebExchangeMatcher secondMatcher = mock(ServerWebExchangeMatcher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(firstMatcher.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(MatchResult.notMatch());

    given(secondMatcher.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(MatchResult.match());

    given(firstHandler.handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>)).willReturn(Mono.empty());

    given(secondHandler.handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>)).willReturn(Mono.empty());

    <span class="hljs-keyword">this</span>.entries.add(<span class="hljs-keyword">new</span> DelegateEntry(firstMatcher, firstHandler));

    <span class="hljs-keyword">this</span>.entries.add(<span class="hljs-keyword">new</span> DelegateEntry(secondMatcher, secondHandler));

    <span class="hljs-keyword">this</span>.delegator = <span class="hljs-keyword">new</span> ServerWebExchangeDelegatingServerAccessDeniedHandler(<span class="hljs-keyword">this</span>.entries);

    <span class="hljs-keyword">this</span>.delegator.handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>).block();

    verify(secondHandler).handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>);

    verify(firstHandler, never()).handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>);

    verify(<span class="hljs-keyword">this</span>.accessDeniedHandler, never()).handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ServerWebExchangeMatcher <span class="hljs-title">createMockMatcher</span><span class="hljs-params">(MatchResult matchResult, ServerWebExchange exchange)</span> </span>{
    ServerWebExchangeMatcher matcher = mock(ServerWebExchangeMatcher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(matcher.matches(exchange)).willReturn(matchResult);
    <span class="hljs-keyword">return</span> matcher;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1514">Test Case ID #spring-security_Test_151_4</h4>
<h4 id="test-case-name-handlewhensecondmatchesthenonlysecondinvokedfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverauthorizationserverwebexchangedelegatingserveraccessdeniedhandlertestsjava">Test Case Name: <code>handleWhenSecondMatchesThenOnlySecondInvoked</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\authorization\ServerWebExchangeDelegatingServerAccessDeniedHandlerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-secondmatcher">Mock Object Variable Name: <code>secondMatcher</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void handleWhenSecondMatchesThenOnlySecondInvoked() {
     ServerAccessDeniedHandler firstHandler = mock(ServerAccessDeniedHandler.class);
     ServerWebExchangeMatcher firstMatcher = mock(ServerWebExchangeMatcher.class);
     ServerAccessDeniedHandler secondHandler = mock(ServerAccessDeniedHandler.class);
<span class="hljs-deletion">-    ServerWebExchangeMatcher secondMatcher = mock(ServerWebExchangeMatcher.class);</span>
<span class="hljs-addition">+    ServerWebExchangeMatcher secondMatcher = createMockMatcher(MatchResult.match(), this.exchange);</span>
     given(firstMatcher.matches(this.exchange)).willReturn(MatchResult.notMatch());
<span class="hljs-deletion">-    given(secondMatcher.matches(this.exchange)).willReturn(MatchResult.match());</span>
     given(firstHandler.handle(this.exchange, null)).willReturn(Mono.empty());
     given(secondHandler.handle(this.exchange, null)).willReturn(Mono.empty());
     this.entries.add(new DelegateEntry(firstMatcher, firstHandler));
     this.entries.add(new DelegateEntry(secondMatcher, secondHandler));
     this.delegator = new ServerWebExchangeDelegatingServerAccessDeniedHandler(this.entries);
     this.delegator.handle(this.exchange, null).block();
     verify(secondHandler).handle(this.exchange, null);
     verify(firstHandler, never()).handle(this.exchange, null);
     verify(this.accessDeniedHandler, never()).handle(this.exchange, null);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleWhenSecondMatchesThenOnlySecondInvoked</span><span class="hljs-params">()</span> </span>{

    ServerAccessDeniedHandler firstHandler = mock(ServerAccessDeniedHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    ServerWebExchangeMatcher firstMatcher = mock(ServerWebExchangeMatcher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    ServerAccessDeniedHandler secondHandler = mock(ServerAccessDeniedHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    ServerWebExchangeMatcher secondMatcher = mock(ServerWebExchangeMatcher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(firstMatcher.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(MatchResult.notMatch());

    given(secondMatcher.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(MatchResult.match());

    given(firstHandler.handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>)).willReturn(Mono.empty());

    given(secondHandler.handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>)).willReturn(Mono.empty());

    <span class="hljs-keyword">this</span>.entries.add(<span class="hljs-keyword">new</span> DelegateEntry(firstMatcher, firstHandler));

    <span class="hljs-keyword">this</span>.entries.add(<span class="hljs-keyword">new</span> DelegateEntry(secondMatcher, secondHandler));

    <span class="hljs-keyword">this</span>.delegator = <span class="hljs-keyword">new</span> ServerWebExchangeDelegatingServerAccessDeniedHandler(<span class="hljs-keyword">this</span>.entries);

    <span class="hljs-keyword">this</span>.delegator.handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>).block();

    verify(secondHandler).handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>);

    verify(firstHandler, never()).handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>);

    verify(<span class="hljs-keyword">this</span>.accessDeniedHandler, never()).handle(<span class="hljs-keyword">this</span>.exchange, <span class="hljs-keyword">null</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ServerWebExchangeMatcher <span class="hljs-title">createMockMatcher</span><span class="hljs-params">(MatchResult matchResult, ServerWebExchange exchange)</span> </span>{
    ServerWebExchangeMatcher matcher = mock(ServerWebExchangeMatcher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(matcher.matches(exchange)).willReturn(matchResult);
    <span class="hljs-keyword">return</span> matcher;
}
</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci152">Mock Clone Instance #spring-security_MCI_152</h2>
<ul>
<li><strong>Scope</strong>: method level</li>
<li><strong>Mocked Class</strong>: <code>org.springframework.security.web.server.util.matcher.ServerWebExchangeMatcher</code></li>
<li><strong>Test Case Count</strong>: 2</li>
<li><strong>MO Count</strong>: 3</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubServerWebExchangeMatcherMatches</span><span class="hljs-params">(ServerWebExchangeMatcher matcher, ServerWebExchangeMatcher.MatchResult matchResult)</span> </span>{
    given(matcher.matches(any())).willReturn(matchResult);
}
</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest1521">Test Case ID #spring-security_Test_152_1</h4>
<h4 id="test-case-name-checkwhenfirstmatchesthennomorematchersandnomoredelegatesinvokedfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverauthorizationdelegatingreactiveauthorizationmanagertestsjava">Test Case Name: <code>checkWhenFirstMatchesThenNoMoreMatchersAndNoMoreDelegatesInvoked</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\authorization\DelegatingReactiveAuthorizationManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-match1">Mock Object Variable Name: <code>match1</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void checkWhenFirstMatchesThenNoMoreMatchersAndNoMoreDelegatesInvoked() {
<span class="hljs-deletion">-    given(this.match1.matches(any())).willReturn(ServerWebExchangeMatcher.MatchResult.match());</span>
<span class="hljs-addition">+    stubServerWebExchangeMatcherMatches(this.match1, ServerWebExchangeMatcher.MatchResult.match());</span>
     given(this.delegate1.check(eq(this.authentication), any(AuthorizationContext.class))).willReturn(Mono.just(this.decision));
     assertThat(this.manager.check(this.authentication, this.exchange).block()).isEqualTo(this.decision);
     verifyNoMoreInteractions(this.match2, this.delegate2);
}
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkWhenFirstMatchesThenNoMoreMatchersAndNoMoreDelegatesInvoked</span><span class="hljs-params">()</span> </span>{

    given(<span class="hljs-keyword">this</span>.match1.matches(any())).willReturn(ServerWebExchangeMatcher.MatchResult.match());

    given(<span class="hljs-keyword">this</span>.delegate1.check(eq(<span class="hljs-keyword">this</span>.authentication), any(AuthorizationContext<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>(<span class="hljs-title">Mono</span>.<span class="hljs-title">just</span>(<span class="hljs-title">this</span>.<span class="hljs-title">decision</span>))</span>;

    assertThat(<span class="hljs-keyword">this</span>.manager.check(<span class="hljs-keyword">this</span>.authentication, <span class="hljs-keyword">this</span>.exchange).block()).isEqualTo(<span class="hljs-keyword">this</span>.decision);

    verifyNoMoreInteractions(<span class="hljs-keyword">this</span>.match2, <span class="hljs-keyword">this</span>.delegate2);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubServerWebExchangeMatcherMatches</span><span class="hljs-params">(ServerWebExchangeMatcher matcher, ServerWebExchangeMatcher.MatchResult matchResult)</span> </span>{
    given(matcher.matches(any())).willReturn(matchResult);
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1522">Test Case ID #spring-security_Test_152_2</h4>
<h4 id="test-case-name-checkwhensecondmatchesthennomorematchersandnomoredelegatesinvokedfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverauthorizationdelegatingreactiveauthorizationmanagertestsjava">Test Case Name: <code>checkWhenSecondMatchesThenNoMoreMatchersAndNoMoreDelegatesInvoked</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\authorization\DelegatingReactiveAuthorizationManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-match1">Mock Object Variable Name: <code>match1</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void checkWhenSecondMatchesThenNoMoreMatchersAndNoMoreDelegatesInvoked() {
<span class="hljs-deletion">-    given(this.match1.matches(any())).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());</span>
<span class="hljs-addition">+    stubServerWebExchangeMatcherMatches(this.match1, ServerWebExchangeMatcher.MatchResult.notMatch());</span>
     given(this.match2.matches(any())).willReturn(ServerWebExchangeMatcher.MatchResult.match());
     given(this.delegate2.check(eq(this.authentication), any(AuthorizationContext.class))).willReturn(Mono.just(this.decision));
     assertThat(this.manager.check(this.authentication, this.exchange).block()).isEqualTo(this.decision);
     verifyNoMoreInteractions(this.delegate1);
}
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkWhenSecondMatchesThenNoMoreMatchersAndNoMoreDelegatesInvoked</span><span class="hljs-params">()</span> </span>{

    given(<span class="hljs-keyword">this</span>.match1.matches(any())).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());

    given(<span class="hljs-keyword">this</span>.match2.matches(any())).willReturn(ServerWebExchangeMatcher.MatchResult.match());

    given(<span class="hljs-keyword">this</span>.delegate2.check(eq(<span class="hljs-keyword">this</span>.authentication), any(AuthorizationContext<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>(<span class="hljs-title">Mono</span>.<span class="hljs-title">just</span>(<span class="hljs-title">this</span>.<span class="hljs-title">decision</span>))</span>;

    assertThat(<span class="hljs-keyword">this</span>.manager.check(<span class="hljs-keyword">this</span>.authentication, <span class="hljs-keyword">this</span>.exchange).block()).isEqualTo(<span class="hljs-keyword">this</span>.decision);

    verifyNoMoreInteractions(<span class="hljs-keyword">this</span>.delegate1);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubServerWebExchangeMatcherMatches</span><span class="hljs-params">(ServerWebExchangeMatcher matcher, ServerWebExchangeMatcher.MatchResult matchResult)</span> </span>{
    given(matcher.matches(any())).willReturn(matchResult);
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1523">Test Case ID #spring-security_Test_152_3</h4>
<h4 id="test-case-name-checkwhensecondmatchesthennomorematchersandnomoredelegatesinvokedfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverauthorizationdelegatingreactiveauthorizationmanagertestsjava">Test Case Name: <code>checkWhenSecondMatchesThenNoMoreMatchersAndNoMoreDelegatesInvoked</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\authorization\DelegatingReactiveAuthorizationManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-match2">Mock Object Variable Name: <code>match2</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void checkWhenSecondMatchesThenNoMoreMatchersAndNoMoreDelegatesInvoked() {
<span class="hljs-deletion">-    given(this.match1.matches(any())).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());</span>
<span class="hljs-addition">+    stubServerWebExchangeMatcherMatches(this.match1, ServerWebExchangeMatcher.MatchResult.notMatch());</span>
     given(this.match2.matches(any())).willReturn(ServerWebExchangeMatcher.MatchResult.match());
     given(this.delegate2.check(eq(this.authentication), any(AuthorizationContext.class))).willReturn(Mono.just(this.decision));
     assertThat(this.manager.check(this.authentication, this.exchange).block()).isEqualTo(this.decision);
     verifyNoMoreInteractions(this.delegate1);
}
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkWhenSecondMatchesThenNoMoreMatchersAndNoMoreDelegatesInvoked</span><span class="hljs-params">()</span> </span>{

    given(<span class="hljs-keyword">this</span>.match1.matches(any())).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());

    given(<span class="hljs-keyword">this</span>.match2.matches(any())).willReturn(ServerWebExchangeMatcher.MatchResult.match());

    given(<span class="hljs-keyword">this</span>.delegate2.check(eq(<span class="hljs-keyword">this</span>.authentication), any(AuthorizationContext<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willReturn</span>(<span class="hljs-title">Mono</span>.<span class="hljs-title">just</span>(<span class="hljs-title">this</span>.<span class="hljs-title">decision</span>))</span>;

    assertThat(<span class="hljs-keyword">this</span>.manager.check(<span class="hljs-keyword">this</span>.authentication, <span class="hljs-keyword">this</span>.exchange).block()).isEqualTo(<span class="hljs-keyword">this</span>.decision);

    verifyNoMoreInteractions(<span class="hljs-keyword">this</span>.delegate1);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubServerWebExchangeMatcherMatches</span><span class="hljs-params">(ServerWebExchangeMatcher matcher, ServerWebExchangeMatcher.MatchResult matchResult)</span> </span>{
    given(matcher.matches(any())).willReturn(matchResult);
}
</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci153">Mock Clone Instance #spring-security_MCI_153</h2>
<ul>
<li><strong>Scope</strong>: class level</li>
<li><strong>Mocked Class</strong>: <code>org.springframework.security.web.server.util.matcher.ServerWebExchangeMatcher</code></li>
<li><strong>Test Case Count</strong>: 9</li>
<li><strong>MO Count</strong>: 13</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockServerWebExchangeMatcher</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the given matcher to return the provided MatchResult when matches(exchange) is called.
     * &lt;p&gt;
     * Usage example:
     * &lt;pre&gt;
     * MockServerWebExchangeMatcher.stubMatches(matcher1, exchange, ServerWebExchangeMatcher.MatchResult.match(params));
     * &lt;/pre&gt;
     *
     * <span class="hljs-doctag">@param</span> matcher the mock ServerWebExchangeMatcher
     * <span class="hljs-doctag">@param</span> exchange the ServerWebExchange to match against
     * <span class="hljs-doctag">@param</span> matchResult the MatchResult to return (e.g., ServerWebExchangeMatcher.MatchResult.match(params), .notMatch(), etc.)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(ServerWebExchangeMatcher matcher, ServerWebExchange exchange, ServerWebExchangeMatcher.MatchResult matchResult)</span> </span>{
        given(matcher.matches(exchange)).willReturn(matchResult);
    }
}

</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest1531">Test Case ID #spring-security_Test_153_1</h4>
<h4 id="test-case-name-matcheswhentruetruethentruefile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverutilmatcherandserverwebexchangematchertestsjava">Test Case Name: <code>matchesWhenTrueTrueThenTrue</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\util\matcher\AndServerWebExchangeMatcherTests.java</code>)</h4>
<h4 id="mock-object-variable-name-matcher1">Mock Object Variable Name: <code>matcher1</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void matchesWhenTrueTrueThenTrue() {
     Map&lt;String, Object&gt; params1 = Collections.singletonMap("foo", "bar");
     Map&lt;String, Object&gt; params2 = Collections.singletonMap("x", "y");
<span class="hljs-deletion">-    given(this.matcher1.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match(params1));</span>
<span class="hljs-deletion">-    given(this.matcher2.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match(params2));</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher1, this.exchange, ServerWebExchangeMatcher.MatchResult.match(params1));</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher2, this.exchange, ServerWebExchangeMatcher.MatchResult.match(params2));</span>
     ServerWebExchangeMatcher.MatchResult matches = this.matcher.matches(this.exchange).block();
     assertThat(matches.isMatch()).isTrue();
     assertThat(matches.getVariables()).hasSize(2);
     assertThat(matches.getVariables()).containsAllEntriesOf(params1);
     assertThat(matches.getVariables()).containsAllEntriesOf(params2);
     verify(this.matcher1).matches(this.exchange);
     verify(this.matcher2).matches(this.exchange);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchesWhenTrueTrueThenTrue</span><span class="hljs-params">()</span> </span>{

    Map&lt;String, Object&gt; params1 = Collections.singletonMap(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>);

    Map&lt;String, Object&gt; params2 = Collections.singletonMap(<span class="hljs-string">"x"</span>, <span class="hljs-string">"y"</span>);

    given(<span class="hljs-keyword">this</span>.matcher1.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match(params1));

    given(<span class="hljs-keyword">this</span>.matcher2.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match(params2));

    ServerWebExchangeMatcher.MatchResult matches = <span class="hljs-keyword">this</span>.matcher.matches(<span class="hljs-keyword">this</span>.exchange).block();

    assertThat(matches.isMatch()).isTrue();

    assertThat(matches.getVariables()).hasSize(<span class="hljs-number">2</span>);

    assertThat(matches.getVariables()).containsAllEntriesOf(params1);

    assertThat(matches.getVariables()).containsAllEntriesOf(params2);

    verify(<span class="hljs-keyword">this</span>.matcher1).matches(<span class="hljs-keyword">this</span>.exchange);

    verify(<span class="hljs-keyword">this</span>.matcher2).matches(<span class="hljs-keyword">this</span>.exchange);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockServerWebExchangeMatcher</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the given matcher to return the provided MatchResult when matches(exchange) is called.
     * &lt;p&gt;
     * Usage example:
     * &lt;pre&gt;
     * MockServerWebExchangeMatcher.stubMatches(matcher1, exchange, ServerWebExchangeMatcher.MatchResult.match(params));
     * &lt;/pre&gt;
     *
     * <span class="hljs-doctag">@param</span> matcher the mock ServerWebExchangeMatcher
     * <span class="hljs-doctag">@param</span> exchange the ServerWebExchange to match against
     * <span class="hljs-doctag">@param</span> matchResult the MatchResult to return (e.g., ServerWebExchangeMatcher.MatchResult.match(params), .notMatch(), etc.)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(ServerWebExchangeMatcher matcher, ServerWebExchange exchange, ServerWebExchangeMatcher.MatchResult matchResult)</span> </span>{
        given(matcher.matches(exchange)).willReturn(matchResult);
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1532">Test Case ID #spring-security_Test_153_2</h4>
<h4 id="test-case-name-matcheswhenfalsefalsethenfalseandmatcher2notinvokedfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverutilmatcherandserverwebexchangematchertestsjava">Test Case Name: <code>matchesWhenFalseFalseThenFalseAndMatcher2NotInvoked</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\util\matcher\AndServerWebExchangeMatcherTests.java</code>)</h4>
<h4 id="mock-object-variable-name-matcher1">Mock Object Variable Name: <code>matcher1</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void matchesWhenFalseFalseThenFalseAndMatcher2NotInvoked() {
<span class="hljs-deletion">-    given(this.matcher1.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher1, this.exchange, ServerWebExchangeMatcher.MatchResult.notMatch());</span>
     ServerWebExchangeMatcher.MatchResult matches = this.matcher.matches(this.exchange).block();
     assertThat(matches.isMatch()).isFalse();
     assertThat(matches.getVariables()).isEmpty();
     verify(this.matcher1).matches(this.exchange);
     verify(this.matcher2, never()).matches(this.exchange);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchesWhenFalseFalseThenFalseAndMatcher2NotInvoked</span><span class="hljs-params">()</span> </span>{

    given(<span class="hljs-keyword">this</span>.matcher1.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());

    ServerWebExchangeMatcher.MatchResult matches = <span class="hljs-keyword">this</span>.matcher.matches(<span class="hljs-keyword">this</span>.exchange).block();

    assertThat(matches.isMatch()).isFalse();

    assertThat(matches.getVariables()).isEmpty();

    verify(<span class="hljs-keyword">this</span>.matcher1).matches(<span class="hljs-keyword">this</span>.exchange);

    verify(<span class="hljs-keyword">this</span>.matcher2, never()).matches(<span class="hljs-keyword">this</span>.exchange);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockServerWebExchangeMatcher</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the given matcher to return the provided MatchResult when matches(exchange) is called.
     * &lt;p&gt;
     * Usage example:
     * &lt;pre&gt;
     * MockServerWebExchangeMatcher.stubMatches(matcher1, exchange, ServerWebExchangeMatcher.MatchResult.match(params));
     * &lt;/pre&gt;
     *
     * <span class="hljs-doctag">@param</span> matcher the mock ServerWebExchangeMatcher
     * <span class="hljs-doctag">@param</span> exchange the ServerWebExchange to match against
     * <span class="hljs-doctag">@param</span> matchResult the MatchResult to return (e.g., ServerWebExchangeMatcher.MatchResult.match(params), .notMatch(), etc.)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(ServerWebExchangeMatcher matcher, ServerWebExchange exchange, ServerWebExchangeMatcher.MatchResult matchResult)</span> </span>{
        given(matcher.matches(exchange)).willReturn(matchResult);
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1533">Test Case ID #spring-security_Test_153_3</h4>
<h4 id="test-case-name-matcheswhentruefalsethenfalsefile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverutilmatcherandserverwebexchangematchertestsjava">Test Case Name: <code>matchesWhenTrueFalseThenFalse</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\util\matcher\AndServerWebExchangeMatcherTests.java</code>)</h4>
<h4 id="mock-object-variable-name-matcher1">Mock Object Variable Name: <code>matcher1</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void matchesWhenTrueFalseThenFalse() {
     Map&lt;String, Object&gt; params = Collections.singletonMap("foo", "bar");
<span class="hljs-deletion">-    given(this.matcher1.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match(params));</span>
<span class="hljs-deletion">-    given(this.matcher2.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher1, this.exchange, ServerWebExchangeMatcher.MatchResult.match(params));</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher2, this.exchange, ServerWebExchangeMatcher.MatchResult.notMatch());</span>
     ServerWebExchangeMatcher.MatchResult matches = this.matcher.matches(this.exchange).block();
     assertThat(matches.isMatch()).isFalse();
     assertThat(matches.getVariables()).isEmpty();
     verify(this.matcher1).matches(this.exchange);
     verify(this.matcher2).matches(this.exchange);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchesWhenTrueFalseThenFalse</span><span class="hljs-params">()</span> </span>{

    Map&lt;String, Object&gt; params = Collections.singletonMap(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>);

    given(<span class="hljs-keyword">this</span>.matcher1.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match(params));

    given(<span class="hljs-keyword">this</span>.matcher2.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());

    ServerWebExchangeMatcher.MatchResult matches = <span class="hljs-keyword">this</span>.matcher.matches(<span class="hljs-keyword">this</span>.exchange).block();

    assertThat(matches.isMatch()).isFalse();

    assertThat(matches.getVariables()).isEmpty();

    verify(<span class="hljs-keyword">this</span>.matcher1).matches(<span class="hljs-keyword">this</span>.exchange);

    verify(<span class="hljs-keyword">this</span>.matcher2).matches(<span class="hljs-keyword">this</span>.exchange);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockServerWebExchangeMatcher</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the given matcher to return the provided MatchResult when matches(exchange) is called.
     * &lt;p&gt;
     * Usage example:
     * &lt;pre&gt;
     * MockServerWebExchangeMatcher.stubMatches(matcher1, exchange, ServerWebExchangeMatcher.MatchResult.match(params));
     * &lt;/pre&gt;
     *
     * <span class="hljs-doctag">@param</span> matcher the mock ServerWebExchangeMatcher
     * <span class="hljs-doctag">@param</span> exchange the ServerWebExchange to match against
     * <span class="hljs-doctag">@param</span> matchResult the MatchResult to return (e.g., ServerWebExchangeMatcher.MatchResult.match(params), .notMatch(), etc.)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(ServerWebExchangeMatcher matcher, ServerWebExchange exchange, ServerWebExchangeMatcher.MatchResult matchResult)</span> </span>{
        given(matcher.matches(exchange)).willReturn(matchResult);
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1534">Test Case ID #spring-security_Test_153_4</h4>
<h4 id="test-case-name-matcheswhenfalsetruethenfalsefile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverutilmatcherandserverwebexchangematchertestsjava">Test Case Name: <code>matchesWhenFalseTrueThenFalse</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\util\matcher\AndServerWebExchangeMatcherTests.java</code>)</h4>
<h4 id="mock-object-variable-name-matcher1">Mock Object Variable Name: <code>matcher1</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void matchesWhenFalseTrueThenFalse() {
<span class="hljs-deletion">-    given(this.matcher1.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher1, this.exchange, ServerWebExchangeMatcher.MatchResult.notMatch());</span>
     ServerWebExchangeMatcher.MatchResult matches = this.matcher.matches(this.exchange).block();
     assertThat(matches.isMatch()).isFalse();
     assertThat(matches.getVariables()).isEmpty();
     verify(this.matcher1).matches(this.exchange);
     verify(this.matcher2, never()).matches(this.exchange);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchesWhenFalseTrueThenFalse</span><span class="hljs-params">()</span> </span>{

    given(<span class="hljs-keyword">this</span>.matcher1.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());

    ServerWebExchangeMatcher.MatchResult matches = <span class="hljs-keyword">this</span>.matcher.matches(<span class="hljs-keyword">this</span>.exchange).block();

    assertThat(matches.isMatch()).isFalse();

    assertThat(matches.getVariables()).isEmpty();

    verify(<span class="hljs-keyword">this</span>.matcher1).matches(<span class="hljs-keyword">this</span>.exchange);

    verify(<span class="hljs-keyword">this</span>.matcher2, never()).matches(<span class="hljs-keyword">this</span>.exchange);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockServerWebExchangeMatcher</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the given matcher to return the provided MatchResult when matches(exchange) is called.
     * &lt;p&gt;
     * Usage example:
     * &lt;pre&gt;
     * MockServerWebExchangeMatcher.stubMatches(matcher1, exchange, ServerWebExchangeMatcher.MatchResult.match(params));
     * &lt;/pre&gt;
     *
     * <span class="hljs-doctag">@param</span> matcher the mock ServerWebExchangeMatcher
     * <span class="hljs-doctag">@param</span> exchange the ServerWebExchange to match against
     * <span class="hljs-doctag">@param</span> matchResult the MatchResult to return (e.g., ServerWebExchangeMatcher.MatchResult.match(params), .notMatch(), etc.)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(ServerWebExchangeMatcher matcher, ServerWebExchange exchange, ServerWebExchangeMatcher.MatchResult matchResult)</span> </span>{
        given(matcher.matches(exchange)).willReturn(matchResult);
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1535">Test Case ID #spring-security_Test_153_5</h4>
<h4 id="test-case-name-matcheswhentruetruethentruefile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverutilmatcherandserverwebexchangematchertestsjava">Test Case Name: <code>matchesWhenTrueTrueThenTrue</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\util\matcher\AndServerWebExchangeMatcherTests.java</code>)</h4>
<h4 id="mock-object-variable-name-matcher2">Mock Object Variable Name: <code>matcher2</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void matchesWhenTrueTrueThenTrue() {
     Map&lt;String, Object&gt; params1 = Collections.singletonMap("foo", "bar");
     Map&lt;String, Object&gt; params2 = Collections.singletonMap("x", "y");
<span class="hljs-deletion">-    given(this.matcher1.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match(params1));</span>
<span class="hljs-deletion">-    given(this.matcher2.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match(params2));</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher1, this.exchange, ServerWebExchangeMatcher.MatchResult.match(params1));</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher2, this.exchange, ServerWebExchangeMatcher.MatchResult.match(params2));</span>
     ServerWebExchangeMatcher.MatchResult matches = this.matcher.matches(this.exchange).block();
     assertThat(matches.isMatch()).isTrue();
     assertThat(matches.getVariables()).hasSize(2);
     assertThat(matches.getVariables()).containsAllEntriesOf(params1);
     assertThat(matches.getVariables()).containsAllEntriesOf(params2);
     verify(this.matcher1).matches(this.exchange);
     verify(this.matcher2).matches(this.exchange);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchesWhenTrueTrueThenTrue</span><span class="hljs-params">()</span> </span>{

    Map&lt;String, Object&gt; params1 = Collections.singletonMap(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>);

    Map&lt;String, Object&gt; params2 = Collections.singletonMap(<span class="hljs-string">"x"</span>, <span class="hljs-string">"y"</span>);

    given(<span class="hljs-keyword">this</span>.matcher1.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match(params1));

    given(<span class="hljs-keyword">this</span>.matcher2.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match(params2));

    ServerWebExchangeMatcher.MatchResult matches = <span class="hljs-keyword">this</span>.matcher.matches(<span class="hljs-keyword">this</span>.exchange).block();

    assertThat(matches.isMatch()).isTrue();

    assertThat(matches.getVariables()).hasSize(<span class="hljs-number">2</span>);

    assertThat(matches.getVariables()).containsAllEntriesOf(params1);

    assertThat(matches.getVariables()).containsAllEntriesOf(params2);

    verify(<span class="hljs-keyword">this</span>.matcher1).matches(<span class="hljs-keyword">this</span>.exchange);

    verify(<span class="hljs-keyword">this</span>.matcher2).matches(<span class="hljs-keyword">this</span>.exchange);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockServerWebExchangeMatcher</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the given matcher to return the provided MatchResult when matches(exchange) is called.
     * &lt;p&gt;
     * Usage example:
     * &lt;pre&gt;
     * MockServerWebExchangeMatcher.stubMatches(matcher1, exchange, ServerWebExchangeMatcher.MatchResult.match(params));
     * &lt;/pre&gt;
     *
     * <span class="hljs-doctag">@param</span> matcher the mock ServerWebExchangeMatcher
     * <span class="hljs-doctag">@param</span> exchange the ServerWebExchange to match against
     * <span class="hljs-doctag">@param</span> matchResult the MatchResult to return (e.g., ServerWebExchangeMatcher.MatchResult.match(params), .notMatch(), etc.)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(ServerWebExchangeMatcher matcher, ServerWebExchange exchange, ServerWebExchangeMatcher.MatchResult matchResult)</span> </span>{
        given(matcher.matches(exchange)).willReturn(matchResult);
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1536">Test Case ID #spring-security_Test_153_6</h4>
<h4 id="test-case-name-matcheswhentruefalsethenfalsefile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverutilmatcherandserverwebexchangematchertestsjava">Test Case Name: <code>matchesWhenTrueFalseThenFalse</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\util\matcher\AndServerWebExchangeMatcherTests.java</code>)</h4>
<h4 id="mock-object-variable-name-matcher2">Mock Object Variable Name: <code>matcher2</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void matchesWhenTrueFalseThenFalse() {
     Map&lt;String, Object&gt; params = Collections.singletonMap("foo", "bar");
<span class="hljs-deletion">-    given(this.matcher1.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match(params));</span>
<span class="hljs-deletion">-    given(this.matcher2.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher1, this.exchange, ServerWebExchangeMatcher.MatchResult.match(params));</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher2, this.exchange, ServerWebExchangeMatcher.MatchResult.notMatch());</span>
     ServerWebExchangeMatcher.MatchResult matches = this.matcher.matches(this.exchange).block();
     assertThat(matches.isMatch()).isFalse();
     assertThat(matches.getVariables()).isEmpty();
     verify(this.matcher1).matches(this.exchange);
     verify(this.matcher2).matches(this.exchange);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchesWhenTrueFalseThenFalse</span><span class="hljs-params">()</span> </span>{

    Map&lt;String, Object&gt; params = Collections.singletonMap(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>);

    given(<span class="hljs-keyword">this</span>.matcher1.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match(params));

    given(<span class="hljs-keyword">this</span>.matcher2.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());

    ServerWebExchangeMatcher.MatchResult matches = <span class="hljs-keyword">this</span>.matcher.matches(<span class="hljs-keyword">this</span>.exchange).block();

    assertThat(matches.isMatch()).isFalse();

    assertThat(matches.getVariables()).isEmpty();

    verify(<span class="hljs-keyword">this</span>.matcher1).matches(<span class="hljs-keyword">this</span>.exchange);

    verify(<span class="hljs-keyword">this</span>.matcher2).matches(<span class="hljs-keyword">this</span>.exchange);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockServerWebExchangeMatcher</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the given matcher to return the provided MatchResult when matches(exchange) is called.
     * &lt;p&gt;
     * Usage example:
     * &lt;pre&gt;
     * MockServerWebExchangeMatcher.stubMatches(matcher1, exchange, ServerWebExchangeMatcher.MatchResult.match(params));
     * &lt;/pre&gt;
     *
     * <span class="hljs-doctag">@param</span> matcher the mock ServerWebExchangeMatcher
     * <span class="hljs-doctag">@param</span> exchange the ServerWebExchange to match against
     * <span class="hljs-doctag">@param</span> matchResult the MatchResult to return (e.g., ServerWebExchangeMatcher.MatchResult.match(params), .notMatch(), etc.)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(ServerWebExchangeMatcher matcher, ServerWebExchange exchange, ServerWebExchangeMatcher.MatchResult matchResult)</span> </span>{
        given(matcher.matches(exchange)).willReturn(matchResult);
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1537">Test Case ID #spring-security_Test_153_7</h4>
<h4 id="test-case-name-matcheswhenfalsethentruefile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverutilmatchernegatedserverwebexchangematchertestsjava">Test Case Name: <code>matchesWhenFalseThenTrue</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\util\matcher\NegatedServerWebExchangeMatcherTests.java</code>)</h4>
<h4 id="mock-object-variable-name-matcher1">Mock Object Variable Name: <code>matcher1</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void matchesWhenFalseThenTrue() {
<span class="hljs-deletion">-    given(this.matcher1.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher1, this.exchange, ServerWebExchangeMatcher.MatchResult.notMatch());</span>
     ServerWebExchangeMatcher.MatchResult matches = this.matcher.matches(this.exchange).block();
     assertThat(matches.isMatch()).isTrue();
     assertThat(matches.getVariables()).isEmpty();
     verify(this.matcher1).matches(this.exchange);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchesWhenFalseThenTrue</span><span class="hljs-params">()</span> </span>{

    given(<span class="hljs-keyword">this</span>.matcher1.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());

    ServerWebExchangeMatcher.MatchResult matches = <span class="hljs-keyword">this</span>.matcher.matches(<span class="hljs-keyword">this</span>.exchange).block();

    assertThat(matches.isMatch()).isTrue();

    assertThat(matches.getVariables()).isEmpty();

    verify(<span class="hljs-keyword">this</span>.matcher1).matches(<span class="hljs-keyword">this</span>.exchange);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockServerWebExchangeMatcher</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the given matcher to return the provided MatchResult when matches(exchange) is called.
     * &lt;p&gt;
     * Usage example:
     * &lt;pre&gt;
     * MockServerWebExchangeMatcher.stubMatches(matcher1, exchange, ServerWebExchangeMatcher.MatchResult.match(params));
     * &lt;/pre&gt;
     *
     * <span class="hljs-doctag">@param</span> matcher the mock ServerWebExchangeMatcher
     * <span class="hljs-doctag">@param</span> exchange the ServerWebExchange to match against
     * <span class="hljs-doctag">@param</span> matchResult the MatchResult to return (e.g., ServerWebExchangeMatcher.MatchResult.match(params), .notMatch(), etc.)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(ServerWebExchangeMatcher matcher, ServerWebExchange exchange, ServerWebExchangeMatcher.MatchResult matchResult)</span> </span>{
        given(matcher.matches(exchange)).willReturn(matchResult);
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1538">Test Case ID #spring-security_Test_153_8</h4>
<h4 id="test-case-name-matcheswhentruethenfalsefile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverutilmatchernegatedserverwebexchangematchertestsjava">Test Case Name: <code>matchesWhenTrueThenFalse</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\util\matcher\NegatedServerWebExchangeMatcherTests.java</code>)</h4>
<h4 id="mock-object-variable-name-matcher1">Mock Object Variable Name: <code>matcher1</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void matchesWhenTrueThenFalse() {
<span class="hljs-deletion">-    given(this.matcher1.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match());</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher1, this.exchange, ServerWebExchangeMatcher.MatchResult.match());</span>
     ServerWebExchangeMatcher.MatchResult matches = this.matcher.matches(this.exchange).block();
     assertThat(matches.isMatch()).isFalse();
     assertThat(matches.getVariables()).isEmpty();
     verify(this.matcher1).matches(this.exchange);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchesWhenTrueThenFalse</span><span class="hljs-params">()</span> </span>{

    given(<span class="hljs-keyword">this</span>.matcher1.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match());

    ServerWebExchangeMatcher.MatchResult matches = <span class="hljs-keyword">this</span>.matcher.matches(<span class="hljs-keyword">this</span>.exchange).block();

    assertThat(matches.isMatch()).isFalse();

    assertThat(matches.getVariables()).isEmpty();

    verify(<span class="hljs-keyword">this</span>.matcher1).matches(<span class="hljs-keyword">this</span>.exchange);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockServerWebExchangeMatcher</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the given matcher to return the provided MatchResult when matches(exchange) is called.
     * &lt;p&gt;
     * Usage example:
     * &lt;pre&gt;
     * MockServerWebExchangeMatcher.stubMatches(matcher1, exchange, ServerWebExchangeMatcher.MatchResult.match(params));
     * &lt;/pre&gt;
     *
     * <span class="hljs-doctag">@param</span> matcher the mock ServerWebExchangeMatcher
     * <span class="hljs-doctag">@param</span> exchange the ServerWebExchange to match against
     * <span class="hljs-doctag">@param</span> matchResult the MatchResult to return (e.g., ServerWebExchangeMatcher.MatchResult.match(params), .notMatch(), etc.)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(ServerWebExchangeMatcher matcher, ServerWebExchange exchange, ServerWebExchangeMatcher.MatchResult matchResult)</span> </span>{
        given(matcher.matches(exchange)).willReturn(matchResult);
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1539">Test Case ID #spring-security_Test_153_9</h4>
<h4 id="test-case-name-matcheswhenfalsefalsethenfalsefile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverutilmatcherorserverwebexchangematchertestsjava">Test Case Name: <code>matchesWhenFalseFalseThenFalse</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\util\matcher\OrServerWebExchangeMatcherTests.java</code>)</h4>
<h4 id="mock-object-variable-name-matcher1">Mock Object Variable Name: <code>matcher1</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void matchesWhenFalseFalseThenFalse() {
<span class="hljs-deletion">-    given(this.matcher1.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());</span>
<span class="hljs-deletion">-    given(this.matcher2.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher1, this.exchange, ServerWebExchangeMatcher.MatchResult.notMatch());</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher2, this.exchange, ServerWebExchangeMatcher.MatchResult.notMatch());</span>
     ServerWebExchangeMatcher.MatchResult matches = this.matcher.matches(this.exchange).block();
     assertThat(matches.isMatch()).isFalse();
     assertThat(matches.getVariables()).isEmpty();
     verify(this.matcher1).matches(this.exchange);
     verify(this.matcher2).matches(this.exchange);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchesWhenFalseFalseThenFalse</span><span class="hljs-params">()</span> </span>{

    given(<span class="hljs-keyword">this</span>.matcher1.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());

    given(<span class="hljs-keyword">this</span>.matcher2.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());

    ServerWebExchangeMatcher.MatchResult matches = <span class="hljs-keyword">this</span>.matcher.matches(<span class="hljs-keyword">this</span>.exchange).block();

    assertThat(matches.isMatch()).isFalse();

    assertThat(matches.getVariables()).isEmpty();

    verify(<span class="hljs-keyword">this</span>.matcher1).matches(<span class="hljs-keyword">this</span>.exchange);

    verify(<span class="hljs-keyword">this</span>.matcher2).matches(<span class="hljs-keyword">this</span>.exchange);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockServerWebExchangeMatcher</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the given matcher to return the provided MatchResult when matches(exchange) is called.
     * &lt;p&gt;
     * Usage example:
     * &lt;pre&gt;
     * MockServerWebExchangeMatcher.stubMatches(matcher1, exchange, ServerWebExchangeMatcher.MatchResult.match(params));
     * &lt;/pre&gt;
     *
     * <span class="hljs-doctag">@param</span> matcher the mock ServerWebExchangeMatcher
     * <span class="hljs-doctag">@param</span> exchange the ServerWebExchange to match against
     * <span class="hljs-doctag">@param</span> matchResult the MatchResult to return (e.g., ServerWebExchangeMatcher.MatchResult.match(params), .notMatch(), etc.)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(ServerWebExchangeMatcher matcher, ServerWebExchange exchange, ServerWebExchangeMatcher.MatchResult matchResult)</span> </span>{
        given(matcher.matches(exchange)).willReturn(matchResult);
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest15310">Test Case ID #spring-security_Test_153_10</h4>
<h4 id="test-case-name-matcheswhentruefalsethentrueandmatcher2notinvokedfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverutilmatcherorserverwebexchangematchertestsjava">Test Case Name: <code>matchesWhenTrueFalseThenTrueAndMatcher2NotInvoked</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\util\matcher\OrServerWebExchangeMatcherTests.java</code>)</h4>
<h4 id="mock-object-variable-name-matcher1">Mock Object Variable Name: <code>matcher1</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void matchesWhenTrueFalseThenTrueAndMatcher2NotInvoked() {
     Map&lt;String, Object&gt; params = Collections.singletonMap("foo", "bar");
<span class="hljs-deletion">-    given(this.matcher1.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match(params));</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher1, this.exchange, ServerWebExchangeMatcher.MatchResult.match(params));</span>
     ServerWebExchangeMatcher.MatchResult matches = this.matcher.matches(this.exchange).block();
     assertThat(matches.isMatch()).isTrue();
     assertThat(matches.getVariables()).isEqualTo(params);
     verify(this.matcher1).matches(this.exchange);
     verify(this.matcher2, never()).matches(this.exchange);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchesWhenTrueFalseThenTrueAndMatcher2NotInvoked</span><span class="hljs-params">()</span> </span>{

    Map&lt;String, Object&gt; params = Collections.singletonMap(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>);

    given(<span class="hljs-keyword">this</span>.matcher1.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match(params));

    ServerWebExchangeMatcher.MatchResult matches = <span class="hljs-keyword">this</span>.matcher.matches(<span class="hljs-keyword">this</span>.exchange).block();

    assertThat(matches.isMatch()).isTrue();

    assertThat(matches.getVariables()).isEqualTo(params);

    verify(<span class="hljs-keyword">this</span>.matcher1).matches(<span class="hljs-keyword">this</span>.exchange);

    verify(<span class="hljs-keyword">this</span>.matcher2, never()).matches(<span class="hljs-keyword">this</span>.exchange);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockServerWebExchangeMatcher</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the given matcher to return the provided MatchResult when matches(exchange) is called.
     * &lt;p&gt;
     * Usage example:
     * &lt;pre&gt;
     * MockServerWebExchangeMatcher.stubMatches(matcher1, exchange, ServerWebExchangeMatcher.MatchResult.match(params));
     * &lt;/pre&gt;
     *
     * <span class="hljs-doctag">@param</span> matcher the mock ServerWebExchangeMatcher
     * <span class="hljs-doctag">@param</span> exchange the ServerWebExchange to match against
     * <span class="hljs-doctag">@param</span> matchResult the MatchResult to return (e.g., ServerWebExchangeMatcher.MatchResult.match(params), .notMatch(), etc.)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(ServerWebExchangeMatcher matcher, ServerWebExchange exchange, ServerWebExchangeMatcher.MatchResult matchResult)</span> </span>{
        given(matcher.matches(exchange)).willReturn(matchResult);
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest15311">Test Case ID #spring-security_Test_153_11</h4>
<h4 id="test-case-name-matcheswhenfalsetruethentruefile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverutilmatcherorserverwebexchangematchertestsjava">Test Case Name: <code>matchesWhenFalseTrueThenTrue</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\util\matcher\OrServerWebExchangeMatcherTests.java</code>)</h4>
<h4 id="mock-object-variable-name-matcher1">Mock Object Variable Name: <code>matcher1</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void matchesWhenFalseTrueThenTrue() {
     Map&lt;String, Object&gt; params = Collections.singletonMap("foo", "bar");
<span class="hljs-deletion">-    given(this.matcher1.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());</span>
<span class="hljs-deletion">-    given(this.matcher2.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match(params));</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher1, this.exchange, ServerWebExchangeMatcher.MatchResult.notMatch());</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher2, this.exchange, ServerWebExchangeMatcher.MatchResult.match(params));</span>
     ServerWebExchangeMatcher.MatchResult matches = this.matcher.matches(this.exchange).block();
     assertThat(matches.isMatch()).isTrue();
     assertThat(matches.getVariables()).isEqualTo(params);
     verify(this.matcher1).matches(this.exchange);
     verify(this.matcher2).matches(this.exchange);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchesWhenFalseTrueThenTrue</span><span class="hljs-params">()</span> </span>{

    Map&lt;String, Object&gt; params = Collections.singletonMap(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>);

    given(<span class="hljs-keyword">this</span>.matcher1.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());

    given(<span class="hljs-keyword">this</span>.matcher2.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match(params));

    ServerWebExchangeMatcher.MatchResult matches = <span class="hljs-keyword">this</span>.matcher.matches(<span class="hljs-keyword">this</span>.exchange).block();

    assertThat(matches.isMatch()).isTrue();

    assertThat(matches.getVariables()).isEqualTo(params);

    verify(<span class="hljs-keyword">this</span>.matcher1).matches(<span class="hljs-keyword">this</span>.exchange);

    verify(<span class="hljs-keyword">this</span>.matcher2).matches(<span class="hljs-keyword">this</span>.exchange);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockServerWebExchangeMatcher</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the given matcher to return the provided MatchResult when matches(exchange) is called.
     * &lt;p&gt;
     * Usage example:
     * &lt;pre&gt;
     * MockServerWebExchangeMatcher.stubMatches(matcher1, exchange, ServerWebExchangeMatcher.MatchResult.match(params));
     * &lt;/pre&gt;
     *
     * <span class="hljs-doctag">@param</span> matcher the mock ServerWebExchangeMatcher
     * <span class="hljs-doctag">@param</span> exchange the ServerWebExchange to match against
     * <span class="hljs-doctag">@param</span> matchResult the MatchResult to return (e.g., ServerWebExchangeMatcher.MatchResult.match(params), .notMatch(), etc.)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(ServerWebExchangeMatcher matcher, ServerWebExchange exchange, ServerWebExchangeMatcher.MatchResult matchResult)</span> </span>{
        given(matcher.matches(exchange)).willReturn(matchResult);
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest15312">Test Case ID #spring-security_Test_153_12</h4>
<h4 id="test-case-name-matcheswhenfalsefalsethenfalsefile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverutilmatcherorserverwebexchangematchertestsjava">Test Case Name: <code>matchesWhenFalseFalseThenFalse</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\util\matcher\OrServerWebExchangeMatcherTests.java</code>)</h4>
<h4 id="mock-object-variable-name-matcher2">Mock Object Variable Name: <code>matcher2</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void matchesWhenFalseFalseThenFalse() {
<span class="hljs-deletion">-    given(this.matcher1.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());</span>
<span class="hljs-deletion">-    given(this.matcher2.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher1, this.exchange, ServerWebExchangeMatcher.MatchResult.notMatch());</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher2, this.exchange, ServerWebExchangeMatcher.MatchResult.notMatch());</span>
     ServerWebExchangeMatcher.MatchResult matches = this.matcher.matches(this.exchange).block();
     assertThat(matches.isMatch()).isFalse();
     assertThat(matches.getVariables()).isEmpty();
     verify(this.matcher1).matches(this.exchange);
     verify(this.matcher2).matches(this.exchange);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchesWhenFalseFalseThenFalse</span><span class="hljs-params">()</span> </span>{

    given(<span class="hljs-keyword">this</span>.matcher1.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());

    given(<span class="hljs-keyword">this</span>.matcher2.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());

    ServerWebExchangeMatcher.MatchResult matches = <span class="hljs-keyword">this</span>.matcher.matches(<span class="hljs-keyword">this</span>.exchange).block();

    assertThat(matches.isMatch()).isFalse();

    assertThat(matches.getVariables()).isEmpty();

    verify(<span class="hljs-keyword">this</span>.matcher1).matches(<span class="hljs-keyword">this</span>.exchange);

    verify(<span class="hljs-keyword">this</span>.matcher2).matches(<span class="hljs-keyword">this</span>.exchange);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockServerWebExchangeMatcher</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the given matcher to return the provided MatchResult when matches(exchange) is called.
     * &lt;p&gt;
     * Usage example:
     * &lt;pre&gt;
     * MockServerWebExchangeMatcher.stubMatches(matcher1, exchange, ServerWebExchangeMatcher.MatchResult.match(params));
     * &lt;/pre&gt;
     *
     * <span class="hljs-doctag">@param</span> matcher the mock ServerWebExchangeMatcher
     * <span class="hljs-doctag">@param</span> exchange the ServerWebExchange to match against
     * <span class="hljs-doctag">@param</span> matchResult the MatchResult to return (e.g., ServerWebExchangeMatcher.MatchResult.match(params), .notMatch(), etc.)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(ServerWebExchangeMatcher matcher, ServerWebExchange exchange, ServerWebExchangeMatcher.MatchResult matchResult)</span> </span>{
        given(matcher.matches(exchange)).willReturn(matchResult);
    }
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest15313">Test Case ID #spring-security_Test_153_13</h4>
<h4 id="test-case-name-matcheswhenfalsetruethentruefile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebserverutilmatcherorserverwebexchangematchertestsjava">Test Case Name: <code>matchesWhenFalseTrueThenTrue</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\server\util\matcher\OrServerWebExchangeMatcherTests.java</code>)</h4>
<h4 id="mock-object-variable-name-matcher2">Mock Object Variable Name: <code>matcher2</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void matchesWhenFalseTrueThenTrue() {
     Map&lt;String, Object&gt; params = Collections.singletonMap("foo", "bar");
<span class="hljs-deletion">-    given(this.matcher1.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());</span>
<span class="hljs-deletion">-    given(this.matcher2.matches(this.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match(params));</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher1, this.exchange, ServerWebExchangeMatcher.MatchResult.notMatch());</span>
<span class="hljs-addition">+    MockServerWebExchangeMatcher.stubMatches(this.matcher2, this.exchange, ServerWebExchangeMatcher.MatchResult.match(params));</span>
     ServerWebExchangeMatcher.MatchResult matches = this.matcher.matches(this.exchange).block();
     assertThat(matches.isMatch()).isTrue();
     assertThat(matches.getVariables()).isEqualTo(params);
     verify(this.matcher1).matches(this.exchange);
     verify(this.matcher2).matches(this.exchange);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchesWhenFalseTrueThenTrue</span><span class="hljs-params">()</span> </span>{

    Map&lt;String, Object&gt; params = Collections.singletonMap(<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>);

    given(<span class="hljs-keyword">this</span>.matcher1.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.notMatch());

    given(<span class="hljs-keyword">this</span>.matcher2.matches(<span class="hljs-keyword">this</span>.exchange)).willReturn(ServerWebExchangeMatcher.MatchResult.match(params));

    ServerWebExchangeMatcher.MatchResult matches = <span class="hljs-keyword">this</span>.matcher.matches(<span class="hljs-keyword">this</span>.exchange).block();

    assertThat(matches.isMatch()).isTrue();

    assertThat(matches.getVariables()).isEqualTo(params);

    verify(<span class="hljs-keyword">this</span>.matcher1).matches(<span class="hljs-keyword">this</span>.exchange);

    verify(<span class="hljs-keyword">this</span>.matcher2).matches(<span class="hljs-keyword">this</span>.exchange);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockServerWebExchangeMatcher</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the given matcher to return the provided MatchResult when matches(exchange) is called.
     * &lt;p&gt;
     * Usage example:
     * &lt;pre&gt;
     * MockServerWebExchangeMatcher.stubMatches(matcher1, exchange, ServerWebExchangeMatcher.MatchResult.match(params));
     * &lt;/pre&gt;
     *
     * <span class="hljs-doctag">@param</span> matcher the mock ServerWebExchangeMatcher
     * <span class="hljs-doctag">@param</span> exchange the ServerWebExchange to match against
     * <span class="hljs-doctag">@param</span> matchResult the MatchResult to return (e.g., ServerWebExchangeMatcher.MatchResult.match(params), .notMatch(), etc.)
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(ServerWebExchangeMatcher matcher, ServerWebExchange exchange, ServerWebExchangeMatcher.MatchResult matchResult)</span> </span>{
        given(matcher.matches(exchange)).willReturn(matchResult);
    }
}

</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci185">Mock Clone Instance #spring-security_MCI_185</h2>
<ul>
<li><strong>Scope</strong>: method level</li>
<li><strong>Mocked Class</strong>: <code>jakarta.servlet.FilterChain</code></li>
<li><strong>Test Case Count</strong>: 3</li>
<li><strong>MO Count</strong>: 3</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain fc;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest1851">Test Case ID #spring-security_Test_185_1</h4>
<h4 id="test-case-name-detectsexpiredsessionsfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebconcurrentconcurrentsessionfiltertestsjava">Test Case Name: <code>detectsExpiredSessions</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\concurrent\ConcurrentSessionFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-fc">Mock Object Variable Name: <code>fc</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
     filter.setLogoutHandlers(new LogoutHandler[] { new SecurityContextLogoutHandler() });
     filter.afterPropertiesSet();
<span class="hljs-deletion">-    FilterChain fc = mock(FilterChain.class);</span>
     filter.doFilter(request, response, fc);
     // Expect that the filter chain will not be invoked, as we redirect to expiredUrl
     verifyNoMoreInteractions(fc);
     assertThat(response.getRedirectedUrl()).isEqualTo("/expired.jsp");
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detectsExpiredSessions</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    <span class="hljs-comment">// Setup our HTTP request</span>

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    MockHttpSession session = <span class="hljs-keyword">new</span> MockHttpSession();

    request.setSession(session);

    MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    SessionRegistry registry = <span class="hljs-keyword">new</span> SessionRegistryImpl();

    registry.registerNewSession(session.getId(), <span class="hljs-string">"principal"</span>);

    registry.getSessionInformation(session.getId()).expireNow();

    <span class="hljs-comment">// Setup our test fixture and registry to want this session to be expired</span>

    SimpleRedirectSessionInformationExpiredStrategy expiredSessionStrategy = <span class="hljs-keyword">new</span> SimpleRedirectSessionInformationExpiredStrategy(<span class="hljs-string">"/expired.jsp"</span>);

    ConcurrentSessionFilter filter = <span class="hljs-keyword">new</span> ConcurrentSessionFilter(registry, expiredSessionStrategy);

    filter.setLogoutHandlers(<span class="hljs-keyword">new</span> LogoutHandler[] { <span class="hljs-keyword">new</span> SecurityContextLogoutHandler() });

    filter.afterPropertiesSet();

    FilterChain fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    filter.doFilter(request, response, fc);

    <span class="hljs-comment">// Expect that the filter chain will not be invoked, as we redirect to expiredUrl</span>

    verifyNoMoreInteractions(fc);

    assertThat(response.getRedirectedUrl()).isEqualTo(<span class="hljs-string">"/expired.jsp"</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain fc;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1852">Test Case ID #spring-security_Test_185_2</h4>
<h4 id="test-case-name-returnsexpectedmessagewhennoexpiredurlsetfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebconcurrentconcurrentsessionfiltertestsjava">Test Case Name: <code>returnsExpectedMessageWhenNoExpiredUrlSet</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\concurrent\ConcurrentSessionFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-fc">Mock Object Variable Name: <code>fc</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
     ConcurrentSessionFilter filter = new ConcurrentSessionFilter(registry);
<span class="hljs-deletion">-    FilterChain fc = mock(FilterChain.class);</span>
     filter.doFilter(request, response, fc);
     verifyNoMoreInteractions(fc);
     assertThat(response.getContentAsString()).isEqualTo("This session has been expired (possibly due to multiple concurrent logins being " + "attempted as the same user).");
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-comment">// As above, but with no expiredUrl set.</span>

<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returnsExpectedMessageWhenNoExpiredUrlSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    MockHttpSession session = <span class="hljs-keyword">new</span> MockHttpSession();

    request.setSession(session);

    MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    SessionRegistry registry = <span class="hljs-keyword">new</span> SessionRegistryImpl();

    registry.registerNewSession(session.getId(), <span class="hljs-string">"principal"</span>);

    registry.getSessionInformation(session.getId()).expireNow();

    ConcurrentSessionFilter filter = <span class="hljs-keyword">new</span> ConcurrentSessionFilter(registry);

    FilterChain fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    filter.doFilter(request, response, fc);

    verifyNoMoreInteractions(fc);

    assertThat(response.getContentAsString()).isEqualTo(<span class="hljs-string">"This session has been expired (possibly due to multiple concurrent logins being "</span> + <span class="hljs-string">"attempted as the same user)."</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain fc;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1853">Test Case ID #spring-security_Test_185_3</h4>
<h4 id="test-case-name-lastrequesttimeupdatescorrectlyfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebconcurrentconcurrentsessionfiltertestsjava">Test Case Name: <code>lastRequestTimeUpdatesCorrectly</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\concurrent\ConcurrentSessionFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-fc">Mock Object Variable Name: <code>fc</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
     MockHttpServletResponse response = new MockHttpServletResponse();
<span class="hljs-deletion">-    FilterChain fc = mock(FilterChain.class);</span>
     // Setup our test fixture
     SessionRegistry registry = new SessionRegistryImpl();
     registry.registerNewSession(session.getId(), "principal");
     SimpleRedirectSessionInformationExpiredStrategy expiredSessionStrategy = new SimpleRedirectSessionInformationExpiredStrategy("/expired.jsp");
     ConcurrentSessionFilter filter = new ConcurrentSessionFilter(registry, expiredSessionStrategy);
     Date lastRequest = registry.getSessionInformation(session.getId()).getLastRequest();
     Thread.sleep(1000);
     filter.doFilter(request, response, fc);
     verify(fc).doFilter(request, response);
     assertThat(registry.getSessionInformation(session.getId()).getLastRequest().after(lastRequest)).isTrue();
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lastRequestTimeUpdatesCorrectly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    <span class="hljs-comment">// Setup our HTTP request</span>

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    MockHttpSession session = <span class="hljs-keyword">new</span> MockHttpSession();

    request.setSession(session);

    MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    FilterChain fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-comment">// Setup our test fixture</span>

    SessionRegistry registry = <span class="hljs-keyword">new</span> SessionRegistryImpl();

    registry.registerNewSession(session.getId(), <span class="hljs-string">"principal"</span>);

    SimpleRedirectSessionInformationExpiredStrategy expiredSessionStrategy = <span class="hljs-keyword">new</span> SimpleRedirectSessionInformationExpiredStrategy(<span class="hljs-string">"/expired.jsp"</span>);

    ConcurrentSessionFilter filter = <span class="hljs-keyword">new</span> ConcurrentSessionFilter(registry, expiredSessionStrategy);

    Date lastRequest = registry.getSessionInformation(session.getId()).getLastRequest();

    Thread.sleep(<span class="hljs-number">1000</span>);

    filter.doFilter(request, response, fc);

    verify(fc).doFilter(request, response);

    assertThat(registry.getSessionInformation(session.getId()).getLastRequest().after(lastRequest)).isTrue();

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain fc;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci186">Mock Clone Instance #spring-security_MCI_186</h2>
<ul>
<li><strong>Scope</strong>: method level</li>
<li><strong>Mocked Class</strong>: <code>jakarta.servlet.FilterChain</code></li>
<li><strong>Test Case Count</strong>: 21</li>
<li><strong>MO Count</strong>: 21</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest1861">Test Case ID #spring-security_Test_186_1</h4>
<h4 id="test-case-name-testfilterignoresrequestscontainingnoauthorizationheaderfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>testFilterIgnoresRequestsContainingNoAuthorizationHeader</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void testFilterIgnoresRequestsContainingNoAuthorizationHeader() throws Exception {
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.setServletPath("/some_file.html");
     final MockHttpServletResponse response = new MockHttpServletResponse();
<span class="hljs-deletion">-    FilterChain chain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `chain`</span>
     this.filter.doFilter(request, response, chain);
     verify(chain).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     // Test
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFilterIgnoresRequestsContainingNoAuthorizationHeader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.setServletPath(<span class="hljs-string">"/some_file.html"</span>);

    <span class="hljs-keyword">final</span> MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    FilterChain chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter.doFilter(request, response, chain);

    verify(chain).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    <span class="hljs-comment">// Test</span>

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1862">Test Case ID #spring-security_Test_186_2</h4>
<h4 id="test-case-name-testinvalidbasicauthorizationtokenisignoredfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>testInvalidBasicAuthorizationTokenIsIgnored</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void testInvalidBasicAuthorizationTokenIsIgnored() throws Exception {
     String token = "NOT_A_VALID_TOKEN_AS_MISSING_COLON";
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "Basic " + CodecTestUtils.encodeBase64(token));
     request.setServletPath("/some_file.html");
     request.setSession(new MockHttpSession());
     final MockHttpServletResponse response = new MockHttpServletResponse();
<span class="hljs-deletion">-    FilterChain chain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `chain`</span>
     this.filter.doFilter(request, response, chain);
     verify(chain, never()).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
     assertThat(response.getStatus()).isEqualTo(401);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInvalidBasicAuthorizationTokenIsIgnored</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    String token = <span class="hljs-string">"NOT_A_VALID_TOKEN_AS_MISSING_COLON"</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Basic "</span> + CodecTestUtils.encodeBase64(token));

    request.setServletPath(<span class="hljs-string">"/some_file.html"</span>);

    request.setSession(<span class="hljs-keyword">new</span> MockHttpSession());

    <span class="hljs-keyword">final</span> MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    FilterChain chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter.doFilter(request, response, chain);

    verify(chain, never()).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();

    assertThat(response.getStatus()).isEqualTo(<span class="hljs-number">401</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1863">Test Case ID #spring-security_Test_186_3</h4>
<h4 id="test-case-name-invalidbase64isignoredfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>invalidBase64IsIgnored</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void invalidBase64IsIgnored() throws Exception {
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "Basic NOT_VALID_BASE64");
     request.setServletPath("/some_file.html");
     request.setSession(new MockHttpSession());
     final MockHttpServletResponse response = new MockHttpServletResponse();
<span class="hljs-deletion">-    FilterChain chain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `chain`</span>
     this.filter.doFilter(request, response, chain);
     // The filter chain shouldn't proceed
     verify(chain, never()).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
     assertThat(response.getStatus()).isEqualTo(401);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invalidBase64IsIgnored</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Basic NOT_VALID_BASE64"</span>);

    request.setServletPath(<span class="hljs-string">"/some_file.html"</span>);

    request.setSession(<span class="hljs-keyword">new</span> MockHttpSession());

    <span class="hljs-keyword">final</span> MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    FilterChain chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter.doFilter(request, response, chain);

    <span class="hljs-comment">// The filter chain shouldn't proceed</span>

    verify(chain, never()).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();

    assertThat(response.getStatus()).isEqualTo(<span class="hljs-number">401</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1864">Test Case ID #spring-security_Test_186_4</h4>
<h4 id="test-case-name-testnormaloperationfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>testNormalOperation</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void testNormalOperation() throws Exception {
     String token = "rod:koala";
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "Basic " + CodecTestUtils.encodeBase64(token));
     request.setServletPath("/some_file.html");
     // Test
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
<span class="hljs-deletion">-    FilterChain chain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `chain`</span>
     this.filter.doFilter(request, new MockHttpServletResponse(), chain);
     verify(chain).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNotNull();
     assertThat(SecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo("rod");
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testNormalOperation</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    String token = <span class="hljs-string">"rod:koala"</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Basic "</span> + CodecTestUtils.encodeBase64(token));

    request.setServletPath(<span class="hljs-string">"/some_file.html"</span>);

    <span class="hljs-comment">// Test</span>

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();

    FilterChain chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter.doFilter(request, <span class="hljs-keyword">new</span> MockHttpServletResponse(), chain);

    verify(chain).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNotNull();

    assertThat(SecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo(<span class="hljs-string">"rod"</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1865">Test Case ID #spring-security_Test_186_5</h4>
<h4 id="test-case-name-dofilterwhenschemelowercasethencaseinsensitvematchworksfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>doFilterWhenSchemeLowercaseThenCaseInsensitveMatchWorks</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 // gh-5586
 @Test
 public void doFilterWhenSchemeLowercaseThenCaseInsensitveMatchWorks() throws Exception {
     String token = "rod:koala";
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "basic " + CodecTestUtils.encodeBase64(token));
     request.setServletPath("/some_file.html");
     // Test
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
<span class="hljs-deletion">-    FilterChain chain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `chain`</span>
     this.filter.doFilter(request, new MockHttpServletResponse(), chain);
     verify(chain).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNotNull();
     assertThat(SecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo("rod");
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-comment">// gh-5586</span>

<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterWhenSchemeLowercaseThenCaseInsensitveMatchWorks</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    String token = <span class="hljs-string">"rod:koala"</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"basic "</span> + CodecTestUtils.encodeBase64(token));

    request.setServletPath(<span class="hljs-string">"/some_file.html"</span>);

    <span class="hljs-comment">// Test</span>

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();

    FilterChain chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter.doFilter(request, <span class="hljs-keyword">new</span> MockHttpServletResponse(), chain);

    verify(chain).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNotNull();

    assertThat(SecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo(<span class="hljs-string">"rod"</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1866">Test Case ID #spring-security_Test_186_6</h4>
<h4 id="test-case-name-dofilterwhenschememixedcasethencaseinsensitivematchworksfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>doFilterWhenSchemeMixedCaseThenCaseInsensitiveMatchWorks</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void doFilterWhenSchemeMixedCaseThenCaseInsensitiveMatchWorks() throws Exception {
     String token = "rod:koala";
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "BaSiC " + CodecTestUtils.encodeBase64(token));
     request.setServletPath("/some_file.html");
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
<span class="hljs-deletion">-    FilterChain chain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `chain`</span>
     this.filter.doFilter(request, new MockHttpServletResponse(), chain);
     verify(chain).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNotNull();
     assertThat(SecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo("rod");
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterWhenSchemeMixedCaseThenCaseInsensitiveMatchWorks</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    String token = <span class="hljs-string">"rod:koala"</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"BaSiC "</span> + CodecTestUtils.encodeBase64(token));

    request.setServletPath(<span class="hljs-string">"/some_file.html"</span>);

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();

    FilterChain chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter.doFilter(request, <span class="hljs-keyword">new</span> MockHttpServletResponse(), chain);

    verify(chain).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNotNull();

    assertThat(SecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo(<span class="hljs-string">"rod"</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1867">Test Case ID #spring-security_Test_186_7</h4>
<h4 id="test-case-name-testotherauthorizationschemeisignoredfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>testOtherAuthorizationSchemeIsIgnored</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void testOtherAuthorizationSchemeIsIgnored() throws Exception {
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "SOME_OTHER_AUTHENTICATION_SCHEME");
     request.setServletPath("/some_file.html");
<span class="hljs-deletion">-    FilterChain chain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `chain`</span>
     this.filter.doFilter(request, new MockHttpServletResponse(), chain);
     verify(chain).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOtherAuthorizationSchemeIsIgnored</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"SOME_OTHER_AUTHENTICATION_SCHEME"</span>);

    request.setServletPath(<span class="hljs-string">"/some_file.html"</span>);

    FilterChain chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter.doFilter(request, <span class="hljs-keyword">new</span> MockHttpServletResponse(), chain);

    verify(chain).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1868">Test Case ID #spring-security_Test_186_8</h4>
<h4 id="test-case-name-testsuccessloginthenfailureloginresultsinsessionlosingtokenfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>testSuccessLoginThenFailureLoginResultsInSessionLosingToken</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void testSuccessLoginThenFailureLoginResultsInSessionLosingToken() throws Exception {
     String token = "rod:koala";
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "Basic " + CodecTestUtils.encodeBase64(token));
     request.setServletPath("/some_file.html");
     final MockHttpServletResponse response1 = new MockHttpServletResponse();
<span class="hljs-deletion">-    FilterChain chain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `chain`</span>
     this.filter.doFilter(request, response1, chain);
     verify(chain).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     // Test
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNotNull();
     assertThat(SecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo("rod");
     // NOW PERFORM FAILED AUTHENTICATION
     token = "otherUser:WRONG_PASSWORD";
     request = new MockHttpServletRequest();
     request.addHeader("Authorization", "Basic " + CodecTestUtils.encodeBase64(token));
     final MockHttpServletResponse response2 = new MockHttpServletResponse();
<span class="hljs-deletion">-    chain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock re-assignment; using global field `chain`</span>
     this.filter.doFilter(request, response2, chain);
     verify(chain, never()).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     request.setServletPath("/some_file.html");
     // Test - the filter chain will not be invoked, as we get a 401 forbidden response
     MockHttpServletResponse response = response2;
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
     assertThat(response.getStatus()).isEqualTo(401);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSuccessLoginThenFailureLoginResultsInSessionLosingToken</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    String token = <span class="hljs-string">"rod:koala"</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Basic "</span> + CodecTestUtils.encodeBase64(token));

    request.setServletPath(<span class="hljs-string">"/some_file.html"</span>);

    <span class="hljs-keyword">final</span> MockHttpServletResponse response1 = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    FilterChain chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter.doFilter(request, response1, chain);

    verify(chain).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    <span class="hljs-comment">// Test</span>

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNotNull();

    assertThat(SecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo(<span class="hljs-string">"rod"</span>);

    <span class="hljs-comment">// NOW PERFORM FAILED AUTHENTICATION</span>

    token = <span class="hljs-string">"otherUser:WRONG_PASSWORD"</span>;

    request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Basic "</span> + CodecTestUtils.encodeBase64(token));

    <span class="hljs-keyword">final</span> MockHttpServletResponse response2 = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter.doFilter(request, response2, chain);

    verify(chain, never()).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    request.setServletPath(<span class="hljs-string">"/some_file.html"</span>);

    <span class="hljs-comment">// Test - the filter chain will not be invoked, as we get a 401 forbidden response</span>

    MockHttpServletResponse response = response2;

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();

    assertThat(response.getStatus()).isEqualTo(<span class="hljs-number">401</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1869">Test Case ID #spring-security_Test_186_9</h4>
<h4 id="test-case-name-testwrongpasswordcontinuesfilterchainifignorefailureistruefile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>testWrongPasswordContinuesFilterChainIfIgnoreFailureIsTrue</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void testWrongPasswordContinuesFilterChainIfIgnoreFailureIsTrue() throws Exception {
     String token = "rod:WRONG_PASSWORD";
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "Basic " + CodecTestUtils.encodeBase64(token));
     request.setServletPath("/some_file.html");
     request.setSession(new MockHttpSession());
     this.filter = new BasicAuthenticationFilter(this.manager);
     assertThat(this.filter.isIgnoreFailure()).isTrue();
<span class="hljs-deletion">-    FilterChain chain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `chain`</span>
     this.filter.doFilter(request, new MockHttpServletResponse(), chain);
     verify(chain).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     // Test - the filter chain will be invoked, as we've set ignoreFailure = true
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWrongPasswordContinuesFilterChainIfIgnoreFailureIsTrue</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    String token = <span class="hljs-string">"rod:WRONG_PASSWORD"</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Basic "</span> + CodecTestUtils.encodeBase64(token));

    request.setServletPath(<span class="hljs-string">"/some_file.html"</span>);

    request.setSession(<span class="hljs-keyword">new</span> MockHttpSession());

    <span class="hljs-keyword">this</span>.filter = <span class="hljs-keyword">new</span> BasicAuthenticationFilter(<span class="hljs-keyword">this</span>.manager);

    assertThat(<span class="hljs-keyword">this</span>.filter.isIgnoreFailure()).isTrue();

    FilterChain chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter.doFilter(request, <span class="hljs-keyword">new</span> MockHttpServletResponse(), chain);

    verify(chain).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    <span class="hljs-comment">// Test - the filter chain will be invoked, as we've set ignoreFailure = true</span>

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest18610">Test Case ID #spring-security_Test_186_10</h4>
<h4 id="test-case-name-testwrongpasswordreturnsforbiddenifignorefailureisfalsefile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>testWrongPasswordReturnsForbiddenIfIgnoreFailureIsFalse</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void testWrongPasswordReturnsForbiddenIfIgnoreFailureIsFalse() throws Exception {
     String token = "rod:WRONG_PASSWORD";
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "Basic " + CodecTestUtils.encodeBase64(token));
     request.setServletPath("/some_file.html");
     request.setSession(new MockHttpSession());
     assertThat(this.filter.isIgnoreFailure()).isFalse();
     final MockHttpServletResponse response = new MockHttpServletResponse();
<span class="hljs-deletion">-    FilterChain chain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `chain`</span>
     this.filter.doFilter(request, response, chain);
     // Test - the filter chain will not be invoked, as we get a 401 forbidden response
     verify(chain, never()).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
     assertThat(response.getStatus()).isEqualTo(401);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWrongPasswordReturnsForbiddenIfIgnoreFailureIsFalse</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    String token = <span class="hljs-string">"rod:WRONG_PASSWORD"</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Basic "</span> + CodecTestUtils.encodeBase64(token));

    request.setServletPath(<span class="hljs-string">"/some_file.html"</span>);

    request.setSession(<span class="hljs-keyword">new</span> MockHttpSession());

    assertThat(<span class="hljs-keyword">this</span>.filter.isIgnoreFailure()).isFalse();

    <span class="hljs-keyword">final</span> MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    FilterChain chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter.doFilter(request, response, chain);

    <span class="hljs-comment">// Test - the filter chain will not be invoked, as we get a 401 forbidden response</span>

    verify(chain, never()).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();

    assertThat(response.getStatus()).isEqualTo(<span class="hljs-number">401</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest18611">Test Case ID #spring-security_Test_186_11</h4>
<h4 id="test-case-name-skippedonerrordispatchfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>skippedOnErrorDispatch</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 // SEC-2054
 @Test
 public void skippedOnErrorDispatch() throws Exception {
     String token = "bad:credentials";
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "Basic " + CodecTestUtils.encodeBase64(token));
     request.setServletPath("/some_file.html");
     request.setAttribute(WebUtils.ERROR_REQUEST_URI_ATTRIBUTE, "/error");
     MockHttpServletResponse response = new MockHttpServletResponse();
<span class="hljs-deletion">-    FilterChain chain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `chain`</span>
     this.filter.doFilter(request, response, chain);
     assertThat(response.getStatus()).isEqualTo(200);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-comment">// SEC-2054</span>

<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">skippedOnErrorDispatch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    String token = <span class="hljs-string">"bad:credentials"</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Basic "</span> + CodecTestUtils.encodeBase64(token));

    request.setServletPath(<span class="hljs-string">"/some_file.html"</span>);

    request.setAttribute(WebUtils.ERROR_REQUEST_URI_ATTRIBUTE, <span class="hljs-string">"/error"</span>);

    MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    FilterChain chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter.doFilter(request, response, chain);

    assertThat(response.getStatus()).isEqualTo(<span class="hljs-number">200</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest18612">Test Case ID #spring-security_Test_186_12</h4>
<h4 id="test-case-name-dofilterwhentokenandfiltercharsetmatchdefaultthenauthenticatedfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>doFilterWhenTokenAndFilterCharsetMatchDefaultThenAuthenticated</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void doFilterWhenTokenAndFilterCharsetMatchDefaultThenAuthenticated() throws Exception {
     SecurityContextHolder.clearContext();
     UsernamePasswordAuthenticationToken rodRequest = UsernamePasswordAuthenticationToken.unauthenticated("rod", "äöü");
     rodRequest.setDetails(new WebAuthenticationDetails(new MockHttpServletRequest()));
     Authentication rod = UsernamePasswordAuthenticationToken.authenticated("rod", "äöü", AuthorityUtils.createAuthorityList("ROLE_1"));
     this.manager = mock(AuthenticationManager.class);
     given(this.manager.authenticate(rodRequest)).willReturn(rod);
     given(this.manager.authenticate(not(eq(rodRequest)))).willThrow(new BadCredentialsException(""));
     this.filter = new BasicAuthenticationFilter(this.manager, new BasicAuthenticationEntryPoint());
     String token = "rod:äöü";
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "Basic " + CodecTestUtils.encodeBase64(token.getBytes(StandardCharsets.UTF_8)));
     request.setServletPath("/some_file.html");
     MockHttpServletResponse response = new MockHttpServletResponse();
     // Test
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
<span class="hljs-deletion">-    FilterChain chain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `chain`</span>
     this.filter.doFilter(request, response, chain);
     assertThat(response.getStatus()).isEqualTo(HttpServletResponse.SC_OK);
     verify(chain).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     assertThat(SecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo("rod");
     assertThat(SecurityContextHolder.getContext().getAuthentication().getCredentials()).isEqualTo("äöü");
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterWhenTokenAndFilterCharsetMatchDefaultThenAuthenticated</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    SecurityContextHolder.clearContext();

    UsernamePasswordAuthenticationToken rodRequest = UsernamePasswordAuthenticationToken.unauthenticated(<span class="hljs-string">"rod"</span>, <span class="hljs-string">"äöü"</span>);

    rodRequest.setDetails(<span class="hljs-keyword">new</span> WebAuthenticationDetails(<span class="hljs-keyword">new</span> MockHttpServletRequest()));

    Authentication rod = UsernamePasswordAuthenticationToken.authenticated(<span class="hljs-string">"rod"</span>, <span class="hljs-string">"äöü"</span>, AuthorityUtils.createAuthorityList(<span class="hljs-string">"ROLE_1"</span>));

    <span class="hljs-keyword">this</span>.manager = mock(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(<span class="hljs-keyword">this</span>.manager.authenticate(rodRequest)).willReturn(rod);

    given(<span class="hljs-keyword">this</span>.manager.authenticate(not(eq(rodRequest)))).willThrow(<span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">""</span>));

    <span class="hljs-keyword">this</span>.filter = <span class="hljs-keyword">new</span> BasicAuthenticationFilter(<span class="hljs-keyword">this</span>.manager, <span class="hljs-keyword">new</span> BasicAuthenticationEntryPoint());

    String token = <span class="hljs-string">"rod:äöü"</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Basic "</span> + CodecTestUtils.encodeBase64(token.getBytes(StandardCharsets.UTF_8)));

    request.setServletPath(<span class="hljs-string">"/some_file.html"</span>);

    MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    <span class="hljs-comment">// Test</span>

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();

    FilterChain chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter.doFilter(request, response, chain);

    assertThat(response.getStatus()).isEqualTo(HttpServletResponse.SC_OK);

    verify(chain).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    assertThat(SecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo(<span class="hljs-string">"rod"</span>);

    assertThat(SecurityContextHolder.getContext().getAuthentication().getCredentials()).isEqualTo(<span class="hljs-string">"äöü"</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest18613">Test Case ID #spring-security_Test_186_13</h4>
<h4 id="test-case-name-dofilterwhentokenandfiltercharsetmatchnondefaultthenauthenticatedfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>doFilterWhenTokenAndFilterCharsetMatchNonDefaultThenAuthenticated</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void doFilterWhenTokenAndFilterCharsetMatchNonDefaultThenAuthenticated() throws Exception {
     SecurityContextHolder.clearContext();
     UsernamePasswordAuthenticationToken rodRequest = UsernamePasswordAuthenticationToken.unauthenticated("rod", "äöü");
     rodRequest.setDetails(new WebAuthenticationDetails(new MockHttpServletRequest()));
     Authentication rod = UsernamePasswordAuthenticationToken.authenticated("rod", "äöü", AuthorityUtils.createAuthorityList("ROLE_1"));
     this.manager = mock(AuthenticationManager.class);
     given(this.manager.authenticate(rodRequest)).willReturn(rod);
     given(this.manager.authenticate(not(eq(rodRequest)))).willThrow(new BadCredentialsException(""));
     this.filter = new BasicAuthenticationFilter(this.manager, new BasicAuthenticationEntryPoint());
     this.filter.setCredentialsCharset("ISO-8859-1");
     String token = "rod:äöü";
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "Basic " + CodecTestUtils.encodeBase64(token.getBytes(StandardCharsets.ISO_8859_1)));
     request.setServletPath("/some_file.html");
     MockHttpServletResponse response = new MockHttpServletResponse();
     // Test
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
<span class="hljs-deletion">-    FilterChain chain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `chain`</span>
     this.filter.doFilter(request, response, chain);
     assertThat(response.getStatus()).isEqualTo(HttpServletResponse.SC_OK);
     verify(chain).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     assertThat(SecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo("rod");
     assertThat(SecurityContextHolder.getContext().getAuthentication().getCredentials()).isEqualTo("äöü");
     assertThat(request.getAttribute(RequestAttributeSecurityContextRepository.DEFAULT_REQUEST_ATTR_NAME)).isNotNull();
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterWhenTokenAndFilterCharsetMatchNonDefaultThenAuthenticated</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    SecurityContextHolder.clearContext();

    UsernamePasswordAuthenticationToken rodRequest = UsernamePasswordAuthenticationToken.unauthenticated(<span class="hljs-string">"rod"</span>, <span class="hljs-string">"äöü"</span>);

    rodRequest.setDetails(<span class="hljs-keyword">new</span> WebAuthenticationDetails(<span class="hljs-keyword">new</span> MockHttpServletRequest()));

    Authentication rod = UsernamePasswordAuthenticationToken.authenticated(<span class="hljs-string">"rod"</span>, <span class="hljs-string">"äöü"</span>, AuthorityUtils.createAuthorityList(<span class="hljs-string">"ROLE_1"</span>));

    <span class="hljs-keyword">this</span>.manager = mock(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(<span class="hljs-keyword">this</span>.manager.authenticate(rodRequest)).willReturn(rod);

    given(<span class="hljs-keyword">this</span>.manager.authenticate(not(eq(rodRequest)))).willThrow(<span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">""</span>));

    <span class="hljs-keyword">this</span>.filter = <span class="hljs-keyword">new</span> BasicAuthenticationFilter(<span class="hljs-keyword">this</span>.manager, <span class="hljs-keyword">new</span> BasicAuthenticationEntryPoint());

    <span class="hljs-keyword">this</span>.filter.setCredentialsCharset(<span class="hljs-string">"ISO-8859-1"</span>);

    String token = <span class="hljs-string">"rod:äöü"</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Basic "</span> + CodecTestUtils.encodeBase64(token.getBytes(StandardCharsets.ISO_8859_1)));

    request.setServletPath(<span class="hljs-string">"/some_file.html"</span>);

    MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    <span class="hljs-comment">// Test</span>

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();

    FilterChain chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter.doFilter(request, response, chain);

    assertThat(response.getStatus()).isEqualTo(HttpServletResponse.SC_OK);

    verify(chain).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    assertThat(SecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo(<span class="hljs-string">"rod"</span>);

    assertThat(SecurityContextHolder.getContext().getAuthentication().getCredentials()).isEqualTo(<span class="hljs-string">"äöü"</span>);

    assertThat(request.getAttribute(RequestAttributeSecurityContextRepository.DEFAULT_REQUEST_ATTR_NAME)).isNotNull();

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest18614">Test Case ID #spring-security_Test_186_14</h4>
<h4 id="test-case-name-dofilterwhentokenandfiltercharsetdonotmatchthenunauthorizedfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>doFilterWhenTokenAndFilterCharsetDoNotMatchThenUnauthorized</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void doFilterWhenTokenAndFilterCharsetDoNotMatchThenUnauthorized() throws Exception {
     SecurityContextHolder.clearContext();
     UsernamePasswordAuthenticationToken rodRequest = UsernamePasswordAuthenticationToken.unauthenticated("rod", "äöü");
     rodRequest.setDetails(new WebAuthenticationDetails(new MockHttpServletRequest()));
     Authentication rod = UsernamePasswordAuthenticationToken.authenticated("rod", "äöü", AuthorityUtils.createAuthorityList("ROLE_1"));
     this.manager = mock(AuthenticationManager.class);
     given(this.manager.authenticate(rodRequest)).willReturn(rod);
     given(this.manager.authenticate(not(eq(rodRequest)))).willThrow(new BadCredentialsException(""));
     this.filter = new BasicAuthenticationFilter(this.manager, new BasicAuthenticationEntryPoint());
     this.filter.setCredentialsCharset("ISO-8859-1");
     String token = "rod:äöü";
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "Basic " + CodecTestUtils.encodeBase64(token.getBytes(StandardCharsets.UTF_8)));
     request.setServletPath("/some_file.html");
     MockHttpServletResponse response = new MockHttpServletResponse();
     // Test
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
<span class="hljs-deletion">-    FilterChain chain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `chain`</span>
     this.filter.doFilter(request, response, chain);
     assertThat(response.getStatus()).isEqualTo(HttpServletResponse.SC_UNAUTHORIZED);
     verify(chain, never()).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterWhenTokenAndFilterCharsetDoNotMatchThenUnauthorized</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    SecurityContextHolder.clearContext();

    UsernamePasswordAuthenticationToken rodRequest = UsernamePasswordAuthenticationToken.unauthenticated(<span class="hljs-string">"rod"</span>, <span class="hljs-string">"äöü"</span>);

    rodRequest.setDetails(<span class="hljs-keyword">new</span> WebAuthenticationDetails(<span class="hljs-keyword">new</span> MockHttpServletRequest()));

    Authentication rod = UsernamePasswordAuthenticationToken.authenticated(<span class="hljs-string">"rod"</span>, <span class="hljs-string">"äöü"</span>, AuthorityUtils.createAuthorityList(<span class="hljs-string">"ROLE_1"</span>));

    <span class="hljs-keyword">this</span>.manager = mock(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(<span class="hljs-keyword">this</span>.manager.authenticate(rodRequest)).willReturn(rod);

    given(<span class="hljs-keyword">this</span>.manager.authenticate(not(eq(rodRequest)))).willThrow(<span class="hljs-keyword">new</span> BadCredentialsException(<span class="hljs-string">""</span>));

    <span class="hljs-keyword">this</span>.filter = <span class="hljs-keyword">new</span> BasicAuthenticationFilter(<span class="hljs-keyword">this</span>.manager, <span class="hljs-keyword">new</span> BasicAuthenticationEntryPoint());

    <span class="hljs-keyword">this</span>.filter.setCredentialsCharset(<span class="hljs-string">"ISO-8859-1"</span>);

    String token = <span class="hljs-string">"rod:äöü"</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Basic "</span> + CodecTestUtils.encodeBase64(token.getBytes(StandardCharsets.UTF_8)));

    request.setServletPath(<span class="hljs-string">"/some_file.html"</span>);

    MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    <span class="hljs-comment">// Test</span>

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();

    FilterChain chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter.doFilter(request, response, chain);

    assertThat(response.getStatus()).isEqualTo(HttpServletResponse.SC_UNAUTHORIZED);

    verify(chain, never()).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest18615">Test Case ID #spring-security_Test_186_15</h4>
<h4 id="test-case-name-requestwhenemptybasicauthorizationheadertokenthenunauthorizedfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>requestWhenEmptyBasicAuthorizationHeaderTokenThenUnauthorized</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void requestWhenEmptyBasicAuthorizationHeaderTokenThenUnauthorized() throws Exception {
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "Basic ");
     request.setServletPath("/some_file.html");
     request.setSession(new MockHttpSession());
     final MockHttpServletResponse response = new MockHttpServletResponse();
<span class="hljs-deletion">-    FilterChain chain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `chain`</span>
     this.filter.doFilter(request, response, chain);
     verify(chain, never()).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
     assertThat(response.getStatus()).isEqualTo(401);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestWhenEmptyBasicAuthorizationHeaderTokenThenUnauthorized</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Basic "</span>);

    request.setServletPath(<span class="hljs-string">"/some_file.html"</span>);

    request.setSession(<span class="hljs-keyword">new</span> MockHttpSession());

    <span class="hljs-keyword">final</span> MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    FilterChain chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter.doFilter(request, response, chain);

    verify(chain, never()).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();

    assertThat(response.getStatus()).isEqualTo(<span class="hljs-number">401</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest18616">Test Case ID #spring-security_Test_186_16</h4>
<h4 id="test-case-name-requestwhensecuritycontextrepositoryfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>requestWhenSecurityContextRepository</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-chain">Mock Object Variable Name: <code>chain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void requestWhenSecurityContextRepository() throws Exception {
     ArgumentCaptor&lt;SecurityContext&gt; contextArg = ArgumentCaptor.forClass(SecurityContext.class);
     SecurityContextRepository securityContextRepository = mock(SecurityContextRepository.class);
     this.filter.setSecurityContextRepository(securityContextRepository);
     String token = "rod:koala";
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "Basic " + CodecTestUtils.encodeBase64(token));
     request.setServletPath("/some_file.html");
     MockHttpServletResponse response = new MockHttpServletResponse();
     // Test
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();
<span class="hljs-deletion">-    FilterChain chain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `chain`</span>
     this.filter.doFilter(request, response, chain);
     verify(chain).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNotNull();
     assertThat(SecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo("rod");
     verify(securityContextRepository).saveContext(contextArg.capture(), eq(request), eq(response));
     assertThat(contextArg.getValue().getAuthentication().getName()).isEqualTo("rod");
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">requestWhenSecurityContextRepository</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    ArgumentCaptor&lt;SecurityContext&gt; contextArg = ArgumentCaptor.forClass(SecurityContext<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    SecurityContextRepository securityContextRepository = mock(SecurityContextRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter.setSecurityContextRepository(securityContextRepository);

    String token = <span class="hljs-string">"rod:koala"</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Basic "</span> + CodecTestUtils.encodeBase64(token));

    request.setServletPath(<span class="hljs-string">"/some_file.html"</span>);

    MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    <span class="hljs-comment">// Test</span>

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNull();

    FilterChain chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-keyword">this</span>.filter.doFilter(request, response, chain);

    verify(chain).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNotNull();

    assertThat(SecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo(<span class="hljs-string">"rod"</span>);

    verify(securityContextRepository).saveContext(contextArg.capture(), eq(request), eq(response));

    assertThat(contextArg.getValue().getAuthentication().getName()).isEqualTo(<span class="hljs-string">"rod"</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest18617">Test Case ID #spring-security_Test_186_17</h4>
<h4 id="test-case-name-dofilterwhenusernamedoesnotchangethenauthenticationisnotrequiredfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>doFilterWhenUsernameDoesNotChangeThenAuthenticationIsNotRequired</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-filterchain">Mock Object Variable Name: <code>filterChain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void doFilterWhenUsernameDoesNotChangeThenAuthenticationIsNotRequired() throws Exception {
     SecurityContextHolderStrategy securityContextHolderStrategy = SecurityContextHolder.getContextHolderStrategy();
     SecurityContext securityContext = securityContextHolderStrategy.createEmptyContext();
     Authentication authentication = UsernamePasswordAuthenticationToken.authenticated("rod", "koala", AuthorityUtils.createAuthorityList("USER"));
     securityContext.setAuthentication(authentication);
     securityContextHolderStrategy.setContext(securityContext);
     String token = "rod:koala";
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "Basic " + CodecTestUtils.encodeBase64(token));
<span class="hljs-deletion">-    FilterChain filterChain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `filterChain`</span>
     MockHttpServletResponse response = new MockHttpServletResponse();
     this.filter.doFilter(request, response, filterChain);
     assertThat(response.getStatus()).isEqualTo(200);
     verify(this.manager, never()).authenticate(any(Authentication.class));
     verify(filterChain).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     verifyNoMoreInteractions(this.manager, filterChain);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterWhenUsernameDoesNotChangeThenAuthenticationIsNotRequired</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    SecurityContextHolderStrategy securityContextHolderStrategy = SecurityContextHolder.getContextHolderStrategy();

    SecurityContext securityContext = securityContextHolderStrategy.createEmptyContext();

    Authentication authentication = UsernamePasswordAuthenticationToken.authenticated(<span class="hljs-string">"rod"</span>, <span class="hljs-string">"koala"</span>, AuthorityUtils.createAuthorityList(<span class="hljs-string">"USER"</span>));

    securityContext.setAuthentication(authentication);

    securityContextHolderStrategy.setContext(securityContext);

    String token = <span class="hljs-string">"rod:koala"</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Basic "</span> + CodecTestUtils.encodeBase64(token));

    FilterChain filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    <span class="hljs-keyword">this</span>.filter.doFilter(request, response, filterChain);

    assertThat(response.getStatus()).isEqualTo(<span class="hljs-number">200</span>);

    verify(<span class="hljs-keyword">this</span>.manager, never()).authenticate(any(Authentication<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;

    verify(filterChain).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    verifyNoMoreInteractions(<span class="hljs-keyword">this</span>.manager, filterChain);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest18618">Test Case ID #spring-security_Test_186_18</h4>
<h4 id="test-case-name-dofilterwhenusernamechangesthenauthenticationisrequiredfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>doFilterWhenUsernameChangesThenAuthenticationIsRequired</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-filterchain">Mock Object Variable Name: <code>filterChain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void doFilterWhenUsernameChangesThenAuthenticationIsRequired() throws Exception {
     SecurityContextHolderStrategy securityContextHolderStrategy = SecurityContextHolder.getContextHolderStrategy();
     SecurityContext securityContext = securityContextHolderStrategy.createEmptyContext();
     Authentication authentication = UsernamePasswordAuthenticationToken.authenticated("user", "password", AuthorityUtils.createAuthorityList("USER"));
     securityContext.setAuthentication(authentication);
     securityContextHolderStrategy.setContext(securityContext);
     String token = "rod:koala";
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "Basic " + CodecTestUtils.encodeBase64(token));
<span class="hljs-deletion">-    FilterChain filterChain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `filterChain`</span>
     MockHttpServletResponse response = new MockHttpServletResponse();
     this.filter.doFilter(request, response, filterChain);
     assertThat(response.getStatus()).isEqualTo(200);
     ArgumentCaptor&lt;Authentication&gt; authenticationCaptor = ArgumentCaptor.forClass(Authentication.class);
     verify(this.manager).authenticate(authenticationCaptor.capture());
     verify(filterChain).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     verifyNoMoreInteractions(this.manager, filterChain);
     Authentication authenticationRequest = authenticationCaptor.getValue();
     assertThat(authenticationRequest).isInstanceOf(UsernamePasswordAuthenticationToken.class);
     assertThat(authenticationRequest.getName()).isEqualTo("rod");
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterWhenUsernameChangesThenAuthenticationIsRequired</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    SecurityContextHolderStrategy securityContextHolderStrategy = SecurityContextHolder.getContextHolderStrategy();

    SecurityContext securityContext = securityContextHolderStrategy.createEmptyContext();

    Authentication authentication = UsernamePasswordAuthenticationToken.authenticated(<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>, AuthorityUtils.createAuthorityList(<span class="hljs-string">"USER"</span>));

    securityContext.setAuthentication(authentication);

    securityContextHolderStrategy.setContext(securityContext);

    String token = <span class="hljs-string">"rod:koala"</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Basic "</span> + CodecTestUtils.encodeBase64(token));

    FilterChain filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    <span class="hljs-keyword">this</span>.filter.doFilter(request, response, filterChain);

    assertThat(response.getStatus()).isEqualTo(<span class="hljs-number">200</span>);

    ArgumentCaptor&lt;Authentication&gt; authenticationCaptor = ArgumentCaptor.forClass(Authentication<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    verify(<span class="hljs-keyword">this</span>.manager).authenticate(authenticationCaptor.capture());

    verify(filterChain).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    verifyNoMoreInteractions(<span class="hljs-keyword">this</span>.manager, filterChain);

    Authentication authenticationRequest = authenticationCaptor.getValue();

    assertThat(authenticationRequest).isInstanceOf(UsernamePasswordAuthenticationToken<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    assertThat(authenticationRequest.getName()).isEqualTo(<span class="hljs-string">"rod"</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest18619">Test Case ID #spring-security_Test_186_19</h4>
<h4 id="test-case-name-dofilterwhenusernamechangesandnotusernamepasswordauthenticationtokenthenauthenticationisrequiredfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>doFilterWhenUsernameChangesAndNotUsernamePasswordAuthenticationTokenThenAuthenticationIsRequired</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-filterchain">Mock Object Variable Name: <code>filterChain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void doFilterWhenUsernameChangesAndNotUsernamePasswordAuthenticationTokenThenAuthenticationIsRequired() throws Exception {
     SecurityContextHolderStrategy securityContextHolderStrategy = SecurityContextHolder.getContextHolderStrategy();
     SecurityContext securityContext = securityContextHolderStrategy.createEmptyContext();
     Authentication authentication = new TestingAuthenticationToken("user", "password", "USER");
     securityContext.setAuthentication(authentication);
     securityContextHolderStrategy.setContext(securityContext);
     String token = "rod:koala";
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "Basic " + CodecTestUtils.encodeBase64(token));
<span class="hljs-deletion">-    FilterChain filterChain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `filterChain`</span>
     MockHttpServletResponse response = new MockHttpServletResponse();
     this.filter.doFilter(request, response, filterChain);
     assertThat(response.getStatus()).isEqualTo(200);
     ArgumentCaptor&lt;Authentication&gt; authenticationCaptor = ArgumentCaptor.forClass(Authentication.class);
     verify(this.manager).authenticate(authenticationCaptor.capture());
     verify(filterChain).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     verifyNoMoreInteractions(this.manager, filterChain);
     Authentication authenticationRequest = authenticationCaptor.getValue();
     assertThat(authenticationRequest).isInstanceOf(UsernamePasswordAuthenticationToken.class);
     assertThat(authenticationRequest.getName()).isEqualTo("rod");
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterWhenUsernameChangesAndNotUsernamePasswordAuthenticationTokenThenAuthenticationIsRequired</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    SecurityContextHolderStrategy securityContextHolderStrategy = SecurityContextHolder.getContextHolderStrategy();

    SecurityContext securityContext = securityContextHolderStrategy.createEmptyContext();

    Authentication authentication = <span class="hljs-keyword">new</span> TestingAuthenticationToken(<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>, <span class="hljs-string">"USER"</span>);

    securityContext.setAuthentication(authentication);

    securityContextHolderStrategy.setContext(securityContext);

    String token = <span class="hljs-string">"rod:koala"</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Basic "</span> + CodecTestUtils.encodeBase64(token));

    FilterChain filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    <span class="hljs-keyword">this</span>.filter.doFilter(request, response, filterChain);

    assertThat(response.getStatus()).isEqualTo(<span class="hljs-number">200</span>);

    ArgumentCaptor&lt;Authentication&gt; authenticationCaptor = ArgumentCaptor.forClass(Authentication<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    verify(<span class="hljs-keyword">this</span>.manager).authenticate(authenticationCaptor.capture());

    verify(filterChain).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    verifyNoMoreInteractions(<span class="hljs-keyword">this</span>.manager, filterChain);

    Authentication authenticationRequest = authenticationCaptor.getValue();

    assertThat(authenticationRequest).isInstanceOf(UsernamePasswordAuthenticationToken<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    assertThat(authenticationRequest.getName()).isEqualTo(<span class="hljs-string">"rod"</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest18620">Test Case ID #spring-security_Test_186_20</h4>
<h4 id="test-case-name-dofilterwhencustomauthenticationconverterthatignoresrequestthenignoresfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>doFilterWhenCustomAuthenticationConverterThatIgnoresRequestThenIgnores</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-filterchain">Mock Object Variable Name: <code>filterChain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void doFilterWhenCustomAuthenticationConverterThatIgnoresRequestThenIgnores() throws Exception {
     this.filter.setAuthenticationConverter(new TestAuthenticationConverter());
     String token = "rod:koala";
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "Basic " + CodecTestUtils.encodeBase64(token));
     request.setServletPath("/ignored");
<span class="hljs-deletion">-    FilterChain filterChain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `filterChain`</span>
     MockHttpServletResponse response = new MockHttpServletResponse();
     this.filter.doFilter(request, response, filterChain);
     assertThat(response.getStatus()).isEqualTo(200);
     verify(this.manager, never()).authenticate(any(Authentication.class));
     verify(filterChain).doFilter(any(ServletRequest.class), any(ServletResponse.class));
     verifyNoMoreInteractions(this.manager, filterChain);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterWhenCustomAuthenticationConverterThatIgnoresRequestThenIgnores</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    <span class="hljs-keyword">this</span>.filter.setAuthenticationConverter(<span class="hljs-keyword">new</span> TestAuthenticationConverter());

    String token = <span class="hljs-string">"rod:koala"</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Basic "</span> + CodecTestUtils.encodeBase64(token));

    request.setServletPath(<span class="hljs-string">"/ignored"</span>);

    FilterChain filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    <span class="hljs-keyword">this</span>.filter.doFilter(request, response, filterChain);

    assertThat(response.getStatus()).isEqualTo(<span class="hljs-number">200</span>);

    verify(<span class="hljs-keyword">this</span>.manager, never()).authenticate(any(Authentication<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;

    verify(filterChain).doFilter(any(ServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">ServletResponse</span>.<span class="hljs-title">class</span>))</span>;

    verifyNoMoreInteractions(<span class="hljs-keyword">this</span>.manager, filterChain);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest18621">Test Case ID #spring-security_Test_186_21</h4>
<h4 id="test-case-name-dofilterwhencustomauthenticationconverterrequestthenauthenticatefile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationwwwbasicauthenticationfiltertestsjava">Test Case Name: <code>doFilterWhenCustomAuthenticationConverterRequestThenAuthenticate</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\www\BasicAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-filterchain">Mock Object Variable Name: <code>filterChain</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void doFilterWhenCustomAuthenticationConverterRequestThenAuthenticate() throws Exception {
     this.filter.setAuthenticationConverter(new TestAuthenticationConverter());
     String token = "rod:koala";
     MockHttpServletRequest request = new MockHttpServletRequest();
     request.addHeader("Authorization", "Basic " + CodecTestUtils.encodeBase64(token));
     request.setServletPath("/ok");
<span class="hljs-deletion">-    FilterChain filterChain = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `filterChain`</span>
     MockHttpServletResponse response = new MockHttpServletResponse();
     this.filter.doFilter(request, response, filterChain);
     assertThat(response.getStatus()).isEqualTo(200);
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isNotNull();
     assertThat(SecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo("rod");
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilterWhenCustomAuthenticationConverterRequestThenAuthenticate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    <span class="hljs-keyword">this</span>.filter.setAuthenticationConverter(<span class="hljs-keyword">new</span> TestAuthenticationConverter());

    String token = <span class="hljs-string">"rod:koala"</span>;

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    request.addHeader(<span class="hljs-string">"Authorization"</span>, <span class="hljs-string">"Basic "</span> + CodecTestUtils.encodeBase64(token));

    request.setServletPath(<span class="hljs-string">"/ok"</span>);

    FilterChain filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    <span class="hljs-keyword">this</span>.filter.doFilter(request, response, filterChain);

    assertThat(response.getStatus()).isEqualTo(<span class="hljs-number">200</span>);

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isNotNull();

    assertThat(SecurityContextHolder.getContext().getAuthentication().getName()).isEqualTo(<span class="hljs-string">"rod"</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain chain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    chain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

<span class="hljs-comment">// For test methods using 'filterChain' as the variable name:</span>
<span class="hljs-keyword">private</span> FilterChain filterChain;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    filterChain = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci187">Mock Clone Instance #spring-security_MCI_187</h2>
<ul>
<li><strong>Scope</strong>: method level</li>
<li><strong>Mocked Class</strong>: <code>jakarta.servlet.FilterChain</code></li>
<li><strong>Test Case Count</strong>: 6</li>
<li><strong>MO Count</strong>: 6</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain fc;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest1871">Test Case ID #spring-security_Test_187_1</h4>
<h4 id="test-case-name-testoperationwhenauthenticationexistsincontextholderfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationremembermeremembermeauthenticationfiltertestsjava">Test Case Name: <code>testOperationWhenAuthenticationExistsInContextHolder</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\rememberme\RememberMeAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-fc">Mock Object Variable Name: <code>fc</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void testOperationWhenAuthenticationExistsInContextHolder() throws Exception {
     // Put an Authentication object into the SecurityContextHolder
     Authentication originalAuth = new TestingAuthenticationToken("user", "password", "ROLE_A");
     SecurityContextHolder.getContext().setAuthentication(originalAuth);
     // Setup our filter correctly
     RememberMeAuthenticationFilter filter = new RememberMeAuthenticationFilter(mock(AuthenticationManager.class), new MockRememberMeServices(this.remembered));
     filter.afterPropertiesSet();
     // Test
     MockHttpServletRequest request = new MockHttpServletRequest();
<span class="hljs-deletion">-    FilterChain fc = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `fc`</span>
     request.setRequestURI("x");
     filter.doFilter(request, new MockHttpServletResponse(), fc);
     // Ensure filter didn't change our original object
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(originalAuth);
     verify(fc).doFilter(any(HttpServletRequest.class), any(HttpServletResponse.class));
}
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOperationWhenAuthenticationExistsInContextHolder</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    <span class="hljs-comment">// Put an Authentication object into the SecurityContextHolder</span>

    Authentication originalAuth = <span class="hljs-keyword">new</span> TestingAuthenticationToken(<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>, <span class="hljs-string">"ROLE_A"</span>);

    SecurityContextHolder.getContext().setAuthentication(originalAuth);

    <span class="hljs-comment">// Setup our filter correctly</span>

    RememberMeAuthenticationFilter filter = <span class="hljs-keyword">new</span> RememberMeAuthenticationFilter(mock(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">new</span> <span class="hljs-title">MockRememberMeServices</span>(<span class="hljs-title">this</span>.<span class="hljs-title">remembered</span>))</span>;

    filter.afterPropertiesSet();

    <span class="hljs-comment">// Test</span>

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    FilterChain fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    request.setRequestURI(<span class="hljs-string">"x"</span>);

    filter.doFilter(request, <span class="hljs-keyword">new</span> MockHttpServletResponse(), fc);

    <span class="hljs-comment">// Ensure filter didn't change our original object</span>

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(originalAuth);

    verify(fc).doFilter(any(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">HttpServletResponse</span>.<span class="hljs-title">class</span>))</span>;

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain fc;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1872">Test Case ID #spring-security_Test_187_2</h4>
<h4 id="test-case-name-testoperationwhennoauthenticationincontextholderfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationremembermeremembermeauthenticationfiltertestsjava">Test Case Name: <code>testOperationWhenNoAuthenticationInContextHolder</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\rememberme\RememberMeAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-fc">Mock Object Variable Name: <code>fc</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void testOperationWhenNoAuthenticationInContextHolder() throws Exception {
     AuthenticationManager am = mock(AuthenticationManager.class);
     given(am.authenticate(this.remembered)).willReturn(this.remembered);
     RememberMeAuthenticationFilter filter = new RememberMeAuthenticationFilter(am, new MockRememberMeServices(this.remembered));
     filter.afterPropertiesSet();
     MockHttpServletRequest request = new MockHttpServletRequest();
<span class="hljs-deletion">-    FilterChain fc = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `fc`</span>
     request.setRequestURI("x");
     filter.doFilter(request, new MockHttpServletResponse(), fc);
     // Ensure filter setup with our remembered authentication object
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(this.remembered);
     verify(fc).doFilter(any(HttpServletRequest.class), any(HttpServletResponse.class));
}
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testOperationWhenNoAuthenticationInContextHolder</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    AuthenticationManager am = mock(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(am.authenticate(<span class="hljs-keyword">this</span>.remembered)).willReturn(<span class="hljs-keyword">this</span>.remembered);

    RememberMeAuthenticationFilter filter = <span class="hljs-keyword">new</span> RememberMeAuthenticationFilter(am, <span class="hljs-keyword">new</span> MockRememberMeServices(<span class="hljs-keyword">this</span>.remembered));

    filter.afterPropertiesSet();

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    FilterChain fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    request.setRequestURI(<span class="hljs-string">"x"</span>);

    filter.doFilter(request, <span class="hljs-keyword">new</span> MockHttpServletResponse(), fc);

    <span class="hljs-comment">// Ensure filter setup with our remembered authentication object</span>

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(<span class="hljs-keyword">this</span>.remembered);

    verify(fc).doFilter(any(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">HttpServletResponse</span>.<span class="hljs-title">class</span>))</span>;

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain fc;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1873">Test Case ID #spring-security_Test_187_3</h4>
<h4 id="test-case-name-onunsuccessfulloginiscalledwhenproviderrejectsauthfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationremembermeremembermeauthenticationfiltertestsjava">Test Case Name: <code>onUnsuccessfulLoginIsCalledWhenProviderRejectsAuth</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\rememberme\RememberMeAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-fc">Mock Object Variable Name: <code>fc</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void onUnsuccessfulLoginIsCalledWhenProviderRejectsAuth() throws Exception {
     final Authentication failedAuth = new TestingAuthenticationToken("failed", "");
     AuthenticationManager am = mock(AuthenticationManager.class);
     given(am.authenticate(any(Authentication.class))).willThrow(new BadCredentialsException(""));
     RememberMeAuthenticationFilter filter = new RememberMeAuthenticationFilter(am, new MockRememberMeServices(this.remembered)) {

         @Override
         protected void onUnsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) {
             super.onUnsuccessfulAuthentication(request, response, failed);
             SecurityContextHolder.getContext().setAuthentication(failedAuth);
         }
     };
     filter.setApplicationEventPublisher(mock(ApplicationEventPublisher.class));
     filter.afterPropertiesSet();
     MockHttpServletRequest request = new MockHttpServletRequest();
<span class="hljs-deletion">-    FilterChain fc = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `fc`</span>
     request.setRequestURI("x");
     filter.doFilter(request, new MockHttpServletResponse(), fc);
     assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(failedAuth);
     verify(fc).doFilter(any(HttpServletRequest.class), any(HttpServletResponse.class));
}
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUnsuccessfulLoginIsCalledWhenProviderRejectsAuth</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    <span class="hljs-keyword">final</span> Authentication failedAuth = <span class="hljs-keyword">new</span> TestingAuthenticationToken(<span class="hljs-string">"failed"</span>, <span class="hljs-string">""</span>);

    AuthenticationManager am = mock(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(am.authenticate(any(Authentication<span class="hljs-class">.<span class="hljs-keyword">class</span>))).<span class="hljs-title">willThrow</span>(<span class="hljs-title">new</span> <span class="hljs-title">BadCredentialsException</span>(""))</span>;

    RememberMeAuthenticationFilter filter = <span class="hljs-keyword">new</span> RememberMeAuthenticationFilter(am, <span class="hljs-keyword">new</span> MockRememberMeServices(<span class="hljs-keyword">this</span>.remembered)) {



        <span class="hljs-meta">@Override</span>

        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUnsuccessfulAuthentication</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed)</span> </span>{

            <span class="hljs-keyword">super</span>.onUnsuccessfulAuthentication(request, response, failed);

            SecurityContextHolder.getContext().setAuthentication(failedAuth);

        }

    };

    filter.setApplicationEventPublisher(mock(ApplicationEventPublisher<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;

    filter.afterPropertiesSet();

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    FilterChain fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    request.setRequestURI(<span class="hljs-string">"x"</span>);

    filter.doFilter(request, <span class="hljs-keyword">new</span> MockHttpServletResponse(), fc);

    assertThat(SecurityContextHolder.getContext().getAuthentication()).isSameAs(failedAuth);

    verify(fc).doFilter(any(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">any</span>(<span class="hljs-title">HttpServletResponse</span>.<span class="hljs-title">class</span>))</span>;

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain fc;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1874">Test Case ID #spring-security_Test_187_4</h4>
<h4 id="test-case-name-authenticationsuccesshandlerisinvokedonsuccessfulauthenticationifsetfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationremembermeremembermeauthenticationfiltertestsjava">Test Case Name: <code>authenticationSuccessHandlerIsInvokedOnSuccessfulAuthenticationIfSet</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\rememberme\RememberMeAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-fc">Mock Object Variable Name: <code>fc</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticationSuccessHandlerIsInvokedOnSuccessfulAuthenticationIfSet() throws Exception {
     AuthenticationManager am = mock(AuthenticationManager.class);
     given(am.authenticate(this.remembered)).willReturn(this.remembered);
     RememberMeAuthenticationFilter filter = new RememberMeAuthenticationFilter(am, new MockRememberMeServices(this.remembered));
     filter.setAuthenticationSuccessHandler(new SimpleUrlAuthenticationSuccessHandler("/target"));
     MockHttpServletRequest request = new MockHttpServletRequest();
     MockHttpServletResponse response = new MockHttpServletResponse();
<span class="hljs-deletion">-    FilterChain fc = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `fc`</span>
     request.setRequestURI("x");
     filter.doFilter(request, response, fc);
     assertThat(response.getRedirectedUrl()).isEqualTo("/target");
     // Should return after success handler is invoked, so chain should not proceed
     verifyNoMoreInteractions(fc);
}
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticationSuccessHandlerIsInvokedOnSuccessfulAuthenticationIfSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    AuthenticationManager am = mock(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(am.authenticate(<span class="hljs-keyword">this</span>.remembered)).willReturn(<span class="hljs-keyword">this</span>.remembered);

    RememberMeAuthenticationFilter filter = <span class="hljs-keyword">new</span> RememberMeAuthenticationFilter(am, <span class="hljs-keyword">new</span> MockRememberMeServices(<span class="hljs-keyword">this</span>.remembered));

    filter.setAuthenticationSuccessHandler(<span class="hljs-keyword">new</span> SimpleUrlAuthenticationSuccessHandler(<span class="hljs-string">"/target"</span>));

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    FilterChain fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    request.setRequestURI(<span class="hljs-string">"x"</span>);

    filter.doFilter(request, response, fc);

    assertThat(response.getRedirectedUrl()).isEqualTo(<span class="hljs-string">"/target"</span>);

    <span class="hljs-comment">// Should return after success handler is invoked, so chain should not proceed</span>

    verifyNoMoreInteractions(fc);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain fc;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1875">Test Case ID #spring-security_Test_187_5</h4>
<h4 id="test-case-name-securitycontextrepositoryinvokedifsetfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationremembermeremembermeauthenticationfiltertestsjava">Test Case Name: <code>securityContextRepositoryInvokedIfSet</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\rememberme\RememberMeAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-fc">Mock Object Variable Name: <code>fc</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void securityContextRepositoryInvokedIfSet() throws Exception {
     SecurityContextRepository securityContextRepository = mock(SecurityContextRepository.class);
     AuthenticationManager am = mock(AuthenticationManager.class);
     given(am.authenticate(this.remembered)).willReturn(this.remembered);
     RememberMeAuthenticationFilter filter = new RememberMeAuthenticationFilter(am, new MockRememberMeServices(this.remembered));
     filter.setAuthenticationSuccessHandler(new SimpleUrlAuthenticationSuccessHandler("/target"));
     filter.setSecurityContextRepository(securityContextRepository);
     MockHttpServletRequest request = new MockHttpServletRequest();
     MockHttpServletResponse response = new MockHttpServletResponse();
<span class="hljs-deletion">-    FilterChain fc = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `fc`</span>
     request.setRequestURI("x");
     filter.doFilter(request, response, fc);
     verify(securityContextRepository).saveContext(any(), eq(request), eq(response));
}
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">securityContextRepositoryInvokedIfSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    SecurityContextRepository securityContextRepository = mock(SecurityContextRepository<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    AuthenticationManager am = mock(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(am.authenticate(<span class="hljs-keyword">this</span>.remembered)).willReturn(<span class="hljs-keyword">this</span>.remembered);

    RememberMeAuthenticationFilter filter = <span class="hljs-keyword">new</span> RememberMeAuthenticationFilter(am, <span class="hljs-keyword">new</span> MockRememberMeServices(<span class="hljs-keyword">this</span>.remembered));

    filter.setAuthenticationSuccessHandler(<span class="hljs-keyword">new</span> SimpleUrlAuthenticationSuccessHandler(<span class="hljs-string">"/target"</span>));

    filter.setSecurityContextRepository(securityContextRepository);

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    FilterChain fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    request.setRequestURI(<span class="hljs-string">"x"</span>);

    filter.doFilter(request, response, fc);

    verify(securityContextRepository).saveContext(any(), eq(request), eq(response));

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain fc;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1876">Test Case ID #spring-security_Test_187_6</h4>
<h4 id="test-case-name-sessionauthenticationstrategyinvokedifsetfile-cjavaprojectsspringspring-securitywebsrctestjavaorgspringframeworksecuritywebauthenticationremembermeremembermeauthenticationfiltertestsjava">Test Case Name: <code>sessionAuthenticationStrategyInvokedIfSet</code>(File: <code>C:\Java_projects\Spring\spring-security\web\src\test\java\org\springframework\security\web\authentication\rememberme\RememberMeAuthenticationFilterTests.java</code>)</h4>
<h4 id="mock-object-variable-name-fc">Mock Object Variable Name: <code>fc</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void sessionAuthenticationStrategyInvokedIfSet() throws Exception {
     SessionAuthenticationStrategy sessionAuthenticationStrategy = mock(SessionAuthenticationStrategy.class);
     AuthenticationManager am = mock(AuthenticationManager.class);
     given(am.authenticate(this.remembered)).willReturn(this.remembered);
     RememberMeAuthenticationFilter filter = new RememberMeAuthenticationFilter(am, new MockRememberMeServices(this.remembered));
     filter.setAuthenticationSuccessHandler(new SimpleUrlAuthenticationSuccessHandler("/target"));
     filter.setSessionAuthenticationStrategy(sessionAuthenticationStrategy);
     MockHttpServletRequest request = new MockHttpServletRequest();
     MockHttpServletResponse response = new MockHttpServletResponse();
<span class="hljs-deletion">-    FilterChain fc = mock(FilterChain.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `fc`</span>
     request.setRequestURI("x");
     filter.doFilter(request, response, fc);
     verify(sessionAuthenticationStrategy).onAuthentication(any(), eq(request), eq(response));
}
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sessionAuthenticationStrategyInvokedIfSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    SessionAuthenticationStrategy sessionAuthenticationStrategy = mock(SessionAuthenticationStrategy<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    AuthenticationManager am = mock(AuthenticationManager<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(am.authenticate(<span class="hljs-keyword">this</span>.remembered)).willReturn(<span class="hljs-keyword">this</span>.remembered);

    RememberMeAuthenticationFilter filter = <span class="hljs-keyword">new</span> RememberMeAuthenticationFilter(am, <span class="hljs-keyword">new</span> MockRememberMeServices(<span class="hljs-keyword">this</span>.remembered));

    filter.setAuthenticationSuccessHandler(<span class="hljs-keyword">new</span> SimpleUrlAuthenticationSuccessHandler(<span class="hljs-string">"/target"</span>));

    filter.setSessionAuthenticationStrategy(sessionAuthenticationStrategy);

    MockHttpServletRequest request = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    MockHttpServletResponse response = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    FilterChain fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    request.setRequestURI(<span class="hljs-string">"x"</span>);

    filter.doFilter(request, response, fc);

    verify(sessionAuthenticationStrategy).onAuthentication(any(), eq(request), eq(response));

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> FilterChain fc;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    fc = mock(FilterChain<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}

</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci188">Mock Clone Instance #spring-security_MCI_188</h2>
<ul>
<li><strong>Scope</strong>: method level</li>
<li><strong>Mocked Class</strong>: <code>org.springframework.core.convert.converter.Converter&lt;org.springframework.security.saml2.provider.service.authentication.OpenSaml5AuthenticationProvider.ResponseToken, org.springframework.security.saml2.provider.service.authentication.Saml2Authentication&gt;</code></li>
<li><strong>Test Case Count</strong>: 3</li>
<li><strong>MO Count</strong>: 3</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> Converter&lt;ResponseToken, Saml2Authentication&gt; responseAuthenticationConverter;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    responseAuthenticationConverter = mock(Converter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest1881">Test Case ID #spring-security_Test_188_1</h4>
<h4 id="test-case-name-authenticatewhenresponseauthenticationconverterconfiguredthenusesfile-cjavaprojectsspringspring-securitysaml2saml2-service-providersrcopensaml5testjavaorgspringframeworksecuritysaml2providerserviceauthenticationopensaml5authenticationprovidertestsjava">Test Case Name: <code>authenticateWhenResponseAuthenticationConverterConfiguredThenUses</code>(File: <code>C:\Java_projects\Spring\spring-security\saml2\saml2-service-provider\src\opensaml5Test\java\org\springframework\security\saml2\provider\service\authentication\OpenSaml5AuthenticationProviderTests.java</code>)</h4>
<h4 id="mock-object-variable-name-authenticationconverter">Mock Object Variable Name: <code>authenticationConverter</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenResponseAuthenticationConverterConfiguredThenUses() {
<span class="hljs-deletion">-    Converter&lt;ResponseToken, Saml2Authentication&gt; authenticationConverter = mock(Converter.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `responseAuthenticationConverter`</span>
     OpenSaml5AuthenticationProvider provider = new OpenSaml5AuthenticationProvider();
<span class="hljs-deletion">-    provider.setResponseAuthenticationConverter(authenticationConverter);</span>
<span class="hljs-addition">+    provider.setResponseAuthenticationConverter(responseAuthenticationConverter);</span>
     Response response = TestOpenSamlObjects.signedResponseWithOneAssertion();
     Saml2AuthenticationToken token = token(response, verifying(registration()));
     provider.authenticate(token);
<span class="hljs-deletion">-    verify(authenticationConverter).convert(any());</span>
<span class="hljs-addition">+    verify(responseAuthenticationConverter).convert(any());</span>
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenResponseAuthenticationConverterConfiguredThenUses</span><span class="hljs-params">()</span> </span>{

    Converter&lt;ResponseToken, Saml2Authentication&gt; authenticationConverter = mock(Converter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    OpenSaml5AuthenticationProvider provider = <span class="hljs-keyword">new</span> OpenSaml5AuthenticationProvider();

    provider.setResponseAuthenticationConverter(authenticationConverter);

    Response response = TestOpenSamlObjects.signedResponseWithOneAssertion();

    Saml2AuthenticationToken token = token(response, verifying(registration()));

    provider.authenticate(token);

    verify(authenticationConverter).convert(any());

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> Converter&lt;ResponseToken, Saml2Authentication&gt; responseAuthenticationConverter;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    responseAuthenticationConverter = mock(Converter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1882">Test Case ID #spring-security_Test_188_2</h4>
<h4 id="test-case-name-authenticatewhenvalidateresponseafterassertionsthencanhaveresponseauthenticationconverterthatdoesntneedanameidfile-cjavaprojectsspringspring-securitysaml2saml2-service-providersrcopensaml5testjavaorgspringframeworksecuritysaml2providerserviceauthenticationopensaml5authenticationprovidertestsjava">Test Case Name: <code>authenticateWhenValidateResponseAfterAssertionsThenCanHaveResponseAuthenticationConverterThatDoesntNeedANameID</code>(File: <code>C:\Java_projects\Spring\spring-security\saml2\saml2-service-provider\src\opensaml5Test\java\org\springframework\security\saml2\provider\service\authentication\OpenSaml5AuthenticationProviderTests.java</code>)</h4>
<h4 id="mock-object-variable-name-responseauthenticationconverter">Mock Object Variable Name: <code>responseAuthenticationConverter</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenValidateResponseAfterAssertionsThenCanHaveResponseAuthenticationConverterThatDoesntNeedANameID() {
<span class="hljs-deletion">-    Converter&lt;ResponseToken, Saml2Authentication&gt; responseAuthenticationConverter = mock(Converter.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `responseAuthenticationConverter`</span>
     OpenSaml5AuthenticationProvider provider = new OpenSaml5AuthenticationProvider();
     provider.setValidateResponseAfterAssertions(true);
     provider.setResponseAuthenticationConverter(responseAuthenticationConverter);
     Response response = TestOpenSamlObjects.signedResponseWithOneAssertion((r) -&gt; r.getAssertions().get(0).setSubject(null));
     Saml2AuthenticationToken token = token(response, verifying(registration()));
     provider.authenticate(token);
     verify(responseAuthenticationConverter).convert(any());
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenValidateResponseAfterAssertionsThenCanHaveResponseAuthenticationConverterThatDoesntNeedANameID</span><span class="hljs-params">()</span> </span>{

    Converter&lt;ResponseToken, Saml2Authentication&gt; responseAuthenticationConverter = mock(Converter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    OpenSaml5AuthenticationProvider provider = <span class="hljs-keyword">new</span> OpenSaml5AuthenticationProvider();

    provider.setValidateResponseAfterAssertions(<span class="hljs-keyword">true</span>);

    provider.setResponseAuthenticationConverter(responseAuthenticationConverter);

    Response response = TestOpenSamlObjects.signedResponseWithOneAssertion((r) -&gt; r.getAssertions().get(<span class="hljs-number">0</span>).setSubject(<span class="hljs-keyword">null</span>));

    Saml2AuthenticationToken token = token(response, verifying(registration()));

    provider.authenticate(token);

    verify(responseAuthenticationConverter).convert(any());

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> Converter&lt;ResponseToken, Saml2Authentication&gt; responseAuthenticationConverter;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    responseAuthenticationConverter = mock(Converter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1883">Test Case ID #spring-security_Test_188_3</h4>
<h4 id="test-case-name-authenticatewhenvalidateresponsebeforeassertionsthenmusthavenameidfile-cjavaprojectsspringspring-securitysaml2saml2-service-providersrcopensaml5testjavaorgspringframeworksecuritysaml2providerserviceauthenticationopensaml5authenticationprovidertestsjava">Test Case Name: <code>authenticateWhenValidateResponseBeforeAssertionsThenMustHaveNameID</code>(File: <code>C:\Java_projects\Spring\spring-security\saml2\saml2-service-provider\src\opensaml5Test\java\org\springframework\security\saml2\provider\service\authentication\OpenSaml5AuthenticationProviderTests.java</code>)</h4>
<h4 id="mock-object-variable-name-responseauthenticationconverter">Mock Object Variable Name: <code>responseAuthenticationConverter</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenValidateResponseBeforeAssertionsThenMustHaveNameID() {
<span class="hljs-deletion">-    Converter&lt;ResponseToken, Saml2Authentication&gt; responseAuthenticationConverter = mock(Converter.class);</span>
<span class="hljs-addition">+    // removed local mock; replaced with global field `responseAuthenticationConverter`</span>
     OpenSaml5AuthenticationProvider provider = new OpenSaml5AuthenticationProvider();
     provider.setValidateResponseAfterAssertions(false);
     provider.setResponseAuthenticationConverter(responseAuthenticationConverter);
     Response response = TestOpenSamlObjects.signedResponseWithOneAssertion((r) -&gt; r.getAssertions().get(0).setSubject(null));
     Saml2AuthenticationToken token = token(response, verifying(registration()));
     assertThatExceptionOfType(Saml2AuthenticationException.class).isThrownBy(() -&gt; provider.authenticate(token));
     verifyNoInteractions(responseAuthenticationConverter);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenValidateResponseBeforeAssertionsThenMustHaveNameID</span><span class="hljs-params">()</span> </span>{

    Converter&lt;ResponseToken, Saml2Authentication&gt; responseAuthenticationConverter = mock(Converter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    OpenSaml5AuthenticationProvider provider = <span class="hljs-keyword">new</span> OpenSaml5AuthenticationProvider();

    provider.setValidateResponseAfterAssertions(<span class="hljs-keyword">false</span>);

    provider.setResponseAuthenticationConverter(responseAuthenticationConverter);

    Response response = TestOpenSamlObjects.signedResponseWithOneAssertion((r) -&gt; r.getAssertions().get(<span class="hljs-number">0</span>).setSubject(<span class="hljs-keyword">null</span>));

    Saml2AuthenticationToken token = token(response, verifying(registration()));

    assertThatExceptionOfType(Saml2AuthenticationException<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">isThrownBy</span>(() -&gt; <span class="hljs-title">provider</span>.<span class="hljs-title">authenticate</span>(<span class="hljs-title">token</span>))</span>;

    verifyNoInteractions(responseAuthenticationConverter);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">private</span> Converter&lt;ResponseToken, Saml2Authentication&gt; responseAuthenticationConverter;

<span class="hljs-meta">@BeforeEach</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{
    responseAuthenticationConverter = mock(Converter<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
}
</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci189">Mock Clone Instance #spring-security_MCI_189</h2>
<ul>
<li><strong>Scope</strong>: class level</li>
<li><strong>Mocked Class</strong>: <code>org.springframework.web.reactive.function.client.ClientResponse.Headers</code></li>
<li><strong>Test Case Count</strong>: 1</li>
<li><strong>MO Count</strong>: 2</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockClientResponseHeaders</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock of ClientResponse.Headers with WWW-Authenticate header stubbed.
     *
     * <span class="hljs-doctag">@param</span> wwwAuthenticateHeader the value to return for the WWW-Authenticate header
     * <span class="hljs-doctag">@return</span> the mocked ClientResponse.Headers
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClientResponse.<span class="hljs-function">Headers <span class="hljs-title">createMockHeadersWithWwwAuthenticate</span><span class="hljs-params">(String wwwAuthenticateHeader)</span> </span>{
        ClientResponse.Headers headers = mock(ClientResponse.Headers<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        when(headers.header(eq(HttpHeaders.WWW_AUTHENTICATE)))
            .thenReturn(Collections.singletonList(wwwAuthenticateHeader));
        <span class="hljs-keyword">return</span> headers;
    }
}
</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest1891">Test Case ID #spring-security_Test_189_1</h4>
<h4 id="test-case-name-filterwhenwwwauthenticateheaderincludeserrortheninvokefailurehandlerfile-cjavaprojectsspringspring-securityoauth2oauth2-clientsrctestjavaorgspringframeworksecurityoauth2clientwebreactivefunctionclientserveroauth2authorizedclientexchangefilterfunctiontestsjava">Test Case Name: <code>filterWhenWWWAuthenticateHeaderIncludesErrorThenInvokeFailureHandler</code>(File: <code>C:\Java_projects\Spring\spring-security\oauth2\oauth2-client\src\test\java\org\springframework\security\oauth2\client\web\reactive\function\client\ServerOAuth2AuthorizedClientExchangeFilterFunctionTests.java</code>)</h4>
<h4 id="mock-object-variable-name-headers">Mock Object Variable Name: <code>headers</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
    String wwwAuthenticateHeader = "Bearer error=\"insufficient_scope\", " + "error_description=\"The request requires higher privileges than provided by the access token.\", " + "error_uri=\"https://tools.ietf.org/html/rfc6750#section-3.1\"";
<span class="hljs-deletion">-    ClientResponse.Headers headers = mock(ClientResponse.Headers.class);</span>
<span class="hljs-deletion">-    given(headers.header(eq(HttpHeaders.WWW_AUTHENTICATE))).willReturn(Collections.singletonList(wwwAuthenticateHeader));</span>
<span class="hljs-addition">+    ClientResponse.Headers headers = MockClientResponseHeaders.createMockHeadersWithWwwAuthenticate(wwwAuthenticateHeader);</span>
    given(this.exchange.getResponse().headers()).willReturn(headers);
    this.function.filter(request, this.exchange).contextWrite(serverWebExchange()).block();
    assertThat(publisherProbe.wasSubscribed()).isTrue();
    verify(this.authorizationFailureHandler).onAuthorizationFailure(this.authorizationExceptionCaptor.capture(), this.authenticationCaptor.capture(), this.attributesCaptor.capture());
    assertThat(this.authorizationExceptionCaptor.getValue()).isInstanceOfSatisfying(ClientAuthorizationException.class, (ex) -&gt; {
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterWhenWWWAuthenticateHeaderIncludesErrorThenInvokeFailureHandler</span><span class="hljs-params">()</span> </span>{

    <span class="hljs-keyword">this</span>.function.setAuthorizationFailureHandler(<span class="hljs-keyword">this</span>.authorizationFailureHandler);

    PublisherProbe&lt;Void&gt; publisherProbe = PublisherProbe.empty();

    given(<span class="hljs-keyword">this</span>.authorizationFailureHandler.onAuthorizationFailure(any(), any(), any())).willReturn(publisherProbe.mono());

    OAuth2RefreshToken refreshToken = <span class="hljs-keyword">new</span> OAuth2RefreshToken(<span class="hljs-string">"refresh-token"</span>, <span class="hljs-keyword">this</span>.accessToken.getIssuedAt());

    OAuth2AuthorizedClient authorizedClient = <span class="hljs-keyword">new</span> OAuth2AuthorizedClient(<span class="hljs-keyword">this</span>.registration, <span class="hljs-string">"principalName"</span>, <span class="hljs-keyword">this</span>.accessToken, refreshToken);

    ClientRequest request = ClientRequest.create(HttpMethod.GET, URI.create(<span class="hljs-string">"https://example.com"</span>)).attributes(ServerOAuth2AuthorizedClientExchangeFilterFunction.oauth2AuthorizedClient(authorizedClient)).build();

    String wwwAuthenticateHeader = <span class="hljs-string">"Bearer error=\"insufficient_scope\", "</span> + <span class="hljs-string">"error_description=\"The request requires higher privileges than provided by the access token.\", "</span> + <span class="hljs-string">"error_uri=\"https://tools.ietf.org/html/rfc6750#section-3.1\""</span>;

    ClientResponse.Headers headers = mock(ClientResponse.Headers<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(headers.header(eq(HttpHeaders.WWW_AUTHENTICATE))).willReturn(Collections.singletonList(wwwAuthenticateHeader));

    given(<span class="hljs-keyword">this</span>.exchange.getResponse().headers()).willReturn(headers);

    <span class="hljs-keyword">this</span>.function.filter(request, <span class="hljs-keyword">this</span>.exchange).contextWrite(serverWebExchange()).block();

    assertThat(publisherProbe.wasSubscribed()).isTrue();

    verify(<span class="hljs-keyword">this</span>.authorizationFailureHandler).onAuthorizationFailure(<span class="hljs-keyword">this</span>.authorizationExceptionCaptor.capture(), <span class="hljs-keyword">this</span>.authenticationCaptor.capture(), <span class="hljs-keyword">this</span>.attributesCaptor.capture());

    assertThat(<span class="hljs-keyword">this</span>.authorizationExceptionCaptor.getValue()).isInstanceOfSatisfying(ClientAuthorizationException<span class="hljs-class">.<span class="hljs-keyword">class</span>, (<span class="hljs-title">ex</span>) -&gt; </span>{

        assertThat(ex.getClientRegistrationId()).isEqualTo(<span class="hljs-keyword">this</span>.registration.getRegistrationId());

        assertThat(ex.getError().getErrorCode()).isEqualTo(OAuth2ErrorCodes.INSUFFICIENT_SCOPE);

        assertThat(ex.getError().getDescription()).isEqualTo(<span class="hljs-string">"The request requires higher privileges than provided by the access token."</span>);

        assertThat(ex.getError().getUri()).isEqualTo(<span class="hljs-string">"https://tools.ietf.org/html/rfc6750#section-3.1"</span>);

        assertThat(ex).hasNoCause();

        assertThat(ex).hasMessageContaining(OAuth2ErrorCodes.INSUFFICIENT_SCOPE);

    });

    assertThat(<span class="hljs-keyword">this</span>.authenticationCaptor.getValue()).isInstanceOf(AnonymousAuthenticationToken<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    assertThat(<span class="hljs-keyword">this</span>.attributesCaptor.getValue()).containsExactly(entry(ServerWebExchange<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>(), <span class="hljs-title">this</span>.<span class="hljs-title">serverWebExchange</span>))</span>;

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockClientResponseHeaders</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock of ClientResponse.Headers with WWW-Authenticate header stubbed.
     *
     * <span class="hljs-doctag">@param</span> wwwAuthenticateHeader the value to return for the WWW-Authenticate header
     * <span class="hljs-doctag">@return</span> the mocked ClientResponse.Headers
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClientResponse.<span class="hljs-function">Headers <span class="hljs-title">createMockHeadersWithWwwAuthenticate</span><span class="hljs-params">(String wwwAuthenticateHeader)</span> </span>{
        ClientResponse.Headers headers = mock(ClientResponse.Headers<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        when(headers.header(eq(HttpHeaders.WWW_AUTHENTICATE)))
            .thenReturn(Collections.singletonList(wwwAuthenticateHeader));
        <span class="hljs-keyword">return</span> headers;
    }
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1892">Test Case ID #spring-security_Test_189_2</h4>
<h4 id="test-case-name-filterwhenwwwauthenticateheaderincludeserrortheninvokefailurehandlerfile-cjavaprojectsspringspring-securityoauth2oauth2-clientsrctestjavaorgspringframeworksecurityoauth2clientwebreactivefunctionclientservletoauth2authorizedclientexchangefilterfunctiontestsjava">Test Case Name: <code>filterWhenWWWAuthenticateHeaderIncludesErrorThenInvokeFailureHandler</code>(File: <code>C:\Java_projects\Spring\spring-security\oauth2\oauth2-client\src\test\java\org\springframework\security\oauth2\client\web\reactive\function\client\ServletOAuth2AuthorizedClientExchangeFilterFunctionTests.java</code>)</h4>
<h4 id="mock-object-variable-name-headers">Mock Object Variable Name: <code>headers</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
    String wwwAuthenticateHeader = "Bearer error=\"insufficient_scope\", " + "error_description=\"The request requires higher privileges than provided by the access token.\", " + "error_uri=\"https://tools.ietf.org/html/rfc6750#section-3.1\"";
<span class="hljs-deletion">-    ClientResponse.Headers headers = mock(ClientResponse.Headers.class);</span>
<span class="hljs-deletion">-    given(headers.header(eq(HttpHeaders.WWW_AUTHENTICATE))).willReturn(Collections.singletonList(wwwAuthenticateHeader));</span>
<span class="hljs-addition">+    ClientResponse.Headers headers = MockClientResponseHeaders.createMockHeadersWithWwwAuthenticate(wwwAuthenticateHeader);</span>
    given(this.exchange.getResponse().headers()).willReturn(headers);
    this.function.setAuthorizationFailureHandler(this.authorizationFailureHandler);
    this.function.filter(request, this.exchange).block();
    verify(this.authorizationFailureHandler).onAuthorizationFailure(this.authorizationExceptionCaptor.capture(), this.authenticationCaptor.capture(), this.attributesCaptor.capture());
    assertThat(this.authorizationExceptionCaptor.getValue()).isInstanceOfSatisfying(ClientAuthorizationException.class, (ex) -&gt; {
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">filterWhenWWWAuthenticateHeaderIncludesErrorThenInvokeFailureHandler</span><span class="hljs-params">()</span> </span>{

    OAuth2AuthorizedClient authorizedClient = <span class="hljs-keyword">new</span> OAuth2AuthorizedClient(<span class="hljs-keyword">this</span>.registration, <span class="hljs-string">"principalName"</span>, <span class="hljs-keyword">this</span>.accessToken);

    MockHttpServletRequest servletRequest = <span class="hljs-keyword">new</span> MockHttpServletRequest();

    MockHttpServletResponse servletResponse = <span class="hljs-keyword">new</span> MockHttpServletResponse();

    ClientRequest request = ClientRequest.create(HttpMethod.GET, URI.create(<span class="hljs-string">"https://example.com"</span>)).attributes(ServletOAuth2AuthorizedClientExchangeFilterFunction.oauth2AuthorizedClient(authorizedClient)).attributes(ServletOAuth2AuthorizedClientExchangeFilterFunction.httpServletRequest(servletRequest)).attributes(ServletOAuth2AuthorizedClientExchangeFilterFunction.httpServletResponse(servletResponse)).build();

    String wwwAuthenticateHeader = <span class="hljs-string">"Bearer error=\"insufficient_scope\", "</span> + <span class="hljs-string">"error_description=\"The request requires higher privileges than provided by the access token.\", "</span> + <span class="hljs-string">"error_uri=\"https://tools.ietf.org/html/rfc6750#section-3.1\""</span>;

    ClientResponse.Headers headers = mock(ClientResponse.Headers<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(headers.header(eq(HttpHeaders.WWW_AUTHENTICATE))).willReturn(Collections.singletonList(wwwAuthenticateHeader));

    given(<span class="hljs-keyword">this</span>.exchange.getResponse().headers()).willReturn(headers);

    <span class="hljs-keyword">this</span>.function.setAuthorizationFailureHandler(<span class="hljs-keyword">this</span>.authorizationFailureHandler);

    <span class="hljs-keyword">this</span>.function.filter(request, <span class="hljs-keyword">this</span>.exchange).block();

    verify(<span class="hljs-keyword">this</span>.authorizationFailureHandler).onAuthorizationFailure(<span class="hljs-keyword">this</span>.authorizationExceptionCaptor.capture(), <span class="hljs-keyword">this</span>.authenticationCaptor.capture(), <span class="hljs-keyword">this</span>.attributesCaptor.capture());

    assertThat(<span class="hljs-keyword">this</span>.authorizationExceptionCaptor.getValue()).isInstanceOfSatisfying(ClientAuthorizationException<span class="hljs-class">.<span class="hljs-keyword">class</span>, (<span class="hljs-title">ex</span>) -&gt; </span>{

        assertThat(ex.getClientRegistrationId()).isEqualTo(<span class="hljs-keyword">this</span>.registration.getRegistrationId());

        assertThat(ex.getError().getErrorCode()).isEqualTo(OAuth2ErrorCodes.INSUFFICIENT_SCOPE);

        assertThat(ex.getError().getDescription()).isEqualTo(<span class="hljs-string">"The request requires higher privileges than provided by the access token."</span>);

        assertThat(ex.getError().getUri()).isEqualTo(<span class="hljs-string">"https://tools.ietf.org/html/rfc6750#section-3.1"</span>);

        assertThat(ex).hasNoCause();

        assertThat(ex).hasMessageContaining(OAuth2ErrorCodes.INSUFFICIENT_SCOPE);

    });

    assertThat(<span class="hljs-keyword">this</span>.authenticationCaptor.getValue().getName()).isEqualTo(authorizedClient.getPrincipalName());

    assertThat(<span class="hljs-keyword">this</span>.attributesCaptor.getValue()).containsExactly(entry(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>(), <span class="hljs-title">servletRequest</span>), <span class="hljs-title">entry</span>(<span class="hljs-title">HttpServletResponse</span>.<span class="hljs-title">class</span>.<span class="hljs-title">getName</span>(), <span class="hljs-title">servletResponse</span>))</span>;

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockClientResponseHeaders</span> </span>{
    <span class="hljs-comment">/**
     * Creates a mock of ClientResponse.Headers with WWW-Authenticate header stubbed.
     *
     * <span class="hljs-doctag">@param</span> wwwAuthenticateHeader the value to return for the WWW-Authenticate header
     * <span class="hljs-doctag">@return</span> the mocked ClientResponse.Headers
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ClientResponse.<span class="hljs-function">Headers <span class="hljs-title">createMockHeadersWithWwwAuthenticate</span><span class="hljs-params">(String wwwAuthenticateHeader)</span> </span>{
        ClientResponse.Headers headers = mock(ClientResponse.Headers<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        when(headers.header(eq(HttpHeaders.WWW_AUTHENTICATE)))
            .thenReturn(Collections.singletonList(wwwAuthenticateHeader));
        <span class="hljs-keyword">return</span> headers;
    }
}
</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci190">Mock Clone Instance #spring-security_MCI_190</h2>
<ul>
<li><strong>Scope</strong>: method level</li>
<li><strong>Mocked Class</strong>: <code>org.springframework.context.ApplicationContext</code></li>
<li><strong>Test Case Count</strong>: 2</li>
<li><strong>MO Count</strong>: 2</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext <span class="hljs-title">mockApplicationContextWithJwtDecoder</span><span class="hljs-params">(JwtDecoder decoderToReturn)</span> </span>{
    ApplicationContext context = mock(ApplicationContext<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(context.getBean(JwtDecoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)).<span class="hljs-title">willReturn</span>(<span class="hljs-title">decoderToReturn</span>)</span>;
    <span class="hljs-keyword">return</span> context;
}
</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest1901">Test Case ID #spring-security_Test_190_1</h4>
<h4 id="test-case-name-getjwtdecoderwhenconflictingjwtdecodersthenthedslwiredonetakesprecedencefile-cjavaprojectsspringspring-securityconfigsrctestjavaorgspringframeworksecurityconfigannotationwebconfigurersoauth2serverresourceoauth2resourceserverconfigurertestsjava">Test Case Name: <code>getJwtDecoderWhenConflictingJwtDecodersThenTheDslWiredOneTakesPrecedence</code>(File: <code>C:\Java_projects\Spring\spring-security\config\src\test\java\org\springframework\security\config\annotation\web\configurers\oauth2\server\resource\OAuth2ResourceServerConfigurerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-context">Mock Object Variable Name: <code>context</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void getJwtDecoderWhenConflictingJwtDecodersThenTheDslWiredOneTakesPrecedence() {
     JwtDecoder decoderBean = mock(JwtDecoder.class);
     JwtDecoder decoder = mock(JwtDecoder.class);
<span class="hljs-deletion">-    ApplicationContext context = mock(ApplicationContext.class);</span>
<span class="hljs-deletion">-    given(context.getBean(JwtDecoder.class)).willReturn(decoderBean);</span>
<span class="hljs-addition">+    ApplicationContext context = mockApplicationContextWithJwtDecoder(decoderBean);</span>
     OAuth2ResourceServerConfigurer.JwtConfigurer jwtConfigurer = new OAuth2ResourceServerConfigurer(context).jwt();
     jwtConfigurer.decoder(decoder);
     assertThat(jwtConfigurer.getJwtDecoder()).isEqualTo(decoder);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getJwtDecoderWhenConflictingJwtDecodersThenTheDslWiredOneTakesPrecedence</span><span class="hljs-params">()</span> </span>{

    JwtDecoder decoderBean = mock(JwtDecoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    JwtDecoder decoder = mock(JwtDecoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    ApplicationContext context = mock(ApplicationContext<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(context.getBean(JwtDecoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)).<span class="hljs-title">willReturn</span>(<span class="hljs-title">decoderBean</span>)</span>;

    OAuth2ResourceServerConfigurer.JwtConfigurer jwtConfigurer = <span class="hljs-keyword">new</span> OAuth2ResourceServerConfigurer(context).jwt();

    jwtConfigurer.decoder(decoder);

    assertThat(jwtConfigurer.getJwtDecoder()).isEqualTo(decoder);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext <span class="hljs-title">mockApplicationContextWithJwtDecoder</span><span class="hljs-params">(JwtDecoder decoderToReturn)</span> </span>{
    ApplicationContext context = mock(ApplicationContext<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(context.getBean(JwtDecoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)).<span class="hljs-title">willReturn</span>(<span class="hljs-title">decoderToReturn</span>)</span>;
    <span class="hljs-keyword">return</span> context;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1902">Test Case ID #spring-security_Test_190_2</h4>
<h4 id="test-case-name-getjwtdecoderwhencontexthasbeananduserconfiguresjwkseturithenjwkseturitakesprecedencefile-cjavaprojectsspringspring-securityconfigsrctestjavaorgspringframeworksecurityconfigannotationwebconfigurersoauth2serverresourceoauth2resourceserverconfigurertestsjava">Test Case Name: <code>getJwtDecoderWhenContextHasBeanAndUserConfiguresJwkSetUriThenJwkSetUriTakesPrecedence</code>(File: <code>C:\Java_projects\Spring\spring-security\config\src\test\java\org\springframework\security\config\annotation\web\configurers\oauth2\server\resource\OAuth2ResourceServerConfigurerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-context">Mock Object Variable Name: <code>context</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void getJwtDecoderWhenContextHasBeanAndUserConfiguresJwkSetUriThenJwkSetUriTakesPrecedence() {
     JwtDecoder decoder = mock(JwtDecoder.class);
<span class="hljs-deletion">-    ApplicationContext context = mock(ApplicationContext.class);</span>
<span class="hljs-deletion">-    given(context.getBean(JwtDecoder.class)).willReturn(decoder);</span>
<span class="hljs-addition">+    ApplicationContext context = mockApplicationContextWithJwtDecoder(decoder);</span>
     OAuth2ResourceServerConfigurer.JwtConfigurer jwtConfigurer = new OAuth2ResourceServerConfigurer(context).jwt();
     jwtConfigurer.jwkSetUri(JWK_SET_URI);
     assertThat(jwtConfigurer.getJwtDecoder()).isNotEqualTo(decoder);
     assertThat(jwtConfigurer.getJwtDecoder()).isInstanceOf(NimbusJwtDecoder.class);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getJwtDecoderWhenContextHasBeanAndUserConfiguresJwkSetUriThenJwkSetUriTakesPrecedence</span><span class="hljs-params">()</span> </span>{

    JwtDecoder decoder = mock(JwtDecoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    ApplicationContext context = mock(ApplicationContext<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(context.getBean(JwtDecoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)).<span class="hljs-title">willReturn</span>(<span class="hljs-title">decoder</span>)</span>;

    OAuth2ResourceServerConfigurer.JwtConfigurer jwtConfigurer = <span class="hljs-keyword">new</span> OAuth2ResourceServerConfigurer(context).jwt();

    jwtConfigurer.jwkSetUri(JWK_SET_URI);

    assertThat(jwtConfigurer.getJwtDecoder()).isNotEqualTo(decoder);

    assertThat(jwtConfigurer.getJwtDecoder()).isInstanceOf(NimbusJwtDecoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ApplicationContext <span class="hljs-title">mockApplicationContextWithJwtDecoder</span><span class="hljs-params">(JwtDecoder decoderToReturn)</span> </span>{
    ApplicationContext context = mock(ApplicationContext<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(context.getBean(JwtDecoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)).<span class="hljs-title">willReturn</span>(<span class="hljs-title">decoderToReturn</span>)</span>;
    <span class="hljs-keyword">return</span> context;
}
</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci197">Mock Clone Instance #spring-security_MCI_197</h2>
<ul>
<li><strong>Scope</strong>: class level</li>
<li><strong>Mocked Class</strong>: <code>org.springframework.test.web.servlet.request.RequestPostProcessor</code></li>
<li><strong>Test Case Count</strong>: 1</li>
<li><strong>MO Count</strong>: 2</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockRequestPostProcessor</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestPostProcessor <span class="hljs-title">createPostProcessor</span><span class="hljs-params">()</span> </span>{
        RequestPostProcessor postProcessor = mock(RequestPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(postProcessor.postProcessRequest(any())).willAnswer((i) -&gt; i.getArgument(<span class="hljs-number">0</span>));
        <span class="hljs-keyword">return</span> postProcessor;
    }
}
</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest1971">Test Case ID #spring-security_Test_197_1</h4>
<h4 id="test-case-name-postprocessorsaremergedduringmockmvcperformfile-cjavaprojectsspringspring-securitytestsrctestjavaorgspringframeworksecuritytestwebservletrequestsecuritymockmvcrequestbuildersformlogintestsjava">Test Case Name: <code>postProcessorsAreMergedDuringMockMvcPerform</code>(File: <code>C:\Java_projects\Spring\spring-security\test\src\test\java\org\springframework\security\test\web\servlet\request\SecurityMockMvcRequestBuildersFormLoginTests.java</code>)</h4>
<h4 id="mock-object-variable-name-postprocessor">Mock Object Variable Name: <code>postProcessor</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void postProcessorsAreMergedDuringMockMvcPerform() throws Exception {
<span class="hljs-deletion">-    RequestPostProcessor postProcessor = mock(RequestPostProcessor.class);</span>
<span class="hljs-deletion">-    given(postProcessor.postProcessRequest(any())).willAnswer((i) -&gt; i.getArgument(0));</span>
<span class="hljs-addition">+    RequestPostProcessor postProcessor = MockRequestPostProcessor.createPostProcessor();</span>
     MockMvc mockMvc = MockMvcBuilders.standaloneSetup(new Object()).defaultRequest(MockMvcRequestBuilders.get("/").with(postProcessor)).build();
     MvcResult mvcResult = mockMvc.perform(formLogin()).andReturn();
     assertThat(mvcResult.getRequest().getMethod()).isEqualTo(HttpMethod.POST.name());
     assertThat(mvcResult.getRequest().getHeader("Accept")).isEqualTo(MediaType.toString(Arrays.asList(MediaType.APPLICATION_FORM_URLENCODED)));
     assertThat(mvcResult.getRequest().getParameter("username")).isEqualTo("user");
     assertThat(mvcResult.getRequest().getParameter("password")).isEqualTo("password");
     assertThat(mvcResult.getRequest().getRequestURI()).isEqualTo("/login");
     assertThat(mvcResult.getRequest().getParameter("_csrf")).isNotEmpty();
     verify(postProcessor).postProcessRequest(any());
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-comment">/**

 * spring-restdocs uses postprocessors to do its trick. It will work only if these are

 * merged together with our request builders. (gh-7572)

 * <span class="hljs-doctag">@throws</span> Exception

 */</span>

<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessorsAreMergedDuringMockMvcPerform</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    RequestPostProcessor postProcessor = mock(RequestPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(postProcessor.postProcessRequest(any())).willAnswer((i) -&gt; i.getArgument(<span class="hljs-number">0</span>));

    MockMvc mockMvc = MockMvcBuilders.standaloneSetup(<span class="hljs-keyword">new</span> Object()).defaultRequest(MockMvcRequestBuilders.get(<span class="hljs-string">"/"</span>).with(postProcessor)).build();

    MvcResult mvcResult = mockMvc.perform(formLogin()).andReturn();

    assertThat(mvcResult.getRequest().getMethod()).isEqualTo(HttpMethod.POST.name());

    assertThat(mvcResult.getRequest().getHeader(<span class="hljs-string">"Accept"</span>)).isEqualTo(MediaType.toString(Arrays.asList(MediaType.APPLICATION_FORM_URLENCODED)));

    assertThat(mvcResult.getRequest().getParameter(<span class="hljs-string">"username"</span>)).isEqualTo(<span class="hljs-string">"user"</span>);

    assertThat(mvcResult.getRequest().getParameter(<span class="hljs-string">"password"</span>)).isEqualTo(<span class="hljs-string">"password"</span>);

    assertThat(mvcResult.getRequest().getRequestURI()).isEqualTo(<span class="hljs-string">"/login"</span>);

    assertThat(mvcResult.getRequest().getParameter(<span class="hljs-string">"_csrf"</span>)).isNotEmpty();

    verify(postProcessor).postProcessRequest(any());

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockRequestPostProcessor</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestPostProcessor <span class="hljs-title">createPostProcessor</span><span class="hljs-params">()</span> </span>{
        RequestPostProcessor postProcessor = mock(RequestPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(postProcessor.postProcessRequest(any())).willAnswer((i) -&gt; i.getArgument(<span class="hljs-number">0</span>));
        <span class="hljs-keyword">return</span> postProcessor;
    }
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1972">Test Case ID #spring-security_Test_197_2</h4>
<h4 id="test-case-name-postprocessorsaremergedduringmockmvcperformfile-cjavaprojectsspringspring-securitytestsrctestjavaorgspringframeworksecuritytestwebservletrequestsecuritymockmvcrequestbuildersformlogouttestsjava">Test Case Name: <code>postProcessorsAreMergedDuringMockMvcPerform</code>(File: <code>C:\Java_projects\Spring\spring-security\test\src\test\java\org\springframework\security\test\web\servlet\request\SecurityMockMvcRequestBuildersFormLogoutTests.java</code>)</h4>
<h4 id="mock-object-variable-name-postprocessor">Mock Object Variable Name: <code>postProcessor</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void postProcessorsAreMergedDuringMockMvcPerform() throws Exception {
<span class="hljs-deletion">-    RequestPostProcessor postProcessor = mock(RequestPostProcessor.class);</span>
<span class="hljs-deletion">-    given(postProcessor.postProcessRequest(any())).willAnswer((i) -&gt; i.getArgument(0));</span>
<span class="hljs-addition">+    RequestPostProcessor postProcessor = MockRequestPostProcessor.createPostProcessor();</span>
     MockMvc mockMvc = MockMvcBuilders.standaloneSetup(new Object()).defaultRequest(MockMvcRequestBuilders.get("/").with(postProcessor)).build();
     MvcResult mvcResult = mockMvc.perform(logout()).andReturn();
     assertThat(mvcResult.getRequest().getMethod()).isEqualTo(HttpMethod.POST.name());
     assertThat(mvcResult.getRequest().getHeader("Accept")).isEqualTo(MediaType.toString(Arrays.asList(MediaType.TEXT_HTML, MediaType.ALL)));
     assertThat(mvcResult.getRequest().getRequestURI()).isEqualTo("/logout");
     assertThat(mvcResult.getRequest().getParameter("_csrf")).isNotEmpty();
     verify(postProcessor).postProcessRequest(any());
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-comment">/**

 * spring-restdocs uses postprocessors to do its trick. It will work only if these are

 * merged together with our request builders. (gh-7572)

 * <span class="hljs-doctag">@throws</span> Exception

 */</span>

<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessorsAreMergedDuringMockMvcPerform</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>{

    RequestPostProcessor postProcessor = mock(RequestPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    given(postProcessor.postProcessRequest(any())).willAnswer((i) -&gt; i.getArgument(<span class="hljs-number">0</span>));

    MockMvc mockMvc = MockMvcBuilders.standaloneSetup(<span class="hljs-keyword">new</span> Object()).defaultRequest(MockMvcRequestBuilders.get(<span class="hljs-string">"/"</span>).with(postProcessor)).build();

    MvcResult mvcResult = mockMvc.perform(logout()).andReturn();

    assertThat(mvcResult.getRequest().getMethod()).isEqualTo(HttpMethod.POST.name());

    assertThat(mvcResult.getRequest().getHeader(<span class="hljs-string">"Accept"</span>)).isEqualTo(MediaType.toString(Arrays.asList(MediaType.TEXT_HTML, MediaType.ALL)));

    assertThat(mvcResult.getRequest().getRequestURI()).isEqualTo(<span class="hljs-string">"/logout"</span>);

    assertThat(mvcResult.getRequest().getParameter(<span class="hljs-string">"_csrf"</span>)).isNotEmpty();

    verify(postProcessor).postProcessRequest(any());

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockRequestPostProcessor</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequestPostProcessor <span class="hljs-title">createPostProcessor</span><span class="hljs-params">()</span> </span>{
        RequestPostProcessor postProcessor = mock(RequestPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        given(postProcessor.postProcessRequest(any())).willAnswer((i) -&gt; i.getArgument(<span class="hljs-number">0</span>));
        <span class="hljs-keyword">return</span> postProcessor;
    }
}
</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci198">Mock Clone Instance #spring-security_MCI_198</h2>
<ul>
<li><strong>Scope</strong>: method level</li>
<li><strong>Mocked Class</strong>: <code>org.springframework.security.crypto.password.PasswordEncoder</code></li>
<li><strong>Test Case Count</strong>: 3</li>
<li><strong>MO Count</strong>: 3</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PasswordEncoder <span class="hljs-title">createMockPasswordEncoder</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> matchesReturn)</span> </span>{
    PasswordEncoder encoder = mock(PasswordEncoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(encoder.matches(any(), any())).willReturn(matchesReturn);
    <span class="hljs-keyword">return</span> encoder;
}
</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest1981">Test Case ID #spring-security_Test_198_1</h4>
<h4 id="test-case-name-authenticatewhensuccessandpasswordmanagerthenupdatesfile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationdaodaoauthenticationprovidertestsjava">Test Case Name: <code>authenticateWhenSuccessAndPasswordManagerThenUpdates</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\dao\DaoAuthenticationProviderTests.java</code>)</h4>
<h4 id="mock-object-variable-name-encoder">Mock Object Variable Name: <code>encoder</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenSuccessAndPasswordManagerThenUpdates() {
     String password = "password";
     String encodedPassword = "encoded";
     UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated("user", password);
<span class="hljs-deletion">-    PasswordEncoder encoder = mock(PasswordEncoder.class);</span>
<span class="hljs-addition">+    PasswordEncoder encoder = createMockPasswordEncoder(true);</span>
     UserDetailsService userDetailsService = mock(UserDetailsService.class);
     UserDetailsPasswordService passwordManager = mock(UserDetailsPasswordService.class);
     DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
     provider.setPasswordEncoder(encoder);
     provider.setUserDetailsService(userDetailsService);
     provider.setUserDetailsPasswordService(passwordManager);
     UserDetails user = PasswordEncodedUser.user();
<span class="hljs-deletion">-    given(encoder.matches(any(), any())).willReturn(true);</span>
<span class="hljs-addition">+    // matches stubbed by helper</span>
     given(encoder.upgradeEncoding(any())).willReturn(true);
     given(encoder.encode(any())).willReturn(encodedPassword);
     given(userDetailsService.loadUserByUsername(any())).willReturn(user);
     given(passwordManager.updatePassword(any(), any())).willReturn(user);
     Authentication result = provider.authenticate(token);
     verify(encoder).encode(password);
     verify(passwordManager).updatePassword(eq(user), eq(encodedPassword));
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenSuccessAndPasswordManagerThenUpdates</span><span class="hljs-params">()</span> </span>{

    String password = <span class="hljs-string">"password"</span>;

    String encodedPassword = <span class="hljs-string">"encoded"</span>;

    UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(<span class="hljs-string">"user"</span>, password);

    PasswordEncoder encoder = mock(PasswordEncoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    UserDetailsService userDetailsService = mock(UserDetailsService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    UserDetailsPasswordService passwordManager = mock(UserDetailsPasswordService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    DaoAuthenticationProvider provider = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();

    provider.setPasswordEncoder(encoder);

    provider.setUserDetailsService(userDetailsService);

    provider.setUserDetailsPasswordService(passwordManager);

    UserDetails user = PasswordEncodedUser.user();

    given(encoder.matches(any(), any())).willReturn(<span class="hljs-keyword">true</span>);

    given(encoder.upgradeEncoding(any())).willReturn(<span class="hljs-keyword">true</span>);

    given(encoder.encode(any())).willReturn(encodedPassword);

    given(userDetailsService.loadUserByUsername(any())).willReturn(user);

    given(passwordManager.updatePassword(any(), any())).willReturn(user);

    Authentication result = provider.authenticate(token);

    verify(encoder).encode(password);

    verify(passwordManager).updatePassword(eq(user), eq(encodedPassword));

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PasswordEncoder <span class="hljs-title">createMockPasswordEncoder</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> matchesReturn)</span> </span>{
    PasswordEncoder encoder = mock(PasswordEncoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(encoder.matches(any(), any())).willReturn(matchesReturn);
    <span class="hljs-keyword">return</span> encoder;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1982">Test Case ID #spring-security_Test_198_2</h4>
<h4 id="test-case-name-authenticatewhenbadcredentialsandpasswordmanagerthennoupdatefile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationdaodaoauthenticationprovidertestsjava">Test Case Name: <code>authenticateWhenBadCredentialsAndPasswordManagerThenNoUpdate</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\dao\DaoAuthenticationProviderTests.java</code>)</h4>
<h4 id="mock-object-variable-name-encoder">Mock Object Variable Name: <code>encoder</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenBadCredentialsAndPasswordManagerThenNoUpdate() {
     UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated("user", "password");
<span class="hljs-deletion">-    PasswordEncoder encoder = mock(PasswordEncoder.class);</span>
<span class="hljs-addition">+    PasswordEncoder encoder = createMockPasswordEncoder(false);</span>
     UserDetailsService userDetailsService = mock(UserDetailsService.class);
     UserDetailsPasswordService passwordManager = mock(UserDetailsPasswordService.class);
     DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
     provider.setPasswordEncoder(encoder);
     provider.setUserDetailsService(userDetailsService);
     provider.setUserDetailsPasswordService(passwordManager);
     UserDetails user = PasswordEncodedUser.user();
<span class="hljs-deletion">-    given(encoder.matches(any(), any())).willReturn(false);</span>
<span class="hljs-addition">+    // matches stubbed by helper</span>
     given(userDetailsService.loadUserByUsername(any())).willReturn(user);
     assertThatExceptionOfType(BadCredentialsException.class).isThrownBy(() -&gt; provider.authenticate(token));
     verifyNoMoreInteractions(passwordManager);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenBadCredentialsAndPasswordManagerThenNoUpdate</span><span class="hljs-params">()</span> </span>{

    UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>);

    PasswordEncoder encoder = mock(PasswordEncoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    UserDetailsService userDetailsService = mock(UserDetailsService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    UserDetailsPasswordService passwordManager = mock(UserDetailsPasswordService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    DaoAuthenticationProvider provider = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();

    provider.setPasswordEncoder(encoder);

    provider.setUserDetailsService(userDetailsService);

    provider.setUserDetailsPasswordService(passwordManager);

    UserDetails user = PasswordEncodedUser.user();

    given(encoder.matches(any(), any())).willReturn(<span class="hljs-keyword">false</span>);

    given(userDetailsService.loadUserByUsername(any())).willReturn(user);

    assertThatExceptionOfType(BadCredentialsException<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">isThrownBy</span>(() -&gt; <span class="hljs-title">provider</span>.<span class="hljs-title">authenticate</span>(<span class="hljs-title">token</span>))</span>;

    verifyNoMoreInteractions(passwordManager);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PasswordEncoder <span class="hljs-title">createMockPasswordEncoder</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> matchesReturn)</span> </span>{
    PasswordEncoder encoder = mock(PasswordEncoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(encoder.matches(any(), any())).willReturn(matchesReturn);
    <span class="hljs-keyword">return</span> encoder;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1983">Test Case ID #spring-security_Test_198_3</h4>
<h4 id="test-case-name-authenticatewhennotupgradeandpasswordmanagerthennoupdatefile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationdaodaoauthenticationprovidertestsjava">Test Case Name: <code>authenticateWhenNotUpgradeAndPasswordManagerThenNoUpdate</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\dao\DaoAuthenticationProviderTests.java</code>)</h4>
<h4 id="mock-object-variable-name-encoder">Mock Object Variable Name: <code>encoder</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenNotUpgradeAndPasswordManagerThenNoUpdate() {
     UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated("user", "password");
<span class="hljs-deletion">-    PasswordEncoder encoder = mock(PasswordEncoder.class);</span>
<span class="hljs-addition">+    PasswordEncoder encoder = createMockPasswordEncoder(true);</span>
     UserDetailsService userDetailsService = mock(UserDetailsService.class);
     UserDetailsPasswordService passwordManager = mock(UserDetailsPasswordService.class);
     DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
     provider.setPasswordEncoder(encoder);
     provider.setUserDetailsService(userDetailsService);
     provider.setUserDetailsPasswordService(passwordManager);
     UserDetails user = PasswordEncodedUser.user();
<span class="hljs-deletion">-    given(encoder.matches(any(), any())).willReturn(true);</span>
<span class="hljs-addition">+    // matches stubbed by helper</span>
     given(encoder.upgradeEncoding(any())).willReturn(false);
     given(userDetailsService.loadUserByUsername(any())).willReturn(user);
     Authentication result = provider.authenticate(token);
     verifyNoMoreInteractions(passwordManager);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenNotUpgradeAndPasswordManagerThenNoUpdate</span><span class="hljs-params">()</span> </span>{

    UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(<span class="hljs-string">"user"</span>, <span class="hljs-string">"password"</span>);

    PasswordEncoder encoder = mock(PasswordEncoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    UserDetailsService userDetailsService = mock(UserDetailsService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    UserDetailsPasswordService passwordManager = mock(UserDetailsPasswordService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    DaoAuthenticationProvider provider = <span class="hljs-keyword">new</span> DaoAuthenticationProvider();

    provider.setPasswordEncoder(encoder);

    provider.setUserDetailsService(userDetailsService);

    provider.setUserDetailsPasswordService(passwordManager);

    UserDetails user = PasswordEncodedUser.user();

    given(encoder.matches(any(), any())).willReturn(<span class="hljs-keyword">true</span>);

    given(encoder.upgradeEncoding(any())).willReturn(<span class="hljs-keyword">false</span>);

    given(userDetailsService.loadUserByUsername(any())).willReturn(user);

    Authentication result = provider.authenticate(token);

    verifyNoMoreInteractions(passwordManager);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PasswordEncoder <span class="hljs-title">createMockPasswordEncoder</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> matchesReturn)</span> </span>{
    PasswordEncoder encoder = mock(PasswordEncoder<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
    given(encoder.matches(any(), any())).willReturn(matchesReturn);
    <span class="hljs-keyword">return</span> encoder;
}
</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci199">Mock Clone Instance #spring-security_MCI_199</h2>
<ul>
<li><strong>Scope</strong>: class level</li>
<li><strong>Mocked Class</strong>: <code>org.springframework.security.crypto.password.PasswordEncoder</code></li>
<li><strong>Test Case Count</strong>: 8</li>
<li><strong>MO Count</strong>: 8</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockPasswordEncoder</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the matches method of the given PasswordEncoder mock.
     *
     * <span class="hljs-doctag">@param</span> passwordEncoder the mock PasswordEncoder
     * <span class="hljs-doctag">@param</span> matchesReturn the boolean value to return from matches()
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(org.springframework.security.crypto.password.PasswordEncoder passwordEncoder, <span class="hljs-keyword">boolean</span> matchesReturn)</span> </span>{
        given(passwordEncoder.matches(any(), any())).willReturn(matchesReturn);
    }
}
</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest1991">Test Case ID #spring-security_Test_199_1</h4>
<h4 id="test-case-name-authenticatewhenpasswordencoderandsuccessthensuccessfile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationreactiveuserdetailsserviceauthenticationmanagertestsjava">Test Case Name: <code>authenticateWhenPasswordEncoderAndSuccessThenSuccess</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\ReactiveUserDetailsServiceAuthenticationManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-passwordencoder">Mock Object Variable Name: <code>passwordEncoder</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenPasswordEncoderAndSuccessThenSuccess() {
     this.manager.setPasswordEncoder(this.passwordEncoder);
<span class="hljs-deletion">-    given(this.passwordEncoder.matches(any(), any())).willReturn(true);</span>
<span class="hljs-addition">+    MockPasswordEncoder.stubMatches(this.passwordEncoder, true);</span>
     User user = new User(this.username, this.password, AuthorityUtils.createAuthorityList("ROLE_USER"));
     given(this.repository.findByUsername(user.getUsername())).willReturn(Mono.just(user));
     UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(this.username, this.password);
     Authentication authentication = this.manager.authenticate(token).block();
     assertThat(authentication).isEqualTo(authentication);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenPasswordEncoderAndSuccessThenSuccess</span><span class="hljs-params">()</span> </span>{

    <span class="hljs-keyword">this</span>.manager.setPasswordEncoder(<span class="hljs-keyword">this</span>.passwordEncoder);

    given(<span class="hljs-keyword">this</span>.passwordEncoder.matches(any(), any())).willReturn(<span class="hljs-keyword">true</span>);

    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-keyword">this</span>.username, <span class="hljs-keyword">this</span>.password, AuthorityUtils.createAuthorityList(<span class="hljs-string">"ROLE_USER"</span>));

    given(<span class="hljs-keyword">this</span>.repository.findByUsername(user.getUsername())).willReturn(Mono.just(user));

    UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(<span class="hljs-keyword">this</span>.username, <span class="hljs-keyword">this</span>.password);

    Authentication authentication = <span class="hljs-keyword">this</span>.manager.authenticate(token).block();

    assertThat(authentication).isEqualTo(authentication);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockPasswordEncoder</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the matches method of the given PasswordEncoder mock.
     *
     * <span class="hljs-doctag">@param</span> passwordEncoder the mock PasswordEncoder
     * <span class="hljs-doctag">@param</span> matchesReturn the boolean value to return from matches()
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(org.springframework.security.crypto.password.PasswordEncoder passwordEncoder, <span class="hljs-keyword">boolean</span> matchesReturn)</span> </span>{
        given(passwordEncoder.matches(any(), any())).willReturn(matchesReturn);
    }
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1992">Test Case ID #spring-security_Test_199_2</h4>
<h4 id="test-case-name-authenticatewhenpasswordencoderandfailthenfailfile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationreactiveuserdetailsserviceauthenticationmanagertestsjava">Test Case Name: <code>authenticateWhenPasswordEncoderAndFailThenFail</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\ReactiveUserDetailsServiceAuthenticationManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-passwordencoder">Mock Object Variable Name: <code>passwordEncoder</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenPasswordEncoderAndFailThenFail() {
     this.manager.setPasswordEncoder(this.passwordEncoder);
<span class="hljs-deletion">-    given(this.passwordEncoder.matches(any(), any())).willReturn(false);</span>
<span class="hljs-addition">+    MockPasswordEncoder.stubMatches(this.passwordEncoder, false);</span>
     User user = new User(this.username, this.password, AuthorityUtils.createAuthorityList("ROLE_USER"));
     given(this.repository.findByUsername(user.getUsername())).willReturn(Mono.just(user));
     UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(this.username, this.password);
     Mono&lt;Authentication&gt; authentication = this.manager.authenticate(token);
     // @formatter:off
     StepVerifier.create(authentication).expectError(BadCredentialsException.class).verify();
     // @formatter:on
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenPasswordEncoderAndFailThenFail</span><span class="hljs-params">()</span> </span>{

    <span class="hljs-keyword">this</span>.manager.setPasswordEncoder(<span class="hljs-keyword">this</span>.passwordEncoder);

    given(<span class="hljs-keyword">this</span>.passwordEncoder.matches(any(), any())).willReturn(<span class="hljs-keyword">false</span>);

    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-keyword">this</span>.username, <span class="hljs-keyword">this</span>.password, AuthorityUtils.createAuthorityList(<span class="hljs-string">"ROLE_USER"</span>));

    given(<span class="hljs-keyword">this</span>.repository.findByUsername(user.getUsername())).willReturn(Mono.just(user));

    UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(<span class="hljs-keyword">this</span>.username, <span class="hljs-keyword">this</span>.password);

    Mono&lt;Authentication&gt; authentication = <span class="hljs-keyword">this</span>.manager.authenticate(token);

    <span class="hljs-comment">// @formatter:off</span>

    StepVerifier.create(authentication).expectError(BadCredentialsException<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">verify</span>()</span>;

    <span class="hljs-comment">// @formatter:on</span>

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockPasswordEncoder</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the matches method of the given PasswordEncoder mock.
     *
     * <span class="hljs-doctag">@param</span> passwordEncoder the mock PasswordEncoder
     * <span class="hljs-doctag">@param</span> matchesReturn the boolean value to return from matches()
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(org.springframework.security.crypto.password.PasswordEncoder passwordEncoder, <span class="hljs-keyword">boolean</span> matchesReturn)</span> </span>{
        given(passwordEncoder.matches(any(), any())).willReturn(matchesReturn);
    }
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1993">Test Case ID #spring-security_Test_199_3</h4>
<h4 id="test-case-name-authenticatewhencustomschedulerthenusedfile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationuserdetailsrepositoryreactiveauthenticationmanagertestsjava">Test Case Name: <code>authenticateWhenCustomSchedulerThenUsed</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\UserDetailsRepositoryReactiveAuthenticationManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-encoder">Mock Object Variable Name: <code>encoder</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenCustomSchedulerThenUsed() {
     given(this.scheduler.schedule(any())).willAnswer((a) -&gt; {
         Runnable r = a.getArgument(0);
         return Schedulers.immediate().schedule(r);
     });
     given(this.userDetailsService.findByUsername(any())).willReturn(Mono.just(this.user));
<span class="hljs-deletion">-    given(this.encoder.matches(any(), any())).willReturn(true);</span>
<span class="hljs-addition">+    MockPasswordEncoder.stubMatches(this.encoder, true);</span>
     this.manager.setScheduler(this.scheduler);
     this.manager.setPasswordEncoder(this.encoder);
     UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(this.user, this.user.getPassword());
     Authentication result = this.manager.authenticate(token).block();
     verify(this.scheduler).schedule(any());
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenCustomSchedulerThenUsed</span><span class="hljs-params">()</span> </span>{

    given(<span class="hljs-keyword">this</span>.scheduler.schedule(any())).willAnswer((a) -&gt; {

        Runnable r = a.getArgument(<span class="hljs-number">0</span>);

        <span class="hljs-keyword">return</span> Schedulers.immediate().schedule(r);

    });

    given(<span class="hljs-keyword">this</span>.userDetailsService.findByUsername(any())).willReturn(Mono.just(<span class="hljs-keyword">this</span>.user));

    given(<span class="hljs-keyword">this</span>.encoder.matches(any(), any())).willReturn(<span class="hljs-keyword">true</span>);

    <span class="hljs-keyword">this</span>.manager.setScheduler(<span class="hljs-keyword">this</span>.scheduler);

    <span class="hljs-keyword">this</span>.manager.setPasswordEncoder(<span class="hljs-keyword">this</span>.encoder);

    UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(<span class="hljs-keyword">this</span>.user, <span class="hljs-keyword">this</span>.user.getPassword());

    Authentication result = <span class="hljs-keyword">this</span>.manager.authenticate(token).block();

    verify(<span class="hljs-keyword">this</span>.scheduler).schedule(any());

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockPasswordEncoder</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the matches method of the given PasswordEncoder mock.
     *
     * <span class="hljs-doctag">@param</span> passwordEncoder the mock PasswordEncoder
     * <span class="hljs-doctag">@param</span> matchesReturn the boolean value to return from matches()
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(org.springframework.security.crypto.password.PasswordEncoder passwordEncoder, <span class="hljs-keyword">boolean</span> matchesReturn)</span> </span>{
        given(passwordEncoder.matches(any(), any())).willReturn(matchesReturn);
    }
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1994">Test Case ID #spring-security_Test_199_4</h4>
<h4 id="test-case-name-authenticatewhenpasswordservicethenupdatedfile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationuserdetailsrepositoryreactiveauthenticationmanagertestsjava">Test Case Name: <code>authenticateWhenPasswordServiceThenUpdated</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\UserDetailsRepositoryReactiveAuthenticationManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-encoder">Mock Object Variable Name: <code>encoder</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenPasswordServiceThenUpdated() {
     String encodedPassword = "encoded";
     given(this.userDetailsService.findByUsername(any())).willReturn(Mono.just(this.user));
<span class="hljs-deletion">-    given(this.encoder.matches(any(), any())).willReturn(true);</span>
<span class="hljs-addition">+    MockPasswordEncoder.stubMatches(this.encoder, true);</span>
     given(this.encoder.upgradeEncoding(any())).willReturn(true);
     given(this.encoder.encode(any())).willReturn(encodedPassword);
     given(this.userDetailsPasswordService.updatePassword(any(), any())).willReturn(Mono.just(this.user));
     this.manager.setPasswordEncoder(this.encoder);
     this.manager.setUserDetailsPasswordService(this.userDetailsPasswordService);
     UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(this.user, this.user.getPassword());
     Authentication result = this.manager.authenticate(token).block();
     verify(this.encoder).encode(this.user.getPassword());
     verify(this.userDetailsPasswordService).updatePassword(eq(this.user), eq(encodedPassword));
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenPasswordServiceThenUpdated</span><span class="hljs-params">()</span> </span>{

    String encodedPassword = <span class="hljs-string">"encoded"</span>;

    given(<span class="hljs-keyword">this</span>.userDetailsService.findByUsername(any())).willReturn(Mono.just(<span class="hljs-keyword">this</span>.user));

    given(<span class="hljs-keyword">this</span>.encoder.matches(any(), any())).willReturn(<span class="hljs-keyword">true</span>);

    given(<span class="hljs-keyword">this</span>.encoder.upgradeEncoding(any())).willReturn(<span class="hljs-keyword">true</span>);

    given(<span class="hljs-keyword">this</span>.encoder.encode(any())).willReturn(encodedPassword);

    given(<span class="hljs-keyword">this</span>.userDetailsPasswordService.updatePassword(any(), any())).willReturn(Mono.just(<span class="hljs-keyword">this</span>.user));

    <span class="hljs-keyword">this</span>.manager.setPasswordEncoder(<span class="hljs-keyword">this</span>.encoder);

    <span class="hljs-keyword">this</span>.manager.setUserDetailsPasswordService(<span class="hljs-keyword">this</span>.userDetailsPasswordService);

    UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(<span class="hljs-keyword">this</span>.user, <span class="hljs-keyword">this</span>.user.getPassword());

    Authentication result = <span class="hljs-keyword">this</span>.manager.authenticate(token).block();

    verify(<span class="hljs-keyword">this</span>.encoder).encode(<span class="hljs-keyword">this</span>.user.getPassword());

    verify(<span class="hljs-keyword">this</span>.userDetailsPasswordService).updatePassword(eq(<span class="hljs-keyword">this</span>.user), eq(encodedPassword));

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockPasswordEncoder</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the matches method of the given PasswordEncoder mock.
     *
     * <span class="hljs-doctag">@param</span> passwordEncoder the mock PasswordEncoder
     * <span class="hljs-doctag">@param</span> matchesReturn the boolean value to return from matches()
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(org.springframework.security.crypto.password.PasswordEncoder passwordEncoder, <span class="hljs-keyword">boolean</span> matchesReturn)</span> </span>{
        given(passwordEncoder.matches(any(), any())).willReturn(matchesReturn);
    }
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1995">Test Case ID #spring-security_Test_199_5</h4>
<h4 id="test-case-name-authenticatewhenpasswordserviceandbadcredentialsthennotupdatedfile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationuserdetailsrepositoryreactiveauthenticationmanagertestsjava">Test Case Name: <code>authenticateWhenPasswordServiceAndBadCredentialsThenNotUpdated</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\UserDetailsRepositoryReactiveAuthenticationManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-encoder">Mock Object Variable Name: <code>encoder</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenPasswordServiceAndBadCredentialsThenNotUpdated() {
     given(this.userDetailsService.findByUsername(any())).willReturn(Mono.just(this.user));
<span class="hljs-deletion">-    given(this.encoder.matches(any(), any())).willReturn(false);</span>
<span class="hljs-addition">+    MockPasswordEncoder.stubMatches(this.encoder, false);</span>
     this.manager.setPasswordEncoder(this.encoder);
     this.manager.setUserDetailsPasswordService(this.userDetailsPasswordService);
     UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(this.user, this.user.getPassword());
     assertThatExceptionOfType(BadCredentialsException.class).isThrownBy(() -&gt; this.manager.authenticate(token).block());
     verifyNoMoreInteractions(this.userDetailsPasswordService);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenPasswordServiceAndBadCredentialsThenNotUpdated</span><span class="hljs-params">()</span> </span>{

    given(<span class="hljs-keyword">this</span>.userDetailsService.findByUsername(any())).willReturn(Mono.just(<span class="hljs-keyword">this</span>.user));

    given(<span class="hljs-keyword">this</span>.encoder.matches(any(), any())).willReturn(<span class="hljs-keyword">false</span>);

    <span class="hljs-keyword">this</span>.manager.setPasswordEncoder(<span class="hljs-keyword">this</span>.encoder);

    <span class="hljs-keyword">this</span>.manager.setUserDetailsPasswordService(<span class="hljs-keyword">this</span>.userDetailsPasswordService);

    UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(<span class="hljs-keyword">this</span>.user, <span class="hljs-keyword">this</span>.user.getPassword());

    assertThatExceptionOfType(BadCredentialsException<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">isThrownBy</span>(() -&gt; <span class="hljs-title">this</span>.<span class="hljs-title">manager</span>.<span class="hljs-title">authenticate</span>(<span class="hljs-title">token</span>).<span class="hljs-title">block</span>())</span>;

    verifyNoMoreInteractions(<span class="hljs-keyword">this</span>.userDetailsPasswordService);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockPasswordEncoder</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the matches method of the given PasswordEncoder mock.
     *
     * <span class="hljs-doctag">@param</span> passwordEncoder the mock PasswordEncoder
     * <span class="hljs-doctag">@param</span> matchesReturn the boolean value to return from matches()
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(org.springframework.security.crypto.password.PasswordEncoder passwordEncoder, <span class="hljs-keyword">boolean</span> matchesReturn)</span> </span>{
        given(passwordEncoder.matches(any(), any())).willReturn(matchesReturn);
    }
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1996">Test Case ID #spring-security_Test_199_6</h4>
<h4 id="test-case-name-authenticatewhenpasswordserviceandupgradefalsethennotupdatedfile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationuserdetailsrepositoryreactiveauthenticationmanagertestsjava">Test Case Name: <code>authenticateWhenPasswordServiceAndUpgradeFalseThenNotUpdated</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\UserDetailsRepositoryReactiveAuthenticationManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-encoder">Mock Object Variable Name: <code>encoder</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenPasswordServiceAndUpgradeFalseThenNotUpdated() {
     given(this.userDetailsService.findByUsername(any())).willReturn(Mono.just(this.user));
<span class="hljs-deletion">-    given(this.encoder.matches(any(), any())).willReturn(true);</span>
<span class="hljs-addition">+    MockPasswordEncoder.stubMatches(this.encoder, true);</span>
     given(this.encoder.upgradeEncoding(any())).willReturn(false);
     this.manager.setPasswordEncoder(this.encoder);
     this.manager.setUserDetailsPasswordService(this.userDetailsPasswordService);
     UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(this.user, this.user.getPassword());
     Authentication result = this.manager.authenticate(token).block();
     verifyNoMoreInteractions(this.userDetailsPasswordService);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenPasswordServiceAndUpgradeFalseThenNotUpdated</span><span class="hljs-params">()</span> </span>{

    given(<span class="hljs-keyword">this</span>.userDetailsService.findByUsername(any())).willReturn(Mono.just(<span class="hljs-keyword">this</span>.user));

    given(<span class="hljs-keyword">this</span>.encoder.matches(any(), any())).willReturn(<span class="hljs-keyword">true</span>);

    given(<span class="hljs-keyword">this</span>.encoder.upgradeEncoding(any())).willReturn(<span class="hljs-keyword">false</span>);

    <span class="hljs-keyword">this</span>.manager.setPasswordEncoder(<span class="hljs-keyword">this</span>.encoder);

    <span class="hljs-keyword">this</span>.manager.setUserDetailsPasswordService(<span class="hljs-keyword">this</span>.userDetailsPasswordService);

    UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(<span class="hljs-keyword">this</span>.user, <span class="hljs-keyword">this</span>.user.getPassword());

    Authentication result = <span class="hljs-keyword">this</span>.manager.authenticate(token).block();

    verifyNoMoreInteractions(<span class="hljs-keyword">this</span>.userDetailsPasswordService);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockPasswordEncoder</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the matches method of the given PasswordEncoder mock.
     *
     * <span class="hljs-doctag">@param</span> passwordEncoder the mock PasswordEncoder
     * <span class="hljs-doctag">@param</span> matchesReturn the boolean value to return from matches()
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(org.springframework.security.crypto.password.PasswordEncoder passwordEncoder, <span class="hljs-keyword">boolean</span> matchesReturn)</span> </span>{
        given(passwordEncoder.matches(any(), any())).willReturn(matchesReturn);
    }
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1997">Test Case ID #spring-security_Test_199_7</h4>
<h4 id="test-case-name-authenticatewhenpostauthenticationchecksfailfile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationuserdetailsrepositoryreactiveauthenticationmanagertestsjava">Test Case Name: <code>authenticateWhenPostAuthenticationChecksFail</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\UserDetailsRepositoryReactiveAuthenticationManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-encoder">Mock Object Variable Name: <code>encoder</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenPostAuthenticationChecksFail() {
     given(this.userDetailsService.findByUsername(any())).willReturn(Mono.just(this.user));
     willThrow(new LockedException("account is locked")).given(this.postAuthenticationChecks).check(any());
<span class="hljs-deletion">-    given(this.encoder.matches(any(), any())).willReturn(true);</span>
<span class="hljs-addition">+    MockPasswordEncoder.stubMatches(this.encoder, true);</span>
     this.manager.setPasswordEncoder(this.encoder);
     this.manager.setPostAuthenticationChecks(this.postAuthenticationChecks);
     assertThatExceptionOfType(LockedException.class).isThrownBy(() -&gt; this.manager.authenticate(UsernamePasswordAuthenticationToken.unauthenticated(this.user, this.user.getPassword())).block()).withMessage("account is locked");
     verify(this.postAuthenticationChecks).check(eq(this.user));
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenPostAuthenticationChecksFail</span><span class="hljs-params">()</span> </span>{

    given(<span class="hljs-keyword">this</span>.userDetailsService.findByUsername(any())).willReturn(Mono.just(<span class="hljs-keyword">this</span>.user));

    willThrow(<span class="hljs-keyword">new</span> LockedException(<span class="hljs-string">"account is locked"</span>)).given(<span class="hljs-keyword">this</span>.postAuthenticationChecks).check(any());

    given(<span class="hljs-keyword">this</span>.encoder.matches(any(), any())).willReturn(<span class="hljs-keyword">true</span>);

    <span class="hljs-keyword">this</span>.manager.setPasswordEncoder(<span class="hljs-keyword">this</span>.encoder);

    <span class="hljs-keyword">this</span>.manager.setPostAuthenticationChecks(<span class="hljs-keyword">this</span>.postAuthenticationChecks);

    assertThatExceptionOfType(LockedException<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">isThrownBy</span>(() -&gt; <span class="hljs-title">this</span>.<span class="hljs-title">manager</span>.<span class="hljs-title">authenticate</span>(<span class="hljs-title">UsernamePasswordAuthenticationToken</span>.<span class="hljs-title">unauthenticated</span>(<span class="hljs-title">this</span>.<span class="hljs-title">user</span>, <span class="hljs-title">this</span>.<span class="hljs-title">user</span>.<span class="hljs-title">getPassword</span>())).<span class="hljs-title">block</span>()).<span class="hljs-title">withMessage</span>("<span class="hljs-title">account</span> <span class="hljs-title">is</span> <span class="hljs-title">locked</span>")</span>;

    verify(<span class="hljs-keyword">this</span>.postAuthenticationChecks).check(eq(<span class="hljs-keyword">this</span>.user));

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockPasswordEncoder</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the matches method of the given PasswordEncoder mock.
     *
     * <span class="hljs-doctag">@param</span> passwordEncoder the mock PasswordEncoder
     * <span class="hljs-doctag">@param</span> matchesReturn the boolean value to return from matches()
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(org.springframework.security.crypto.password.PasswordEncoder passwordEncoder, <span class="hljs-keyword">boolean</span> matchesReturn)</span> </span>{
        given(passwordEncoder.matches(any(), any())).willReturn(matchesReturn);
    }
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest1998">Test Case ID #spring-security_Test_199_8</h4>
<h4 id="test-case-name-authenticatewhenpostauthenticationchecksnotsetfile-cjavaprojectsspringspring-securitycoresrctestjavaorgspringframeworksecurityauthenticationuserdetailsrepositoryreactiveauthenticationmanagertestsjava">Test Case Name: <code>authenticateWhenPostAuthenticationChecksNotSet</code>(File: <code>C:\Java_projects\Spring\spring-security\core\src\test\java\org\springframework\security\authentication\UserDetailsRepositoryReactiveAuthenticationManagerTests.java</code>)</h4>
<h4 id="mock-object-variable-name-encoder">Mock Object Variable Name: <code>encoder</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void authenticateWhenPostAuthenticationChecksNotSet() {
     given(this.userDetailsService.findByUsername(any())).willReturn(Mono.just(this.user));
<span class="hljs-deletion">-    given(this.encoder.matches(any(), any())).willReturn(true);</span>
<span class="hljs-addition">+    MockPasswordEncoder.stubMatches(this.encoder, true);</span>
     this.manager.setPasswordEncoder(this.encoder);
     UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(this.user, this.user.getPassword());
     this.manager.authenticate(token).block();
     verifyNoMoreInteractions(this.postAuthenticationChecks);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">authenticateWhenPostAuthenticationChecksNotSet</span><span class="hljs-params">()</span> </span>{

    given(<span class="hljs-keyword">this</span>.userDetailsService.findByUsername(any())).willReturn(Mono.just(<span class="hljs-keyword">this</span>.user));

    given(<span class="hljs-keyword">this</span>.encoder.matches(any(), any())).willReturn(<span class="hljs-keyword">true</span>);

    <span class="hljs-keyword">this</span>.manager.setPasswordEncoder(<span class="hljs-keyword">this</span>.encoder);

    UsernamePasswordAuthenticationToken token = UsernamePasswordAuthenticationToken.unauthenticated(<span class="hljs-keyword">this</span>.user, <span class="hljs-keyword">this</span>.user.getPassword());

    <span class="hljs-keyword">this</span>.manager.authenticate(token).block();

    verifyNoMoreInteractions(<span class="hljs-keyword">this</span>.postAuthenticationChecks);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockPasswordEncoder</span> </span>{
    <span class="hljs-comment">/**
     * Stubs the matches method of the given PasswordEncoder mock.
     *
     * <span class="hljs-doctag">@param</span> passwordEncoder the mock PasswordEncoder
     * <span class="hljs-doctag">@param</span> matchesReturn the boolean value to return from matches()
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stubMatches</span><span class="hljs-params">(org.springframework.security.crypto.password.PasswordEncoder passwordEncoder, <span class="hljs-keyword">boolean</span> matchesReturn)</span> </span>{
        given(passwordEncoder.matches(any(), any())).willReturn(matchesReturn);
    }
}
</div></code></pre>
</details>
<hr>
<h2 id="mock-clone-instance-spring-securitymci200">Mock Clone Instance #spring-security_MCI_200</h2>
<ul>
<li><strong>Scope</strong>: method level</li>
<li><strong>Mocked Class</strong>: <code>org.springframework.security.crypto.password.PasswordEncoder</code></li>
<li><strong>Test Case Count</strong>: 4</li>
<li><strong>MO Count</strong>: 4</li>
</ul>
<h3 id="reusable-method">Reusable Method</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PasswordEncoder <span class="hljs-title">stubMatches</span><span class="hljs-params">(PasswordEncoder mock, String rawPassword, String encodedPassword, <span class="hljs-keyword">boolean</span> matchesReturn)</span> </span>{
    given(mock.matches(rawPassword, encodedPassword)).willReturn(matchesReturn);
    <span class="hljs-keyword">return</span> mock;
}
</div></code></pre>
<h3 id="the-refactoring-details-in-each-test-cases">The refactoring details in each test cases</h3>
<hr>
<h4 id="test-case-id-spring-securitytest2001">Test Case ID #spring-security_Test_200_1</h4>
<h4 id="test-case-name-matcheswhenbcryptthendelegatestobcryptfile-cjavaprojectsspringspring-securitycryptosrctestjavaorgspringframeworksecuritycryptopassworddelegatingpasswordencodertestsjava">Test Case Name: <code>matchesWhenBCryptThenDelegatesToBCrypt</code>(File: <code>C:\Java_projects\Spring\spring-security\crypto\src\test\java\org\springframework\security\crypto\password\DelegatingPasswordEncoderTests.java</code>)</h4>
<h4 id="mock-object-variable-name-bcrypt">Mock Object Variable Name: <code>bcrypt</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void matchesWhenBCryptThenDelegatesToBCrypt() {
<span class="hljs-deletion">-    given(this.bcrypt.matches(this.rawPassword, this.encodedPassword)).willReturn(true);</span>
<span class="hljs-addition">+    stubMatches(this.bcrypt, this.rawPassword, this.encodedPassword, true);</span>
     assertThat(this.passwordEncoder.matches(this.rawPassword, this.bcryptEncodedPassword)).isTrue();
     verify(this.bcrypt).matches(this.rawPassword, this.encodedPassword);
     verifyNoMoreInteractions(this.noop);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchesWhenBCryptThenDelegatesToBCrypt</span><span class="hljs-params">()</span> </span>{

    given(<span class="hljs-keyword">this</span>.bcrypt.matches(<span class="hljs-keyword">this</span>.rawPassword, <span class="hljs-keyword">this</span>.encodedPassword)).willReturn(<span class="hljs-keyword">true</span>);

    assertThat(<span class="hljs-keyword">this</span>.passwordEncoder.matches(<span class="hljs-keyword">this</span>.rawPassword, <span class="hljs-keyword">this</span>.bcryptEncodedPassword)).isTrue();

    verify(<span class="hljs-keyword">this</span>.bcrypt).matches(<span class="hljs-keyword">this</span>.rawPassword, <span class="hljs-keyword">this</span>.encodedPassword);

    verifyNoMoreInteractions(<span class="hljs-keyword">this</span>.noop);

}
<span class="hljs-meta">@BeforeEach</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{

    <span class="hljs-keyword">this</span>.delegates = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

    <span class="hljs-keyword">this</span>.delegates.put(<span class="hljs-keyword">this</span>.bcryptId, <span class="hljs-keyword">this</span>.bcrypt);

    <span class="hljs-keyword">this</span>.delegates.put(<span class="hljs-string">"noop"</span>, <span class="hljs-keyword">this</span>.noop);

    <span class="hljs-keyword">this</span>.passwordEncoder = <span class="hljs-keyword">new</span> DelegatingPasswordEncoder(<span class="hljs-keyword">this</span>.bcryptId, <span class="hljs-keyword">this</span>.delegates);

    <span class="hljs-keyword">this</span>.onlySuffixPasswordEncoder = <span class="hljs-keyword">new</span> DelegatingPasswordEncoder(<span class="hljs-keyword">this</span>.bcryptId, <span class="hljs-keyword">this</span>.delegates, <span class="hljs-string">""</span>, <span class="hljs-string">"$"</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PasswordEncoder <span class="hljs-title">stubMatches</span><span class="hljs-params">(PasswordEncoder mock, String rawPassword, String encodedPassword, <span class="hljs-keyword">boolean</span> matchesReturn)</span> </span>{
    given(mock.matches(rawPassword, encodedPassword)).willReturn(matchesReturn);
    <span class="hljs-keyword">return</span> mock;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest2002">Test Case ID #spring-security_Test_200_2</h4>
<h4 id="test-case-name-matcheswhenbcryptbyspecifydelegatingpasswordencoderthendelegatestobcryptfile-cjavaprojectsspringspring-securitycryptosrctestjavaorgspringframeworksecuritycryptopassworddelegatingpasswordencodertestsjava">Test Case Name: <code>matchesWhenBCryptBySpecifyDelegatingPasswordEncoderThenDelegatesToBCrypt</code>(File: <code>C:\Java_projects\Spring\spring-security\crypto\src\test\java\org\springframework\security\crypto\password\DelegatingPasswordEncoderTests.java</code>)</h4>
<h4 id="mock-object-variable-name-bcrypt">Mock Object Variable Name: <code>bcrypt</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void matchesWhenBCryptBySpecifyDelegatingPasswordEncoderThenDelegatesToBCrypt() {
<span class="hljs-deletion">-    given(this.bcrypt.matches(this.rawPassword, this.encodedPassword)).willReturn(true);</span>
<span class="hljs-addition">+    stubMatches(this.bcrypt, this.rawPassword, this.encodedPassword, true);</span>
     assertThat(this.onlySuffixPasswordEncoder.matches(this.rawPassword, "bcrypt$" + this.encodedPassword)).isTrue();
     verify(this.bcrypt).matches(this.rawPassword, this.encodedPassword);
     verifyNoMoreInteractions(this.noop);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@BeforeEach</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{

    <span class="hljs-keyword">this</span>.delegates = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

    <span class="hljs-keyword">this</span>.delegates.put(<span class="hljs-keyword">this</span>.bcryptId, <span class="hljs-keyword">this</span>.bcrypt);

    <span class="hljs-keyword">this</span>.delegates.put(<span class="hljs-string">"noop"</span>, <span class="hljs-keyword">this</span>.noop);

    <span class="hljs-keyword">this</span>.passwordEncoder = <span class="hljs-keyword">new</span> DelegatingPasswordEncoder(<span class="hljs-keyword">this</span>.bcryptId, <span class="hljs-keyword">this</span>.delegates);

    <span class="hljs-keyword">this</span>.onlySuffixPasswordEncoder = <span class="hljs-keyword">new</span> DelegatingPasswordEncoder(<span class="hljs-keyword">this</span>.bcryptId, <span class="hljs-keyword">this</span>.delegates, <span class="hljs-string">""</span>, <span class="hljs-string">"$"</span>);

}
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchesWhenBCryptBySpecifyDelegatingPasswordEncoderThenDelegatesToBCrypt</span><span class="hljs-params">()</span> </span>{

    given(<span class="hljs-keyword">this</span>.bcrypt.matches(<span class="hljs-keyword">this</span>.rawPassword, <span class="hljs-keyword">this</span>.encodedPassword)).willReturn(<span class="hljs-keyword">true</span>);

    assertThat(<span class="hljs-keyword">this</span>.onlySuffixPasswordEncoder.matches(<span class="hljs-keyword">this</span>.rawPassword, <span class="hljs-string">"bcrypt$"</span> + <span class="hljs-keyword">this</span>.encodedPassword)).isTrue();

    verify(<span class="hljs-keyword">this</span>.bcrypt).matches(<span class="hljs-keyword">this</span>.rawPassword, <span class="hljs-keyword">this</span>.encodedPassword);

    verifyNoMoreInteractions(<span class="hljs-keyword">this</span>.noop);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PasswordEncoder <span class="hljs-title">stubMatches</span><span class="hljs-params">(PasswordEncoder mock, String rawPassword, String encodedPassword, <span class="hljs-keyword">boolean</span> matchesReturn)</span> </span>{
    given(mock.matches(rawPassword, encodedPassword)).willReturn(matchesReturn);
    <span class="hljs-keyword">return</span> mock;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest2003">Test Case ID #spring-security_Test_200_3</h4>
<h4 id="test-case-name-matcheswhennoopthendelegatestonoopfile-cjavaprojectsspringspring-securitycryptosrctestjavaorgspringframeworksecuritycryptopassworddelegatingpasswordencodertestsjava">Test Case Name: <code>matchesWhenNoopThenDelegatesToNoop</code>(File: <code>C:\Java_projects\Spring\spring-security\crypto\src\test\java\org\springframework\security\crypto\password\DelegatingPasswordEncoderTests.java</code>)</h4>
<h4 id="mock-object-variable-name-noop">Mock Object Variable Name: <code>noop</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void matchesWhenNoopThenDelegatesToNoop() {
<span class="hljs-deletion">-    given(this.noop.matches(this.rawPassword, this.encodedPassword)).willReturn(true);</span>
<span class="hljs-addition">+    stubMatches(this.noop, this.rawPassword, this.encodedPassword, true);</span>
     assertThat(this.passwordEncoder.matches(this.rawPassword, this.noopEncodedPassword)).isTrue();
     verify(this.noop).matches(this.rawPassword, this.encodedPassword);
     verifyNoMoreInteractions(this.bcrypt);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchesWhenNoopThenDelegatesToNoop</span><span class="hljs-params">()</span> </span>{

    given(<span class="hljs-keyword">this</span>.noop.matches(<span class="hljs-keyword">this</span>.rawPassword, <span class="hljs-keyword">this</span>.encodedPassword)).willReturn(<span class="hljs-keyword">true</span>);

    assertThat(<span class="hljs-keyword">this</span>.passwordEncoder.matches(<span class="hljs-keyword">this</span>.rawPassword, <span class="hljs-keyword">this</span>.noopEncodedPassword)).isTrue();

    verify(<span class="hljs-keyword">this</span>.noop).matches(<span class="hljs-keyword">this</span>.rawPassword, <span class="hljs-keyword">this</span>.encodedPassword);

    verifyNoMoreInteractions(<span class="hljs-keyword">this</span>.bcrypt);

}
<span class="hljs-meta">@BeforeEach</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{

    <span class="hljs-keyword">this</span>.delegates = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();

    <span class="hljs-keyword">this</span>.delegates.put(<span class="hljs-keyword">this</span>.bcryptId, <span class="hljs-keyword">this</span>.bcrypt);

    <span class="hljs-keyword">this</span>.delegates.put(<span class="hljs-string">"noop"</span>, <span class="hljs-keyword">this</span>.noop);

    <span class="hljs-keyword">this</span>.passwordEncoder = <span class="hljs-keyword">new</span> DelegatingPasswordEncoder(<span class="hljs-keyword">this</span>.bcryptId, <span class="hljs-keyword">this</span>.delegates);

    <span class="hljs-keyword">this</span>.onlySuffixPasswordEncoder = <span class="hljs-keyword">new</span> DelegatingPasswordEncoder(<span class="hljs-keyword">this</span>.bcryptId, <span class="hljs-keyword">this</span>.delegates, <span class="hljs-string">""</span>, <span class="hljs-string">"$"</span>);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PasswordEncoder <span class="hljs-title">stubMatches</span><span class="hljs-params">(PasswordEncoder mock, String rawPassword, String encodedPassword, <span class="hljs-keyword">boolean</span> matchesReturn)</span> </span>{
    given(mock.matches(rawPassword, encodedPassword)).willReturn(matchesReturn);
    <span class="hljs-keyword">return</span> mock;
}
</div></code></pre>
</details>
<hr>
<h4 id="test-case-id-spring-securitytest2004">Test Case ID #spring-security_Test_200_4</h4>
<h4 id="test-case-name-matcheswhennullidthendelegatestoinvalididfile-cjavaprojectsspringspring-securitycryptosrctestjavaorgspringframeworksecuritycryptopassworddelegatingpasswordencodertestsjava">Test Case Name: <code>matchesWhenNullIdThenDelegatesToInvalidId</code>(File: <code>C:\Java_projects\Spring\spring-security\crypto\src\test\java\org\springframework\security\crypto\password\DelegatingPasswordEncoderTests.java</code>)</h4>
<h4 id="mock-object-variable-name-invalidid">Mock Object Variable Name: <code>invalidId</code></h4>
<summary>Suggested Diff</summary>
<pre class="hljs"><code><div>
@@
 @Test
 public void matchesWhenNullIdThenDelegatesToInvalidId() {
     this.delegates.put(null, this.invalidId);
     this.passwordEncoder = new DelegatingPasswordEncoder(this.bcryptId, this.delegates);
<span class="hljs-deletion">-    given(this.invalidId.matches(this.rawPassword, this.encodedPassword)).willReturn(true);</span>
<span class="hljs-addition">+    stubMatches(this.invalidId, this.rawPassword, this.encodedPassword, true);</span>
     assertThat(this.passwordEncoder.matches(this.rawPassword, this.encodedPassword)).isTrue();
     verify(this.invalidId).matches(this.rawPassword, this.encodedPassword);
     verifyNoMoreInteractions(this.bcrypt, this.noop);
 }
</div></code></pre>
<details><summary>Original Test Code (click to expand)</summary>
<pre class="hljs"><code><div>
<span class="hljs-meta">@Test</span>

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">matchesWhenNullIdThenDelegatesToInvalidId</span><span class="hljs-params">()</span> </span>{

    <span class="hljs-keyword">this</span>.delegates.put(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">this</span>.invalidId);

    <span class="hljs-keyword">this</span>.passwordEncoder = <span class="hljs-keyword">new</span> DelegatingPasswordEncoder(<span class="hljs-keyword">this</span>.bcryptId, <span class="hljs-keyword">this</span>.delegates);

    given(<span class="hljs-keyword">this</span>.invalidId.matches(<span class="hljs-keyword">this</span>.rawPassword, <span class="hljs-keyword">this</span>.encodedPassword)).willReturn(<span class="hljs-keyword">true</span>);

    assertThat(<span class="hljs-keyword">this</span>.passwordEncoder.matches(<span class="hljs-keyword">this</span>.rawPassword, <span class="hljs-keyword">this</span>.encodedPassword)).isTrue();

    verify(<span class="hljs-keyword">this</span>.invalidId).matches(<span class="hljs-keyword">this</span>.rawPassword, <span class="hljs-keyword">this</span>.encodedPassword);

    verifyNoMoreInteractions(<span class="hljs-keyword">this</span>.bcrypt, <span class="hljs-keyword">this</span>.noop);

}
</div></code></pre>
</details>
<details><summary>Reusable Method for MCI (click to expand)</summary>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> PasswordEncoder <span class="hljs-title">stubMatches</span><span class="hljs-params">(PasswordEncoder mock, String rawPassword, String encodedPassword, <span class="hljs-keyword">boolean</span> matchesReturn)</span> </span>{
    given(mock.matches(rawPassword, encodedPassword)).willReturn(matchesReturn);
    <span class="hljs-keyword">return</span> mock;
}
</div></code></pre>
</details>
<hr>

</body>
</html>
